
.vsteensy/build/mtp-test_T40.elf:     file format elf32-littlearm

SYMBOL TABLE:
60000000 l    d  .text.headers	00000000 .text.headers
60001400 l    d  .text.code	00000000 .text.code
6000162c l    d  .text.progmem	00000000 .text.progmem
00000000 l    d  .text.itcm	00000000 .text.itcm
00013ab0 l    d  .fini	00000000 .fini
00013ab4 l    d  .vectors	00000000 .vectors
00013c4c l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .data	00000000 .data
20001698 l    d  .usbbuffers	00000000 .usbbuffers
20001c38 l    d  .usbdescriptortable	00000000 .usbdescriptortable
20001d18 l    d  .bss	00000000 .bss
20200000 l    d  .bss.dma	00000000 .bss.dma
60016f98 l    d  .text.csf	00000000 .text.csf
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 mk20dx128.c
0000d4a0 l     F .text.itcm	0000000c startup_default_early_hook
0000d4ac l     F .text.itcm	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 bootdata.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00000020 l     F .text.itcm	00000000 __do_global_dtors_aux
20001d18 l       .bss	00000000 completed.8605
00000044 l     F .text.itcm	00000000 frame_dummy
20001d1c l       .bss	00000000 object.8610
60001620 l     O .text.code	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 mtp-test.ino
000001e4 l     F .text.itcm	00000002 __tcf_0
0000121c l     F .text.itcm	00000140 _GLOBAL__sub_I_sd_str
00000000 l    df *ABS*	00000000 SD.cpp
00007690 l     F .text.itcm	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 Storage.cpp
000015b8 l     F .text.itcm	000000a0 File::invalidate() [clone .isra.1]
00001b4c l     F .text.itcm	00000084 MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]
00002fd4 l     F .text.itcm	00000036 MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]
0000300c l     F .text.itcm	00000030 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]
00003838 l     F .text.itcm	000000b2 MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]
000043e8 l     F .text.itcm	00000a4c mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]
00000000 l    df *ABS*	00000000 MTP.cpp
00005088 l     F .text.itcm	00000064 MTPD::write(char const*, int) [clone .part.2]
00005194 l     F .text.itcm	000000bc MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]
00006398 l     F .text.itcm	0000002c MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]
20000334 l     O .data	00000028 supported_op
2000035c l     O .data	00000010 propertyList
200003bc l     O .data	00000008 supported_events
00000000 l    df *ABS*	00000000 SPI.cpp
00006c88 l     F .text.itcm	000001f8 SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]
00000000 l    df *ABS*	00000000 Time.cpp
00007510 l     F .text.itcm	00000018 refreshCache(long) [clone .part.0]
20004c08 l     O .bss	00000004 cacheTime
20004c0c l     O .bss	00000007 tm
20004c14 l     O .bss	00000004 sysTime
20004c18 l     O .bss	00000001 Status
20004c20 l     O .bss	00000004 prevMillis
20000bdc l     O .data	00000004 syncInterval
20000578 l     O .data	0000000c monthDays
20004c24 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 FsCache.cpp
000076f4 l     F .text.itcm	00000046 FsCache::sync() [clone .part.0]
00000000 l    df *ABS*	00000000 FmtNumber.cpp
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatFilePrint.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00008548 l     F .text.itcm	00000034 ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]
0000857c l     F .text.itcm	0000002a ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]
00000000 l    df *ABS*	00000000 upcase.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
000093f8 l     F .text.itcm	00000032 FatFile::openRoot(FatVolume*) [clone .part.38]
00009518 l     F .text.itcm	00000094 FatFile::sync() [clone .part.42]
00000000 l    df *ABS*	00000000 FatFilePrint.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
0000a6dc l     F .text.itcm	00000028 lfnGetChar(DirLfn_t*, unsigned char)
00000000 l    df *ABS*	00000000 FatFileSFN.cpp
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
0000b3fc l     F .text.itcm	00000018 SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]
0000b414 l     F .text.itcm	00000022 SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
0000bd04 l     F .text.itcm	00000030 sdIrs()
0000bd34 l     F .text.itcm	00000018 isBusyCommandComplete()
0000bd4c l     F .text.itcm	00000010 isBusyCommandInhibit()
0000bd5c l     F .text.itcm	00000014 isBusyDat()
0000bd70 l     F .text.itcm	0000000c isBusyDMA()
0000bd7c l     F .text.itcm	00000014 isBusyFifoRead()
0000bd90 l     F .text.itcm	00000014 isBusyFifoWrite()
0000bda4 l     F .text.itcm	00000018 isBusyTransferComplete()
0000bdbc l     F .text.itcm	000000cc setSdclk(unsigned long)
0000beec l     F .text.itcm	00000028 waitTimeout(bool (*)())
0000bf14 l     F .text.itcm	0000004c yieldTimeout(bool (*)())
0000bf90 l     F .text.itcm	0000005c cardCommand(unsigned long, unsigned long)
0000bfec l     F .text.itcm	0000002c isBusyCMD13()
0000c038 l     F .text.itcm	00000064 readReg16(unsigned long, void*)
0000c09c l     F .text.itcm	00000020 waitDmaStatus() [clone .part.4]
0000c0bc l     F .text.itcm	000000b4 rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
0000c2c8 l     F .text.itcm	00000058 waitTransferComplete() [clone .part.8]
0000c69c l     F .text.itcm	000000ac cardCMD6(unsigned long, unsigned char*)
200050f0 l     O .bss	00000001 m_version2
200050f4 l     O .bss	00000010 m_cid
20005104 l     O .bss	00000004 m_busyFcn
20005108 l     O .bss	00000001 m_highCapacity
2000510c l     O .bss	00000004 m_ocr
20005110 l     O .bss	00000004 m_rca
20005114 l     O .bss	00000001 m_transferActive
20005118 l     O .bss	00000004 m_irqstat
20000be0 l     O .data	00000001 m_errorCode
2000511c l     O .bss	00000001 m_initDone
20005120 l     O .bss	00000010 m_csd
20005130 l     O .bss	00000001 m_dmaBusy
20005134 l     O .bss	00000004 m_sdClkKhz
20005138 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 SdSpiTeensy3.cpp
00000000 l    df *ABS*	00000000 SdSpiChipSelect.cpp
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
2000513d l     O .bss	00000001 tx_noautoflush
20005140 l     O .bss	00000004 tx_packet
20005144 l     O .bss	00000001 transmit_previous_timeout
20005148 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 usb_desc.c
20000be8 l     O .data	00000012 device_descriptor
20000c14 l     O .data	00000069 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 pins_teensy.c
0000d8fc l     F .text.itcm	0000004c digitalWrite.part.1
0000d948 l     F .text.itcm	00000078 pinMode.part.2
00000000 l    df *ABS*	00000000 usb_mem.c
20000cd4 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
20005154 l     O .bss	00000004 ep0_tx_ptr
20005158 l     O .bss	00000018 rx_last
20005170 l     O .bss	00000002 ep0_tx_len
20005174 l     O .bss	00000040 ep0_rx0_buf
200051b4 l     O .bss	00000018 rx_first
200051cc l     O .bss	00000001 ep0_tx_data_toggle
200051d0 l     O .bss	00000040 ep0_rx1_buf
20005210 l     O .bss	00000018 tx_first
20001c38 l     O .usbdescriptortable	000000e0 table
20005228 l     O .bss	00000018 tx_last
20005240 l     O .bss	00000008 setup
20005248 l     O .bss	00000001 ep0_tx_bdt_bank
2000524c l     O .bss	00000008 reply_buffer
20005258 l     O .bss	00000006 tx_state
00000000 l    df *ABS*	00000000 yield.cpp
2000525e l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
2000528d l     O .bss	00000001 calibrating
20000ced l     O .data	00000001 analog_config_bits
2000528e l     O .bss	00000001 analog_reference_internal
20000cee l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 efgcvt.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlcat.c
00000000 l    df *ABS*	00000000 strlcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
200008ec l     O .data	00000010 zeroes.7258
2000093c l     O .data	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
00012034 l     F .text.itcm	00000128 quorem
00000000 l    df *ABS*	00000000 ecvtbuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mprec.c
20000b50 l     O .data	0000000c p05.6087
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 impure.c
20000cf0 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 __fini_array_end
00000000 l       *UND*	00000000 __bss_start__
00000000 l       *UND*	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 __fini_array_start
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 __stack
600015f0 l     F .text.code	00000008 __main_veneer
600015f8 l     F .text.code	00000008 __rtc_set_veneer
60001600 l     F .text.code	00000008 ____libc_init_array_veneer
60001608 l     F .text.code	00000008 ___init_Teensyduino_internal__veneer
60001610 l     F .text.code	00000008 __startup_early_hook_veneer
60001618 l     F .text.code	00000008 __startup_late_hook_veneer
00013aa0 l     F .text.itcm	00000008 ___init_veneer
0000d498  w    F .text.itcm	00000006 adc0_isr
000019f0 g     F .text.itcm	0000015c MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)
0000f414 g     F .text.itcm	0000002c .hidden __aeabi_dcmpun
0000d1f4 g     F .text.itcm	0000001c usb_serial_available
0000f3d8 g     F .text.itcm	00000012 .hidden __aeabi_dcmple
00010510 g     F .text.itcm	000000ba strcpy
0000f314 g     F .text.itcm	0000007a .hidden __cmpdf2
0000c614 g     F .text.itcm	00000088 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000e748  w    F .text.itcm	000000ec yield
00009fe8 g     F .text.itcm	00000218 FatFile::write(void const*, unsigned int)
0000f314 g     F .text.itcm	0000007a .hidden __eqdf2
0000b3e8  w    F .text.itcm	00000002 SdSpiCard::~SdSpiCard()
0000e9ac g     F .text.itcm	000000ba Print::printNumber64(unsigned long long, unsigned char, unsigned char)
00007dc8 g     F .text.itcm	000003dc ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)
200026b0 g     O .bss	00000104 storage
20000bfc g     O .data	00000018 usb_string_manufacturer_name_default
20004c04 g     O .bss	00000004 tx_event_packet
00009f70 g     F .text.itcm	00000076 FatFile::truncate()
00001e40 g     F .text.itcm	0000003c MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)
0000ee84 g     F .text.itcm	0000005a .hidden __floatdidf
0000d450  w    F .text.itcm	00000048 hard_fault_isr
0000d498  w    F .text.itcm	00000006 dma_ch6_isr
200050e0 g     O .bss	00000004 FsDateTime::callback
0000e960 g     F .text.itcm	00000020 Print::println()
0000d498  w    F .text.itcm	00000006 uart0_lon_isr
00007cc8 g     F .text.itcm	000000fe ExFatFile::seekSet(unsigned long long)
00012f94 g     F .text.itcm	00000100 fcvtbuf
0000dd08 g     F .text.itcm	00000084 usb_rx_memory
0000b3cc  w    F .text.itcm	00000004 SdSpiCard::errorCode() const
000000c0  w    F .text.itcm	0000000c File::flush()
00006be8 g     F .text.itcm	00000018 usb_init_events
0000d498  w    F .text.itcm	00000006 dma_ch8_isr
000100bc g     F .text.itcm	00000002 __malloc_unlock
000002dc  w    F .text.itcm	000000bc SDFile::openNextFile(unsigned char)
200050ec g     O .bss	00000004 FsVolume::m_cwv
00009844 g     F .text.itcm	000000be FatFile::open(FatFile*, char const*, int)
0000ea84 g     F .text.itcm	000000e0 analog_init
0000dd8c g     F .text.itcm	00000084 usb_tx
0000d498  w    F .text.itcm	00000006 portcd_isr
0000a200 g     F .text.itcm	00000024 FatFile::printModifyDateTime(Print*)
00011ee4 g     F .text.itcm	0000004a _vdprintf_r
000072a8 g     F .text.itcm	000000b0 SPIClass::setSCK(unsigned char)
200000cc  w    O .data	00000060 vtable for SDFile
0000ff54 g     F .text.itcm	000000c6 memmove
0000303c g     F .text.itcm	00000046 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)
0000cd0c g     F .text.itcm	00000068 SdioCard::stopTransmission(bool)
0001331c g     F .text.itcm	0000004c _Balloc
0000d498  w    F .text.itcm	00000006 can1_rx_warn_isr
00006c38 g     F .text.itcm	0000002c MTPD::send_Event(unsigned short)
00001378  w    F .text.itcm	00000004 MTPStorage_SD::get_FSCount()
00013c54 g       .ARM.exidx	00000000 __exidx_end
0000d498  w    F .text.itcm	00000006 dma_error_isr
0000a4d4 g     F .text.itcm	0000003c FatPartition::freeChain(unsigned long)
20005270 g     O .bss	00000001 EventResponder::runningFromYield
0000cf20 g     F .text.itcm	0000001a SdSpiArduinoDriver::receive()
0000b5c0 g     F .text.itcm	00000096 SdSpiCard::cardCommand(unsigned char, unsigned long)
0000d498  w    F .text.itcm	00000006 i2c0_isr
0000e934 g     F .text.itcm	0000002c Print::write(unsigned char const*, unsigned int)
0000f304 g     F .text.itcm	0000008a .hidden __gtdf2
0000a704 g     F .text.itcm	00000024 FatFile::lfnChecksum(unsigned char*)
0000f838 g     F .text.itcm	0000000c __errno
00000778  w    F .text.itcm	00000026 SDFile::isDirectory()
0000d498  w    F .text.itcm	00000006 portd_isr
60001000 g     O .text.headers	00000020 ImageVectorTable
0000d498  w    F .text.itcm	00000006 enet_error_isr
00008378 g     F .text.itcm	000000ae ExFatFile::printName(Print*)
00000a40  w    F .text.itcm	00000028 File::~File()
20005260 g     O .bss	00000004 EventResponder::firstInterrupt
00005534 g     F .text.itcm	0000006e MTPD::GetObjectHandles(unsigned long, unsigned long)
0000b3ec  w    F .text.itcm	0000000e SdSpiCard::~SdSpiCard()
0000b158 g     F .text.itcm	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000d498  w    F .text.itcm	00000006 tpm1_isr
000089d8 g     F .text.itcm	00000018 ExFatPartition::rootLength()
0000b3d0  w    F .text.itcm	00000004 SdSpiCard::errorData() const
0000e924  w    F .text.itcm	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
200006ac g     O .data	00000200 digital_pin_to_info_PGM
200052dc g     O .bss	00000004 errno
0000b86c g     F .text.itcm	0000004c SdSpiCard::readOCR(unsigned long*)
0000cf3c g     F .text.itcm	00000020 SdSpiArduinoDriver::receive(unsigned char*, unsigned int)
0000ad2c g     F .text.itcm	00000390 FatFile::open(FatFile*, fname_t*, int)
000087cc g     F .text.itcm	00000012 ExFatPartition::fatGet(unsigned long, unsigned long*)
00013ab8 g       .text.itcm	00000000 _etext
00006fb4 g     F .text.itcm	00000134 _spi_dma_rxISR0()
20001d18 g       .bss	00000000 _sbss
0000cfc8 g     F .text.itcm	00000006 sdCsInit(unsigned char)
0000f3a0 g     F .text.itcm	00000010 .hidden __aeabi_cdcmple
0000be94 g     F .text.itcm	0000000c SdioCard::errorData() const
0000138c g     F .text.itcm	0000000c MTPStorage_SD::totalSize(unsigned long)
000041a8 g     F .text.itcm	000000fe MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)
0000c544 g     F .text.itcm	000000d0 SdioCard::writeSector(unsigned long, unsigned char const*)
0000d498  w    F .text.itcm	00000006 porte_isr
6000162c g       *ABS*	00000000 _stextload
000011d0 g     F .text.itcm	0000004c loop
0000d498  w    F .text.itcm	00000006 portb_isr
0000d498  w    F .text.itcm	00000006 spi1_isr
00005a20 g     F .text.itcm	00000144 MTPD::GetStorageInfo(unsigned long)
0000d498  w    F .text.itcm	00000006 uart3_status_isr
00007a2c g     F .text.itcm	000000c4 ExFatFile::parsePathName(char const*, ExName_t*, char const**)
0000d498  w    F .text.itcm	00000006 mcm_isr
0000cadc g     F .text.itcm	000000cc SdioCard::readData(unsigned char*)
0000b504 g     F .text.itcm	00000080 SdSpiCard::readData(unsigned char*, unsigned int)
20005264 g     O .bss	00000004 EventResponder::lastInterrupt
0000d498  w    F .text.itcm	00000006 uart1_status_isr
0000b1d0 g     F .text.itcm	00000028 FsBaseFile::close()
0000cfd4 g     F .text.itcm	000001a6 memcpy
0000d498  w    F .text.itcm	00000006 randnum_isr
0000f390 g     F .text.itcm	00000020 .hidden __aeabi_cdrcmple
000000a4  w    F .text.itcm	0000000c File::available()
00003084 g     F .text.itcm	000007b4 MTPStorage_SD::removeFile(unsigned long, char*)
000027bc g     F .text.itcm	00000816 MTPStorage_SD::ScanDir(unsigned long, unsigned long)
00008804 g     F .text.itcm	00000080 ExFatPartition::freeChain(unsigned long)
00002144 g     F .text.itcm	0000046c MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)
00009ac0 g     F .text.itcm	0000002a FatFile::peek()
00010800 g     F .text.itcm	000016e4 _svfprintf_r
0000ee14 g     F .text.itcm	00000022 .hidden __floatsidf
00000210  w    F .text.itcm	00000014 SDFile::whoami()
20001d34  w    O .bss	00000001 SDFile::name()::zeroterm
20005150 g     O .bss	00000004 systick_millis_count
0000f30c g     F .text.itcm	00000082 .hidden __ltdf2
00009004 g     F .text.itcm	000000aa ExFatFile::rename(ExFatFile*, char const*)
0000d450  w    F .text.itcm	00000048 bus_fault_isr
0000054c  w    F .text.itcm	00000044 SDFile::truncate(unsigned long long)
00006570 g     F .text.itcm	00000678 MTPD::loop()
0000d498  w    F .text.itcm	00000006 watchdog_isr
0000f490 g     F .text.itcm	00000000 .hidden __aeabi_uldivmod
0000d498  w    F .text.itcm	00000006 i2c1_isr
20005254 g     O .bss	00000001 usb_configuration
0000d498  w    F .text.itcm	00000006 dma_ch11_isr
00000084  w    F .text.itcm	00000006 SdCardInterface::status()
60000010 g     O .text.headers	00000200 FlexSPI_NOR_Config
0000cdf4 g     F .text.itcm	0000002c SdioCard::syncDevice()
0000c3ac g     F .text.itcm	0000009c SdioCard::writeData(unsigned char const*)
20005271 g     O .bss	00000001 SPCRemulation::pinout
00000910  w    F .text.itcm	0000005a StreamFile<FsBaseFile, unsigned long long>::available()
00009aec g     F .text.itcm	00000040 FatFile::readDirCache(bool)
0000d498  w    F .text.itcm	00000006 i2c2_isr
20000bfc  w    O .data	00000018 usb_string_manufacturer_name
200052d0 g     O .bss	0000000c usb_rx_byte_count_data
0000d498  w    F .text.itcm	00000006 pit1_isr
20000c80 g     O .data	00000008 usb_string_mtp
0000f894 g     F .text.itcm	00000010 malloc
0000d498  w    F .text.itcm	00000006 dma_ch4_isr
0000d498  w    F .text.itcm	00000006 software_isr
20000048  w    O .data	00000024 vtable for FsFile
0000d498  w    F .text.itcm	00000006 dma_ch7_isr
00006c6c  w    F .text.itcm	0000001c EventResponder::triggerEvent(int, void*)
20000a60 g     O .data	000000c8 __mprec_tens
0000e684 g     F .text.itcm	000000c4 usb_init
20004c00 g     O .bss	00000004 sessionID_
0000b3e4  w    F .text.itcm	00000004 SdSpiCard::type() const
0000d498  w    F .text.itcm	00000006 lptmr_isr
000009b8  w    F .text.itcm	00000088 SDFile::seek(unsigned long long, int)
20005298 g     O .bss	00000004 __malloc_top_pad
0000d9d0 g     F .text.itcm	00000024 rtc_set
20000ba4 g     O .data	00000038 SPI1
0000b438 g     F .text.itcm	0000007a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
aaaaaabf g       *ABS*	00000000 _flexram_bank_config
000090b0 g     F .text.itcm	000000e2 ExFatFile::truncate()
20000b5c g     O .data	00000000 .hidden __dso_handle
0000edf4 g     F .text.itcm	0000001e .hidden __aeabi_ui2d
00013300 g     F .text.itcm	0000001c _localeconv_r
20000b60 g     O .data	00000008 sd_str
0000d9c0 g     F .text.itcm	00000010 attachInterruptVector
0000cee8 g     F .text.itcm	00000038 SdSpiArduinoDriver::deactivate()
00013498 g     F .text.itcm	00000012 __i2b
20000000 g       .data	00000000 _sdata
0000011c  w    F .text.itcm	0000000c File::operator bool()
0000f4c0 g     F .text.itcm	000002e2 .hidden __udivmoddi4
00005864 g     F .text.itcm	000001bc MTPD::getObjectPropValue(unsigned long, unsigned long)
0000eb70 g     F .text.itcm	00000000 .hidden __aeabi_drsub
0000942c g     F .text.itcm	00000034 FatFile::addCluster()
000104a0 g     F .text.itcm	00000024 _sbrk_r
0000b8b8 g     F .text.itcm	0000003e SdSpiCard::readRegister(unsigned char, void*)
0000bf70 g     F .text.itcm	00000020 SdioCard::type() const
00000098  w    F .text.itcm	0000000c File::write(void const*, unsigned int)
60001400 g     F .text.code	000001e4 ResetHandler
0000d17c g     F .text.itcm	00000048 usb_serial_getchar
0000d498  w    F .text.itcm	00000006 can1_bus_off_isr
0000d498  w    F .text.itcm	00000006 ftm2_isr
00000500  w    F .text.itcm	0000004c SDFile::name()
200052c4 g     O .bss	00000008 usb_cdc_line_coding
0000d9f4 g     F .text.itcm	0000000a digitalWrite
20005268 g     O .bss	00000004 EventResponder::lastYield
0000d498  w    F .text.itcm	00000006 uart5_status_isr
0000d498  w    F .text.itcm	00000006 lpuart0_status_isr
00007a04 g     F .text.itcm	00000028 ExFatFile::openRoot(ExFatVolume*)
2000063c g     O .data	00000006 usb_endpoint_config_table
0000d498  w    F .text.itcm	00000006 dma_ch9_isr
0000040c  w    F .text.itcm	00000038 StreamFile<FsBaseFile, unsigned long long>::read()
0000d498  w    F .text.itcm	00000006 pit2_isr
0000f3c4 g     F .text.itcm	00000012 .hidden __aeabi_dcmplt
2000051c g     O .data	0000005c SPISettings::ctar_clock_table
20005294 g     O .bss	00000004 __malloc_max_sbrked_mem
000006dc  w    F .text.itcm	0000001a SDFile::position()
0000da00 g     F .text.itcm	0000000a pinMode
0000bbb8 g     F .text.itcm	00000042 SdSpiCard::writeStop()
000025b0 g     F .text.itcm	00000160 MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)
0000dc54 g     F .text.itcm	0000004c usb_free
0000d498  w    F .text.itcm	00000006 i2c3_isr
0000ee38 g     F .text.itcm	0000003a .hidden __extendsfdf2
0000f134 g     F .text.itcm	000001d0 .hidden __aeabi_ddiv
0000eb7c g     F .text.itcm	00000276 .hidden __adddf3
000057f8 g     F .text.itcm	0000006c MTPD::getObjectPropsSupported(unsigned long)
60017000 g     O .text.csf	00000c00 hab_csf
000050ec g     F .text.itcm	000000a8 MTPD::writestring(char const*)
0000bc50 g     F .text.itcm	00000032 SdSpiCard::writeData(unsigned char const*)
000000b0  w    F .text.itcm	00000010 File::peek()
0000a510 g     F .text.itcm	000000b0 FatPartition::freeClusterCount()
20280000 g       .text.csf	00000000 _heap_end
00000804  w    F .text.itcm	000000d0 SDClass::open(char const*, unsigned char)
00013c4c g       .ARM.exidx	00000000 __exidx_start
0000eee0 g     F .text.itcm	00000254 .hidden __aeabi_dmul
0000bab0 g     F .text.itcm	00000050 SdSpiCard::writeStart(unsigned long)
0000d498  w    F .text.itcm	00000006 pit0_isr
2000526c g     O .bss	00000004 EventResponder::firstYield
200008d8 g     O .data	00000004 _global_impure_ptr
000013a4 g     F .text.itcm	00000080 MTPStorage_SD::write(char const*, unsigned long)
0000d498  w    F .text.itcm	00000006 can1_error_isr
00000458  w    F .text.itcm	00000034 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
000100c0 g     F .text.itcm	000003de _realloc_r
00000714  w    F .text.itcm	00000018 SDFile::read(void*, unsigned int)
0000f844 g     F .text.itcm	00000050 __libc_init_array
0000d5a8 g     F .text.itcm	00000354 dtostrf
000005e0  w    F .text.itcm	00000044 SDFile::rewindDirectory()
0000d498  w    F .text.itcm	00000006 can0_wakeup_isr
000082a4 g     F .text.itcm	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
0000bea0 g     F .text.itcm	0000001c SdioCard::readCID(CID*)
00008de8 g     F .text.itcm	000000e6 ExFatFile::addDirCluster()
0000d498  w    F .text.itcm	00000006 flash_cmd_isr
000043b4 g     F .text.itcm	00000034 mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)
0000bbfc g     F .text.itcm	00000052 SdSpiCard::writeData(unsigned char, unsigned char const*)
20000b28 g     O .data	00000028 __mprec_bigtens
0000e90c  w    F .text.itcm	00000004 usb_serial_class::clear()
0000edf4 g     F .text.itcm	0000001e .hidden __floatunsidf
0000d498  w    F .text.itcm	00000006 uart2_status_isr
60015280 g       *ABS*	00000000 _sdataload
0000d4b0 g     F .text.itcm	0000002c _sbrk
0001372c g     F .text.itcm	00000042 __mcmp
00003900 g     F .text.itcm	000008a8 mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)
2000012c  w    O .data	00000028 vtable for SDClass
000001d0  w    F .text.itcm	00000012 SDFile::operator bool()
20000be4 g     O .data	00000004 __brkval
000078dc g     F .text.itcm	00000042 fsPrintDateTime(Print*, unsigned short, unsigned short)
2000514c g     O .bss	00000001 usb_cdc_line_rtsdtr
0000d408 g     F .text.itcm	00000048 usb_serial_flush_callback
600015e4 g     F .text.code	00000000 _init
000094f8 g     F .text.itcm	0000001e FatFile::cacheDirEntry(unsigned char)
0000d498  w    F .text.itcm	00000006 svcall_isr
000007a0  w    F .text.itcm	00000062 SDClass::remove(char const*)
000002c0  w    F .text.itcm	0000001c SDFile::close()
0000d498  w    F .text.itcm	00000006 dma_ch15_isr
00000b74  w    F .text.itcm	0000005c SDFile::~SDFile()
00007628 g     F .text.itcm	00000020 day()
0000d498  w    F .text.itcm	00000006 uart1_error_isr
0000d498  w    F .text.itcm	00000006 usbhs_phy_isr
0000ce98 g     F .text.itcm	00000050 SdSpiArduinoDriver::begin(SdSpiConfig)
20005300 g       .bss	00000000 _ebss
0000c4bc g     F .text.itcm	00000088 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005250 g     F .text.itcm	0000027c MTPD::WriteDescriptor()
20000b68 g     O .data	00000004 propertyListNum
000008d4  w    F .text.itcm	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
000133fc g     F .text.itcm	00000040 __hi0bits
0000f440 g     F .text.itcm	0000004e .hidden __fixdfsi
00008ed0 g     F .text.itcm	0000005a ExFatFile::mkdir(ExFatFile*, ExName_t*)
0000d498 g     F .text.itcm	00000006 unused_isr
202001a0 g       .bss.dma	00000000 _heap_start
000054cc g     F .text.itcm	00000068 MTPD::WriteStorageIDs()
0000d498  w    F .text.itcm	00000006 spi0_isr
0000d498  w    F .text.itcm	00000006 dma_ch3_isr
0000768c  w    F .text.itcm	00000002 SDClass::~SDClass()
00004e34 g     F .text.itcm	00000214 MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)
20001d38 g     O .bss	00000978 sdx
00000a40  w    F .text.itcm	00000028 File::~File()
00000bd0 g     F .text.itcm	000003a2 storage_configure()
00000003 g       *ABS*	00000000 _itcm_block_count
00007668 g     F .text.itcm	00000024 year()
0000ea80 g     F .text.itcm	00000004 operator delete(void*, unsigned int)
0000d498  w    F .text.itcm	00000006 flash_error_isr
0000eb7c g     F .text.itcm	00000276 .hidden __aeabi_dadd
0000f30c g     F .text.itcm	00000082 .hidden __ledf2
0000d498  w    F .text.itcm	00000006 uart5_error_isr
0000d498  w    F .text.itcm	00000006 rtc_seconds_isr
20000488 g     O .data	00000094 SPIClass::spi0_hardware
0000d498  w    F .text.itcm	00000006 pdb_isr
000135dc g     F .text.itcm	000000a0 __pow5mult
00009d00 g     F .text.itcm	0000005c FatFile::rmdir()
0000ee74 g     F .text.itcm	0000006a .hidden __aeabi_ul2d
0000d450  w    F .text.itcm	00000048 usage_fault_isr
0000d498  w    F .text.itcm	00000006 dac1_isr
00013ab4 g     O .vectors	00000198 _VectorsFlash
0000a450 g     F .text.itcm	00000082 FatPartition::allocateCluster(unsigned long, unsigned long*)
0000d498  w    F .text.itcm	00000006 dma_ch14_isr
0000096c  w    F .text.itcm	0000004c SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
200052cc g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
0000e8fc g     F .text.itcm	00000010 systick_isr
0000d498  w    F .text.itcm	00000006 rtc_alarm_isr
0000013c  w    F .text.itcm	0000000c File::isDirectory()
0000b0bc g     F .text.itcm	00000076 FatFile::getSFN(char*)
0000b9f0 g     F .text.itcm	0000006c SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000d498  w    F .text.itcm	00000006 dma_ch2_isr
20000cdc g     O .data	00000010 Serial
000077ac g     F .text.itcm	00000054 fmtBase10(char*, unsigned short)
0000d498  w    F .text.itcm	00000006 ftm1_isr
000000d8  w    F .text.itcm	00000016 File::seek(unsigned long long, int)
000082f4 g     F .text.itcm	00000060 ExFatFile::printFileSize(Print*)
0000e92c  w    F .text.itcm	00000006 usb_serial_class::write(unsigned char)
0000b278 g     F .text.itcm	0000005e FsBaseFile::openNext(FsBaseFile*, int)
0000d4a0  w    F .text.itcm	0000000c startup_early_hook
0000bc84 g     F .text.itcm	00000064 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
0000d498  w    F .text.itcm	00000006 dma_ch13_isr
00008a84 g     F .text.itcm	0000008c ExFatFile::addCluster()
2000006c  w    O .data	00000060 vtable for File
0000d498  w    F .text.itcm	00000006 uart2_error_isr
00000624  w    F .text.itcm	00000052 SDClass::usedSize()
0000d1c4 g     F .text.itcm	00000030 usb_serial_peekchar
0000f400 g     F .text.itcm	00000012 .hidden __aeabi_dcmpgt
00001658 g     F .text.itcm	00000002 mtp_yield()
0000fe50 g     F .text.itcm	00000000 memchr
0000a3e8 g     F .text.itcm	00000066 FatPartition::fatPut(unsigned long, unsigned long)
20000cbc g     O .data	00000016 usb_string_serial_number_default
0000d450 g     F .text.itcm	00000048 fault_isr
00013130 g     F .text.itcm	000001d0 _free_r
0000c320 g     F .text.itcm	0000008c SdioCard::readStop()
0000773c g     F .text.itcm	00000060 FsCache::get(unsigned long, unsigned char)
0000f3ec g     F .text.itcm	00000012 .hidden __aeabi_dcmpge
0000d498  w    F .text.itcm	00000006 usb_charge_isr
000042a8 g     F .text.itcm	0000010a MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)
0000e91c  w    F .text.itcm	00000004 usb_serial_class::flush()
0000d498  w    F .text.itcm	00000006 cmt_isr
0000eb78 g     F .text.itcm	0000027a .hidden __aeabi_dsub
0000a5c0 g     F .text.itcm	0000011a FatPartition::init(BlockDeviceInterface*, unsigned char)
0000d498  w    F .text.itcm	00000006 usbhs_isr
00009630 g     F .text.itcm	0000014e FatFile::mkdir(FatFile*, fname_t*)
20001694 g     O .data	00000004 __malloc_sbrk_base
0000e914  w    F .text.itcm	00000004 usb_serial_class::read()
0000d498  w    F .text.itcm	00000006 ftm3_isr
00000180  w    F .text.itcm	0000000c File::rewindDirectory()
0000d498  w    F .text.itcm	00000006 tsi0_isr
0000ab4c g     F .text.itcm	00000128 FatFile::remove()
0000ee74 g     F .text.itcm	0000006a .hidden __floatundidf
0000d4dc  w    F .text.itcm	00000002 __cxa_pure_virtual
0001367c g     F .text.itcm	000000ae __lshift
00009780 g     F .text.itcm	000000c2 FatFile::mkdir(FatFile*, char const*, bool)
0000d498  w    F .text.itcm	00000006 spi2_isr
000089f0 g     F .text.itcm	00000058 exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)
00013940 g     F .text.itcm	00000100 __ssprint_r
00013a40 g     F .text.itcm	0000005e _vasnprintf_r
0000ea78  w    F .text.itcm	00000002 serialEvent()
200051cd g     O .bss	00000001 usb_reboot_timer
00011f90 g     F .text.itcm	000000a4 __register_exitproc
000081a4 g     F .text.itcm	000000fe ExFatFile::open(ExFatFile*, char const*, int)
00007854 g     F .text.itcm	00000050 fsFmtDate(char*, unsigned short)
00010620 g     F .text.itcm	0000002c strlcpy
0001075c g     F .text.itcm	000000a0 strncmp
00008f2c g     F .text.itcm	000000d6 ExFatFile::mkdir(ExFatFile*, char const*, bool)
0000d210 g     F .text.itcm	00000038 usb_serial_flush_input
00008884 g     F .text.itcm	00000072 ExFatPartition::freeClusterCount()
00002030 g     F .text.itcm	00000064 MTPStorage_SD::ConstructFilename(int, char*, int)
000078a4 g     F .text.itcm	00000038 fsFmtTime(char*, unsigned short)
000134ac g     F .text.itcm	00000130 __multiply
0000d350 g     F .text.itcm	00000018 usb_serial_putchar
00000024 g       *ABS*	00000000 _teensy_model_identifier
2000529c g     O .bss	00000028 __malloc_current_mallinfo
00013884 g     F .text.itcm	000000ba __d2b
20005274 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
0000d498  w    F .text.itcm	00000006 can0_bus_off_isr
0000bf60  w    F .text.itcm	0000000e SdioCard::~SdioCard()
0000137c  w    F .text.itcm	00000008 MTPStorage_SD::get_FSName(unsigned long)
00007954 g     F .text.itcm	000000ae ExFatFile::getName(char*, unsigned int)
20005249 g     O .bss	00000001 usb_rx_memory_needed
0000c448 g     F .text.itcm	00000074 SdioCard::writeStart(unsigned long)
0000de10 g     F .text.itcm	00000874 usb_isr
0000f808 g     F .text.itcm	0000000c __cxa_atexit
00007af0 g     F .text.itcm	000001a8 ExFatFile::read(void*, unsigned int)
0000ee14 g     F .text.itcm	00000022 .hidden __aeabi_i2d
0000072c  w    F .text.itcm	00000018 SDFile::peek()
0000779c g     F .text.itcm	0000000e FsCache::sync()
20000b6c g     O .data	00000038 SPI
0000fef0 g     F .text.itcm	00000062 memcmp
200008ac  w    O .data	00000028 vtable for usb_serial_class
0000cf5c g     F .text.itcm	00000016 SdSpiArduinoDriver::send(unsigned char)
0000d498  w    F .text.itcm	00000006 uart3_error_isr
00006268 g     F .text.itcm	0000007c MTPD::GetObject(unsigned long)
0000cfd0 g     F .text.itcm	00000004 sdCsWrite(unsigned char, bool)
0000f7a4  w    F .text.itcm	00000002 .hidden __aeabi_ldiv0
00008be8 g     F .text.itcm	0000005a ExFatFile::rmdir()
0000d498  w    F .text.itcm	00000006 porta_isr
00005b64 g     F .text.itcm	000006e6 MTPD::getObjectPropDesc(unsigned long, unsigned long)
0000f134 g     F .text.itcm	000001d0 .hidden __divdf3
20001698 g     O .usbbuffers	000005a0 usb_buffer_memory
0000b908 g     F .text.itcm	00000098 SdSpiCard::sectorCount()
0000d498  w    F .text.itcm	00000006 low_voltage_isr
00001388 g     F .text.itcm	00000004 MTPStorage_SD::has_directories(unsigned long)
20001288 g     O .data	00000408 __malloc_av_
0000d498  w    F .text.itcm	00000006 can0_error_isr
0000daec g     F .text.itcm	00000128 _init_Teensyduino_internal_
00000444  w    F .text.itcm	00000014 SDFile::flush()
0000eee0 g     F .text.itcm	00000254 .hidden __muldf3
0000d3b0 g     F .text.itcm	00000058 usb_serial_flush_output
0000d498  w    F .text.itcm	00000006 dma_ch12_isr
000100b8 g     F .text.itcm	00000002 __malloc_lock
0000a844 g     F .text.itcm	0000024c FatFile::parsePathName(char const*, fname_t*, char const**)
0000d498  w    F .text.itcm	00000006 can1_wakeup_isr
00006c00 g     F .text.itcm	00000038 usb_mtp_sendEvent
20200000 g     O .bss.dma	00000198 _VectorsRam
0000cf74 g     F .text.itcm	00000052 SdSpiArduinoDriver::send(unsigned char const*, unsigned int)
0000f7a8 g     F .text.itcm	0000005e _calloc_r
0000d498  w    F .text.itcm	00000006 pit3_isr
000070e8 g     F .text.itcm	0000007c SPIClass::begin()
000062e4 g     F .text.itcm	0000006e MTPD::read(char*, unsigned long)
20004c1c g     O .bss	00000004 getTimePtr
20000cd8 g     O .data	00000001 yield_active_check_flags
0000d498  w    F .text.itcm	00000006 enet_rx_isr
00008d88 g     F .text.itcm	0000005e ExFatFile::sync()
00009b2c g     F .text.itcm	000001d4 FatFile::rename(FatFile*, char const*)
0000cd74 g     F .text.itcm	00000080 SdioCard::isBusy()
0000d498  w    F .text.itcm	00000006 portc_isr
0000ba5c g     F .text.itcm	00000038 SdSpiCard::readStop()
0001001c g     F .text.itcm	0000009a memset
0000ea68 g     F .text.itcm	00000010 main
20005290 g     O .bss	00000004 __malloc_max_total_mem
000085a8 g     F .text.itcm	000000b4 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00007528 g     F .text.itcm	000000a0 now()
00009194 g     F .text.itcm	00000264 ExFatFile::write(void const*, unsigned int)
20000274 g     O .data	00000060 vtable for MTPStorage_SD
000063c4 g     F .text.itcm	00000132 MTPD::SendObjectInfo(unsigned long, unsigned long)
000105cc g     F .text.itcm	00000052 strlcat
0000d450  w    F .text.itcm	00000048 memmanage_fault_isr
000095cc g     F .text.itcm	00000044 FatFile::dirEntry(DirFat_t*)
00000398  w    F .text.itcm	0000005a SDFile::available()
00000110  w    F .text.itcm	0000000c File::close()
0000d4e0 g     F .text.itcm	0000007c usb_init_serialnumber
6000162c g       .text.code	00000000 __init_array_end
00012160 g     F .text.itcm	00000e34 _dtoa_r
0000f8b4 g     F .text.itcm	00000570 _malloc_r
2000528c g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
0000d498  w    F .text.itcm	00000006 debugmonitor_isr
00011f48 g     F .text.itcm	0000001a __ascii_wctomb
0000b158 g     F .text.itcm	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000ee84 g     F .text.itcm	0000005a .hidden __aeabi_l2d
200050e8 g     O .bss	00000004 FatVolume::m_cwv
0000e834 g     F .text.itcm	00000080 EventResponder::triggerEventNotImmediate()
00007358 g     F .text.itcm	00000008 SPIClass::transfer(void const*, void*, unsigned int)
00000031 g       *ABS*	00000000 __rtc_localtime
0000da0c g     F .text.itcm	00000044 micros
00000148  w    F .text.itcm	00000038 File::openNextFile(unsigned char)
0000d498  w    F .text.itcm	00000006 cmp1_isr
0000aa90 g     F .text.itcm	000000ba FatFile::printName(Print*)
0000d498  w    F .text.itcm	00000006 ftm0_isr
00008c44 g     F .text.itcm	00000144 ExFatFile::syncDir()
00013094 g     F .text.itcm	0000009c _malloc_trim_r
20000cb8 g     O .data	00000004 string0
0000d248 g     F .text.itcm	00000108 usb_serial_write
0000135c  w    F .text.itcm	0000001a MTPStorage_SD::addFilesystem(FS&, char const*)
0000d4ac  w    F .text.itcm	00000002 startup_late_hook
0000e918  w    F .text.itcm	00000004 usb_serial_class::available()
20000cec g     O .data	00000001 _serialEvent_default
00006354 g     F .text.itcm	00000044 MTPD::readstring(char*)
00009f64 g     F .text.itcm	0000000c FatFile::sync()
00000590  w    F .text.itcm	00000050 SDClass::mkdir(char const*)
20000c88  w    O .data	0000002e usb_string_product_name
00005048 g     F .text.itcm	00000028 MTPD::GetNumObjects(unsigned long, unsigned long)
0000da50 g     F .text.itcm	0000009c delay
0000f314 g     F .text.itcm	0000007a .hidden __nedf2
0000d498  w    F .text.itcm	00000006 tpm0_isr
000014a0 g     F .text.itcm	00000118 MTPStorage_SD::CloseIndex()
00007934 g     F .text.itcm	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00013ab0 g     F .fini	00000000 _fini
00005070 g     F .text.itcm	00000018 MTPD::get_buffer()
00000128  w    F .text.itcm	00000014 File::name()
60001020 g     O .text.headers	0000000c BootData
00007648 g     F .text.itcm	00000020 month()
20000458 g     O .data	0000002e SPISettings::ctar_div_table
0000b9a0 g     F .text.itcm	00000050 SdSpiCard::readStart(unsigned long)
000082b4 g     F .text.itcm	00000040 ExFatFile::openNext(ExFatFile*, int)
000104c4 g     F .text.itcm	0000004c sprintf
0000e990 g     F .text.itcm	0000001c Print::printf(char const*, ...)
0000d498  w    F .text.itcm	00000006 i2s0_rx_isr
0000d498  w    F .text.itcm	00000006 uart4_error_isr
000095ac g     F .text.itcm	0000001e FatFile::close()
00007800 g     F .text.itcm	00000052 fmtBase10(char*, unsigned long)
000000f0  w    F .text.itcm	00000010 File::position()
00000a68  w    F .text.itcm	00000064 SDFile::~SDFile()
0000bee8  w    F .text.itcm	00000002 SdioCard::~SdioCard()
000003f4  w    F .text.itcm	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
000001b8  w    F .text.itcm	00000018 File::write(unsigned char)
00011f64 g     F .text.itcm	0000002c _write_r
20004c28 g     O .bss	000004b8 SD
0000c1dc g     F .text.itcm	000000ec SdioCard::erase(unsigned long, unsigned long)
0000d498  w    F .text.itcm	00000006 can0_message_isr
00007164 g     F .text.itcm	000000a4 SPIClass::setMOSI(unsigned char)
20001118 g     O .data	00000004 _impure_ptr
20000000  w    O .data	00000024 vtable for Stream
0000d498  w    F .text.itcm	00000006 can1_message_isr
00007c98 g     F .text.itcm	0000002e ExFatFile::peek()
20000024  w    O .data	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
0000d498  w    F .text.itcm	00000006 nmi_isr
0000ac74 g     F .text.itcm	000000b6 FatFile::lfnUniqueSfn(fname_t*)
000008e8  w    F .text.itcm	00000014 SDFile::write(void const*, unsigned int)
0000b3a0 g     F .text.itcm	00000028 FsVolume::open(char const*, int)
0000be88 g     F .text.itcm	0000000c SdioCard::errorCode() const
00009904 g     F .text.itcm	0000000e FatFile::open(FatVolume*, char const*, int)
000008fc  w    F .text.itcm	00000014 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
60001620 g       .text.code	00000000 __preinit_array_end
00000224 g     F .text.itcm	0000009c dateTime(unsigned short*, unsigned short*, unsigned char*)
0000b3e8  w    F .text.itcm	00000002 SdSpiCard::~SdSpiCard()
0000d498  w    F .text.itcm	00000006 sdhc_isr
000075e8 g     F .text.itcm	00000020 minute()
000088f8 g     F .text.itcm	000000e0 ExFatPartition::init(BlockDeviceInterface*, unsigned char)
00008740 g     F .text.itcm	00000034 ExFatPartition::dirCache(DirPos_t*, unsigned char)
0000bb00 g     F .text.itcm	000000b8 SdSpiCard::erase(unsigned long, unsigned long)
000038ec g     F .text.itcm	00000012 MTPStorage_SD::DeleteObject(unsigned long)
0000fe24 g     F .text.itcm	0000002a __ascii_mbtowc
0000b4b4 g     F .text.itcm	0000004e SdSpiCard::isBusy()
2000058c g     O .data	00000058 vtable for SdSpiCard
0000b900  w    F .text.itcm	00000008 SdSpiCard::readCID(CID*)
00000f74 g     F .text.itcm	0000025c setup
20000644 g     O .data	00000060 usb_descriptor_list
0000dca0 g     F .text.itcm	0000003c usb_rx
0000c018 g     F .text.itcm	00000020 SdioCard::status()
00001424 g     F .text.itcm	0000007c MTPStorage_SD::ResetIndex()
0000d498  w    F .text.itcm	00000006 dma_ch10_isr
00009610 g     F .text.itcm	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000080  w    F .text.itcm	00000002 Print::flush()
0000d498  w    F .text.itcm	00000006 uart0_error_isr
00000100  w    F .text.itcm	00000010 File::size()
00000678  w    F .text.itcm	00000062 SDClass::rmdir(char const*)
0000dc14 g     F .text.itcm	00000040 usb_malloc
00009920 g     F .text.itcm	0000019e FatFile::read(void*, unsigned int)
0000d498  w    F .text.itcm	00000006 i2s0_isr
00009914 g     F .text.itcm	0000000c FatFile::openRoot(FatVolume*)
200050e4 g     O .bss	00000004 ExFatVolume::m_cwv
20068000 g       .text.csf	00000000 _estack
0000b3c8 g     F .text.itcm	00000004 operator new(unsigned int, unsigned long*)
0000b8f8  w    F .text.itcm	00000008 SdSpiCard::readCSD(csd_t*)
0000018c  w    F .text.itcm	0000002c File::read()
0000d368 g     F .text.itcm	00000048 usb_serial_write_buffer_free
0000b584 g     F .text.itcm	0000003c SdSpiCard::waitNotBusy(unsigned short)
0000d498  w    F .text.itcm	00000006 enet_timer_isr
0000f3b0 g     F .text.itcm	00000012 .hidden __aeabi_dcmpeq
00000acc  w    F .text.itcm	00000030 File::~File()
0000e980  w    F .text.itcm	0000000e _write
20001698 g       .data	00000000 _edata
000087e0 g     F .text.itcm	00000024 ExFatPartition::fatPut(unsigned long, unsigned long)
000055a4 g     F .text.itcm	00000254 MTPD::GetObjectInfo(unsigned long)
0000bee8  w    F .text.itcm	00000002 SdioCard::~SdioCard()
0000d498  w    F .text.itcm	00000006 i2s0_tx_isr
0000d498  w    F .text.itcm	00000006 adc1_isr
0000ba94 g     F .text.itcm	0000001c SdSpiCard::syncDevice()
00009460 g     F .text.itcm	00000098 FatFile::addDirCluster()
0000008c  w    F .text.itcm	0000000c File::read(void*, unsigned int)
0000e920  w    F .text.itcm	00000004 usb_serial_class::availableForWrite()
0000d498  w    F .text.itcm	00000006 cmp0_isr
000000cc  w    F .text.itcm	0000000c File::truncate(unsigned long long)
0000d55c g     F .text.itcm	0000004c ultoa
0000768c  w    F .text.itcm	00000002 SDClass::~SDClass()
0000b658 g     F .text.itcm	00000214 SdSpiCard::begin(SdSpiConfig)
00007608 g     F .text.itcm	00000020 second()
0000b1f8 g     F .text.itcm	00000080 FsBaseFile::open(FsVolume*, char const*, int)
00001bd0 g     F .text.itcm	00000210 MTPStorage_SD::ReadIndexRecord(unsigned long)
0000ea7c g     F .text.itcm	00000004 operator new(unsigned int)
0000e8b4 g     F .text.itcm	00000044 EventResponder::runFromInterrupt()
20001690 g     O .data	00000004 __malloc_trim_threshold
0000e910  w    F .text.itcm	00000004 usb_serial_class::peek()
0000f814 g     F .text.itcm	00000024 fcvtf
00001de0 g     F .text.itcm	0000005e MTPStorage_SD::GetNextObjectHandle(unsigned long)
00000afc  w    F .text.itcm	00000078 MTPStorage_SD::~MTPStorage_SD()
200027c0 g     O .bss	00002440 mtpd
00013770 g     F .text.itcm	00000114 __mdiff
0000bed8 g     F .text.itcm	00000010 SdioCard::readOCR(unsigned long*)
0000f440 g     F .text.itcm	0000004e .hidden __aeabi_d2iz
00002710 g     F .text.itcm	000000aa MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)
00008774 g     F .text.itcm	00000058 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
2000513c g     O .bss	00000001 usb_cdc_transmit_flush_timer
00006e80 g     F .text.itcm	00000134 _spi_dma_rxISR1()
0000d498  w    F .text.itcm	00000006 pit_isr
000075c8 g     F .text.itcm	00000020 hour()
0000c320 g     F .text.itcm	0000008c SdioCard::writeStop()
0000bce8  w    F .text.itcm	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
0000b134 g     F .text.itcm	00000024 FatFile::printSFN(Print*)
00007920 g     F .text.itcm	00000014 ExFatFile::close()
2000094c g     O .data	00000101 _ctype_
0000d498  w    F .text.itcm	00000006 dac0_isr
0000b3d4  w    F .text.itcm	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
60001620 g       .text.code	00000000 __init_array_start
0000f7a4  w    F .text.itcm	00000002 .hidden __aeabi_idiv0
0000d498  w    F .text.itcm	00000006 can1_tx_warn_isr
0000165c g     F .text.itcm	00000394 MTPStorage_SD::OpenIndex()
0000f414 g     F .text.itcm	0000002c .hidden __unorddf2
0000048c  w    F .text.itcm	00000074 SDClass::rename(char const*, char const*)
0000d498  w    F .text.itcm	00000006 uart0_status_isr
0000d498  w    F .text.itcm	00000006 mcg_isr
60000000 g     O .text.headers	00000010 flashconfigbytes
00000000 g       .text.itcm	00000000 _stext
0000a224 g     F .text.itcm	0000003e FatFile::printFileSize(Print*)
00010680 g     F .text.itcm	000000dc strlen
0000a728 g     F .text.itcm	0000002e FatFile::openCluster(FatFile*)
200003c4 g     O .data	00000094 SPIClass::spi1_hardware
0000f3a0 g     F .text.itcm	00000010 .hidden __aeabi_cdcmpeq
00008428 g     F .text.itcm	00000120 ExFatFile::ls(Print*, unsigned char, unsigned char)
0000f304 g     F .text.itcm	0000008a .hidden __gedf2
00009d5c g     F .text.itcm	000000b0 FatFile::seekSet(unsigned long)
20000c88 g     O .data	0000002e usb_string_product_name_default
00011f30 g     F .text.itcm	00000018 vdprintf
0000d498  w    F .text.itcm	00000006 dma_ch1_isr
0000c170 g     F .text.itcm	0000006c SdioCard::sectorCount()
0000b2d8 g     F .text.itcm	000000c8 FsVolume::begin(BlockDeviceInterface*)
00006c64 g     F .text.itcm	00000008 MTPD::send_DeviceResetEvent()
0000dcdc g     F .text.itcm	0000002c usb_tx_packet_count
00009ee4 g     F .text.itcm	00000080 FatFile::openNext(FatFile*, int)
200005e4 g     O .data	00000058 vtable for SdioCard
0000ee38 g     F .text.itcm	0000003a .hidden __aeabi_f2d
0000d498  w    F .text.itcm	00000006 dma_ch5_isr
00001e94 g     F .text.itcm	0000019c MTPStorage_SD::close()
0000a758 g     F .text.itcm	000000ec FatFile::getName(char*, unsigned int)
0000d498  w    F .text.itcm	00000006 can0_rx_warn_isr
00000afc  w    F .text.itcm	00000078 MTPStorage_SD::~MTPStorage_SD()
00002094 g     F .text.itcm	000000b0 MTPStorage_SD::rename(unsigned long, char const*)
0000d498  w    F .text.itcm	00000006 can0_tx_warn_isr
0000d498  w    F .text.itcm	00000006 uart4_status_isr
0000cba8 g     F .text.itcm	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0000ce20 g     F .text.itcm	00000078 SdSpiArduinoDriver::activate()
00008354 g     F .text.itcm	00000024 ExFatFile::printModifyDateTime(Print*)
0000a264 g     F .text.itcm	00000114 FatFile::ls(Print*, unsigned char, unsigned char)
00001384 g     F .text.itcm	00000004 MTPStorage_SD::readonly(unsigned long)
0000eb78 g     F .text.itcm	0000027a .hidden __subdf3
60001620 g       .text.code	00000000 __preinit_array_start
0000865c g     F .text.itcm	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00001e7c g     F .text.itcm	00000016 MTPStorage_SD::GetSize(unsigned long)
000001e8  w    F .text.itcm	00000028 File::whoami()
0001343c g     F .text.itcm	0000005a __lo0bits
00008704 g     F .text.itcm	0000003a ExFatPartition::chainSize(unsigned long)
00009e0c g     F .text.itcm	000000d6 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
000173e4 g       *ABS*	00000000 _flashimagelen
0000eb64 g     F .text.itcm	0000000a __aeabi_atexit
0000624c g     F .text.itcm	0000001a MTPD::receive_buffer()
00000000  w      *UND*	00000000 __register_frame_info
00008b10 g     F .text.itcm	000000d6 ExFatFile::remove()
0000d498  w    F .text.itcm	00000006 cmp2_isr
0000e8f8 g     F .text.itcm	00000004 pendablesrvreq_isr
00000744  w    F .text.itcm	00000034 SDClass::totalSize()
000064f8 g     F .text.itcm	00000076 MTPD::SendObject()
00001398 g     F .text.itcm	0000000c MTPStorage_SD::usedSize(unsigned long)
0000007c  w    F .text.itcm	00000004 Print::availableForWrite()
2000111c g     O .data	0000016c __global_locale
0000d498  w    F .text.itcm	00000006 wakeup_isr
00007208 g     F .text.itcm	000000a0 SPIClass::setMISO(unsigned char)
0000c748 g     F .text.itcm	00000394 SdioCard::begin(SdioConfig)
0000d498  w    F .text.itcm	00000006 cmp3_isr
00007360 g     F .text.itcm	000001b0 breakTime(long, tmElements_t&)
0000a378 g     F .text.itcm	0000006e FatPartition::fatGet(unsigned long, unsigned long*)
0000f8a4 g     F .text.itcm	00000010 free
0000d498  w    F .text.itcm	00000006 tpm2_isr
0001337c g     F .text.itcm	00000080 __multadd
00013368 g     F .text.itcm	00000012 _Bfree
000006f8  w    F .text.itcm	0000001a SDFile::size()
0000d498  w    F .text.itcm	00000006 dma_ch0_isr
00000b74  w    F .text.itcm	0000005c SDFile::~SDFile()
20000cbc  w    O .data	00000016 usb_string_serial_number
0000d498  w    F .text.itcm	00000006 enet_tx_isr
00008a48 g     F .text.itcm	0000003a exFatHashName(char const*, unsigned int, unsigned short)
0000cc1c g     F .text.itcm	000000f0 SdioCard::readSector(unsigned long, unsigned char*)
0000bebc g     F .text.itcm	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text.code:

60001400 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
60001400:	ldr	r3, [pc, #352]	; (60001564 <ResetHandler+0x164>)
60001402:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
60001406:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
60001408:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
6000140a:	movw	r2, #55592	; 0xd928
6000140e:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
60001410:	nop
	__asm__ volatile ("nop");
60001412:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
60001414:	bl	60001610 <__startup_early_hook_veneer>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
60001418:	ldr	r3, [pc, #332]	; (60001568 <ResetHandler+0x168>)
6000141a:	mov.w	r2, #184549376	; 0xb000000
6000141e:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
60001420:	ldr	r2, [pc, #328]	; (6000156c <ResetHandler+0x16c>)
60001422:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
60001424:	ldr	r2, [pc, #328]	; (60001570 <ResetHandler+0x170>)
60001426:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
60001428:	ldr	r3, [pc, #328]	; (60001574 <ResetHandler+0x174>)
6000142a:	mov.w	r2, #15728640	; 0xf00000
6000142e:	str	r2, [r3, #0]
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
60001430:	ldr	r2, [pc, #324]	; (60001578 <ResetHandler+0x178>)
60001432:	ldr	r3, [r2, #0]
60001434:	ands.w	r3, r3, #256	; 0x100
60001438:	bne.n	60001444 <ResetHandler+0x44>
		RTC_SR = 0;
6000143a:	ldr	r1, [pc, #320]	; (6000157c <ResetHandler+0x17c>)
6000143c:	str	r3, [r1, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
6000143e:	mov.w	r3, #5376	; 0x1500
60001442:	str	r3, [r2, #0]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
60001444:	ldr	r3, [pc, #312]	; (60001580 <ResetHandler+0x180>)
60001446:	ldrb	r2, [r3, #0]
60001448:	lsls	r1, r2, #28
6000144a:	bpl.n	60001454 <ResetHandler+0x54>
6000144c:	ldrb	r2, [r3, #0]
6000144e:	orr.w	r2, r2, #8
60001452:	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
60001454:	ldr	r3, [pc, #300]	; (60001584 <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
60001456:	ldr	r1, [pc, #304]	; (60001588 <ResetHandler+0x188>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
60001458:	movs	r2, #42	; 0x2a
6000145a:	strb	r2, [r3, #0]
6000145c:	ldr	r2, [pc, #300]	; (6000158c <ResetHandler+0x18c>)
6000145e:	ldr	r3, [pc, #304]	; (60001590 <ResetHandler+0x190>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
60001460:	cmp	r3, r1
60001462:	bcs.n	6000146e <ResetHandler+0x6e>
60001464:	ldr.w	r0, [r2, #4]!
60001468:	str.w	r0, [r3], #4
6000146c:	b.n	60001460 <ResetHandler+0x60>
6000146e:	ldr	r3, [pc, #292]	; (60001594 <ResetHandler+0x194>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
60001470:	ldr	r1, [pc, #292]	; (60001598 <ResetHandler+0x198>)
60001472:	movs	r2, #0
60001474:	cmp	r3, r1
60001476:	bcs.n	6000147e <ResetHandler+0x7e>
60001478:	str.w	r2, [r3], #4
6000147c:	b.n	60001474 <ResetHandler+0x74>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
6000147e:	ldr	r1, [pc, #284]	; (6000159c <ResetHandler+0x19c>)
60001480:	ldr	r2, [pc, #284]	; (600015a0 <ResetHandler+0x1a0>)
60001482:	movs	r3, #0
60001484:	ldr.w	r0, [r2, r3, lsl #2]
60001488:	str.w	r0, [r1, r3, lsl #2]
6000148c:	adds	r3, #1
6000148e:	cmp	r3, #102	; 0x66
60001490:	bne.n	60001484 <ResetHandler+0x84>
60001492:	ldr	r3, [pc, #272]	; (600015a4 <ResetHandler+0x1a4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
60001494:	ldr	r2, [pc, #272]	; (600015a8 <ResetHandler+0x1a8>)
60001496:	movs	r1, #128	; 0x80
60001498:	strb.w	r1, [r3], #1
6000149c:	cmp	r3, r2
6000149e:	bne.n	60001498 <ResetHandler+0x98>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
600014a0:	ldr	r3, [pc, #264]	; (600015ac <ResetHandler+0x1ac>)
600014a2:	ldr	r2, [pc, #248]	; (6000159c <ResetHandler+0x19c>)
600014a4:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
600014a6:	ldr	r3, [pc, #264]	; (600015b0 <ResetHandler+0x1b0>)
600014a8:	movs	r2, #138	; 0x8a
600014aa:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
600014ac:	sub.w	r3, r3, #4096	; 0x1000
600014b0:	movs	r2, #36	; 0x24
600014b2:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
600014b4:	movs	r2, #160	; 0xa0
600014b6:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
600014b8:	ldrb	r2, [r3, #6]
600014ba:	lsls	r2, r2, #30
600014bc:	bpl.n	600014b8 <ResetHandler+0xb8>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
600014be:	ldrb	r2, [r3, #6]
600014c0:	lsls	r4, r2, #27
600014c2:	bmi.n	600014be <ResetHandler+0xbe>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
600014c4:	ldr	r2, [pc, #236]	; (600015b4 <ResetHandler+0x1b4>)
600014c6:	ldrb	r3, [r2, #6]
600014c8:	and.w	r3, r3, #12
600014cc:	cmp	r3, #8
600014ce:	ldr	r3, [pc, #228]	; (600015b4 <ResetHandler+0x1b4>)
600014d0:	bne.n	600014c6 <ResetHandler+0xc6>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
600014d2:	movs	r2, #3
600014d4:	strb	r2, [r3, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
600014d6:	movs	r2, #64	; 0x40
600014d8:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
600014da:	ldrb	r2, [r3, #6]
600014dc:	lsls	r0, r2, #26
600014de:	bpl.n	600014da <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
600014e0:	ldr	r2, [pc, #208]	; (600015b4 <ResetHandler+0x1b4>)
600014e2:	ldrb	r1, [r2, #6]
600014e4:	ldr	r3, [pc, #204]	; (600015b4 <ResetHandler+0x1b4>)
600014e6:	lsls	r1, r1, #25
600014e8:	bpl.n	600014e2 <ResetHandler+0xe2>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
600014ea:	ldr	r2, [pc, #204]	; (600015b8 <ResetHandler+0x1b8>)
600014ec:	ldr	r1, [pc, #204]	; (600015bc <ResetHandler+0x1bc>)
600014ee:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
600014f0:	movs	r1, #2
600014f2:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
600014f4:	movs	r2, #32
600014f6:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
600014f8:	ldrb	r2, [r3, #6]
600014fa:	and.w	r2, r2, #12
600014fe:	cmp	r2, #12
60001500:	bne.n	600014f8 <ResetHandler+0xf8>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
60001502:	ldr	r3, [pc, #188]	; (600015c0 <ResetHandler+0x1c0>)
60001504:	ldr	r2, [pc, #188]	; (600015c4 <ResetHandler+0x1c4>)
60001506:	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
60001508:	ldr	r3, [pc, #188]	; (600015c8 <ResetHandler+0x1c8>)
6000150a:	ldr	r2, [pc, #192]	; (600015cc <ResetHandler+0x1cc>)
6000150c:	str	r2, [r3, #0]
	SYST_CVR = 0;
6000150e:	movs	r2, #0
60001510:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001512:	movs	r2, #7
60001514:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
60001518:	ldr	r2, [pc, #180]	; (600015d0 <ResetHandler+0x1d0>)
6000151a:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
6000151e:	cpsie	i

	_init_Teensyduino_internal_();
60001520:	bl	60001608 <___init_Teensyduino_internal__veneer>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
60001524:	ldr	r3, [pc, #84]	; (6000157c <ResetHandler+0x17c>)
60001526:	ldr	r3, [r3, #0]
60001528:	lsls	r2, r3, #31
6000152a:	bpl.n	60001538 <ResetHandler+0x138>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
6000152c:	ldr	r0, [pc, #164]	; (600015d4 <ResetHandler+0x1d4>)
6000152e:	bl	600015f8 <__rtc_set_veneer>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
60001532:	ldr	r3, [pc, #164]	; (600015d8 <ResetHandler+0x1d8>)
60001534:	ldr	r2, [pc, #164]	; (600015dc <ResetHandler+0x1dc>)
60001536:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
60001538:	ldr	r3, [pc, #164]	; (600015e0 <ResetHandler+0x1e0>)
6000153a:	ldrb	r3, [r3, #0]
6000153c:	lsls	r3, r3, #25
6000153e:	bpl.n	60001554 <ResetHandler+0x154>
60001540:	ldr	r4, [pc, #148]	; (600015d8 <ResetHandler+0x1d8>)
60001542:	ldr	r3, [pc, #152]	; (600015dc <ResetHandler+0x1dc>)
60001544:	ldr	r2, [r4, #0]
60001546:	cmp	r2, r3
60001548:	bne.n	60001554 <ResetHandler+0x154>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
6000154a:	ldr	r0, [pc, #136]	; (600015d4 <ResetHandler+0x1d4>)
6000154c:	bl	600015f8 <__rtc_set_veneer>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
60001550:	movs	r3, #0
60001552:	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
60001554:	bl	60001600 <____libc_init_array_veneer>

	startup_late_hook();
60001558:	bl	60001618 <__startup_late_hook_veneer>
	main();
6000155c:	bl	600015f0 <__main_veneer>
60001560:	b.n	60001560 <ResetHandler+0x160>
60001562:	nop
60001564:	.word	0x4005200e
60001568:	.word	0x40048030
6000156c:	.word	0x00043f82
60001570:	.word	0x2b000001
60001574:	.word	0xe000ed88
60001578:	.word	0x4003d010
6000157c:	.word	0x4003d014
60001580:	.word	0x4007d002
60001584:	.word	0x4007e000
60001588:	.word	0x20001698
6000158c:	.word	0x00013ab4
60001590:	.word	0x20000000
60001594:	.word	0x20001d18
60001598:	.word	0x20005300
6000159c:	.word	0x20200000
600015a0:	.word	0x00013ab4
600015a4:	.word	0xe000e400
600015a8:	.word	0xe000e456
600015ac:	.word	0xe000ed08
600015b0:	.word	0x40065000
600015b4:	.word	0x40064000
600015b8:	.word	0x40048044
600015bc:	.word	0x01030000
600015c0:	.word	0x40048004
600015c4:	.word	0x000510c0
600015c8:	.word	0xe000e014
600015cc:	.word	0x000176ff
600015d0:	.word	0x20200000
600015d4:	.word	0x00000031
600015d8:	.word	0x4003e01c
600015dc:	.word	0x5a94c3a5
600015e0:	.word	0x4007f000

600015e4 <_init>:
600015e4:	push	{r3, r4, r5, r6, r7, lr}
600015e6:	nop
600015e8:	pop	{r3, r4, r5, r6, r7}
600015ea:	pop	{r3}
600015ec:	mov	lr, r3
600015ee:	bx	lr

600015f0 <__main_veneer>:
600015f0:	ldr.w	pc, [pc]	; 600015f4 <__main_veneer+0x4>
600015f4:	.word	0x0000ea69

600015f8 <__rtc_set_veneer>:
600015f8:	ldr.w	pc, [pc]	; 600015fc <__rtc_set_veneer+0x4>
600015fc:	.word	0x0000d9d1

60001600 <____libc_init_array_veneer>:
60001600:	ldr.w	pc, [pc]	; 60001604 <____libc_init_array_veneer+0x4>
60001604:	.word	0x0000f845

60001608 <___init_Teensyduino_internal__veneer>:
60001608:	ldr.w	pc, [pc]	; 6000160c <___init_Teensyduino_internal__veneer+0x4>
6000160c:	.word	0x0000daed

60001610 <__startup_early_hook_veneer>:
60001610:	ldr.w	pc, [pc]	; 60001614 <__startup_early_hook_veneer+0x4>
60001614:	.word	0x0000d4a1

60001618 <__startup_late_hook_veneer>:
60001618:	ldr.w	pc, [pc]	; 6000161c <__startup_late_hook_veneer+0x4>
6000161c:	.word	0x0000d4ad

60001620 <__init_array_start>:
60001620:	.word	0x00000045
60001624:	.word	0x0000121d
60001628:	.word	0x00007691

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
	if (basepri > 0 && basepri < priority) priority = basepri;
      20:	.word	0x4c05b510
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
	if (faultmask) return -1;
      24:	ldrb	r3, [r4, #0]
      26:	cbnz	r3, 36 <__rtc_localtime+0x5>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
	if (basepri > 0 && basepri < priority) priority = basepri;
	return priority;
}
      28:	ldr	r3, [pc, #16]	; (3c <__rtc_localtime+0xb>)
	if (faultmask) return -1;
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
	if (primask) return 0;
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
      2a:	cbz	r3, 32 <__rtc_localtime+0x1>
      2c:	ldr	r0, [pc, #16]	; (40 <__rtc_localtime+0xf>)
      2e:	nop.w
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
      32:	movs	r3, #1
      34:	.word	0xbd107023
      38:	adds	r0, r3, #4
      3a:	movs	r0, #0
    goto fail;
  }
  if (!dir.isDir()) {
    goto fail;
  }
  m_vwd = dir;
      3c:	movs	r0, r0
  return true;

 fail:
  return false;
}
      3e:	movs	r0, r0
      40:	subs	r2, #180	; 0xb4
      42:	movs	r1, r0

00000044 <frame_dummy>:
  }
  m_vwd = dir;
  return true;

 fail:
  return false;
      44:	ldr	r3, [pc, #32]	; (68 <frame_dummy+0x24>)
}
      46:	push	{r4, lr}
      48:	.word	0x4908b11b
uint8_t 		HardwareSerial::s_count_serials_with_serial_events = 0;

// simple helper function that add us to the list of Serial ports that have
// their own serialEvent code defined that needs to be called at yield.
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
      4c:	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	.short	0xf3af
  m_vwd = dir;
  return true;

 fail:
  return false;
}
      50:	strh	r0, [r0, #0]
      52:	.short	0x4808
      54:	ldr	r3, [r0, #0]
  }
  m_vwd = dir;
  return true;

 fail:
  return false;
      56:	.short	0xb903
}
      58:	pop	{r4, pc}
      5a:	ldr	r3, [pc, #28]	; (78 <frame_dummy+0x34>)
      5c:	.word	0xd0fb2b00
      60:	ldmia.w	sp!, {r4, lr}
      64:	.word	0xbf004718
      68:	movs	r0, r0
      6a:	.short	0x0000
      6c:	adds	r4, r3, #4
      6e:	.short	0x2000
      70:	subs	r2, #180	; 0xb4
      72:	.short	0x0001
      74:	asrs	r0, r3, #26
      76:	movs	r0, #0
      78:	.word	0x00000000

0000007c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
      7c:	movs	r0, #0
      7e:	.short	0x4770

00000080 <Print::flush()>:
	virtual void flush()				{ }
      80:	bx	lr
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
      82:	nop

00000084 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
      84:	.word	0x30fff04f
      88:	bx	lr
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
      8a:	nop

0000008c <File::read(void*, unsigned int)>:
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
      8c:	.word	0xb1106900
      90:	ldr	r3, [r0, #0]
      92:	.short	0x6a9b
      94:	bx	r3
	}
      96:	.short	0x4770

00000098 <File::write(void const*, unsigned int)>:
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
      98:	ldr	r0, [r0, #16]
      9a:	.short	0xb110
      9c:	ldr	r3, [r0, #0]
      9e:	.short	0x6adb
      a0:	bx	r3
	}
      a2:	.short	0x4770

000000a4 <File::available()>:
	virtual int available() {
		return (f) ? f->available() : 0;
      a4:	ldr	r0, [r0, #16]
      a6:	.short	0xb110
      a8:	ldr	r3, [r0, #0]
      aa:	.short	0x691b
      ac:	bx	r3
	}
      ae:	bx	lr

000000b0 <File::peek()>:
	virtual int peek() {
		return (f) ? f->peek() : -1;
      b0:	ldr	r0, [r0, #16]
      b2:	cbz	r0, ba <File::peek()+0xa>
      b4:	ldr	r3, [r0, #0]
      b6:	ldr	r3, [r3, #24]
      b8:	.word	0xf04f4718
	}
      bc:	adds	r0, #255	; 0xff
      be:	.short	0x4770

000000c0 <File::flush()>:
	virtual void flush() {
		if (f) f->flush();
      c0:	ldr	r0, [r0, #16]
      c2:	cbz	r0, ca <File::flush()+0xa>
      c4:	.word	0x68db6803
      c8:	bx	r3
      ca:	bx	lr

000000cc <File::truncate(unsigned long long)>:
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
      cc:	ldr	r0, [r0, #16]
      ce:	cbz	r0, d6 <File::truncate(unsigned long long)+0xa>
      d0:	ldr	r1, [r0, #0]
      d2:	ldr	r1, [r1, #48]	; 0x30
      d4:	bx	r1
	}
      d6:	bx	lr

000000d8 <File::seek(unsigned long long, int)>:
	virtual bool seek(uint64_t pos, int mode) {
      d8:	.word	0x6900b410
		return (f) ? f->seek(pos, mode) : false;
      dc:	cbz	r0, e8 <File::seek(unsigned long long, int)+0x10>
      de:	.short	0x6804
      e0:	ldr	r1, [r4, #52]	; 0x34
	}
      e2:	.short	0xf85d
      e4:	ldr	r3, [pc, #16]	; (f8 <File::position()+0x8>)
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
      e6:	.short	0x4708
	}
      e8:	ldr.w	r4, [sp], #4
      ec:	.word	0xbf004770

000000f0 <File::position()>:
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
      f0:	ldr	r0, [r0, #16]
      f2:	.short	0xb110
      f4:	ldr	r3, [r0, #0]
      f6:	ldr	r3, [r3, #56]	; 0x38
      f8:	bx	r3
	}
      fa:	movs	r0, #0
      fc:	movs	r1, #0
      fe:	bx	lr

00000100 <File::size()>:
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
     100:	ldr	r0, [r0, #16]
     102:	cbz	r0, 10a <File::size()+0xa>
     104:	ldr	r3, [r0, #0]
     106:	ldr	r3, [r3, #60]	; 0x3c
     108:	bx	r3
	}
     10a:	movs	r0, #0
     10c:	movs	r1, #0
     10e:	.short	0x4770

00000110 <File::close()>:
	virtual void close() {
		if (f) f->close();
     110:	ldr	r0, [r0, #16]
     112:	cbz	r0, 11a <File::close()+0xa>
     114:	ldr	r3, [r0, #0]
     116:	ldr	r3, [r3, #64]	; 0x40
     118:	bx	r3
     11a:	bx	lr

0000011c <File::operator bool()>:
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
     11c:	ldr	r0, [r0, #16]
     11e:	cbz	r0, 126 <File::operator bool()+0xa>
     120:	.word	0x6c5b6803
     124:	bx	r3
	}
     126:	bx	lr

00000128 <File::name()>:
	virtual const char* name() {
		return (f) ? f->name() : "";
     128:	ldr	r0, [r0, #16]
     12a:	cbz	r0, 132 <File::name()+0xa>
     12c:	ldr	r3, [r0, #0]
     12e:	ldr	r3, [r3, #72]	; 0x48
     130:	bx	r3
	}
     132:	ldr	r0, [pc, #4]	; (138 <File::name()+0x10>)
     134:	bx	lr
     136:	nop
     138:	.word	0x2000016c

0000013c <File::isDirectory()>:
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
     13c:	ldr	r0, [r0, #16]
     13e:	cbz	r0, 146 <File::isDirectory()+0xa>
     140:	.word	0x6cdb6803
     144:	bx	r3
	}
     146:	.short	0x4770

00000148 <File::openNextFile(unsigned char)>:
	virtual File openNextFile(uint8_t mode=0) {
     148:	push	{r3, r4, r5, lr}
		return (f) ? f->openNextFile(mode) : *this;
     14a:	.short	0x690b
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
     14c:	mov	r4, r0
		return (f) ? f->openNextFile(mode) : *this;
     14e:	.short	0xb12b
     150:	ldr	r5, [r3, #0]
     152:	.short	0x4619
     154:	ldr	r3, [r5, #80]	; 0x50
     156:	.short	0x4798
	}
     158:	mov	r0, r4
     15a:	.short	0xbd38
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     15c:	mov.w	r0, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
     160:	.word	0x71234a06
     164:	strb	r3, [r4, #12]
     166:	.short	0x60a0
     168:	str	r2, [r4, #0]
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
     16a:	.short	0x690b
     16c:	str	r3, [r4, #16]
		if (f) f->refcount++;
     16e:	.short	0x2b00
     170:	beq.n	158 <File::openNextFile(unsigned char)+0x10>
     172:	.short	0x691a
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
	}
     174:	mov	r0, r4
	File(const File &file) {
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
		if (f) f->refcount++;
     176:	.short	0x3201
     178:	str	r2, [r3, #16]
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
	}
     17a:	.short	0xbd38
     17c:	lsls	r4, r6, #1
     17e:	.short	0x2000

00000180 <File::rewindDirectory()>:
	virtual void rewindDirectory(void) {
		if (f) f->rewindDirectory();
     180:	ldr	r0, [r0, #16]
     182:	.short	0xb110
     184:	ldr	r3, [r0, #0]
     186:	.short	0x6d5b
     188:	bx	r3
     18a:	.short	0x4770

0000018c <File::read()>:
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     18c:	ldr	r0, [r0, #16]
     18e:	.short	0xb180
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     190:	ldr	r3, [r0, #0]
     192:	.short	0x2201
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     194:	push	{lr}
     196:	.short	0xb083
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     198:	ldr	r3, [r3, #40]	; 0x28
     19a:	add.w	r1, sp, #7
     19e:	blx	r3
     1a0:	.word	0xf89db120
		return b;
     1a4:	movs	r7, r0
	}
     1a6:	.short	0xb003
     1a8:	ldr.w	pc, [sp], #4
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     1ac:	.word	0x30fff04f
     1b0:	b.n	1a6 <File::read()+0x1a>
     1b2:	.short	0xf04f
     1b4:	adds	r0, #255	; 0xff
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
     1b6:	.short	0x4770

000001b8 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     1b8:	push	{r4, lr}
     1ba:	sub	sp, #8
		return write(&b, 1);
     1bc:	.word	0x22016804
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     1c0:	add	r3, sp, #8
     1c2:	strb.w	r1, [r3, #-1]!
		return write(&b, 1);
     1c6:	.short	0x4619
     1c8:	ldr	r3, [r4, #44]	; 0x2c
     1ca:	blx	r3
	}
     1cc:	.word	0xbd10b002

000001d0 <SDFile::operator bool()>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     1d0:	ldr	r3, [r0, #92]	; 0x5c
     1d2:	cbz	r3, 1d8 <SDFile::operator bool()+0x8>
     1d4:	.word	0x47702001
     1d8:	ldr	r0, [r0, #96]	; 0x60
     1da:	.short	0x3000
     1dc:	it	ne
     1de:	.short	0x2001
     1e0:	bx	lr	; unpredictable branch in IT block

     1e2:	.short	0xbf00

000001e4 <__tcf_0>:
    const char *sd_str[]={"sd1"}; // edit to reflect your configuration
    const int cs[] = {10}; // edit to reflect your configuration
  #endif
  const int nsd = sizeof(sd_str)/sizeof(const char *);

SDClass sdx[nsd];
     1e4:	bx	lr	; unpredictable branch in IT block

     1e6:	nopne

000001e8 <File::whoami()>:
	}
	virtual ~File() {
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
     1e8:	.word	0x4604b510
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
     1ec:	ldr	r1, [pc, #24]	; (208 <File::whoami()+0x20>)
     1ee:	.short	0x4807
     1f0:	ldr	r3, [r4, #16]
     1f2:	.short	0x4622
     1f4:	bl	e990 <Print::printf(char const*, ...)>
		if (f) f->whoami();
     1f8:	.word	0xb1206920
     1fc:	ldr	r3, [r0, #0]
	}
     1fe:	.short	0xe8bd
     200:	ands	r0, r2
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
		if (f) f->whoami();
     202:	ldr	r3, [r3, #36]	; 0x24
     204:	bx	r3
     206:	pop	{r4, pc}
     208:	lsls	r4, r2, #5
     20a:	movs	r0, #0
     20c:	lsrs	r4, r3, #19
     20e:	movs	r0, #0

00000210 <SDFile::whoami()>:
	virtual ~SDFile(void) {
		if (sdfatfile) sdfatfile.close();
		if (filename) free(filename);
	}
#ifdef FILE_WHOAMI
	virtual void whoami() {
     210:	.word	0x49024602
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
     214:	ldr	r0, [pc, #8]	; (220 <SDFile::whoami()+0x10>)
     216:	.short	0x6913
     218:	b.w	e990 <Print::printf(char const*, ...)>
     21c:	.word	0x20000170
     220:	lsrs	r4, r3, #19
     222:	.short	0x2000

00000224 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:

  #if USE_SD==1
    // Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
    #include "TimeLib.h"
    void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
    { *date = FS_DATE(year(), month(), day());
     224:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     228:	.word	0x4615460e
     22c:	mov	r7, r0
     22e:	.short	0xf007
     230:			; <UNDEFINED> instruction: 0xfa1b4604
     234:	.word	0xfa08f007
     238:	mov	r8, r0
     23a:	.short	0xf007
     23c:	ldr??.w	fp, [r5, #704]	; 0x2c0
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     240:	.word	0xf388fa5f
     244:	cmp	r3, #12
     246:	.short	0xbf98
     248:	cmpls	r0, #31
     24a:	.short	0xd837
     24c:	subw	r4, r4, #1980	; 0x7bc
     250:	.word	0x2c7fb2a4
     254:	bhi.n	2bc <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x98>
         year << 9 | month << 5 | day;
     256:	.short	0xea4f
     258:	adds	r0, r1, r1
     25a:	.short	0xf408
     25c:	ldr	r7, [r7, r3]
     25e:	.short	0xea48
     260:	movs	r0, r0
     262:	.short	0xea40
     264:	movs	r4, #68	; 0x44
     266:	.short	0xb2a4
     268:	strh	r4, [r7, #0]
      *time = FS_TIME(hour(), minute(), second());
     26a:	.short	0xf007
     26c:	vld3.16	{d4[0],d5[0],d6[0]}, [sp], r7
     270:	.word	0xf9baf007
     274:	mov	r4, r0
     276:	.short	0xf007
     278:	vst3.8	{d27[7],d28[7],d29[7]}, [r7], r2
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     27c:	.word	0x2a3bb2fb
     280:	it	ls
     282:	.short	0x2b17
     284:	bhi.n	2b8 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x94>
     286:	.short	0xb2c3
     288:	cmp	r3, #59	; 0x3b
     28a:	.short	0xd815
         hour << 11 | minute << 5 | second >> 1;
     28c:	lsls	r7, r7, #11
     28e:	.short	0xf3c0
     290:	lsls	r6, r0, #13
     292:	.short	0x0164
     294:	and.w	r0, r7, #522240	; 0x7f800
     298:	.word	0x54fff404
     29c:	orrs	r0, r4
     29e:	.short	0x4318
     2a0:	uxth	r0, r0
     2a2:	strhls	r0, [r6, #0]
      *ms10 = second() & 1 ? 100 : 0;
     2a4:	.word	0xf9b0f007
     2a8:	tst.w	r0, #1
     2ac:	.word	0x2364bf14
     2b0:	moveq	r3, #0
     2b2:	strb	r3, [r5, #0]
     2b4:	.word	0x81f0e8bd
     2b8:	movs	r0, #0
     2ba:	.short	0xe7f2
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
     2bc:	movs	r4, #0
     2be:	.short	0xe7d3

000002c0 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     2c0:	push	{r4, lr}
     2c2:	.short	0x4604
		if (filename) {
     2c4:	ldr	r0, [r0, #100]	; 0x64
     2c6:	.short	0xb118
			free(filename);
     2c8:	bl	f8a4 <free>
			filename = nullptr;
     2cc:	.word	0x66632300
		}
		sdfatfile.close();
     2d0:	add.w	r0, r4, #36	; 0x24
	}
     2d4:	.word	0x4010e8bd
	virtual void close() {
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		sdfatfile.close();
     2d8:	b.w	b1d0 <FsBaseFile::close()>

000002dc <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     2dc:	.word	0x41f0e92d
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     2e0:	movs	r3, #0
     2e2:	.short	0xb094
     2e4:	mov.w	r4, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     2e8:	.word	0x461a4f26
     2ec:	mov	r5, r0
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     2ee:	.short	0x3124
     2f0:	add	r0, sp, #16
     2f2:	.short	0xf88d
     2f4:	adds	r0, #4
     2f6:	.short	0xf88d
     2f8:	adds	r0, #12
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     2fa:	.short	0x9312
     2fc:	str	r3, [sp, #76]	; 0x4c
     2fe:	str	r4, [sp, #8]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     300:	.word	0xf00a9700
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     304:			; <UNDEFINED> instruction: 0xffb99b12
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     308:	cmp	r3, #0
     30a:	beq.n	370 <SDFile::openNextFile(unsigned char)+0x94>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     30c:	movs	r0, #104	; 0x68
     30e:	.short	0x2600
     310:	bl	ea7c <operator new(unsigned int)>
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     314:	.word	0x3004f89d
     318:	mov	r4, r0
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     31a:	ldr	r2, [pc, #108]	; (388 <SDFile::openNextFile(unsigned char)+0xac>)
     31c:	mov.w	r8, #1000	; 0x3e8
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     320:	adds	r0, #36	; 0x24
     322:	.short	0x7623
     324:	add	r1, sp, #16
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     326:	.short	0x9b02
     328:	str	r2, [r4, #0]
     32a:	str	r3, [r4, #28]
     32c:	ldr	r2, [pc, #92]	; (38c <SDFile::openNextFile(unsigned char)+0xb0>)
     32e:	ldrb.w	r3, [sp, #12]
     332:	str	r2, [r4, #20]
     334:	.word	0x3020f884
{
  public:
	constexpr Print() : write_error(0) {}
     338:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     33a:	strb	r6, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     33c:	.word	0xf8c46126
     340:	strh	r0, [r1, #0]
     342:	.short	0xf00a
     344:	vmls.i8	d6, d9, d19
	File(File *file) {
     348:	ldr	r2, [pc, #68]	; (390 <SDFile::openNextFile(unsigned char)+0xb4>)
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     34a:	adds	r3, #1
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     34c:	str	r7, [r4, #20]
     34e:	str	r6, [r4, #100]	; 0x64
     350:	strb	r6, [r5, #4]
     352:	str.w	r8, [r5, #8]
     356:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     358:	str	r4, [r5, #16]
		if (f) f->refcount++;
     35a:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     35c:	str	r2, [r5, #0]
     35e:	ldr	r3, [pc, #52]	; (394 <SDFile::openNextFile(unsigned char)+0xb8>)
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     360:	.word	0x9300a804
     364:	bl	b1d0 <FsBaseFile::close()>
	}
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
     368:	.word	0xb0144628
     36c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     370:	ldr	r3, [sp, #76]	; 0x4c
     372:	cmp	r3, #0
     374:	bne.n	30c <SDFile::openNextFile(unsigned char)+0x30>

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     376:	ldr	r2, [pc, #24]	; (390 <SDFile::openNextFile(unsigned char)+0xb4>)
     378:	strb	r3, [r5, #4]
     37a:	str	r4, [r5, #8]
     37c:	.word	0x612b732b
     380:	str	r2, [r5, #0]
     382:	b.n	35e <SDFile::openNextFile(unsigned char)+0x82>
     384:	lsls	r0, r2, #1
     386:	movs	r0, #0
     388:	.word	0x200000d4
     38c:	movs	r0, r1
     38e:	movs	r0, #0
     390:	lsls	r4, r6, #1
     392:	movs	r0, #0
     394:	movs	r4, r5
     396:	movs	r0, #0

00000398 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     398:	ldr	r2, [r0, #92]	; 0x5c
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     39a:	cbz	r2, 3b6 <SDFile::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     39c:	ldrb	r3, [r2, #0]
     39e:	and.w	r3, r3, #8
     3a2:	and.w	r0, r3, #255	; 0xff
     3a6:	cbz	r3, 3ec <SDFile::available()+0x54>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     3a8:	ldr	r3, [r2, #28]
     3aa:	ldr	r0, [r2, #20]
     3ac:	.word	0xbf481a18
     3b0:	mvnmi.w	r0, #2147483648	; 0x80000000
     3b4:	bx	lr
     3b6:	ldr	r1, [r0, #96]	; 0x60
     3b8:	cbz	r1, 3ee <SDFile::available()+0x56>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     3ba:	ldrb.w	r3, [r1, #49]	; 0x31
     3be:	and.w	r3, r3, #8
     3c2:	and.w	r0, r3, #255	; 0xff
     3c6:	cbz	r3, 3ec <SDFile::available()+0x54>
     3c8:	ldrd	r2, r3, [r1, #16]
     3cc:	ldrd	r0, r1, [r1]
     3d0:	push	{r4, r5}
     3d2:	subs	r0, r2, r0
     3d4:	mov.w	r5, #0
     3d8:	mvn.w	r4, #2147483648	; 0x80000000
     3dc:	sbc.w	r1, r3, r1
     3e0:	cmp	r5, r1
     3e2:	it	eq
     3e4:	cmpeq	r4, r0
     3e6:	bcs.n	3ea <SDFile::available()+0x52>
     3e8:	.word	0xbc304620
		return sdfatfile.available();
	}
     3ec:	bx	lr
     3ee:	mov	r0, r1
     3f0:	.word	0xbf004770

000003f4 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     3f4:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     3f6:	cbz	r3, 3fe <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     3f8:	mov	r0, r3
     3fa:	.short	0xf009
     3fc:	cbnz	r1, 458 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>
     3fe:	ldr	r0, [r0, #76]	; 0x4c
     400:	cbz	r0, 406 <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     402:	b.w	7c98 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     406:	mov.w	r0, #4294967295
     40a:	bx	lr

0000040c <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     40c:	ldr	r3, [r0, #72]	; 0x48
     40e:	.short	0xb500
     410:	sub	sp, #12
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     412:	cbz	r3, 42e <StreamFile<FsBaseFile, unsigned long long>::read()+0x22>
     414:	mov	r0, r3
     416:	movs	r2, #1
     418:	add.w	r1, sp, #7
     41c:	bl	9920 <FatFile::read(void*, unsigned int)>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     420:	cmp	r0, #1
     422:	.short	0xd10c
     424:	ldrb.w	r0, [sp, #7]
    return BaseFile::read();
  }
     428:	add	sp, #12
     42a:	ldr.w	pc, [sp], #4
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     42e:	ldr	r0, [r0, #76]	; 0x4c
     430:	cbz	r0, 43e <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     432:	movs	r2, #1
     434:	add.w	r1, sp, #7
     438:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
     43c:	b.n	420 <StreamFile<FsBaseFile, unsigned long long>::read()+0x14>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     43e:	mov.w	r0, #4294967295
     442:	b.n	428 <StreamFile<FsBaseFile, unsigned long long>::read()+0x1c>

00000444 <SDFile::flush()>:
	virtual void flush() {
     444:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     446:	cbz	r3, 44e <SDFile::flush()+0xa>
     448:	mov	r0, r3
     44a:	b.w	9f64 <FatFile::sync()>
     44e:	ldr	r0, [r0, #96]	; 0x60
     450:	cbz	r0, 456 <SDFile::flush()+0x12>
     452:	b.w	8d88 <ExFatFile::sync()>
     456:	bx	lr

00000458 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     458:	.word	0x6c83b500
     45c:	sub	sp, #12
     45e:	.short	0xf88d
     460:	asrs	r7, r0, #32
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     462:	cbz	r3, 476 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x1e>
     464:	mov	r0, r3
     466:	movs	r2, #1
     468:	.word	0x0107f10d
     46c:	bl	9fe8 <FatFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     470:	add	sp, #12
     472:	ldr.w	pc, [sp], #4
     476:	ldr	r0, [r0, #76]	; 0x4c
     478:	cmp	r0, #0
     47a:	beq.n	470 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x18>
     47c:	movs	r2, #1
     47e:	add.w	r1, sp, #7
     482:	bl	9194 <ExFatFile::write(void const*, unsigned int)>
     486:	add	sp, #12
     488:	ldr.w	pc, [sp], #4

0000048c <SDClass::rename(char const*, char const*)>:
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
     48c:	push	{r4, r5, r6, lr}
     48e:	ldr.w	r4, [r0, #1156]	; 0x484
     492:	.short	0xb08e
     494:	mov	r6, r2
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
     496:	cbz	r4, 4ca <SDClass::rename(char const*, char const*)+0x3e>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     498:	.word	0xf2042500
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
     49c:	add	r4, r8
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     49e:	.short	0x460a
     4a0:	mov	r0, sp
     4a2:	.short	0x4621
     4a4:	mov	r3, r5
     4a6:	.short	0xf88d
     4a8:	str	r0, [r0, r0]
     4aa:	.short	0xf88d
     4ac:	str	r1, [r0, r0]
     4ae:	.short	0xf88d
     4b0:	str	r2, [r0, r0]
     4b2:	.short	0xf009
     4b4:	vst2.32	{d27[0],d28[0]}, [r7], r8
		return sdfs.rename(oldfilepath, newfilepath);
	}
     4b8:	.word	0xbd70b00e
     4bc:	mov	r2, r6
     4be:	.short	0x4621
     4c0:	mov	r0, sp
     4c2:	bl	9b2c <FatFile::rename(FatFile*, char const*)>
     4c6:	.short	0xb00e
     4c8:	pop	{r4, r5, r6, pc}
     4ca:	.short	0xf8d0
     4cc:	lsls	r0, r1, #18
     4ce:	.short	0x2800
     4d0:	beq.n	4b8 <SDClass::rename(char const*, char const*)+0x2c>
#endif  //  USE_EXFAT_UNICODE_NAMES

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
     4d2:	.short	0xf500
     4d4:	str	r1, [r1, #88]	; 0x58
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     4d6:	.short	0x460a
     4d8:	mov	r3, r4
     4da:	.short	0x4668
     4dc:	mov	r1, r5
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     4de:	.short	0xf88d
     4e0:	ands	r1, r6
     4e2:	strb.w	r4, [sp, #50]	; 0x32
     4e6:	strb.w	r4, [sp, #51]	; 0x33
     4ea:	bl	81a4 <ExFatFile::open(ExFatFile*, char const*, int)>
     4ee:	.short	0x2800
     4f0:	beq.n	4b8 <SDClass::rename(char const*, char const*)+0x2c>
     4f2:	.short	0x4632
     4f4:	mov	r1, r5
     4f6:	.short	0x4668
     4f8:	bl	9004 <ExFatFile::rename(ExFatFile*, char const*)>
     4fc:	.word	0xbd70b00e

00000500 <SDFile::name()>:
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     500:	push	{r3, r4, r5, lr}
		if (!filename) {
     502:	ldr	r4, [r0, #100]	; 0x64
     504:	cbz	r4, 50a <SDFile::name()+0xa>
				static char zeroterm = 0;
				filename = &zeroterm;
			}
		}
		return filename;
	}
     506:	mov	r0, r4
     508:	pop	{r3, r4, r5, pc}
     50a:	mov	r5, r0
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
		if (!filename) {
			filename = (char *)malloc(MAX_FILENAME_LEN);
     50c:	mov.w	r0, #256	; 0x100
     510:	bl	f894 <malloc>
     514:	mov	r1, r0
     516:	.short	0x6668
			if (filename) {
     518:	cbz	r0, 53c <SDFile::name()+0x3c>
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
     51a:	.short	0x6de8
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     51c:	strb	r4, [r1, #0]
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
     51e:	.short	0xb128
     520:	mov.w	r2, #256	; 0x100
     524:	.word	0xf918f00a
     528:	ldr	r4, [r5, #100]	; 0x64
     52a:	.short	0xe7ec
     52c:	ldr	r0, [r5, #96]	; 0x60
     52e:	.short	0xb140
     530:	mov.w	r2, #256	; 0x100
     534:	bl	7954 <ExFatFile::getName(char*, unsigned int)>
     538:	.word	0xe7e46e6c
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     53c:	ldr	r4, [pc, #8]	; (548 <SDFile::name()+0x48>)
     53e:	.short	0x666c
     540:	b.n	506 <SDFile::name()+0x6>
     542:	.short	0x460c
     544:	b.n	506 <SDFile::name()+0x6>
     546:	nop
     548:	adds	r4, r6, #4
     54a:	movs	r0, #0

0000054c <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     54c:	push	{r4, r6, r7, lr}
     54e:	.short	0x6dc4
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
           m_xFile ? m_xFile->truncate(length) : false;
     550:	cbz	r4, 576 <SDFile::truncate(unsigned long long)+0x2a>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     552:	.short	0x2b01
     554:	it	eq
     556:	.short	0x2a00
     558:	bcc.n	55e <SDFile::truncate(unsigned long long)+0x12>
     55a:	.short	0x2000
		return sdfatfile.truncate(size);
	}
     55c:	pop	{r4, r6, r7, pc}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     55e:	.short	0x4611
     560:	mov	r0, r4
     562:	bleq	9d5c <FatFile::seekSet(unsigned long)>
     566:	cmp	r0, #0
     568:	beq.n	55a <SDFile::truncate(unsigned long long)+0xe>
     56a:	.short	0x4620
     56c:	bl	9f70 <FatFile::truncate()>
     570:	.word	0xd0f22800
     574:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     576:	.short	0x6e04
     578:	cmp	r4, #0
     57a:	.short	0xd0ee
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     57c:	mov	r0, r4
     57e:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
     582:	cmp	r0, #0
     584:	.word	0x4620d0e9
     588:	ldmia.w	sp!, {r4, r6, r7, lr}
     58c:	.word	0xbd90f008

00000590 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
     590:	push	{r4, r5, lr}
     592:	.short	0xf8d0
     594:	add	ip, r0
     596:	sub	sp, #60	; 0x3c
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
     598:	cbz	r4, 5ba <SDClass::mkdir(char const*)+0x2a>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     59a:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     59c:	mov	r2, r1
     59e:	.short	0x2301
     5a0:	addw	r1, r4, #1092	; 0x444
     5a4:	.word	0xf88d4668
     5a8:	str	r0, [r0, r0]
     5aa:	strb.w	r5, [sp, #1]
     5ae:	.short	0xf88d
     5b0:	str	r2, [r0, r0]
     5b2:	bl	9780 <FatFile::mkdir(FatFile*, char const*, bool)>
		return sdfs.mkdir(filepath);
	}
     5b6:	.short	0xb00f
     5b8:	pop	{r4, r5, pc}
     5ba:	.short	0xf8d0
     5bc:	lsls	r0, r1, #18
     5be:	.short	0x2800
     5c0:	beq.n	5b6 <SDClass::mkdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     5c2:	.short	0x460a
     5c4:	movs	r3, #1
     5c6:	.short	0xf500
     5c8:	str	r1, [r1, #24]
     5ca:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     5cc:	strb.w	r4, [sp, #49]	; 0x31
     5d0:	strb.w	r4, [sp, #50]	; 0x32
     5d4:	.word	0x4033f88d
     5d8:	bl	8f2c <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
     5dc:	.word	0xbd30b00f

000005e0 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     5e0:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     5e2:	.short	0xb19b
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     5e4:	ldrb	r2, [r3, #0]
     5e6:	.short	0xf012
     5e8:	lsrs	r0, r6, #29
     5ea:	.short	0xd100
     5ec:	bx	lr
     5ee:	push	{r4, lr}
     5f0:	.word	0x21004604
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     5f4:	mov	r0, r3
     5f6:	.short	0xf009
     5f8:			; <UNDEFINED> instruction: 0xfbb16e20
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
    if (m_xFile) m_xFile->rewind();
     5fc:	.word	0x2200b128
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     600:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     602:	.short	0xe8bd
     604:	ands	r0, r2
     606:	b.w	7cc8 <ExFatFile::seekSet(unsigned long long)>
     60a:	pop	{r4, pc}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     60c:	ldr	r0, [r0, #96]	; 0x60
     60e:	cmp	r0, #0
     610:	beq.n	5ec <SDFile::rewindDirectory()+0xc>
     612:	ldrb.w	r3, [r0, #49]	; 0x31
     616:	tst.w	r3, #80	; 0x50
     61a:	.short	0xd0e7
     61c:	movs	r2, #0
     61e:	.short	0x2300
     620:	b.w	7cc8 <ExFatFile::seekSet(unsigned long long)>

00000624 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
     624:	.word	0x4605b538
     628:	ldr.w	r0, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     62c:	cbz	r0, 660 <SDClass::usedSize()+0x3c>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
     62e:	.short	0x69c4
     630:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
     632:	.short	0xf009
     634:	vceq.i32	<illegal reg q15.5>, <illegal reg q14.5>, <illegal reg q2.5>
     638:	.word	0x1a243484
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     63c:	cbz	r3, 650 <SDClass::usedSize()+0x2c>
     63e:	.short	0x7998
     640:	mov.w	r3, #512	; 0x200
     644:	.word	0xf000fa03
     648:	uxth	r0, r0
     64a:	.short	0xfba0
     64c:	lsls	r4, r0, #4
     64e:	pop	{r3, r4, r5, pc}
     650:	ldr.w	r3, [r5, #1160]	; 0x488
     654:	cbz	r3, 670 <SDClass::usedSize()+0x4c>
     656:	ldr.w	r0, [r3, #1084]	; 0x43c
     65a:	umull	r0, r1, r0, r4
     65e:	pop	{r3, r4, r5, pc}
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     660:	.word	0x0488f8d5
     664:	cbz	r0, 670 <SDClass::usedSize()+0x4c>
     666:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
     66a:	bl	8884 <ExFatPartition::freeClusterCount()>
     66e:	b.n	636 <SDClass::usedSize()+0x12>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     670:	movs	r0, #0
     672:	movs	r1, #0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
     674:	pop	{r3, r4, r5, pc}
     676:	nop

00000678 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
     678:	push	{r4, r5, lr}
     67a:	ldr.w	r4, [r0, #1156]	; 0x484
     67e:	sub	sp, #60	; 0x3c
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
           m_xVol ? m_xVol->rmdir(path) : false;
     680:	cbz	r4, 6ac <SDClass::rmdir(char const*)+0x34>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     682:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     684:	mov	r2, r1
     686:	mov	r0, sp
     688:	mov	r1, r4
     68a:	mov	r3, r5
     68c:	strb.w	r5, [sp]
     690:	strb.w	r5, [sp, #1]
     694:	strb.w	r5, [sp, #2]
     698:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>
     69c:	cbnz	r0, 6a2 <SDClass::rmdir(char const*)+0x2a>
		return sdfs.rmdir(filepath);
	}
     69e:	add	sp, #60	; 0x3c
     6a0:	pop	{r4, r5, pc}
     6a2:	mov	r0, sp
     6a4:	bl	9d00 <FatFile::rmdir()>
     6a8:	add	sp, #60	; 0x3c
     6aa:	pop	{r4, r5, pc}
     6ac:	ldr.w	r0, [r0, #1160]	; 0x488
     6b0:	cmp	r0, #0
     6b2:	beq.n	69e <SDClass::rmdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     6b4:	mov	r2, r1
     6b6:	mov	r3, r4
     6b8:	mov	r1, r0
     6ba:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     6bc:	strb.w	r4, [sp, #49]	; 0x31
     6c0:	strb.w	r4, [sp, #50]	; 0x32
     6c4:	strb.w	r4, [sp, #51]	; 0x33
     6c8:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
     6cc:	cmp	r0, #0
     6ce:	beq.n	69e <SDClass::rmdir(char const*)+0x26>
     6d0:	mov	r0, sp
     6d2:	bl	8be8 <ExFatFile::rmdir()>
     6d6:	add	sp, #60	; 0x3c
     6d8:	pop	{r4, r5, pc}
     6da:	nop

000006dc <SDFile::position()>:
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
		return false;
	}
	virtual uint64_t position() {
     6dc:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     6de:	cbz	r3, 6e6 <SDFile::position()+0xa>
     6e0:	ldr	r0, [r3, #20]
     6e2:	movs	r1, #0
     6e4:	bx	lr
     6e6:	ldr	r3, [r0, #96]	; 0x60
     6e8:	cbz	r3, 6f0 <SDFile::position()+0x14>
     6ea:	ldmia.w	r3, {r0, r1}
     6ee:	bx	lr
     6f0:	mov	r0, r3
     6f2:	mov	r1, r3
		return sdfatfile.curPosition();
	}
     6f4:	bx	lr
     6f6:	nop

000006f8 <SDFile::size()>:
	virtual uint64_t size() {
     6f8:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     6fa:	cbz	r3, 702 <SDFile::size()+0xa>
     6fc:	ldr	r0, [r3, #28]
     6fe:	movs	r1, #0
     700:	bx	lr
     702:	ldr	r3, [r0, #96]	; 0x60
     704:	cbz	r3, 70c <SDFile::size()+0x14>
     706:	ldr	r0, [r3, #16]
     708:	ldr	r1, [r3, #20]
     70a:	bx	lr
     70c:	mov	r0, r3
     70e:	mov	r1, r3
		return sdfatfile.size();
	}
     710:	bx	lr
     712:	nop

00000714 <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     714:	ldr	r3, [r0, #92]	; 0x5c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     716:	cbz	r3, 71e <SDFile::read(void*, unsigned int)+0xa>
     718:	mov	r0, r3
     71a:	b.w	9920 <FatFile::read(void*, unsigned int)>
     71e:	ldr	r0, [r0, #96]	; 0x60
     720:	cbz	r0, 726 <SDFile::read(void*, unsigned int)+0x12>
     722:	b.w	7af0 <ExFatFile::read(void*, unsigned int)>
		return sdfatfile.read(buf, nbyte);
	}
     726:	mov.w	r0, #4294967295
     72a:	bx	lr

0000072c <SDFile::peek()>:
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     72c:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     72e:	cbz	r3, 736 <SDFile::peek()+0xa>
     730:	mov	r0, r3
     732:	b.w	9ac0 <FatFile::peek()>
     736:	ldr	r0, [r0, #96]	; 0x60
     738:	cbz	r0, 73e <SDFile::peek()+0x12>
     73a:	b.w	7c98 <ExFatFile::peek()>
		return sdfatfile.peek();
	}
     73e:	mov.w	r0, #4294967295
     742:	bx	lr

00000744 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
     744:	ldr.w	r2, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     748:	cbz	r2, 75e <SDClass::totalSize()+0x1a>
     74a:	ldrb	r1, [r2, #6]
     74c:	mov.w	r3, #512	; 0x200
     750:	ldr	r0, [r2, #28]
     752:	lsls	r3, r1
     754:	subs	r0, #1
     756:	uxth	r3, r3
     758:	umull	r0, r1, r3, r0
     75c:	bx	lr
     75e:	ldr.w	r2, [r0, #1160]	; 0x488
     762:	cbz	r2, 772 <SDClass::totalSize()+0x2e>
     764:	ldr.w	r3, [r2, #1072]	; 0x430
     768:	ldr.w	r0, [r2, #1084]	; 0x43c
     76c:	umull	r0, r1, r3, r0
     770:	bx	lr
     772:	movs	r0, #0
     774:	movs	r1, #0
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
	}
     776:	bx	lr

00000778 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     778:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     77a:	cbz	r3, 78a <SDFile::isDirectory()+0x12>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     77c:	ldrb	r3, [r3, #0]
     77e:	tst.w	r3, #112	; 0x70
     782:	ite	ne
     784:	movne	r0, #1
     786:	moveq	r0, #0
     788:	bx	lr
     78a:	ldr	r0, [r0, #96]	; 0x60
     78c:	cbz	r0, 79c <SDFile::isDirectory()+0x24>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     78e:	ldrb.w	r3, [r0, #49]	; 0x31
     792:	tst.w	r3, #80	; 0x50
     796:	ite	ne
     798:	movne	r0, #1
     79a:	moveq	r0, #0
		return sdfatfile.isDirectory();
	}
     79c:	bx	lr
     79e:	nop

000007a0 <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
     7a0:	push	{r4, r5, lr}
     7a2:	ldr.w	r4, [r0, #1156]	; 0x484
     7a6:	sub	sp, #60	; 0x3c
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
     7a8:	cbz	r4, 7d4 <SDClass::remove(char const*)+0x34>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     7aa:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     7ac:	mov	r2, r1
     7ae:	mov	r0, sp
     7b0:	mov	r1, r4
     7b2:	movs	r3, #1
     7b4:	strb.w	r5, [sp]
     7b8:	strb.w	r5, [sp, #1]
     7bc:	strb.w	r5, [sp, #2]
     7c0:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>
     7c4:	cbnz	r0, 7ca <SDClass::remove(char const*)+0x2a>
		return sdfs.remove(filepath);
	}
     7c6:	add	sp, #60	; 0x3c
     7c8:	pop	{r4, r5, pc}
     7ca:	mov	r0, sp
     7cc:	bl	ab4c <FatFile::remove()>
     7d0:	add	sp, #60	; 0x3c
     7d2:	pop	{r4, r5, pc}
     7d4:	ldr.w	r0, [r0, #1160]	; 0x488
     7d8:	cmp	r0, #0
     7da:	beq.n	7c6 <SDClass::remove(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     7dc:	mov	r2, r1
     7de:	movs	r3, #1
     7e0:	mov	r1, r0
     7e2:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     7e4:	strb.w	r4, [sp, #49]	; 0x31
     7e8:	strb.w	r4, [sp, #50]	; 0x32
     7ec:	strb.w	r4, [sp, #51]	; 0x33
     7f0:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
     7f4:	cmp	r0, #0
     7f6:	beq.n	7c6 <SDClass::remove(char const*)+0x26>
     7f8:	mov	r0, sp
     7fa:	bl	8b10 <ExFatFile::remove()>
     7fe:	add	sp, #60	; 0x3c
     800:	pop	{r4, r5, pc}
     802:	nop

00000804 <SDClass::open(char const*, unsigned char)>:
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     804:	cmp	r3, #1
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     806:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     80a:	mov	r5, r0
     80c:	sub	sp, #80	; 0x50
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     80e:	beq.n	892 <SDClass::open(char const*, unsigned char)+0x8e>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     810:	cmp	r3, #2
		SDFAT_FILE file = sdfs.open(filepath, flags);
     812:	add.w	r1, r1, #4
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     816:	movw	r3, #514	; 0x202
		SDFAT_FILE file = sdfs.open(filepath, flags);
     81a:	mov	r0, sp
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     81c:	it	ne
     81e:	movne	r3, #0
		SDFAT_FILE file = sdfs.open(filepath, flags);
     820:	bl	b3a0 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     824:	ldr	r3, [sp, #72]	; 0x48
     826:	cmp	r3, #0
     828:	beq.n	8a4 <SDClass::open(char const*, unsigned char)+0xa0>
		if (file) return File(new SDFile(file));
     82a:	movs	r0, #104	; 0x68
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     82c:	add	r7, sp, #16
     82e:	bl	ea7c <operator new(unsigned int)>
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     832:	ldrb.w	r2, [sp, #4]
     836:	mov	r4, r0
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     838:	ldr	r3, [pc, #132]	; (8c0 <SDClass::open(char const*, unsigned char)+0xbc>)
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     83a:	ldr	r1, [pc, #136]	; (8c4 <SDClass::open(char const*, unsigned char)+0xc0>)
{
  public:
	constexpr Print() : write_error(0) {}
     83c:	movs	r6, #0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     83e:	mov.w	r8, #1000	; 0x3e8
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     842:	strb	r2, [r4, #24]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     844:	str	r3, [r4, #20]
     846:	adds	r0, #36	; 0x24
     848:	ldr	r3, [sp, #8]
     84a:	ldrb.w	r2, [sp, #12]
     84e:	str	r1, [r4, #0]
     850:	mov	r1, r7
     852:	str	r3, [r4, #28]
     854:	strb.w	r2, [r4, #32]
{
  public:
	constexpr Print() : write_error(0) {}
     858:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     85a:	strb	r6, [r4, #12]
     85c:	str	r6, [r4, #16]
     85e:	str.w	r8, [r4, #8]
     862:	bl	b158 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     866:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     868:	ldr	r1, [pc, #92]	; (8c8 <SDClass::open(char const*, unsigned char)+0xc4>)
     86a:	adds	r3, #1
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     86c:	ldr	r2, [pc, #92]	; (8cc <SDClass::open(char const*, unsigned char)+0xc8>)
     86e:	str	r6, [r4, #100]	; 0x64
     870:	strb	r6, [r5, #4]
     872:	str.w	r8, [r5, #8]
     876:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     878:	str	r4, [r5, #16]
     87a:	str	r1, [r4, #20]
		if (f) f->refcount++;
     87c:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     87e:	str	r2, [r5, #0]
     880:	ldr	r3, [pc, #76]	; (8d0 <SDClass::open(char const*, unsigned char)+0xcc>)
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     882:	mov	r0, r7
     884:	str	r3, [sp, #0]
     886:	bl	b1d0 <FsBaseFile::close()>
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
     88a:	mov	r0, r5
     88c:	add	sp, #80	; 0x50
     88e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     892:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     896:	adds	r1, #4
     898:	mov	r0, sp
     89a:	bl	b3a0 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     89e:	ldr	r3, [sp, #72]	; 0x48
     8a0:	cmp	r3, #0
     8a2:	bne.n	82a <SDClass::open(char const*, unsigned char)+0x26>
     8a4:	ldr	r3, [sp, #76]	; 0x4c
     8a6:	cmp	r3, #0
     8a8:	bne.n	82a <SDClass::open(char const*, unsigned char)+0x26>
     8aa:	mov.w	r1, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     8ae:	ldr	r2, [pc, #28]	; (8cc <SDClass::open(char const*, unsigned char)+0xc8>)
     8b0:	strb	r3, [r5, #4]
     8b2:	add	r7, sp, #16
     8b4:	strb	r3, [r5, #12]
     8b6:	str	r3, [r5, #16]
     8b8:	str	r1, [r5, #8]
     8ba:	str	r2, [r5, #0]
     8bc:	b.n	880 <SDClass::open(char const*, unsigned char)+0x7c>
     8be:	nop
     8c0:	.word	0x20000008
     8c4:	.word	0x200000d4
     8c8:	.word	0x20000050
     8cc:	.word	0x20000074
     8d0:	.word	0x2000002c

000008d4 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     8d4:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     8d6:	cbz	r3, 8de <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     8d8:	mov	r0, r3
     8da:	b.w	9f64 <FatFile::sync()>
     8de:	ldr	r0, [r0, #76]	; 0x4c
     8e0:	cbz	r0, 8e6 <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     8e2:	b.w	8d88 <ExFatFile::sync()>
     8e6:	bx	lr

000008e8 <SDFile::write(void const*, unsigned int)>:
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
     8e8:	ldr	r3, [r0, #92]	; 0x5c
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     8ea:	cbz	r3, 8f2 <SDFile::write(void const*, unsigned int)+0xa>
     8ec:	mov	r0, r3
     8ee:	b.w	9fe8 <FatFile::write(void const*, unsigned int)>
     8f2:	ldr	r0, [r0, #96]	; 0x60
     8f4:	cbz	r0, 8fa <SDFile::write(void const*, unsigned int)+0x12>
     8f6:	b.w	9194 <ExFatFile::write(void const*, unsigned int)>
		return sdfatfile.write(buf, size);
	}
     8fa:	bx	lr

000008fc <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     8fc:	ldr	r3, [r0, #72]	; 0x48
     8fe:	cbz	r3, 906 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0xa>
     900:	mov	r0, r3
     902:	b.w	9fe8 <FatFile::write(void const*, unsigned int)>
     906:	ldr	r0, [r0, #76]	; 0x4c
     908:	cbz	r0, 90e <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0x12>
     90a:	b.w	9194 <ExFatFile::write(void const*, unsigned int)>
    return BaseFile::write(buffer, size);
  }
     90e:	bx	lr

00000910 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     910:	ldr	r2, [r0, #72]	; 0x48
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     912:	cbz	r2, 92e <StreamFile<FsBaseFile, unsigned long long>::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     914:	ldrb	r3, [r2, #0]
     916:	and.w	r3, r3, #8
     91a:	and.w	r0, r3, #255	; 0xff
     91e:	cbz	r3, 964 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     920:	ldr	r3, [r2, #28]
     922:	ldr	r0, [r2, #20]
     924:	subs	r0, r3, r0
     926:	it	mi
     928:	mvnmi.w	r0, #2147483648	; 0x80000000
     92c:	bx	lr
     92e:	ldr	r1, [r0, #76]	; 0x4c
     930:	cbz	r1, 966 <StreamFile<FsBaseFile, unsigned long long>::available()+0x56>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     932:	ldrb.w	r3, [r1, #49]	; 0x31
     936:	and.w	r3, r3, #8
     93a:	and.w	r0, r3, #255	; 0xff
     93e:	cbz	r3, 964 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
     940:	ldrd	r2, r3, [r1, #16]
     944:	ldrd	r0, r1, [r1]
     948:	push	{r4, r5}
     94a:	subs	r0, r2, r0
     94c:	mov.w	r5, #0
     950:	mvn.w	r4, #2147483648	; 0x80000000
     954:	sbc.w	r1, r3, r1
     958:	cmp	r5, r1
     95a:	it	eq
     95c:	cmpeq	r4, r0
     95e:	bcs.n	962 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     960:	mov	r0, r4
    return BaseFile::available();
  }
     962:	pop	{r4, r5}
     964:	bx	lr
     966:	mov	r0, r1
     968:	bx	lr
     96a:	nop

0000096c <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
     96c:	push	{r4, r5, lr}
     96e:	ldr.w	r4, [r0, #1156]	; 0x484
     972:	sub	sp, #60	; 0x3c
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
     974:	cbz	r4, 994 <SDClass::exists(char const*)+0x28>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     976:	movs	r5, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     978:	mov	r2, r1
     97a:	mov	r0, sp
     97c:	mov	r1, r4
     97e:	mov	r3, r5
     980:	strb.w	r5, [sp]
     984:	strb.w	r5, [sp, #1]
     988:	strb.w	r5, [sp, #2]
     98c:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
     990:	add	sp, #60	; 0x3c
     992:	pop	{r4, r5, pc}
     994:	ldr.w	r0, [r0, #1160]	; 0x488
     998:	cmp	r0, #0
     99a:	beq.n	990 <SDClass::exists(char const*)+0x24>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     99c:	mov	r2, r1
     99e:	mov	r3, r4
     9a0:	mov	r1, r0
     9a2:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     9a4:	strb.w	r4, [sp, #49]	; 0x31
     9a8:	strb.w	r4, [sp, #50]	; 0x32
     9ac:	strb.w	r4, [sp, #51]	; 0x33
     9b0:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
     9b4:	add	sp, #60	; 0x3c
     9b6:	pop	{r4, r5, pc}

000009b8 <SDFile::seek(unsigned long long, int)>:
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     9b8:	push	{r4, r6, r7}
     9ba:	ldr	r4, [sp, #12]
     9bc:	mov	r6, r2
     9be:	mov	r7, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     9c0:	cbz	r4, 9d0 <SDFile::seek(unsigned long long, int)+0x18>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     9c2:	cmp	r4, #1
     9c4:	beq.n	a04 <SDFile::seek(unsigned long long, int)+0x4c>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     9c6:	cmp	r4, #2
     9c8:	beq.n	9e6 <SDFile::seek(unsigned long long, int)+0x2e>
		return false;
	}
     9ca:	movs	r0, #0
     9cc:	pop	{r4, r6, r7}
     9ce:	bx	lr
     9d0:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     9d2:	cbz	r4, a0c <SDFile::seek(unsigned long long, int)+0x54>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     9d4:	cmp	r3, #1
     9d6:	it	eq
     9d8:	cmpeq	r2, #0
     9da:	bcs.n	9ca <SDFile::seek(unsigned long long, int)+0x12>
     9dc:	mov	r0, r4
     9de:	mov	r1, r2
     9e0:	pop	{r4, r6, r7}
     9e2:	b.w	9d5c <FatFile::seekSet(unsigned long)>
     9e6:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     9e8:	cbz	r3, a18 <SDFile::seek(unsigned long long, int)+0x60>
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     9ea:	ldr	r2, [r3, #28]
     9ec:	adds	r6, r6, r2
     9ee:	adc.w	r7, r7, #0
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     9f2:	cmp	r7, #1
     9f4:	it	eq
     9f6:	cmpeq	r6, #0
     9f8:	bcs.n	9ca <SDFile::seek(unsigned long long, int)+0x12>
     9fa:	mov	r1, r6
     9fc:	mov	r0, r3
     9fe:	pop	{r4, r6, r7}
     a00:	b.w	9d5c <FatFile::seekSet(unsigned long)>
     a04:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     a06:	cbz	r3, a2e <SDFile::seek(unsigned long long, int)+0x76>
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int64_t offset) {
    return seekSet(curPosition() + offset);
     a08:	ldr	r2, [r3, #20]
     a0a:	b.n	9ec <SDFile::seek(unsigned long long, int)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     a0c:	ldr	r0, [r0, #96]	; 0x60
     a0e:	cmp	r0, #0
     a10:	beq.n	9ca <SDFile::seek(unsigned long long, int)+0x12>
     a12:	pop	{r4, r6, r7}
     a14:	b.w	7cc8 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     a18:	ldr	r3, [r0, #96]	; 0x60
     a1a:	cmp	r3, #0
     a1c:	beq.n	9ca <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     a1e:	mov	r0, r3
     a20:	ldrd	r2, r3, [r3, #16]
     a24:	adds	r2, r2, r6
     a26:	adcs	r3, r7
     a28:	pop	{r4, r6, r7}
     a2a:	b.w	7cc8 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     a2e:	ldr	r3, [r0, #96]	; 0x60
     a30:	cmp	r3, #0
     a32:	beq.n	9ca <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     a34:	mov	r0, r3
     a36:	ldrd	r2, r3, [r3]
     a3a:	adds	r2, r2, r6
     a3c:	adcs	r3, r7
     a3e:	b.n	a12 <SDFile::seek(unsigned long long, int)+0x5a>

00000a40 <File::~File()>:
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     a40:	ldr	r3, [pc, #32]	; (a64 <File::~File()+0x24>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     a42:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     a44:	push	{r4, lr}
     a46:	mov	r4, r0
     a48:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     a4a:	cbz	r2, a5e <File::~File()+0x1e>
     a4c:	ldr	r3, [r2, #16]
     a4e:	subs	r3, #1
     a50:	str	r3, [r2, #16]
     a52:	cbnz	r3, a5e <File::~File()+0x1e>
     a54:	ldr	r0, [r0, #16]
     a56:	cbz	r0, a5e <File::~File()+0x1e>
     a58:	ldr	r3, [r0, #0]
     a5a:	ldr	r3, [r3, #32]
     a5c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     a5e:	mov	r0, r4
     a60:	pop	{r4, pc}
     a62:	nop
     a64:	.word	0x20000074

00000a68 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     a68:	push	{r3, r4, r5, lr}
     a6a:	ldr	r2, [pc, #84]	; (ac0 <SDFile::~SDFile()+0x58>)
     a6c:	mov	r4, r0
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     a6e:	ldr	r3, [r0, #92]	; 0x5c
		if (sdfatfile) sdfatfile.close();
     a70:	add.w	r5, r0, #36	; 0x24
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     a74:	str	r2, [r0, #0]
     a76:	cbz	r3, ab6 <SDFile::~SDFile()+0x4e>
		if (sdfatfile) sdfatfile.close();
     a78:	mov	r0, r5
     a7a:	bl	b1d0 <FsBaseFile::close()>
		if (filename) free(filename);
     a7e:	ldr	r0, [r4, #100]	; 0x64
     a80:	cbz	r0, a86 <SDFile::~SDFile()+0x1e>
     a82:	bl	f8a4 <free>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     a86:	ldr	r3, [pc, #60]	; (ac4 <SDFile::~SDFile()+0x5c>)
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     a88:	mov	r0, r5
     a8a:	str	r3, [r4, #20]
     a8c:	bl	b1d0 <FsBaseFile::close()>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     a90:	ldr	r3, [pc, #52]	; (ac8 <SDFile::~SDFile()+0x60>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     a92:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     a94:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     a96:	cbz	r2, aaa <SDFile::~SDFile()+0x42>
     a98:	ldr	r3, [r2, #16]
     a9a:	subs	r3, #1
     a9c:	str	r3, [r2, #16]
     a9e:	cbnz	r3, aaa <SDFile::~SDFile()+0x42>
     aa0:	ldr	r0, [r4, #16]
     aa2:	cbz	r0, aaa <SDFile::~SDFile()+0x42>
     aa4:	ldr	r3, [r0, #0]
     aa6:	ldr	r3, [r3, #32]
     aa8:	blx	r3
	}
     aaa:	mov	r0, r4
     aac:	movs	r1, #104	; 0x68
     aae:	bl	ea80 <operator delete(void*, unsigned int)>
     ab2:	mov	r0, r4
     ab4:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     ab6:	ldr	r3, [r0, #96]	; 0x60
     ab8:	cmp	r3, #0
     aba:	bne.n	a78 <SDFile::~SDFile()+0x10>
     abc:	b.n	a7e <SDFile::~SDFile()+0x16>
     abe:	nop
     ac0:	.word	0x200000d4
     ac4:	.word	0x2000002c
     ac8:	.word	0x20000074

00000acc <File::~File()>:
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     acc:	ldr	r3, [pc, #40]	; (af8 <File::~File()+0x2c>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ace:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     ad0:	push	{r4, lr}
     ad2:	mov	r4, r0
     ad4:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ad6:	cbz	r2, aea <File::~File()+0x1e>
     ad8:	ldr	r3, [r2, #16]
     ada:	subs	r3, #1
     adc:	str	r3, [r2, #16]
     ade:	cbnz	r3, aea <File::~File()+0x1e>
     ae0:	ldr	r0, [r0, #16]
     ae2:	cbz	r0, aea <File::~File()+0x1e>
     ae4:	ldr	r3, [r0, #0]
     ae6:	ldr	r3, [r3, #32]
     ae8:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     aea:	mov	r0, r4
     aec:	movs	r1, #20
     aee:	bl	ea80 <operator delete(void*, unsigned int)>
     af2:	mov	r0, r4
     af4:	pop	{r4, pc}
     af6:	nop
     af8:	.word	0x20000074

00000afc <MTPStorage_SD::~MTPStorage_SD()>:

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
     afc:	push	{r3, r4, r5, lr}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     afe:	ldr.w	r2, [r0, #224]	; 0xe0
     b02:	mov	r4, r0
     b04:	ldr	r3, [pc, #100]	; (b6c <MTPStorage_SD::~MTPStorage_SD()+0x70>)
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     b06:	ldr	r5, [pc, #104]	; (b70 <MTPStorage_SD::~MTPStorage_SD()+0x74>)
     b08:	str	r3, [r0, #0]
     b0a:	str.w	r5, [r0, #208]	; 0xd0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     b0e:	cbz	r2, b18 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     b10:	ldr	r3, [r2, #16]
     b12:	subs	r3, #1
     b14:	str	r3, [r2, #16]
     b16:	cbz	r3, b4c <MTPStorage_SD::~MTPStorage_SD()+0x50>
     b18:	ldr.w	r2, [r4, #204]	; 0xcc
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     b1c:	str.w	r5, [r4, #188]	; 0xbc
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     b20:	cbz	r2, b2a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     b22:	ldr	r3, [r2, #16]
     b24:	subs	r3, #1
     b26:	str	r3, [r2, #16]
     b28:	cbz	r3, b5c <MTPStorage_SD::~MTPStorage_SD()+0x60>
     b2a:	ldr.w	r2, [r4, #184]	; 0xb8
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     b2e:	str.w	r5, [r4, #168]	; 0xa8
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     b32:	cbz	r2, b48 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     b34:	ldr	r3, [r2, #16]
     b36:	subs	r3, #1
     b38:	str	r3, [r2, #16]
     b3a:	cbnz	r3, b48 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     b3c:	ldr.w	r0, [r4, #184]	; 0xb8
     b40:	cbz	r0, b48 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     b42:	ldr	r3, [r0, #0]
     b44:	ldr	r3, [r3, #32]
     b46:	blx	r3
     b48:	mov	r0, r4
     b4a:	pop	{r3, r4, r5, pc}
     b4c:	ldr.w	r0, [r0, #224]	; 0xe0
     b50:	cmp	r0, #0
     b52:	beq.n	b18 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     b54:	ldr	r3, [r0, #0]
     b56:	ldr	r3, [r3, #32]
     b58:	blx	r3
     b5a:	b.n	b18 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     b5c:	ldr.w	r0, [r4, #204]	; 0xcc
     b60:	cmp	r0, #0
     b62:	beq.n	b2a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     b64:	ldr	r3, [r0, #0]
     b66:	ldr	r3, [r3, #32]
     b68:	blx	r3
     b6a:	b.n	b2a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     b6c:	.word	0x2000027c
     b70:	.word	0x20000074

00000b74 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b74:	push	{r3, r4, r5, lr}
     b76:	ldr	r2, [pc, #76]	; (bc4 <SDFile::~SDFile()+0x50>)
     b78:	mov	r4, r0
     b7a:	ldr	r3, [r0, #92]	; 0x5c
		if (sdfatfile) sdfatfile.close();
     b7c:	add.w	r5, r0, #36	; 0x24
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b80:	str	r2, [r0, #0]
     b82:	cbz	r3, bba <SDFile::~SDFile()+0x46>
		if (sdfatfile) sdfatfile.close();
     b84:	mov	r0, r5
     b86:	bl	b1d0 <FsBaseFile::close()>
		if (filename) free(filename);
     b8a:	ldr	r0, [r4, #100]	; 0x64
     b8c:	cbz	r0, b92 <SDFile::~SDFile()+0x1e>
     b8e:	bl	f8a4 <free>
     b92:	ldr	r3, [pc, #52]	; (bc8 <SDFile::~SDFile()+0x54>)
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     b94:	mov	r0, r5
     b96:	str	r3, [r4, #20]
     b98:	bl	b1d0 <FsBaseFile::close()>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     b9c:	ldr	r3, [pc, #44]	; (bcc <SDFile::~SDFile()+0x58>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     b9e:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     ba0:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     ba2:	cbz	r2, bb6 <SDFile::~SDFile()+0x42>
     ba4:	ldr	r3, [r2, #16]
     ba6:	subs	r3, #1
     ba8:	str	r3, [r2, #16]
     baa:	cbnz	r3, bb6 <SDFile::~SDFile()+0x42>
     bac:	ldr	r0, [r4, #16]
     bae:	cbz	r0, bb6 <SDFile::~SDFile()+0x42>
     bb0:	ldr	r3, [r0, #0]
     bb2:	ldr	r3, [r3, #32]
     bb4:	blx	r3
	}
     bb6:	mov	r0, r4
     bb8:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     bba:	ldr	r3, [r0, #96]	; 0x60
     bbc:	cmp	r3, #0
     bbe:	bne.n	b84 <SDFile::~SDFile()+0x10>
     bc0:	b.n	b8a <SDFile::~SDFile()+0x16>
     bc2:	nop
     bc4:	.word	0x200000d4
     bc8:	.word	0x2000002c
     bcc:	.word	0x20000074

00000bd0 <storage_configure()>:

MTPStorage_SD storage;
MTPD    mtpd(&storage);

void storage_configure()
{
     bd0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     bd4:	ldr	r4, [pc, #748]	; (ec4 <storage_configure()+0x2f4>)
     bd6:	sub	sp, #68	; 0x44
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
     bd8:	movs	r1, #11
     bda:	ldr	r0, [pc, #748]	; (ec8 <storage_configure()+0x2f8>)
     bdc:	bl	7164 <SPIClass::setMOSI(unsigned char)>
     be0:	addw	r6, r4, #1172	; 0x494
      SPI.setMISO(SD_MISO);
     be4:	movs	r1, #12
     be6:	ldr	r0, [pc, #736]	; (ec8 <storage_configure()+0x2f8>)
     be8:	bl	7208 <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
     bec:	movs	r1, #13
     bee:	ldr	r0, [pc, #728]	; (ec8 <storage_configure()+0x2f8>)
    #endif

    for(int ii=0; ii<nsd; ii++)
     bf0:	movs	r5, #0
{
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
     bf2:	bl	72a8 <SPIClass::setSCK(unsigned char)>
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
     bf6:	mov	r0, r6
     bf8:	mov.w	r1, #0
     bfc:	ldr.w	fp, [pc, #756]	; ef4 <storage_configure()+0x324>
     c00:	bl	c748 <SdioCard::begin(SdioConfig)>
				CORE_PIN54_PORTCLEAR = CORE_PIN54_BITMASK;
#endif
			}
		}
	} else {
		if(val) *portSetRegister(pin) = digitalPinToBitMask(pin);
     c04:	ldr.w	r9, [pc, #752]	; ef8 <storage_configure()+0x328>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
     c08:	str.w	r6, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
     c0c:	cbz	r6, c18 <storage_configure()+0x48>
     c0e:	mov	r0, r6
     c10:	bl	be88 <SdioCard::errorCode() const>
     c14:	cmp	r0, #0
     c16:	beq.n	cca <storage_configure()+0xfa>
    { 
      #if defined(BUILTIN_SDCARD)
        if(cs[ii] == BUILTIN_SDCARD)
        {
          if(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO))) 
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
     c18:	ldr.w	r0, [fp]
     c1c:	movs	r3, #254	; 0xfe
     c1e:	mov	r2, r5
     c20:	ldr	r1, [pc, #680]	; (ecc <storage_configure()+0x2fc>)
     c22:	str	r0, [sp, #0]
     c24:	ldr	r0, [pc, #680]	; (ed0 <storage_configure()+0x300>)
     c26:	bl	e990 <Print::printf(char const*, ...)>
     c2a:	ldr	r0, [pc, #676]	; (ed0 <storage_configure()+0x300>)
     c2c:	bl	e960 <Print::println()>
      SPI.setMOSI(SD_MOSI);
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    for(int ii=0; ii<nsd; ii++)
     c30:	adds	r5, #1
     c32:	add.w	fp, fp, #4
     c36:	addw	r4, r4, #1212	; 0x4bc
     c3a:	cmp	r5, #2
     c3c:	beq.n	cc4 <storage_configure()+0xf4>
     c3e:	mov.w	r8, #10
          }
        }
        else if(cs[ii]<BUILTIN_SDCARD)
      #endif
      {
        pinMode(cs[ii],OUTPUT); digitalWriteFast(cs[ii],HIGH);
     c42:	movs	r1, #1
     c44:	add.w	r6, r4, #1184	; 0x4a0
     c48:	adds	r7, r4, #4
     c4a:	uxtb.w	sl, r8
     c4e:	mov	r0, sl
     c50:	bl	da00 <pinMode>
     c54:	mov.w	lr, #0
     c58:	ldr	r3, [pc, #632]	; (ed4 <storage_configure()+0x304>)
     c5a:	add	r2, sp, #28
     c5c:	strb.w	sl, [sp, #28]
     c60:	mov.w	ip, sl, lsl #4
     c64:	str	r3, [sp, #32]
     c66:	add	r3, sp, #40	; 0x28
     c68:	strb.w	lr, [sp, #29]
     c6c:	str.w	lr, [sp, #36]	; 0x24
     c70:	ldmia	r2, {r0, r1, r2}
     c72:	stmia.w	r3, {r0, r1, r2}
     c76:	add.w	r2, r9, ip
     c7a:	ldr	r1, [pc, #600]	; (ed4 <storage_configure()+0x304>)
     c7c:	strb.w	sl, [sp, #40]	; 0x28
     c80:	add.w	sl, sp, #52	; 0x34
     c84:	strb.w	lr, [sp, #41]	; 0x29
     c88:	str.w	lr, [sp, #48]	; 0x30
     c8c:	str	r1, [sp, #44]	; 0x2c
     c8e:	ldr.w	ip, [r9, ip]
     c92:	ldr.w	lr, [r2, #12]
     c96:	ldmia.w	r3, {r0, r1, r2}
     c9a:	str.w	lr, [ip, #132]	; 0x84
     c9e:	stmia.w	sl, {r0, r1, r2}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
     ca2:	mov	r0, r6
     ca4:	ldmia.w	sl, {r1, r2, r3}
     ca8:	bl	b658 <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
     cac:	ldrb.w	r3, [r4, #1207]	; 0x4b7
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
     cb0:	str.w	r6, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
     cb4:	cmp	r3, #0
     cb6:	beq.n	da6 <storage_configure()+0x1d6>
        if(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED))) 
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
     cb8:	ldr.w	r0, [fp]
     cbc:	mov	r3, r8
     cbe:	mov	r2, r5
     cc0:	ldr	r1, [pc, #532]	; (ed8 <storage_configure()+0x308>)
     cc2:	b.n	c22 <storage_configure()+0x52>
        uint64_t usedSize  = spifs[ii].usedSize();
        Serial.printf("SPIFlash Storage %d %d %s ",ii,lfs_cs[ii],lfs_spi_str[ii]); Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
      }
    }
    #endif
}
     cc4:	add	sp, #68	; 0x44
     cc6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     cca:	adds	r7, r4, #4
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    return cardBegin(sdioConfig) && Vol::begin(m_card);
     ccc:	ldr.w	r1, [r4, #1168]	; 0x490
     cd0:	mov	r0, r7
     cd2:	bl	b2d8 <FsVolume::begin(BlockDeviceInterface*)>
     cd6:	cmp	r0, #0
     cd8:	beq.n	c18 <storage_configure()+0x48>
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
     cda:	ldr	r3, [pc, #512]	; (edc <storage_configure()+0x30c>)
     cdc:	ldr	r3, [r3, #4]
     cde:	cmp	r3, #19
     ce0:	bgt.n	cf6 <storage_configure()+0x126>
        sd_name[fsCount] = name;
     ce2:	ldr	r2, [pc, #504]	; (edc <storage_configure()+0x30c>)
     ce4:	ldr.w	r1, [fp]
     ce8:	add.w	r0, r2, r3, lsl #2
        sdx[fsCount++] = &fs;
     cec:	ldr	r6, [pc, #492]	; (edc <storage_configure()+0x30c>)
     cee:	adds	r2, r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
     cf0:	str	r1, [r0, #8]
        sdx[fsCount++] = &fs;
     cf2:	str	r2, [r6, #4]
     cf4:	str	r4, [r0, #88]	; 0x58
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
     cf6:	ldr	r2, [r4, #0]
     cf8:	ldr	r1, [pc, #484]	; (ee0 <storage_configure()+0x310>)
     cfa:	ldr	r3, [r2, #28]
     cfc:	cmp	r3, r1
     cfe:	bne.w	f06 <storage_configure()+0x336>
     d02:	ldr.w	r1, [r4, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     d06:	cmp	r1, #0
     d08:	beq.w	f26 <storage_configure()+0x356>
     d0c:	ldrb.w	r8, [r1, #6]
     d10:	mov.w	r3, #512	; 0x200
     d14:	ldr	r1, [r1, #28]
     d16:	lsl.w	r3, r3, r8
     d1a:	add.w	r8, r1, #4294967295
     d1e:	uxth	r3, r3
     d20:	umull	r0, r1, r3, r8
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
     d24:	strd	r0, r1, [sp, #8]
            uint64_t usedSize  = sdx[ii].usedSize();
     d28:	ldr	r3, [r2, #24]
     d2a:	ldr	r2, [pc, #440]	; (ee4 <storage_configure()+0x314>)
     d2c:	cmp	r3, r2
     d2e:	bne.w	efc <storage_configure()+0x32c>
     d32:	ldr.w	r0, [r4, #1156]	; 0x484
     d36:	cmp	r0, #0
     d38:	beq.w	f3e <storage_configure()+0x36e>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
     d3c:	ldr	r6, [r0, #28]
     d3e:	subs	r6, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
     d40:	bl	a510 <FatPartition::freeClusterCount()>
     d44:	ldr.w	r3, [r4, #1156]	; 0x484
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
     d48:	rsb	sl, r0, r6
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     d4c:	cmp	r3, #0
     d4e:	beq.w	f12 <storage_configure()+0x342>
     d52:	ldrb	r2, [r3, #6]
     d54:	mov.w	r3, #512	; 0x200
     d58:	lsls	r3, r2
     d5a:	uxth	r3, r3
     d5c:	umull	r2, r3, r3, sl
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
     d60:	strd	r2, r3, [sp, #16]
            Serial.printf("SDIO Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
     d64:	ldr.w	r1, [fp]
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
     d68:	movs	r7, #0
     d6a:	movs	r6, #10
     d6c:	mov	r2, r5
     d6e:	str	r1, [sp, #0]
     d70:	movs	r3, #254	; 0xfe
     d72:	ldr	r1, [pc, #372]	; (ee8 <storage_configure()+0x318>)
     d74:	ldr	r0, [pc, #344]	; (ed0 <storage_configure()+0x300>)
     d76:	bl	e990 <Print::printf(char const*, ...)>
     d7a:	ldr	r0, [pc, #340]	; (ed0 <storage_configure()+0x300>)
     d7c:	ldrd	r2, r3, [sp, #8]
     d80:	stmia.w	sp, {r6, r7}
     d84:	bl	e9ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     d88:	movs	r1, #1
     d8a:	ldr	r0, [pc, #352]	; (eec <storage_configure()+0x31c>)
     d8c:	bl	d248 <usb_serial_write>
     d90:	ldr	r0, [pc, #316]	; (ed0 <storage_configure()+0x300>)
     d92:	stmia.w	sp, {r6, r7}
     d96:	ldrd	r2, r3, [sp, #16]
     d9a:	bl	e9ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
     d9e:	ldr	r0, [pc, #304]	; (ed0 <storage_configure()+0x300>)
     da0:	bl	e960 <Print::println()>
     da4:	b.n	c30 <storage_configure()+0x60>
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    return cardBegin(spiConfig) && Vol::begin(m_card);
     da6:	mov	r1, r6
     da8:	mov	r0, r7
     daa:	bl	b2d8 <FsVolume::begin(BlockDeviceInterface*)>
     dae:	cmp	r0, #0
     db0:	beq.n	cb8 <storage_configure()+0xe8>
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
     db2:	ldr	r3, [pc, #296]	; (edc <storage_configure()+0x30c>)
     db4:	ldr	r3, [r3, #4]
     db6:	cmp	r3, #19
     db8:	bgt.n	dce <storage_configure()+0x1fe>
        sd_name[fsCount] = name;
     dba:	ldr	r2, [pc, #288]	; (edc <storage_configure()+0x30c>)
     dbc:	ldr.w	r1, [fp]
     dc0:	add.w	r0, r2, r3, lsl #2
        sdx[fsCount++] = &fs;
     dc4:	ldr	r6, [pc, #276]	; (edc <storage_configure()+0x30c>)
     dc6:	adds	r2, r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
     dc8:	str	r1, [r0, #8]
        sdx[fsCount++] = &fs;
     dca:	str	r2, [r6, #4]
     dcc:	str	r4, [r0, #88]	; 0x58
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
        }
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
          uint64_t totalSize = sdx[ii].totalSize();
     dce:	ldr	r2, [r4, #0]
     dd0:	ldr	r1, [pc, #268]	; (ee0 <storage_configure()+0x310>)
     dd2:	ldr	r3, [r2, #28]
     dd4:	cmp	r3, r1
     dd6:	bne.n	e70 <storage_configure()+0x2a0>
     dd8:	ldr.w	r1, [r4, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     ddc:	cmp	r1, #0
     dde:	beq.n	e9c <storage_configure()+0x2cc>
     de0:	ldrb	r0, [r1, #6]
     de2:	mov.w	r3, #512	; 0x200
     de6:	ldr	r6, [r1, #28]
     de8:	lsls	r3, r0
     dea:	subs	r6, #1
     dec:	uxth	r3, r3
     dee:	umull	r6, r7, r3, r6
          uint64_t usedSize  = sdx[ii].usedSize();
     df2:	ldr	r3, [r2, #24]
     df4:	ldr	r2, [pc, #236]	; (ee4 <storage_configure()+0x314>)
     df6:	cmp	r3, r2
     df8:	bne.n	e7c <storage_configure()+0x2ac>
     dfa:	ldr.w	r0, [r4, #1156]	; 0x484
     dfe:	cmp	r0, #0
     e00:	beq.n	eb2 <storage_configure()+0x2e2>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
     e02:	ldr	r3, [r0, #28]
     e04:	add.w	sl, r3, #4294967295
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
     e08:	bl	a510 <FatPartition::freeClusterCount()>
     e0c:	ldr.w	r3, [r4, #1156]	; 0x484
     e10:	rsb	r0, r0, sl
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     e14:	cmp	r3, #0
     e16:	beq.n	e86 <storage_configure()+0x2b6>
     e18:	ldrb	r2, [r3, #6]
     e1a:	mov.w	r3, #512	; 0x200
     e1e:	lsls	r3, r2
     e20:	uxth	r3, r3
     e22:	umull	r0, r1, r3, r0
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
     e26:	strd	r0, r1, [sp, #8]
          Serial.printf("SD Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
     e2a:	ldr.w	r1, [fp]
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
     e2e:	mov.w	sl, #0
     e32:	mov	r3, r8
     e34:	mov.w	r8, #10
     e38:	mov	r2, r5
     e3a:	str	r1, [sp, #0]
     e3c:	ldr	r0, [pc, #144]	; (ed0 <storage_configure()+0x300>)
     e3e:	ldr	r1, [pc, #176]	; (ef0 <storage_configure()+0x320>)
     e40:	bl	e990 <Print::printf(char const*, ...)>
     e44:	mov	r2, r6
     e46:	mov	r3, r7
     e48:	ldr	r0, [pc, #132]	; (ed0 <storage_configure()+0x300>)
     e4a:	stmia.w	sp, {r8, sl}
     e4e:	bl	e9ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
     e52:	movs	r1, #1
     e54:	ldr	r0, [pc, #148]	; (eec <storage_configure()+0x31c>)
     e56:	bl	d248 <usb_serial_write>
     e5a:	ldr	r0, [pc, #116]	; (ed0 <storage_configure()+0x300>)
     e5c:	stmia.w	sp, {r8, sl}
     e60:	ldrd	r2, r3, [sp, #8]
     e64:	bl	e9ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
     e68:	ldr	r0, [pc, #100]	; (ed0 <storage_configure()+0x300>)
     e6a:	bl	e960 <Print::println()>
     e6e:	b.n	c30 <storage_configure()+0x60>
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
        }
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
          uint64_t totalSize = sdx[ii].totalSize();
     e70:	mov	r0, r4
     e72:	blx	r3
     e74:	ldr	r2, [r4, #0]
     e76:	mov	r6, r0
     e78:	mov	r7, r1
     e7a:	b.n	df2 <storage_configure()+0x222>
          uint64_t usedSize  = sdx[ii].usedSize();
     e7c:	mov	r0, r4
     e7e:	blx	r3
     e80:	strd	r0, r1, [sp, #8]
     e84:	b.n	e2a <storage_configure()+0x25a>
     e86:	ldr.w	r3, [r4, #1160]	; 0x488
     e8a:	cmp	r3, #0
     e8c:	beq.n	f4e <storage_configure()+0x37e>
     e8e:	ldr.w	r3, [r3, #1084]	; 0x43c
     e92:	umull	r2, r3, r0, r3
     e96:	strd	r2, r3, [sp, #8]
     e9a:	b.n	e2a <storage_configure()+0x25a>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     e9c:	ldr.w	r3, [r4, #1160]	; 0x488
     ea0:	cmp	r3, #0
     ea2:	beq.n	f58 <storage_configure()+0x388>
     ea4:	ldr.w	r1, [r3, #1072]	; 0x430
     ea8:	ldr.w	r6, [r3, #1084]	; 0x43c
     eac:	umull	r6, r7, r6, r1
     eb0:	b.n	df2 <storage_configure()+0x222>
     eb2:	ldr.w	r0, [r4, #1160]	; 0x488
     eb6:	cmp	r0, #0
     eb8:	beq.n	f4e <storage_configure()+0x37e>
     eba:	ldr.w	sl, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
     ebe:	bl	8884 <ExFatPartition::freeClusterCount()>
     ec2:	b.n	e0c <storage_configure()+0x23c>
     ec4:	.word	0x20001d38
     ec8:	.word	0x20000b6c
     ecc:	.word	0x200001e8
     ed0:	.word	0x20000cdc
     ed4:	.word	0x01f78a40
     ed8:	.word	0x200001a8
     edc:	.word	0x200026b0
     ee0:	.word	0x00000745
     ee4:	.word	0x00000625
     ee8:	.word	0x20000190
     eec:	.word	0x200003a8
     ef0:	.word	0x200001d0
     ef4:	.word	0x20000b60
     ef8:	.word	0x200006ac
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();
     efc:	mov	r0, r4
     efe:	blx	r3
     f00:	strd	r0, r1, [sp, #16]
     f04:	b.n	d64 <storage_configure()+0x194>
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
     f06:	mov	r0, r4
     f08:	blx	r3
     f0a:	ldr	r2, [r4, #0]
     f0c:	strd	r0, r1, [sp, #8]
     f10:	b.n	d28 <storage_configure()+0x158>
     f12:	ldr.w	r3, [r4, #1160]	; 0x488
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     f16:	cbz	r3, f5e <storage_configure()+0x38e>
     f18:	ldr.w	r3, [r3, #1084]	; 0x43c
     f1c:	umull	r2, r3, sl, r3
     f20:	strd	r2, r3, [sp, #16]
     f24:	b.n	d64 <storage_configure()+0x194>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     f26:	ldr.w	r3, [r4, #1160]	; 0x488
     f2a:	cbz	r3, f68 <storage_configure()+0x398>
     f2c:	ldr.w	r1, [r3, #1072]	; 0x430
     f30:	ldr.w	r3, [r3, #1084]	; 0x43c
     f34:	umull	r0, r1, r1, r3
     f38:	strd	r0, r1, [sp, #8]
     f3c:	b.n	d28 <storage_configure()+0x158>
     f3e:	ldr.w	r0, [r4, #1160]	; 0x488
     f42:	cbz	r0, f5e <storage_configure()+0x38e>
     f44:	ldr.w	r6, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
     f48:	bl	8884 <ExFatPartition::freeClusterCount()>
     f4c:	b.n	d44 <storage_configure()+0x174>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     f4e:	movs	r2, #0
     f50:	movs	r3, #0
     f52:	strd	r2, r3, [sp, #8]
     f56:	b.n	e2a <storage_configure()+0x25a>
     f58:	movs	r6, #0
     f5a:	movs	r7, #0
     f5c:	b.n	df2 <storage_configure()+0x222>
     f5e:	movs	r2, #0
     f60:	movs	r3, #0
     f62:	strd	r2, r3, [sp, #16]
     f66:	b.n	d64 <storage_configure()+0x194>
     f68:	movs	r0, #0
     f6a:	movs	r1, #0
     f6c:	strd	r0, r1, [sp, #8]
     f70:	b.n	d28 <storage_configure()+0x158>
     f72:	nop

00000f74 <setup>:
      *ms10 = second() & 1 ? 100 : 0;
    }
  #endif

void setup()
{ 
     f74:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     f78:	ldr	r2, [pc, #520]	; (1184 <setup+0x210>)
     f7a:	sub	sp, #108	; 0x6c
     f7c:	ldr	r1, [pc, #520]	; (1188 <setup+0x214>)
     f7e:	ldr	r5, [pc, #524]	; (118c <setup+0x218>)
     f80:	ldr	r4, [pc, #524]	; (1190 <setup+0x21c>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     f82:	ldrb	r3, [r2, #0]
     f84:	cmp	r3, #0
     f86:	beq.n	f82 <setup+0xe>
     f88:	ldrb	r3, [r1, #0]
     f8a:	lsls	r3, r3, #31
     f8c:	bpl.n	f82 <setup+0xe>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     f8e:	ldr	r3, [r5, #0]
     f90:	ldr	r0, [r4, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     f92:	subs	r3, r3, r0
     f94:	cmp	r3, #14
     f96:	bls.n	f82 <setup+0xe>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     f98:	movs	r1, #8
     f9a:	ldr	r0, [pc, #504]	; (1194 <setup+0x220>)
     f9c:	ldr.w	r8, [pc, #552]	; 11c8 <setup+0x254>
     fa0:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     fa4:	ldr	r0, [pc, #496]	; (1198 <setup+0x224>)
     fa6:	bl	e960 <Print::println()>
    while(!Serial.available()); // comment if you do not want to wait for terminal (otherwise press any key to continue)
  #endif
  Serial.println("MTP_test");

  #if USE_EVENTS==1
    usb_init_events();
     faa:	bl	6be8 <usb_init_events>
  #endif

  #if !__has_include("usb_mtp.h")
    usb_mtp_configure();
  #endif
  storage_configure();
     fae:	bl	bd0 <storage_configure()>

  #if USE_SD==1
  // Set Time callback // needed for SDFat
  FsDateTime::callback = dateTime;
     fb2:	ldr	r3, [pc, #488]	; (119c <setup+0x228>)
     fb4:	ldr	r2, [pc, #488]	; (11a0 <setup+0x22c>)
     fb6:	ldr.w	r6, [r8, #1156]	; 0x484
     fba:	str	r2, [r3, #0]
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
     fbc:	cmp	r6, #0
     fbe:	beq.w	10ca <setup+0x156>
     fc2:	movs	r5, #0
     fc4:	add	r4, sp, #24
     fc6:	mov	r1, r6
     fc8:	ldr	r2, [pc, #472]	; (11a4 <setup+0x230>)
     fca:	mov	r3, r5
     fcc:	mov	r0, r4
     fce:	strb.w	r5, [sp, #24]
     fd2:	strb.w	r5, [sp, #25]
     fd6:	strb.w	r5, [sp, #26]
     fda:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>

  if(1){
    const char *str = "/test1.txt";
    if(sdx[0].exists(str)) sdx[0].remove(str);
     fde:	cmp	r0, #0
     fe0:	bne.w	10f0 <setup+0x17c>
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     fe4:	movw	r3, #514	; 0x202
     fe8:	mov	r0, r4
     fea:	ldr	r2, [pc, #440]	; (11a4 <setup+0x230>)
     fec:	ldr	r1, [pc, #440]	; (11a8 <setup+0x234>)
     fee:	bl	b3a0 <FsVolume::open(char const*, int)>
     ff2:	ldr	r3, [sp, #96]	; 0x60
     ff4:	cmp	r3, #0
     ff6:	beq.w	1164 <setup+0x1f0>
		if (file) return File(new SDFile(file));
     ffa:	movs	r0, #104	; 0x68
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     ffc:	movs	r5, #0
     ffe:	bl	ea7c <operator new(unsigned int)>
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    1002:	ldrb.w	r2, [sp, #28]
    1006:	mov	r4, r0
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    1008:	ldr	r3, [pc, #416]	; (11ac <setup+0x238>)
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    100a:	ldr	r1, [pc, #420]	; (11b0 <setup+0x23c>)
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    100c:	mov.w	r9, #1000	; 0x3e8
    1010:	strb	r2, [r4, #24]
    1012:	add	r7, sp, #40	; 0x28
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    1014:	ldrb.w	r2, [sp, #36]	; 0x24
    1018:	adds	r0, #36	; 0x24
    101a:	str	r3, [r4, #20]
    101c:	ldr	r3, [sp, #32]
    101e:	str	r1, [r4, #0]
    1020:	mov	r1, r7
    1022:	str	r3, [r4, #28]
    1024:	strb.w	r2, [r4, #32]
{
  public:
	constexpr Print() : write_error(0) {}
    1028:	strb	r5, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    102a:	strb	r5, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    102c:	str	r5, [r4, #16]
    102e:	str.w	r9, [r4, #8]
    1032:	bl	b158 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    1036:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1038:	ldr	r2, [pc, #376]	; (11b4 <setup+0x240>)
    103a:	adds	r3, #1
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    103c:	ldr	r6, [pc, #376]	; (11b8 <setup+0x244>)
    103e:	str	r5, [r4, #100]	; 0x64
    1040:	strb.w	r5, [sp, #8]
    1044:	str.w	r9, [sp, #12]
    1048:	strb.w	r5, [sp, #16]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
    104c:	str	r4, [sp, #20]
    104e:	str	r2, [r4, #20]
		if (f) f->refcount++;
    1050:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    1052:	str	r6, [sp, #4]
    1054:	ldr	r3, [pc, #356]	; (11bc <setup+0x248>)
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1056:	mov	r0, r7
    1058:	str	r3, [sp, #24]
    105a:	bl	b1d0 <FsBaseFile::close()>
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    105e:	movs	r2, #19
    1060:	ldr	r1, [pc, #348]	; (11c0 <setup+0x24c>)
    1062:	add	r0, sp, #4
    1064:	bl	e934 <Print::write(unsigned char const*, unsigned int)>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1068:	add	r0, sp, #4
    106a:	bl	e960 <Print::println()>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    106e:	ldr	r0, [sp, #20]
    1070:	cbz	r0, 1078 <setup+0x104>
    1072:	ldr	r3, [r0, #0]
    1074:	ldr	r3, [r3, #64]	; 0x40
    1076:	blx	r3
    1078:	movs	r1, #23
    107a:	ldr	r0, [pc, #328]	; (11c4 <setup+0x250>)
    107c:	bl	d248 <usb_serial_write>
    1080:	ldr	r0, [pc, #276]	; (1198 <setup+0x224>)
    1082:	bl	e960 <Print::println()>
    1086:	ldr.w	r2, [r8, #1156]	; 0x484
    108a:	ldr	r3, [pc, #316]	; (11c8 <setup+0x254>)
   *
   * \return true for success or false for failure.
   */
  bool ls(print_t* pr) {
    return m_fVol ? m_fVol->ls(pr) :
           m_xVol ? m_xVol->ls(pr) : false;
    108c:	cmp	r2, #0
    108e:	beq.n	1120 <setup+0x1ac>
   * LS_R - Recursive list of subdirectories.
   *
   * \return true for success or false for failure.
   */
  bool ls(print_t* pr, uint8_t flags = 0) {
    return m_vwd.ls(pr, flags);
    1090:	movs	r3, #0
    1092:	addw	r0, r2, #1092	; 0x444
    1096:	ldr	r1, [pc, #256]	; (1198 <setup+0x224>)
    1098:	mov	r2, r3
    109a:	bl	a264 <FatFile::ls(Print*, unsigned char, unsigned char)>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    109e:	ldr	r2, [sp, #20]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    10a0:	str	r6, [sp, #4]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    10a2:	cbz	r2, 10b6 <setup+0x142>
    10a4:	ldr	r3, [r2, #16]
    10a6:	subs	r3, #1
    10a8:	str	r3, [r2, #16]
    10aa:	cbnz	r3, 10b6 <setup+0x142>
    10ac:	ldr	r0, [sp, #20]
    10ae:	cbz	r0, 10b6 <setup+0x142>
    10b0:	ldr	r3, [r0, #0]
    10b2:	ldr	r3, [r3, #32]
    10b4:	blx	r3
    10b6:	movs	r1, #11
    10b8:	ldr	r0, [pc, #272]	; (11cc <setup+0x258>)
    10ba:	bl	d248 <usb_serial_write>
    10be:	ldr	r0, [pc, #216]	; (1198 <setup+0x224>)
    10c0:	bl	e960 <Print::println()>
    file.close();

  #endif

  Serial.println("\nSetup done");
}
    10c4:	add	sp, #108	; 0x6c
    10c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
    10ca:	ldr.w	r1, [r8, #1160]	; 0x488
    10ce:	add	r4, sp, #24
    10d0:	cmp	r1, #0
    10d2:	beq.n	fe4 <setup+0x70>
    10d4:	mov	r3, r6
    10d6:	ldr	r2, [pc, #204]	; (11a4 <setup+0x230>)
    10d8:	mov	r0, r4
    10da:	strb.w	r6, [sp, #73]	; 0x49
    10de:	strb.w	r6, [sp, #74]	; 0x4a
    10e2:	strb.w	r6, [sp, #75]	; 0x4b
    10e6:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
  // Set Time callback // needed for SDFat
  FsDateTime::callback = dateTime;

  if(1){
    const char *str = "/test1.txt";
    if(sdx[0].exists(str)) sdx[0].remove(str);
    10ea:	cmp	r0, #0
    10ec:	beq.w	fe4 <setup+0x70>
    10f0:	ldr.w	r5, [r8, #1156]	; 0x484
    10f4:	ldr	r3, [pc, #208]	; (11c8 <setup+0x254>)
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    10f6:	cbz	r5, 1136 <setup+0x1c2>
    10f8:	movs	r6, #0
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    10fa:	mov	r1, r5
    10fc:	movs	r3, #1
    10fe:	ldr	r2, [pc, #164]	; (11a4 <setup+0x230>)
    1100:	mov	r0, r4
    1102:	strb.w	r6, [sp, #24]
    1106:	strb.w	r6, [sp, #25]
    110a:	strb.w	r6, [sp, #26]
    110e:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>
    1112:	cmp	r0, #0
    1114:	beq.w	fe4 <setup+0x70>
    1118:	mov	r0, r4
    111a:	bl	ab4c <FatFile::remove()>
    111e:	b.n	fe4 <setup+0x70>
   *
   * \return true for success or false for failure.
   */
  bool ls(print_t* pr) {
    return m_fVol ? m_fVol->ls(pr) :
           m_xVol ? m_xVol->ls(pr) : false;
    1120:	ldr.w	r0, [r3, #1160]	; 0x488
    1124:	cmp	r0, #0
    1126:	beq.n	109e <setup+0x12a>
   * LS_R - Recursive list of subdirectories.
   *
   * \return true for success or false for failure.
   */
  bool ls(print_t* pr, uint8_t flags = 0) {
    return m_vwd.ls(pr, flags);
    1128:	mov	r3, r2
    112a:	ldr	r1, [pc, #108]	; (1198 <setup+0x224>)
    112c:	add.w	r0, r0, #1096	; 0x448
    1130:	bl	8428 <ExFatFile::ls(Print*, unsigned char, unsigned char)>
    1134:	b.n	109e <setup+0x12a>
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    1136:	ldr.w	r1, [r3, #1160]	; 0x488
    113a:	cmp	r1, #0
    113c:	beq.w	fe4 <setup+0x70>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    1140:	movs	r3, #1
    1142:	ldr	r2, [pc, #96]	; (11a4 <setup+0x230>)
    1144:	mov	r0, r4
    1146:	strb.w	r5, [sp, #73]	; 0x49
    114a:	strb.w	r5, [sp, #74]	; 0x4a
    114e:	strb.w	r5, [sp, #75]	; 0x4b
    1152:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
    1156:	cmp	r0, #0
    1158:	beq.w	fe4 <setup+0x70>
    115c:	mov	r0, r4
    115e:	bl	8b10 <ExFatFile::remove()>
    1162:	b.n	fe4 <setup+0x70>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    1164:	ldr	r3, [sp, #100]	; 0x64
    1166:	cmp	r3, #0
    1168:	bne.w	ffa <setup+0x86>
    116c:	mov.w	r2, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    1170:	ldr	r6, [pc, #68]	; (11b8 <setup+0x244>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    1172:	strb.w	r3, [sp, #8]
    1176:	add	r7, sp, #40	; 0x28
    1178:	strb.w	r3, [sp, #16]
    117c:	str	r3, [sp, #20]
    117e:	str	r2, [sp, #12]
    1180:	str	r6, [sp, #4]
    1182:	b.n	1054 <setup+0xe0>
    1184:	.word	0x20005254
    1188:	.word	0x2000514c
    118c:	.word	0x20005150
    1190:	.word	0x200052cc
    1194:	.word	0x20000254
    1198:	.word	0x20000cdc
    119c:	.word	0x200050e0
    11a0:	.word	0x00000225
    11a4:	.word	0x20000210
    11a8:	.word	0x20001d3c
    11ac:	.word	0x20000008
    11b0:	.word	0x200000d4
    11b4:	.word	0x20000050
    11b8:	.word	0x20000074
    11bc:	.word	0x2000002c
    11c0:	.word	0x2000021c
    11c4:	.word	0x20000230
    11c8:	.word	0x20001d38
    11cc:	.word	0x20000248

000011d0 <loop>:

  Serial.println("\nSetup done");
}

void loop()
{ 
    11d0:	push	{r4, lr}
  mtpd.loop();
    11d2:	ldr	r0, [pc, #60]	; (1210 <loop+0x40>)
    11d4:	bl	6570 <MTPD::loop()>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    11d8:	bl	d1f4 <usb_serial_available>

#if USE_EVENTS==1
  if(Serial.available())
    11dc:	cbnz	r0, 11e0 <loop+0x10>
    11de:	pop	{r4, pc}
        virtual int read() { return usb_serial_getchar(); }
    11e0:	bl	d17c <usb_serial_getchar>
  {
    char ch=Serial.read();
    11e4:	uxtb	r4, r0
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    11e6:	mov	r0, r4
    11e8:	bl	d350 <usb_serial_putchar>

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
    11ec:	ldr	r0, [pc, #36]	; (1214 <loop+0x44>)
    11ee:	bl	e960 <Print::println()>
    Serial.println(ch);
    if(ch=='r') 
    11f2:	cmp	r4, #114	; 0x72
    11f4:	bne.n	11de <loop+0xe>
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    11f6:	movs	r1, #5
    11f8:	ldr	r0, [pc, #28]	; (1218 <loop+0x48>)
    11fa:	bl	d248 <usb_serial_write>
	size_t println(const char s[])			{ return print(s) + println(); }
    11fe:	ldr	r0, [pc, #20]	; (1214 <loop+0x44>)
    1200:	bl	e960 <Print::println()>
    {
      Serial.println("Reset");
      mtpd.send_DeviceResetEvent();
    1204:	ldr	r0, [pc, #8]	; (1210 <loop+0x40>)
        mtpd.send_StorageInfoChangedEvent(store);
      }
    #endif
  }
#endif
}
    1206:	ldmia.w	sp!, {r4, lr}
    char ch=Serial.read();
    Serial.println(ch);
    if(ch=='r') 
    {
      Serial.println("Reset");
      mtpd.send_DeviceResetEvent();
    120a:	b.w	6c64 <MTPD::send_DeviceResetEvent()>
    120e:	nop
    1210:	.word	0x200027c0
    1214:	.word	0x20000cdc
    1218:	.word	0x20000260

0000121c <_GLOBAL__sub_I_sd_str>:
        mtpd.send_StorageInfoChangedEvent(store);
      }
    #endif
  }
#endif
}
    121c:	push	{r3, r4, r5, r6, r7, lr}


class SDClass : public FS
{
public:
	SDClass() { }
    121e:	ldr	r3, [pc, #268]	; (132c <_GLOBAL__sub_I_sd_str+0x110>)
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    1220:	movs	r4, #0
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    1222:	ldr.w	lr, [pc, #300]	; 1350 <_GLOBAL__sub_I_sd_str+0x134>
		init_AlwaysInline(MSBFIRST, SPI_MODE0);
	}
private:
	void init_AlwaysInline(uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
			tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
    1226:	movs	r1, #7
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1228:	ldr.w	ip, [pc, #296]	; 1354 <_GLOBAL__sub_I_sd_str+0x138>
    122c:	movs	r5, #1
    122e:	ldr	r2, [pc, #256]	; (1330 <_GLOBAL__sub_I_sd_str+0x114>)
    1230:	movs	r6, #41	; 0x29
    1232:	str.w	lr, [r3, #1184]	; 0x4a0
    const char *sd_str[]={"sd1"}; // edit to reflect your configuration
    const int cs[] = {10}; // edit to reflect your configuration
  #endif
  const int nsd = sizeof(sd_str)/sizeof(const char *);

SDClass sdx[nsd];
    1236:	mov	r0, r4
    1238:	str.w	lr, [r3, #2396]	; 0x95c
    123c:	ldr	r7, [pc, #244]	; (1334 <_GLOBAL__sub_I_sd_str+0x118>)
public:
	SPISettings(uint32_t clockIn, uint8_t bitOrderIn, uint8_t dataModeIn) : _clock(clockIn) {
		init_AlwaysInline(bitOrderIn, dataModeIn);
	}

	SPISettings() : _clock(4000000) {
    123e:	ldr.w	lr, [pc, #280]	; 1358 <_GLOBAL__sub_I_sd_str+0x13c>
    1242:	str	r2, [r3, #0]
    1244:	str.w	r2, [r3, #1212]	; 0x4bc
    1248:	mov	r2, r7
    124a:	str.w	ip, [r3, #1172]	; 0x494
    124e:	str.w	ip, [r3, #2384]	; 0x950
		init_AlwaysInline(MSBFIRST, SPI_MODE0);
	}
private:
	void init_AlwaysInline(uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
			tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
    1252:	str.w	r1, [r3, #1196]	; 0x4ac
public:
	SPISettings(uint32_t clockIn, uint8_t bitOrderIn, uint8_t dataModeIn) : _clock(clockIn) {
		init_AlwaysInline(bitOrderIn, dataModeIn);
	}

	SPISettings() : _clock(4000000) {
    1256:	str.w	lr, [r3, #1192]	; 0x4a8
    125a:	str.w	lr, [r3, #2404]	; 0x964
		init_AlwaysInline(MSBFIRST, SPI_MODE0);
	}
private:
	void init_AlwaysInline(uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
			tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
    125e:	str.w	r1, [r3, #2408]	; 0x968
    1262:	strb.w	r5, [r3, #1205]	; 0x4b5
    1266:	strb.w	r5, [r3, #2417]	; 0x971
    126a:	strb.w	r6, [r3, #1207]	; 0x4b7
    126e:	strb.w	r6, [r3, #2419]	; 0x973
    1272:	mov.w	r6, #1000	; 0x3e8
    1276:	str.w	r4, [r3, #1156]	; 0x484
    127a:	str.w	r4, [r3, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    127e:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1282:	strb.w	r4, [r3, #1181]	; 0x49d
    1286:	strb.w	r4, [r3, #1210]	; 0x4ba
    128a:	str.w	r4, [r3, #2368]	; 0x940
    128e:	str.w	r4, [r3, #2372]	; 0x944
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    1292:	strb.w	r4, [r3, #2392]	; 0x958
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1296:	strb.w	r4, [r3, #2393]	; 0x959
    129a:	strb.w	r4, [r3, #2422]	; 0x976
    129e:	ldr	r1, [pc, #152]	; (1338 <_GLOBAL__sub_I_sd_str+0x11c>)
    12a0:	bl	eb64 <__aeabi_atexit>

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    12a4:	ldr	r5, [pc, #148]	; (133c <_GLOBAL__sub_I_sd_str+0x120>)
    12a6:	ldr	r3, [pc, #152]	; (1340 <_GLOBAL__sub_I_sd_str+0x124>)

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    12a8:	mvn.w	lr, #1
    12ac:	ldr	r1, [pc, #148]	; (1344 <_GLOBAL__sub_I_sd_str+0x128>)

LittleFS_SPIFlash spifs[nfs_spi];
#endif


MTPStorage_SD storage;
    12ae:	mov	r2, r7
    12b0:	str.w	r3, [r5, #168]	; 0xa8
    12b4:	mov	r0, r5
    12b6:	str	r1, [r5, #0]
    12b8:	str.w	r3, [r5, #188]	; 0xbc
    12bc:	ldr	r1, [pc, #136]	; (1348 <_GLOBAL__sub_I_sd_str+0x12c>)
    12be:	str.w	r3, [r5, #208]	; 0xd0

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    12c2:	str	r4, [r5, #4]
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    12c4:	strb.w	r4, [r5, #172]	; 0xac
    12c8:	strb.w	r4, [r5, #180]	; 0xb4
    12cc:	str.w	r4, [r5, #184]	; 0xb8
    12d0:	strb.w	r4, [r5, #192]	; 0xc0
    12d4:	strb.w	r4, [r5, #200]	; 0xc8
    12d8:	str.w	r4, [r5, #204]	; 0xcc
    12dc:	strb.w	r4, [r5, #212]	; 0xd4
    12e0:	strb.w	r4, [r5, #220]	; 0xdc
    12e4:	str.w	r4, [r5, #224]	; 0xe0
    12e8:	str.w	r6, [r5, #176]	; 0xb0
    12ec:	str.w	r6, [r5, #196]	; 0xc4
    12f0:	str.w	r6, [r5, #216]	; 0xd8

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    12f4:	str.w	r4, [r5, #228]	; 0xe4
    12f8:	str.w	r4, [r5, #232]	; 0xe8
    12fc:	str.w	r4, [r5, #236]	; 0xec
    1300:	str.w	r4, [r5, #244]	; 0xf4
    1304:	strb.w	r4, [r5, #248]	; 0xf8
    1308:	strb.w	r4, [r5, #249]	; 0xf9
    130c:	str.w	lr, [r5, #240]	; 0xf0
    1310:	bl	eb64 <__aeabi_atexit>

// MTP Responder.
class MTPD {
public:

  explicit MTPD(MTPStorageInterface* storage): storage_(storage) {}
    1314:	ldr	r3, [pc, #52]	; (134c <_GLOBAL__sub_I_sd_str+0x130>)
    1316:	movw	r0, #9248	; 0x2420
    131a:	movw	r1, #9252	; 0x2424
    131e:	movw	r2, #9256	; 0x2428
    1322:	str	r5, [r3, #0]
    1324:	str	r4, [r3, r0]
    1326:	strb	r4, [r3, r1]
    1328:	str	r4, [r3, r2]
    132a:	pop	{r3, r4, r5, r6, r7, pc}
    132c:	.word	0x20001d38
    1330:	.word	0x20000134
    1334:	.word	0x20000b5c
    1338:	.word	0x000001e5
    133c:	.word	0x200026b0
    1340:	.word	0x20000074
    1344:	.word	0x2000027c
    1348:	.word	0x00000afd
    134c:	.word	0x200027c0
    1350:	.word	0x20000594
    1354:	.word	0x200005ec
    1358:	.word	0x003d0900

0000135c <MTPStorage_SD::addFilesystem(FS&, char const*)>:
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    135c:	ldr	r3, [r0, #4]
    135e:	cmp	r3, #19
    1360:	bgt.n	1374 <MTPStorage_SD::addFilesystem(FS&, char const*)+0x18>

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1362:	push	{r4}
    1364:	add.w	r4, r0, r3, lsl #2
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
        sdx[fsCount++] = &fs;
    1368:	adds	r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
    136a:	str	r2, [r4, #8]
        sdx[fsCount++] = &fs;
    136c:	str	r3, [r0, #4]
    136e:	str	r1, [r4, #88]	; 0x58

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1370:	ldr.w	r4, [sp], #4
    1374:	bx	lr
    1376:	nop

00001378 <MTPStorage_SD::get_FSCount()>:
  Record ReadIndexRecord(uint32_t i) ;
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
    1378:	ldr	r0, [r0, #4]
    137a:	bx	lr

0000137c <MTPStorage_SD::get_FSName(unsigned long)>:
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    137c:	add.w	r1, r0, r1, lsl #2
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
  const char *get_FSName(uint32_t storage) { return sd_getFSName(storage);}
    1380:	ldr	r0, [r1, #8]
    1382:	bx	lr

00001384 <MTPStorage_SD::readonly(unsigned long)>:

// These should probably be weak.
void mtp_yield() {}
void mtp_lock_storage(bool lock) {}

  bool MTPStorage_SD::readonly(uint32_t store) { return false; }
    1384:	movs	r0, #0
    1386:	bx	lr

00001388 <MTPStorage_SD::has_directories(unsigned long)>:
  bool MTPStorage_SD::has_directories(uint32_t store) { return true; }
    1388:	movs	r0, #1
    138a:	bx	lr

0000138c <MTPStorage_SD::totalSize(unsigned long)>:
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }

    uint64_t sd_totalSize(uint32_t store) { return sdx[store]->totalSize();  }
    138c:	add.w	r1, r0, r1, lsl #2
    1390:	ldr	r0, [r1, #88]	; 0x58
    1392:	ldr	r3, [r0, #0]
    1394:	ldr	r3, [r3, #28]
    1396:	bx	r3

00001398 <MTPStorage_SD::usedSize(unsigned long)>:
    uint64_t sd_usedSize(uint32_t store)  { return sdx[store]->usedSize();  }
    1398:	add.w	r1, r0, r1, lsl #2
    139c:	ldr	r0, [r1, #88]	; 0x58
    139e:	ldr	r3, [r0, #0]
    13a0:	ldr	r3, [r3, #24]
    13a2:	bx	r3

000013a4 <MTPStorage_SD::write(char const*, unsigned long)>:
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    13a4:	ldr.w	r0, [r0, #204]	; 0xcc
    13a8:	cmp	r0, #0
    13aa:	beq.n	1412 <MTPStorage_SD::write(char const*, unsigned long)+0x6e>
    #endif
    return ret;
  }

  size_t MTPStorage_SD::write(const char* data, uint32_t bytes)
  {
    13ac:	push	{r4, r5, r6}
    13ae:	ldr	r4, [r0, #0]
    13b0:	ldr	r3, [pc, #108]	; (1420 <MTPStorage_SD::write(char const*, unsigned long)+0x7c>)
    13b2:	ldr	r4, [r4, #44]	; 0x2c
    13b4:	cmp	r4, r3
    13b6:	bne.n	140c <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    13b8:	ldr	r0, [r0, #16]
    13ba:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13bc:	ldr	r4, [r0, #0]
    13be:	ldr	r4, [r4, #44]	; 0x2c
    13c0:	cmp	r4, r3
    13c2:	bne.n	140c <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    13c4:	ldr	r0, [r0, #16]
    13c6:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13c8:	ldr	r4, [r0, #0]
    13ca:	ldr	r4, [r4, #44]	; 0x2c
    13cc:	cmp	r4, r3
    13ce:	bne.n	140c <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    13d0:	ldr	r0, [r0, #16]
    13d2:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13d4:	ldr	r4, [r0, #0]
    13d6:	ldr	r4, [r4, #44]	; 0x2c
    13d8:	cmp	r4, r3
    13da:	bne.n	140c <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    13dc:	ldr	r0, [r0, #16]
    13de:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13e0:	mov	r6, r2
    13e2:	ldr	r2, [r0, #0]
    13e4:	ldr	r4, [r2, #44]	; 0x2c
    13e6:	cmp	r4, r3
    13e8:	mov	r5, r1
    13ea:	bne.n	1416 <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    13ec:	ldr	r0, [r0, #16]
    13ee:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13f0:	ldr	r2, [r0, #0]
    13f2:	ldr	r4, [r2, #44]	; 0x2c
    13f4:	cmp	r4, r3
    13f6:	bne.n	1416 <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    13f8:	ldr	r0, [r0, #16]
    13fa:	cbz	r0, 1406 <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    13fc:	ldr	r3, [r0, #0]
    13fe:	mov	r2, r6
    1400:	ldr	r3, [r3, #44]	; 0x2c
      mtp_lock_storage(true);
      size_t ret = file_.write(data,bytes);
      mtp_lock_storage(false);
      return ret;
  }
    1402:	pop	{r4, r5, r6}
    1404:	bx	r3
    1406:	movs	r0, #0
    1408:	pop	{r4, r5, r6}
    140a:	bx	lr
    140c:	mov	r3, r4
    140e:	pop	{r4, r5, r6}
    1410:	bx	r3
    1412:	movs	r0, #0
    1414:	bx	lr
    1416:	mov	r2, r6
    1418:	mov	r1, r5
    141a:	mov	r3, r4
    141c:	pop	{r4, r5, r6}
    141e:	bx	r3
    1420:	.word	0x00000099

00001424 <MTPStorage_SD::ResetIndex()>:
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1424:	ldr.w	r3, [r0, #184]	; 0xb8
    1428:	cmp	r3, #0
    142a:	beq.n	1494 <MTPStorage_SD::ResetIndex()+0x70>
    142c:	ldr	r2, [r3, #0]
    142e:	ldr	r1, [pc, #108]	; (149c <MTPStorage_SD::ResetIndex()+0x78>)
    1430:	ldr	r2, [r2, #68]	; 0x44
    1432:	cmp	r2, r1
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    mtp_lock_storage(false);
  }

  void MTPStorage_SD::ResetIndex() {
    1434:	push	{r4, lr}
    1436:	mov	r4, r0
    1438:	bne.n	148e <MTPStorage_SD::ResetIndex()+0x6a>
    143a:	ldr	r0, [r3, #16]
    143c:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    143e:	ldr	r3, [r0, #0]
    1440:	ldr	r3, [r3, #68]	; 0x44
    1442:	cmp	r3, r2
    1444:	bne.n	1496 <MTPStorage_SD::ResetIndex()+0x72>
    1446:	ldr	r0, [r0, #16]
    1448:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    144a:	ldr	r2, [r0, #0]
    144c:	ldr	r2, [r2, #68]	; 0x44
    144e:	cmp	r2, r3
    1450:	bne.n	1490 <MTPStorage_SD::ResetIndex()+0x6c>
    1452:	ldr	r0, [r0, #16]
    1454:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    1456:	ldr	r3, [r0, #0]
    1458:	ldr	r3, [r3, #68]	; 0x44
    145a:	cmp	r3, r2
    145c:	bne.n	1496 <MTPStorage_SD::ResetIndex()+0x72>
    145e:	ldr	r0, [r0, #16]
    1460:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    1462:	ldr	r2, [r0, #0]
    1464:	ldr	r2, [r2, #68]	; 0x44
    1466:	cmp	r2, r3
    1468:	bne.n	1490 <MTPStorage_SD::ResetIndex()+0x6c>
    146a:	ldr	r0, [r0, #16]
    146c:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    146e:	ldr	r3, [r0, #0]
    1470:	ldr	r3, [r3, #68]	; 0x44
    1472:	blx	r3
    if(!sd_isOpen(index_)) return;
    1474:	cbz	r0, 148c <MTPStorage_SD::ResetIndex()+0x68>
    CloseIndex();
    1476:	ldr	r3, [r4, #0]
    1478:	mov	r0, r4
    147a:	ldr	r3, [r3, #64]	; 0x40
    147c:	blx	r3
//    OpenIndex();

    all_scanned_ = false;
    147e:	movs	r2, #0
    open_file_ = 0xFFFFFFFEUL;
    1480:	mvn.w	r3, #1
  void MTPStorage_SD::ResetIndex() {
    if(!sd_isOpen(index_)) return;
    CloseIndex();
//    OpenIndex();

    all_scanned_ = false;
    1484:	strb.w	r2, [r4, #249]	; 0xf9
    open_file_ = 0xFFFFFFFEUL;
    1488:	str.w	r3, [r4, #240]	; 0xf0
    148c:	pop	{r4, pc}
    148e:	mov	r0, r3
    1490:	blx	r2
    1492:	b.n	1474 <MTPStorage_SD::ResetIndex()+0x50>
    1494:	bx	lr
    1496:	blx	r3
    1498:	b.n	1474 <MTPStorage_SD::ResetIndex()+0x50>
    149a:	nop
    149c:	.word	0x0000011d

000014a0 <MTPStorage_SD::CloseIndex()>:

  uint64_t MTPStorage_SD::totalSize(uint32_t store) { return sd_totalSize(store); }
  uint64_t MTPStorage_SD::usedSize(uint32_t store) { return sd_usedSize(store); }

  void MTPStorage_SD::CloseIndex()
  {
    14a0:	push	{r4, lr}
    14a2:	mov	r4, r0
    14a4:	ldr.w	r0, [r0, #184]	; 0xb8
    14a8:	cmp	r0, #0
    14aa:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14ac:	ldr	r3, [r0, #0]
    14ae:	ldr	r2, [pc, #256]	; (15b0 <MTPStorage_SD::CloseIndex()+0x110>)
    14b0:	ldr	r3, [r3, #68]	; 0x44
    14b2:	cmp	r3, r2
    14b4:	bne.n	1598 <MTPStorage_SD::CloseIndex()+0xf8>
    14b6:	ldr	r0, [r0, #16]
    14b8:	cmp	r0, #0
    14ba:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14bc:	ldr	r2, [r0, #0]
    14be:	ldr	r2, [r2, #68]	; 0x44
    14c0:	cmp	r2, r3
    14c2:	bne.n	15aa <MTPStorage_SD::CloseIndex()+0x10a>
    14c4:	ldr	r0, [r0, #16]
    14c6:	cmp	r0, #0
    14c8:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14ca:	ldr	r3, [r0, #0]
    14cc:	ldr	r3, [r3, #68]	; 0x44
    14ce:	cmp	r3, r2
    14d0:	bne.n	1598 <MTPStorage_SD::CloseIndex()+0xf8>
    14d2:	ldr	r0, [r0, #16]
    14d4:	cmp	r0, #0
    14d6:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14d8:	ldr	r2, [r0, #0]
    14da:	ldr	r2, [r2, #68]	; 0x44
    14dc:	cmp	r2, r3
    14de:	bne.n	15aa <MTPStorage_SD::CloseIndex()+0x10a>
    14e0:	ldr	r0, [r0, #16]
    14e2:	cmp	r0, #0
    14e4:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14e6:	ldr	r3, [r0, #0]
    14e8:	ldr	r3, [r3, #68]	; 0x44
    14ea:	cmp	r3, r2
    14ec:	bne.n	1598 <MTPStorage_SD::CloseIndex()+0xf8>
    14ee:	ldr	r0, [r0, #16]
    14f0:	cmp	r0, #0
    14f2:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    14f4:	ldr	r3, [r0, #0]
    14f6:	ldr	r3, [r3, #68]	; 0x44
    14f8:	blx	r3
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    14fa:	cmp	r0, #0
    14fc:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    14fe:	ldr.w	r0, [r4, #184]	; 0xb8
    1502:	cmp	r0, #0
    1504:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    1506:	ldr	r2, [r0, #0]
    1508:	ldr	r3, [pc, #168]	; (15b4 <MTPStorage_SD::CloseIndex()+0x114>)
    150a:	ldr	r2, [r2, #64]	; 0x40
    150c:	cmp	r2, r3
    150e:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    1510:	ldr	r0, [r0, #16]
    1512:	cmp	r0, #0
    1514:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    1516:	ldr	r2, [r0, #0]
    1518:	ldr	r2, [r2, #64]	; 0x40
    151a:	cmp	r2, r3
    151c:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    151e:	ldr	r0, [r0, #16]
    1520:	cmp	r0, #0
    1522:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    1524:	ldr	r2, [r0, #0]
    1526:	ldr	r2, [r2, #64]	; 0x40
    1528:	cmp	r2, r3
    152a:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    152c:	ldr	r0, [r0, #16]
    152e:	cmp	r0, #0
    1530:	beq.n	158c <MTPStorage_SD::CloseIndex()+0xec>
    1532:	ldr	r2, [r0, #0]
    1534:	ldr	r2, [r2, #64]	; 0x40
    1536:	cmp	r2, r3
    1538:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    153a:	ldr	r0, [r0, #16]
    153c:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    153e:	ldr	r2, [r0, #0]
    1540:	ldr	r2, [r2, #64]	; 0x40
    1542:	cmp	r2, r3
    1544:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    1546:	ldr	r0, [r0, #16]
    1548:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    154a:	ldr	r2, [r0, #0]
    154c:	ldr	r2, [r2, #64]	; 0x40
    154e:	cmp	r2, r3
    1550:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    1552:	ldr	r0, [r0, #16]
    1554:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    1556:	ldr	r2, [r0, #0]
    1558:	ldr	r2, [r2, #64]	; 0x40
    155a:	cmp	r2, r3
    155c:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    155e:	ldr	r0, [r0, #16]
    1560:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    1562:	ldr	r2, [r0, #0]
    1564:	ldr	r2, [r2, #64]	; 0x40
    1566:	cmp	r2, r3
    1568:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    156a:	ldr	r0, [r0, #16]
    156c:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    156e:	ldr	r2, [r0, #0]
    1570:	ldr	r2, [r2, #64]	; 0x40
    1572:	cmp	r2, r3
    1574:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    1576:	ldr	r0, [r0, #16]
    1578:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    157a:	ldr	r2, [r0, #0]
    157c:	ldr	r2, [r2, #64]	; 0x40
    157e:	cmp	r2, r3
    1580:	bne.n	159c <MTPStorage_SD::CloseIndex()+0xfc>
    1582:	ldr	r0, [r0, #16]
    1584:	cbz	r0, 158c <MTPStorage_SD::CloseIndex()+0xec>
    1586:	ldr	r3, [r0, #0]
    1588:	ldr	r3, [r3, #64]	; 0x40
    158a:	blx	r3
    mtp_lock_storage(false);
    index_generated = false;
    158c:	movs	r3, #0
    158e:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    1592:	str.w	r3, [r4, #244]	; 0xf4
    1596:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1598:	blx	r3
    159a:	b.n	14fa <MTPStorage_SD::CloseIndex()+0x5a>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    159c:	blx	r2
  void MTPStorage_SD::CloseIndex()
  {
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    mtp_lock_storage(false);
    index_generated = false;
    159e:	movs	r3, #0
    15a0:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    15a4:	str.w	r3, [r4, #244]	; 0xf4
    15a8:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    15aa:	blx	r2
    15ac:	b.n	14fa <MTPStorage_SD::CloseIndex()+0x5a>
    15ae:	nop
    15b0:	.word	0x0000011d
    15b4:	.word	0x00000111

000015b8 <File::invalidate() [clone .isra.1]>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    15b8:	ldr	r2, [r0, #0]
    15ba:	cmp	r2, #0
    15bc:	beq.n	1638 <File::invalidate() [clone .isra.1]+0x80>
    15be:	ldr	r3, [r2, #16]
    15c0:	subs	r3, #1
    15c2:	str	r3, [r2, #16]
    15c4:	cmp	r3, #0
    15c6:	bne.n	1638 <File::invalidate() [clone .isra.1]+0x80>
	}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
    15c8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (f && --(f->refcount) == 0) delete f;
    15cc:	ldr	r4, [r0, #0]
    15ce:	cmp	r4, #0
    15d0:	beq.n	163a <File::invalidate() [clone .isra.1]+0x82>
    15d2:	ldr	r3, [r4, #0]
    15d4:	ldr	r1, [pc, #120]	; (1650 <File::invalidate() [clone .isra.1]+0x98>)
    15d6:	ldr	r3, [r3, #32]
    15d8:	cmp	r3, r1
    15da:	bne.n	163e <File::invalidate() [clone .isra.1]+0x86>
    15dc:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    15de:	ldr	r6, [pc, #116]	; (1654 <File::invalidate() [clone .isra.1]+0x9c>)
    15e0:	str	r6, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    15e2:	cbz	r2, 162c <File::invalidate() [clone .isra.1]+0x74>
    15e4:	ldr	r3, [r2, #16]
    15e6:	subs	r3, #1
    15e8:	str	r3, [r2, #16]
    15ea:	cbnz	r3, 162c <File::invalidate() [clone .isra.1]+0x74>
    15ec:	ldr	r5, [r4, #16]
    15ee:	cbz	r5, 162c <File::invalidate() [clone .isra.1]+0x74>
    15f0:	ldr	r3, [r5, #0]
    15f2:	ldr	r3, [r3, #32]
    15f4:	cmp	r3, r1
    15f6:	bne.n	1646 <File::invalidate() [clone .isra.1]+0x8e>
    15f8:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    15fa:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    15fc:	cbz	r2, 1624 <File::invalidate() [clone .isra.1]+0x6c>
    15fe:	ldr	r3, [r2, #16]
    1600:	subs	r3, #1
    1602:	str	r3, [r2, #16]
    1604:	cbnz	r3, 1624 <File::invalidate() [clone .isra.1]+0x6c>
    1606:	ldr	r7, [r5, #16]
    1608:	cbz	r7, 1624 <File::invalidate() [clone .isra.1]+0x6c>
    160a:	ldr	r3, [r7, #0]
    160c:	ldr	r3, [r3, #32]
    160e:	cmp	r3, r1
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    1610:	mov	r0, r7
    1612:	bne.n	164c <File::invalidate() [clone .isra.1]+0x94>
    1614:	str.w	r6, [r0], #16
		invalidate();
    1618:	bl	15b8 <File::invalidate() [clone .isra.1]>
	}
    161c:	mov	r0, r7
    161e:	movs	r1, #20
    1620:	bl	ea80 <operator delete(void*, unsigned int)>
    1624:	mov	r0, r5
    1626:	movs	r1, #20
    1628:	bl	ea80 <operator delete(void*, unsigned int)>
    162c:	mov	r0, r4
    162e:	movs	r1, #20
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
	}
    1630:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    1634:	b.w	ea80 <operator delete(void*, unsigned int)>
    1638:	bx	lr
    163a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    163e:	mov	r0, r4
	}
    1640:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1644:	bx	r3
    1646:	mov	r0, r5
    1648:	blx	r3
    164a:	b.n	162c <File::invalidate() [clone .isra.1]+0x74>
    164c:	blx	r3
    164e:	b.n	1624 <File::invalidate() [clone .isra.1]+0x6c>
    1650:	.word	0x00000acd
    1654:	.word	0x20000074

00001658 <mtp_yield()>:
//   support serialflash
//   partial object fetch/receive
//   events (notify usb host when local storage changes) (But, this seems too difficult)

// These should probably be weak.
void mtp_yield() {}
    1658:	bx	lr
    165a:	nop

0000165c <MTPStorage_SD::OpenIndex()>:
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    165c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1660:	mov	r4, r0
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1662:	ldr.w	r0, [r0, #184]	; 0xb8
    1666:	sub	sp, #28
    1668:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    166a:	ldr	r3, [r0, #0]
    166c:	ldr	r2, [pc, #536]	; (1888 <MTPStorage_SD::OpenIndex()+0x22c>)
    166e:	ldr	r3, [r3, #68]	; 0x44
    1670:	cmp	r3, r2
    1672:	bne.w	198c <MTPStorage_SD::OpenIndex()+0x330>
    1676:	ldr	r0, [r0, #16]
    1678:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    167a:	ldr	r2, [r0, #0]
    167c:	ldr	r2, [r2, #68]	; 0x44
    167e:	cmp	r2, r3
    1680:	bne.w	19a0 <MTPStorage_SD::OpenIndex()+0x344>
    1684:	ldr	r0, [r0, #16]
    1686:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    1688:	ldr	r3, [r0, #0]
    168a:	ldr	r3, [r3, #68]	; 0x44
    168c:	cmp	r3, r2
    168e:	bne.w	198c <MTPStorage_SD::OpenIndex()+0x330>
    1692:	ldr	r0, [r0, #16]
    1694:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    1696:	ldr	r2, [r0, #0]
    1698:	ldr	r2, [r2, #68]	; 0x44
    169a:	cmp	r2, r3
    169c:	bne.w	19a0 <MTPStorage_SD::OpenIndex()+0x344>
    16a0:	ldr	r0, [r0, #16]
    16a2:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    16a4:	ldr	r3, [r0, #0]
    16a6:	ldr	r3, [r3, #68]	; 0x44
    16a8:	cmp	r3, r2
    16aa:	bne.w	198c <MTPStorage_SD::OpenIndex()+0x330>
    16ae:	ldr	r0, [r0, #16]
    16b0:	cbz	r0, 16bc <MTPStorage_SD::OpenIndex()+0x60>
    16b2:	ldr	r3, [r0, #0]
    16b4:	ldr	r3, [r3, #68]	; 0x44
    16b6:	blx	r3
    16b8:	cmp	r0, #0
    16ba:	bne.n	1790 <MTPStorage_SD::OpenIndex()+0x134>
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    16bc:	ldr	r1, [r4, #88]	; 0x58
    16be:	ldr	r2, [pc, #460]	; (188c <MTPStorage_SD::OpenIndex()+0x230>)
    16c0:	ldr	r3, [r1, #0]
    16c2:	add	r0, sp, #4
    16c4:	ldr	r5, [r3, #0]
    16c6:	movs	r3, #2
    16c8:	blx	r5
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    16ca:	ldr.w	r3, [r4, #184]	; 0xb8
    16ce:	cbz	r3, 16dc <MTPStorage_SD::OpenIndex()+0x80>
    16d0:	ldr	r2, [r3, #16]
    16d2:	subs	r2, #1
    16d4:	str	r2, [r3, #16]
    16d6:	cmp	r2, #0
    16d8:	beq.w	18a0 <MTPStorage_SD::OpenIndex()+0x244>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    16dc:	ldr	r3, [sp, #20]
    16de:	str.w	r3, [r4, #184]	; 0xb8
		if (f) f->refcount++;
    16e2:	cbz	r3, 16fc <MTPStorage_SD::OpenIndex()+0xa0>
    16e4:	ldr	r2, [r3, #16]
		return *this;
	}
	virtual ~File() {
    16e6:	ldr	r1, [pc, #424]	; (1890 <MTPStorage_SD::OpenIndex()+0x234>)
    16e8:	str	r1, [sp, #4]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    16ea:	adds	r2, #1
    16ec:	str	r2, [r3, #16]
    16ee:	ldr	r2, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    16f0:	cbz	r2, 16fc <MTPStorage_SD::OpenIndex()+0xa0>
    16f2:	ldr	r3, [r2, #16]
    16f4:	subs	r3, #1
    16f6:	str	r3, [r2, #16]
    16f8:	cmp	r3, #0
    16fa:	beq.n	1796 <MTPStorage_SD::OpenIndex()+0x13a>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    16fc:	ldr.w	r0, [r4, #184]	; 0xb8
    1700:	cmp	r0, #0
    1702:	beq.n	1782 <MTPStorage_SD::OpenIndex()+0x126>
    1704:	ldr	r2, [r0, #0]
    1706:	ldr	r3, [pc, #384]	; (1888 <MTPStorage_SD::OpenIndex()+0x22c>)
    1708:	ldr	r2, [r2, #68]	; 0x44
    170a:	cmp	r2, r3
    170c:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    1710:	ldr	r0, [r0, #16]
    1712:	cmp	r0, #0
    1714:	beq.n	1782 <MTPStorage_SD::OpenIndex()+0x126>
    1716:	ldr	r2, [r0, #0]
    1718:	ldr	r2, [r2, #68]	; 0x44
    171a:	cmp	r2, r3
    171c:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    1720:	ldr	r0, [r0, #16]
    1722:	cmp	r0, #0
    1724:	beq.n	1782 <MTPStorage_SD::OpenIndex()+0x126>
    1726:	ldr	r2, [r0, #0]
    1728:	ldr	r2, [r2, #68]	; 0x44
    172a:	cmp	r2, r3
    172c:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    1730:	ldr	r0, [r0, #16]
    1732:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    1734:	ldr	r2, [r0, #0]
    1736:	ldr	r2, [r2, #68]	; 0x44
    1738:	cmp	r2, r3
    173a:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    173e:	ldr	r0, [r0, #16]
    1740:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    1742:	ldr	r2, [r0, #0]
    1744:	ldr	r2, [r2, #68]	; 0x44
    1746:	cmp	r2, r3
    1748:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    174c:	ldr	r0, [r0, #16]
    174e:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    1750:	ldr	r2, [r0, #0]
    1752:	ldr	r2, [r2, #68]	; 0x44
    1754:	cmp	r2, r3
    1756:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    175a:	ldr	r0, [r0, #16]
    175c:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    175e:	ldr	r2, [r0, #0]
    1760:	ldr	r2, [r2, #68]	; 0x44
    1762:	cmp	r2, r3
    1764:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    1768:	ldr	r0, [r0, #16]
    176a:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    176c:	ldr	r2, [r0, #0]
    176e:	ldr	r2, [r2, #68]	; 0x44
    1770:	cmp	r2, r3
    1772:	bne.w	1996 <MTPStorage_SD::OpenIndex()+0x33a>
    1776:	ldr	r0, [r0, #16]
    1778:	cbz	r0, 1782 <MTPStorage_SD::OpenIndex()+0x126>
    177a:	ldr	r3, [r0, #0]
    177c:	ldr	r3, [r3, #68]	; 0x44
    177e:	blx	r3
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    1780:	cbnz	r0, 1790 <MTPStorage_SD::OpenIndex()+0x134>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1782:	movs	r1, #22
    1784:	ldr	r0, [pc, #268]	; (1894 <MTPStorage_SD::OpenIndex()+0x238>)
    1786:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    178a:	ldr	r0, [pc, #268]	; (1898 <MTPStorage_SD::OpenIndex()+0x23c>)
    178c:	bl	e960 <Print::println()>
    mtp_lock_storage(false);
  }
    1790:	add	sp, #28
    1792:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1796:	ldr	r5, [sp, #20]
    1798:	cmp	r5, #0
    179a:	beq.n	16fc <MTPStorage_SD::OpenIndex()+0xa0>
    179c:	ldr	r2, [r5, #0]
    179e:	ldr	r3, [pc, #252]	; (189c <MTPStorage_SD::OpenIndex()+0x240>)
    17a0:	ldr	r2, [r2, #32]
    17a2:	cmp	r2, r3
    17a4:	bne.w	19b0 <MTPStorage_SD::OpenIndex()+0x354>
    17a8:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    17aa:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    17ac:	cmp	r0, #0
    17ae:	beq.n	187e <MTPStorage_SD::OpenIndex()+0x222>
    17b0:	ldr	r2, [r0, #16]
    17b2:	subs	r2, #1
    17b4:	str	r2, [r0, #16]
    17b6:	cmp	r2, #0
    17b8:	bne.n	187e <MTPStorage_SD::OpenIndex()+0x222>
    17ba:	ldr	r6, [r5, #16]
    17bc:	cmp	r6, #0
    17be:	beq.n	187e <MTPStorage_SD::OpenIndex()+0x222>
    17c0:	ldr	r2, [r6, #0]
    17c2:	ldr	r2, [r2, #32]
    17c4:	cmp	r2, r3
    17c6:	bne.w	19b6 <MTPStorage_SD::OpenIndex()+0x35a>
    17ca:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    17cc:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    17ce:	cmp	r0, #0
    17d0:	beq.n	1876 <MTPStorage_SD::OpenIndex()+0x21a>
    17d2:	ldr	r2, [r0, #16]
    17d4:	subs	r2, #1
    17d6:	str	r2, [r0, #16]
    17d8:	cmp	r2, #0
    17da:	bne.n	1876 <MTPStorage_SD::OpenIndex()+0x21a>
    17dc:	ldr	r7, [r6, #16]
    17de:	cmp	r7, #0
    17e0:	beq.n	1876 <MTPStorage_SD::OpenIndex()+0x21a>
    17e2:	ldr	r2, [r7, #0]
    17e4:	ldr	r2, [r2, #32]
    17e6:	cmp	r2, r3
    17e8:	bne.w	19c8 <MTPStorage_SD::OpenIndex()+0x36c>
    17ec:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    17ee:	str	r1, [r7, #0]
    17f0:	ldr.w	lr, [pc, #156]	; 1890 <MTPStorage_SD::OpenIndex()+0x234>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    17f4:	cmp	r0, #0
    17f6:	beq.n	186e <MTPStorage_SD::OpenIndex()+0x212>
    17f8:	ldr	r2, [r0, #16]
    17fa:	subs	r2, #1
    17fc:	str	r2, [r0, #16]
    17fe:	cmp	r2, #0
    1800:	bne.n	186e <MTPStorage_SD::OpenIndex()+0x212>
    1802:	ldr.w	r8, [r7, #16]
    1806:	cmp.w	r8, #0
    180a:	beq.n	186e <MTPStorage_SD::OpenIndex()+0x212>
    180c:	ldr.w	r2, [r8]
    1810:	ldr	r2, [r2, #32]
    1812:	cmp	r2, r3
    1814:	bne.w	19d4 <MTPStorage_SD::OpenIndex()+0x378>
    1818:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    181c:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1820:	cbz	r0, 1866 <MTPStorage_SD::OpenIndex()+0x20a>
    1822:	ldr	r2, [r0, #16]
    1824:	subs	r2, #1
    1826:	str	r2, [r0, #16]
    1828:	cbnz	r2, 1866 <MTPStorage_SD::OpenIndex()+0x20a>
    182a:	ldr.w	r9, [r8, #16]
    182e:	cmp.w	r9, #0
    1832:	beq.n	1866 <MTPStorage_SD::OpenIndex()+0x20a>
    1834:	ldr.w	r2, [r9]
    1838:	ldr	r2, [r2, #32]
    183a:	cmp	r2, r3
    183c:	bne.w	19e0 <MTPStorage_SD::OpenIndex()+0x384>
    1840:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    1844:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1848:	cbz	r2, 185e <MTPStorage_SD::OpenIndex()+0x202>
    184a:	ldr	r3, [r2, #16]
    184c:	subs	r3, #1
    184e:	str	r3, [r2, #16]
    1850:	cbnz	r3, 185e <MTPStorage_SD::OpenIndex()+0x202>
    1852:	ldr.w	r0, [r9, #16]
    1856:	cbz	r0, 185e <MTPStorage_SD::OpenIndex()+0x202>
    1858:	ldr	r3, [r0, #0]
    185a:	ldr	r3, [r3, #32]
    185c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    185e:	mov	r0, r9
    1860:	movs	r1, #20
    1862:	bl	ea80 <operator delete(void*, unsigned int)>
    1866:	mov	r0, r8
    1868:	movs	r1, #20
    186a:	bl	ea80 <operator delete(void*, unsigned int)>
    186e:	mov	r0, r7
    1870:	movs	r1, #20
    1872:	bl	ea80 <operator delete(void*, unsigned int)>
    1876:	mov	r0, r6
    1878:	movs	r1, #20
    187a:	bl	ea80 <operator delete(void*, unsigned int)>
    187e:	mov	r0, r5
    1880:	movs	r1, #20
    1882:	bl	ea80 <operator delete(void*, unsigned int)>
    1886:	b.n	16fc <MTPStorage_SD::OpenIndex()+0xa0>
    1888:	.word	0x0000011d
    188c:	.word	0x200002d4
    1890:	.word	0x20000074
    1894:	.word	0x200002e4
    1898:	.word	0x20000cdc
    189c:	.word	0x00000acd
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18a0:	ldr.w	r5, [r4, #184]	; 0xb8
    18a4:	cmp	r5, #0
    18a6:	beq.w	16dc <MTPStorage_SD::OpenIndex()+0x80>
    18aa:	ldr	r2, [r5, #0]
    18ac:	ldr	r3, [pc, #312]	; (19e8 <MTPStorage_SD::OpenIndex()+0x38c>)
    18ae:	ldr	r2, [r2, #32]
    18b0:	cmp	r2, r3
    18b2:	bne.n	19aa <MTPStorage_SD::OpenIndex()+0x34e>
    18b4:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    18b6:	ldr	r1, [pc, #308]	; (19ec <MTPStorage_SD::OpenIndex()+0x390>)
    18b8:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18ba:	cmp	r0, #0
    18bc:	beq.n	1982 <MTPStorage_SD::OpenIndex()+0x326>
    18be:	ldr	r2, [r0, #16]
    18c0:	subs	r2, #1
    18c2:	str	r2, [r0, #16]
    18c4:	cmp	r2, #0
    18c6:	bne.n	1982 <MTPStorage_SD::OpenIndex()+0x326>
    18c8:	ldr	r6, [r5, #16]
    18ca:	cmp	r6, #0
    18cc:	beq.n	1982 <MTPStorage_SD::OpenIndex()+0x326>
    18ce:	ldr	r2, [r6, #0]
    18d0:	ldr	r2, [r2, #32]
    18d2:	cmp	r2, r3
    18d4:	bne.n	19bc <MTPStorage_SD::OpenIndex()+0x360>
    18d6:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    18d8:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18da:	cmp	r0, #0
    18dc:	beq.n	197a <MTPStorage_SD::OpenIndex()+0x31e>
    18de:	ldr	r2, [r0, #16]
    18e0:	subs	r2, #1
    18e2:	str	r2, [r0, #16]
    18e4:	cmp	r2, #0
    18e6:	bne.n	197a <MTPStorage_SD::OpenIndex()+0x31e>
    18e8:	ldr	r7, [r6, #16]
    18ea:	cmp	r7, #0
    18ec:	beq.n	197a <MTPStorage_SD::OpenIndex()+0x31e>
    18ee:	ldr	r2, [r7, #0]
    18f0:	ldr	r2, [r2, #32]
    18f2:	cmp	r2, r3
    18f4:	bne.n	19c2 <MTPStorage_SD::OpenIndex()+0x366>
    18f6:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    18f8:	str	r1, [r7, #0]
    18fa:	ldr.w	lr, [pc, #240]	; 19ec <MTPStorage_SD::OpenIndex()+0x390>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18fe:	cmp	r0, #0
    1900:	beq.n	1972 <MTPStorage_SD::OpenIndex()+0x316>
    1902:	ldr	r2, [r0, #16]
    1904:	subs	r2, #1
    1906:	str	r2, [r0, #16]
    1908:	cbnz	r2, 1972 <MTPStorage_SD::OpenIndex()+0x316>
    190a:	ldr.w	r8, [r7, #16]
    190e:	cmp.w	r8, #0
    1912:	beq.n	1972 <MTPStorage_SD::OpenIndex()+0x316>
    1914:	ldr.w	r2, [r8]
    1918:	ldr	r2, [r2, #32]
    191a:	cmp	r2, r3
    191c:	bne.n	19ce <MTPStorage_SD::OpenIndex()+0x372>
    191e:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    1922:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1926:	cbz	r0, 196a <MTPStorage_SD::OpenIndex()+0x30e>
    1928:	ldr	r2, [r0, #16]
    192a:	subs	r2, #1
    192c:	str	r2, [r0, #16]
    192e:	cbnz	r2, 196a <MTPStorage_SD::OpenIndex()+0x30e>
    1930:	ldr.w	r9, [r8, #16]
    1934:	cmp.w	r9, #0
    1938:	beq.n	196a <MTPStorage_SD::OpenIndex()+0x30e>
    193a:	ldr.w	r2, [r9]
    193e:	ldr	r2, [r2, #32]
    1940:	cmp	r2, r3
    1942:	bne.n	19da <MTPStorage_SD::OpenIndex()+0x37e>
    1944:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    1948:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    194c:	cbz	r2, 1962 <MTPStorage_SD::OpenIndex()+0x306>
    194e:	ldr	r3, [r2, #16]
    1950:	subs	r3, #1
    1952:	str	r3, [r2, #16]
    1954:	cbnz	r3, 1962 <MTPStorage_SD::OpenIndex()+0x306>
    1956:	ldr.w	r0, [r9, #16]
    195a:	cbz	r0, 1962 <MTPStorage_SD::OpenIndex()+0x306>
    195c:	ldr	r3, [r0, #0]
    195e:	ldr	r3, [r3, #32]
    1960:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    1962:	mov	r0, r9
    1964:	movs	r1, #20
    1966:	bl	ea80 <operator delete(void*, unsigned int)>
    196a:	mov	r0, r8
    196c:	movs	r1, #20
    196e:	bl	ea80 <operator delete(void*, unsigned int)>
    1972:	mov	r0, r7
    1974:	movs	r1, #20
    1976:	bl	ea80 <operator delete(void*, unsigned int)>
    197a:	mov	r0, r6
    197c:	movs	r1, #20
    197e:	bl	ea80 <operator delete(void*, unsigned int)>
    1982:	mov	r0, r5
    1984:	movs	r1, #20
    1986:	bl	ea80 <operator delete(void*, unsigned int)>
    198a:	b.n	16dc <MTPStorage_SD::OpenIndex()+0x80>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    198c:	blx	r3
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    198e:	cmp	r0, #0
    1990:	bne.w	1790 <MTPStorage_SD::OpenIndex()+0x134>
    1994:	b.n	16bc <MTPStorage_SD::OpenIndex()+0x60>
    1996:	blx	r2
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    1998:	cmp	r0, #0
    199a:	bne.w	1790 <MTPStorage_SD::OpenIndex()+0x134>
    199e:	b.n	1782 <MTPStorage_SD::OpenIndex()+0x126>
    19a0:	blx	r2
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    19a2:	cmp	r0, #0
    19a4:	bne.w	1790 <MTPStorage_SD::OpenIndex()+0x134>
    19a8:	b.n	16bc <MTPStorage_SD::OpenIndex()+0x60>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    19aa:	mov	r0, r5
    19ac:	blx	r2
    19ae:	b.n	16dc <MTPStorage_SD::OpenIndex()+0x80>
    19b0:	mov	r0, r5
    19b2:	blx	r2
    19b4:	b.n	16fc <MTPStorage_SD::OpenIndex()+0xa0>
    19b6:	mov	r0, r6
    19b8:	blx	r2
    19ba:	b.n	187e <MTPStorage_SD::OpenIndex()+0x222>
    19bc:	mov	r0, r6
    19be:	blx	r2
    19c0:	b.n	1982 <MTPStorage_SD::OpenIndex()+0x326>
    19c2:	mov	r0, r7
    19c4:	blx	r2
    19c6:	b.n	197a <MTPStorage_SD::OpenIndex()+0x31e>
    19c8:	mov	r0, r7
    19ca:	blx	r2
    19cc:	b.n	1876 <MTPStorage_SD::OpenIndex()+0x21a>
    19ce:	mov	r0, r8
    19d0:	blx	r2
    19d2:	b.n	1972 <MTPStorage_SD::OpenIndex()+0x316>
    19d4:	mov	r0, r8
    19d6:	blx	r2
    19d8:	b.n	186e <MTPStorage_SD::OpenIndex()+0x212>
    19da:	mov	r0, r9
    19dc:	blx	r2
    19de:	b.n	196a <MTPStorage_SD::OpenIndex()+0x30e>
    19e0:	mov	r0, r9
    19e2:	blx	r2
    19e4:	b.n	1866 <MTPStorage_SD::OpenIndex()+0x20a>
    19e6:	nop
    19e8:	.word	0x00000acd
    19ec:	.word	0x20000074

000019f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>:
    all_scanned_ = false;
    open_file_ = 0xFFFFFFFEUL;
  }

  void MTPStorage_SD::WriteIndexRecord(uint32_t i, const Record& r) 
  { OpenIndex();
    19f0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    19f4:	mov	r6, r0
    19f6:	sub	sp, #12
    19f8:	mov	r4, r1
    19fa:	mov	r7, r2
    19fc:	bl	165c <MTPStorage_SD::OpenIndex()>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    1a00:	ldr.w	r5, [r6, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek((sizeof(r) * i));
    1a04:	add.w	r4, r4, r4, lsl #4
    1a08:	cmp	r5, #0
    1a0a:	beq.n	1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1a0c:	ldr	r0, [r5, #0]
    1a0e:	ldr	r1, [pc, #308]	; (1b44 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x154>)
    1a10:	lsls	r2, r4, #4
    1a12:	ldr	r4, [r0, #52]	; 0x34
    1a14:	cmp	r4, r1
    1a16:	mov.w	ip, #0
    1a1a:	bne.n	1b0a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x11a>
    1a1c:	ldr	r1, [r5, #16]
    1a1e:	cmp	r1, #0
    1a20:	beq.n	1ada <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xea>
    1a22:	ldr	r3, [r1, #0]
    1a24:	ldr.w	r8, [r3, #52]	; 0x34
    1a28:	cmp	r8, r4
    1a2a:	bne.n	1b16 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x126>
    1a2c:	ldr.w	lr, [r1, #16]
    1a30:	cmp.w	lr, #0
    1a34:	beq.n	1ae8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    1a36:	ldr.w	r4, [lr]
    1a3a:	ldr	r4, [r4, #52]	; 0x34
    1a3c:	cmp	r4, r8
    1a3e:	bne.n	1b22 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x132>
    1a40:	ldr.w	lr, [lr, #16]
    1a44:	cmp.w	lr, #0
    1a48:	beq.n	1ae8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    1a4a:	ldr.w	r3, [lr]
    1a4e:	ldr.w	r8, [r3, #52]	; 0x34
    1a52:	cmp	r8, r4
    1a54:	bne.n	1b2e <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x13e>
    1a56:	ldr.w	r4, [lr, #16]
    1a5a:	cmp	r4, #0
    1a5c:	beq.n	1ae8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    1a5e:	ldr	r3, [r4, #0]
    1a60:	ldr.w	r9, [r3, #52]	; 0x34
    1a64:	cmp	r9, r8
    1a66:	bne.n	1b3a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x14a>
    1a68:	ldr	r4, [r4, #16]
    1a6a:	cmp	r4, #0
    1a6c:	beq.n	1ae8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    1a6e:	ldr	r1, [r4, #0]
    1a70:	str.w	ip, [sp]
    1a74:	mov	r3, ip
    1a76:	mov	r0, r4
    1a78:	ldr	r1, [r1, #52]	; 0x34
    1a7a:	blx	r1
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1a7c:	ldr.w	r5, [r6, #184]	; 0xb8
    1a80:	cmp	r5, #0
    1a82:	beq.n	1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1a84:	ldr	r2, [r5, #0]
    1a86:	ldr	r3, [pc, #192]	; (1b48 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    1a88:	ldr	r4, [r2, #44]	; 0x2c
    1a8a:	cmp	r4, r3
    1a8c:	bne.n	1af4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    1a8e:	ldr	r0, [r5, #16]
    1a90:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1a92:	ldr	r2, [r0, #0]
    1a94:	ldr	r4, [r2, #44]	; 0x2c
    1a96:	cmp	r4, r3
    1a98:	bne.n	1b06 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    1a9a:	ldr	r0, [r0, #16]
    1a9c:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1a9e:	ldr	r2, [r0, #0]
    1aa0:	ldr	r4, [r2, #44]	; 0x2c
    1aa2:	cmp	r4, r3
    1aa4:	bne.n	1b06 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    1aa6:	ldr	r0, [r0, #16]
    1aa8:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1aaa:	ldr	r2, [r0, #0]
    1aac:	ldr	r4, [r2, #44]	; 0x2c
    1aae:	cmp	r4, r3
    1ab0:	bne.n	1b06 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    1ab2:	ldr	r0, [r0, #16]
    1ab4:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1ab6:	ldr	r2, [r0, #0]
    1ab8:	ldr	r4, [r2, #44]	; 0x2c
    1aba:	cmp	r4, r3
    1abc:	bne.n	1b06 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    1abe:	ldr	r0, [r0, #16]
    1ac0:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1ac2:	ldr	r2, [r0, #0]
    1ac4:	ldr	r4, [r2, #44]	; 0x2c
    1ac6:	cmp	r4, r3
    1ac8:	bne.n	1b06 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    1aca:	ldr	r0, [r0, #16]
    1acc:	cbz	r0, 1ae2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    1ace:	ldr	r3, [r0, #0]
    1ad0:	mov	r1, r7
    1ad2:	ldr	r3, [r3, #44]	; 0x2c
    1ad4:	mov.w	r2, #272	; 0x110
    1ad8:	b.n	1afe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x10e>
    1ada:	ldr	r4, [r0, #44]	; 0x2c
    1adc:	ldr	r3, [pc, #104]	; (1b48 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    1ade:	cmp	r4, r3
    1ae0:	bne.n	1af4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }
    1ae2:	add	sp, #12
    1ae4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1ae8:	ldr	r4, [r0, #44]	; 0x2c
    1aea:	ldr	r3, [pc, #92]	; (1b48 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    1aec:	cmp	r4, r3
    1aee:	bne.n	1af4 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    1af0:	mov	r0, r1
    1af2:	b.n	1a92 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xa2>
    1af4:	mov	r1, r7
    1af6:	mov	r0, r5
    1af8:	mov.w	r2, #272	; 0x110
    1afc:	mov	r3, r4
    1afe:	add	sp, #12
    1b00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1b04:	bx	r3
    1b06:	mov	r1, r7
    1b08:	b.n	1af8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x108>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    1b0a:	str.w	ip, [sp]
    1b0e:	mov	r3, ip
    1b10:	mov	r0, r5
    1b12:	blx	r4
    1b14:	b.n	1a7c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    1b16:	str.w	ip, [sp]
    1b1a:	mov	r3, ip
    1b1c:	mov	r0, r1
    1b1e:	blx	r8
    1b20:	b.n	1a7c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    1b22:	str.w	ip, [sp]
    1b26:	mov	r3, ip
    1b28:	mov	r0, lr
    1b2a:	blx	r4
    1b2c:	b.n	1a7c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    1b2e:	str.w	ip, [sp]
    1b32:	mov	r3, ip
    1b34:	mov	r0, lr
    1b36:	blx	r8
    1b38:	b.n	1a7c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    1b3a:	movs	r3, #0
    1b3c:	mov	r0, r4
    1b3e:	str	r3, [sp, #0]
    1b40:	blx	r9
    1b42:	b.n	1a7c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    1b44:	.word	0x000000d9
    1b48:	.word	0x00000099

00001b4c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>:
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    1b4c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  { if (index_generated) return; 
    index_generated = true;
    1b50:	movs	r7, #1
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    1b52:	mov	r4, r0
    1b54:	sub	sp, #272	; 0x110
    1b56:	movs	r1, #13
  { if (index_generated) return; 
    index_generated = true;
    1b58:	strb.w	r7, [r0, #248]	; 0xf8
    1b5c:	ldr	r0, [pc, #104]	; (1bc8 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    1b5e:	bl	d248 <usb_serial_write>
    1b62:	ldr	r0, [pc, #104]	; (1bcc <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x80>)
    1b64:	bl	e960 <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    1b68:	ldr	r0, [r4, #88]	; 0x58
    1b6a:	ldr	r1, [pc, #92]	; (1bc8 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    1b6c:	ldr	r3, [r0, #0]
    1b6e:	ldr	r3, [r3, #16]
    1b70:	blx	r3
    1b72:	ldr	r3, [r4, #4]
    // first remove old index file
    mtp_lock_storage(true);
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();
    1b74:	str.w	r3, [r4, #228]	; 0xe4

    index_entries_ = 0;
    1b78:	movs	r1, #0
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    1b7a:	cmp	r3, r1
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    1b7c:	str.w	r1, [r4, #244]	; 0xf4
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    1b80:	ble.n	1bc2 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x76>
    1b82:	mov	r5, r1
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
    1b84:	mov	r6, r1
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    1b86:	mov.w	r8, #4294967295
    1b8a:	b.n	1b90 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x44>
    1b8c:	ldr.w	r1, [r4, #244]	; 0xf4

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
    1b90:	strh.w	r5, [sp, #14]
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    1b94:	adds	r3, r1, #1
    1b96:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    1b9a:	mov	r2, sp
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    1b9c:	movs	r3, #47	; 0x2f
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    1b9e:	mov	r0, r4
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    1ba0:	strh.w	r3, [sp, #16]
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    1ba4:	str.w	r8, [sp]
      r.sibling = 0;
    1ba8:	str	r6, [sp, #8]
      r.child = 0;
    1baa:	str	r6, [sp, #4]
      r.isdir = true;
    1bac:	strb.w	r7, [sp, #12]
      r.scanned = false;
    1bb0:	strb.w	r6, [sp, #13]
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    1bb4:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    1bb8:	ldr.w	r3, [r4, #228]	; 0xe4
    1bbc:	adds	r5, #1
    1bbe:	cmp	r3, r5
    1bc0:	bgt.n	1b8c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x40>
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
      AppendIndexRecord(r);
    }
  }
    1bc2:	add	sp, #272	; 0x110
    1bc4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1bc8:	.word	0x200002d4
    1bcc:	.word	0x20000cdc

00001bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>:
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    1bd0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1bd4:	mov	r5, r1
    1bd6:	mov	r4, r2
    1bd8:	sub	sp, #8
    Record ret;
    memset(&ret, 0, sizeof(ret));
    1bda:	movs	r1, #0
    1bdc:	mov.w	r2, #272	; 0x110
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    1be0:	mov	r6, r0
    Record ret;
    memset(&ret, 0, sizeof(ret));
    1be2:	bl	1001c <memset>
    if (i > index_entries_) 
    1be6:	ldr.w	r3, [r5, #244]	; 0xf4
    1bea:	cmp	r3, r4
    1bec:	bcc.w	1d66 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x196>
    { memset(&ret, 0, sizeof(ret));
      return ret;
    }
    OpenIndex();
    1bf0:	mov	r0, r5
    1bf2:	bl	165c <MTPStorage_SD::OpenIndex()>
    1bf6:	ldr.w	r0, [r5, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    1bfa:	add.w	r4, r4, r4, lsl #4
    1bfe:	lsls	r2, r4, #4
    1c00:	mov.w	ip, #0
    1c04:	cmp	r0, #0
    1c06:	beq.w	1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1c0a:	ldr	r7, [r0, #0]
    1c0c:	ldr	r4, [pc, #456]	; (1dd8 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x208>)
    1c0e:	ldr	r1, [r7, #52]	; 0x34
    1c10:	cmp	r1, r4
    1c12:	bne.w	1d92 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1c2>
    1c16:	ldr	r1, [r0, #16]
    1c18:	cmp	r1, #0
    1c1a:	beq.w	1d7a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1aa>
    1c1e:	ldr	r3, [r1, #0]
    1c20:	ldr.w	r8, [r3, #52]	; 0x34
    1c24:	cmp	r8, r4
    1c26:	bne.w	1dc0 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1f0>
    1c2a:	ldr.w	lr, [r1, #16]
    1c2e:	cmp.w	lr, #0
    1c32:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1c34:	ldr.w	r3, [lr]
    1c38:	ldr.w	r8, [r3, #52]	; 0x34
    1c3c:	cmp	r8, r4
    1c3e:	bne.w	1db4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    1c42:	ldr.w	lr, [lr, #16]
    1c46:	cmp.w	lr, #0
    1c4a:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1c4c:	ldr.w	r3, [lr]
    1c50:	ldr.w	r8, [r3, #52]	; 0x34
    1c54:	cmp	r8, r4
    1c56:	bne.w	1db4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    1c5a:	ldr.w	lr, [lr, #16]
    1c5e:	cmp.w	lr, #0
    1c62:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1c64:	ldr.w	r3, [lr]
    1c68:	ldr.w	r8, [r3, #52]	; 0x34
    1c6c:	cmp	r8, r4
    1c6e:	bne.w	1dcc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    1c72:	ldr.w	lr, [lr, #16]
    1c76:	cmp.w	lr, #0
    1c7a:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1c7c:	ldr.w	r3, [lr]
    1c80:	ldr.w	r8, [r3, #52]	; 0x34
    1c84:	cmp	r8, r4
    1c86:	bne.w	1dcc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    1c8a:	ldr.w	lr, [lr, #16]
    1c8e:	cmp.w	lr, #0
    1c92:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1c94:	ldr.w	r3, [lr]
    1c98:	ldr.w	r8, [r3, #52]	; 0x34
    1c9c:	cmp	r8, r4
    1c9e:	bne.w	1dcc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    1ca2:	ldr.w	lr, [lr, #16]
    1ca6:	cmp.w	lr, #0
    1caa:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1cac:	ldr.w	r3, [lr]
    1cb0:	ldr.w	r8, [r3, #52]	; 0x34
    1cb4:	cmp	r8, r4
    1cb6:	bne.w	1dcc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    1cba:	ldr.w	lr, [lr, #16]
    1cbe:	cmp.w	lr, #0
    1cc2:	beq.n	1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1cc4:	ldr.w	r3, [lr]
    1cc8:	ldr.w	r8, [r3, #52]	; 0x34
    1ccc:	cmp	r8, r4
    1cce:	bne.n	1dcc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    1cd0:	ldr.w	r4, [lr, #16]
    1cd4:	cbz	r4, 1ce6 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    1cd6:	ldr	r1, [r4, #0]
    1cd8:	str.w	ip, [sp]
    1cdc:	mov	r3, ip
    1cde:	mov	r0, r4
    1ce0:	ldr	r1, [r1, #52]	; 0x34
    1ce2:	blx	r1
    1ce4:	b.n	1d9a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    1ce6:	ldr	r4, [r7, #40]	; 0x28
    1ce8:	ldr	r3, [pc, #240]	; (1ddc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    1cea:	cmp	r4, r3
    1cec:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1cee:	mov	r0, r1
    1cf0:	ldr	r2, [r0, #0]
    1cf2:	ldr	r4, [r2, #40]	; 0x28
    1cf4:	cmp	r4, r3
    1cf6:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1cf8:	ldr	r0, [r0, #16]
    1cfa:	cmp	r0, #0
    1cfc:	beq.n	1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1cfe:	ldr	r2, [r0, #0]
    1d00:	ldr	r4, [r2, #40]	; 0x28
    1d02:	cmp	r4, r3
    1d04:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d06:	ldr	r0, [r0, #16]
    1d08:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d0a:	ldr	r2, [r0, #0]
    1d0c:	ldr	r4, [r2, #40]	; 0x28
    1d0e:	cmp	r4, r3
    1d10:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d12:	ldr	r0, [r0, #16]
    1d14:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d16:	ldr	r2, [r0, #0]
    1d18:	ldr	r4, [r2, #40]	; 0x28
    1d1a:	cmp	r4, r3
    1d1c:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d1e:	ldr	r0, [r0, #16]
    1d20:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d22:	ldr	r2, [r0, #0]
    1d24:	ldr	r4, [r2, #40]	; 0x28
    1d26:	cmp	r4, r3
    1d28:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d2a:	ldr	r0, [r0, #16]
    1d2c:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d2e:	ldr	r2, [r0, #0]
    1d30:	ldr	r4, [r2, #40]	; 0x28
    1d32:	cmp	r4, r3
    1d34:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d36:	ldr	r0, [r0, #16]
    1d38:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d3a:	ldr	r2, [r0, #0]
    1d3c:	ldr	r4, [r2, #40]	; 0x28
    1d3e:	cmp	r4, r3
    1d40:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d42:	ldr	r0, [r0, #16]
    1d44:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d46:	ldr	r2, [r0, #0]
    1d48:	ldr	r4, [r2, #40]	; 0x28
    1d4a:	cmp	r4, r3
    1d4c:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1d4e:	ldr	r0, [r0, #16]
    1d50:	cbz	r0, 1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d52:	ldr	r3, [r0, #0]
    1d54:	mov.w	r2, #272	; 0x110
    1d58:	ldr	r3, [r3, #40]	; 0x28
    1d5a:	mov	r1, r6
    1d5c:	blx	r3
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    1d5e:	mov	r0, r6
    1d60:	add	sp, #8
    1d62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    Record ret;
    memset(&ret, 0, sizeof(ret));
    if (i > index_entries_) 
    { memset(&ret, 0, sizeof(ret));
    1d66:	mov.w	r2, #272	; 0x110
    1d6a:	movs	r1, #0
    1d6c:	mov	r0, r6
    1d6e:	bl	1001c <memset>
    index_.seek(sizeof(ret) * i);
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    1d72:	mov	r0, r6
    1d74:	add	sp, #8
    1d76:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1d7a:	ldr	r4, [r7, #40]	; 0x28
    1d7c:	ldr	r3, [pc, #92]	; (1ddc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    1d7e:	cmp	r4, r3
    1d80:	beq.n	1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1d82:	mov.w	r2, #272	; 0x110
    1d86:	mov	r1, r6
    1d88:	blx	r4
    1d8a:	mov	r0, r6
    1d8c:	add	sp, #8
    1d8e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    1d92:	str.w	ip, [sp]
    1d96:	mov	r3, ip
    1d98:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    1d9a:	ldr.w	r0, [r5, #184]	; 0xb8
    1d9e:	cmp	r0, #0
    1da0:	beq.n	1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    1da2:	ldr	r2, [r0, #0]
    1da4:	ldr	r3, [pc, #52]	; (1ddc <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    1da6:	ldr	r4, [r2, #40]	; 0x28
    1da8:	cmp	r4, r3
    1daa:	bne.n	1d82 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    1dac:	ldr	r0, [r0, #16]
    1dae:	cmp	r0, #0
    1db0:	bne.n	1cf0 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x120>
    1db2:	b.n	1d5e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    1db4:	str.w	ip, [sp]
    1db8:	mov	r3, ip
    1dba:	mov	r0, lr
    1dbc:	blx	r8
    1dbe:	b.n	1d9a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    1dc0:	str.w	ip, [sp]
    1dc4:	mov	r3, ip
    1dc6:	mov	r0, r1
    1dc8:	blx	r8
    1dca:	b.n	1d9a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    1dcc:	movs	r3, #0
    1dce:	mov	r0, lr
    1dd0:	str	r3, [sp, #0]
    1dd2:	blx	r8
    1dd4:	b.n	1d9a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    1dd6:	nop
    1dd8:	.word	0x000000d9
    1ddc:	.word	0x0000008d

00001de0 <MTPStorage_SD::GetNextObjectHandle(unsigned long)>:
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    1de0:	push	{r4, r5, lr}
    while (true) 
    { if (next_ == 0) return 0;
    1de2:	ldr.w	r5, [r0, #252]	; 0xfc
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    1de6:	sub	sp, #276	; 0x114
    1de8:	mov	r4, r0
    while (true) 
    { if (next_ == 0) return 0;
    1dea:	cbnz	r5, 1e00 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x20>
    1dec:	b.n	1e36 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
    1dee:	ldr	r3, [sp, #8]
    1df0:	str.w	r3, [r4, #252]	; 0xfc
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    1df4:	ldrb.w	r3, [sp, #16]
    1df8:	cbnz	r3, 1e30 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x50>
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    1dfa:	ldr.w	r5, [r4, #252]	; 0xfc
    1dfe:	cbz	r5, 1e36 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
    1e00:	mov	r2, r5
    1e02:	mov	r1, r4
    1e04:	mov	r0, sp
    1e06:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      if (follow_sibling_) 
    1e0a:	ldrb.w	r2, [r4, #256]	; 0x100
    1e0e:	cmp	r2, #0
    1e10:	bne.n	1dee <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0xe>
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    1e12:	ldr.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    1e16:	ldr.w	r1, [r4, #244]	; 0xf4
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    1e1a:	adds	r3, #1
    1e1c:	str.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    1e20:	cmp	r3, r1
      }
      if (r.name[0]) return ret;
    1e22:	ldrb.w	r3, [sp, #16]
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
    1e26:	it	cs
    1e28:	strcs.w	r2, [r4, #252]	; 0xfc
      }
      if (r.name[0]) return ret;
    1e2c:	cmp	r3, #0
    1e2e:	beq.n	1dfa <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x1a>
    }
  }
    1e30:	mov	r0, r5
    1e32:	add	sp, #276	; 0x114
    1e34:	pop	{r4, r5, pc}
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    1e36:	movs	r5, #0
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    }
  }
    1e38:	mov	r0, r5
    1e3a:	add	sp, #276	; 0x114
    1e3c:	pop	{r4, r5, pc}
    1e3e:	nop

00001e40 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)>:

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    1e40:	push	{r4, r5, r6, r7, lr}
    1e42:	sub	sp, #276	; 0x114
    1e44:	mov	r7, r2
    Record r = ReadIndexRecord(handle);
    1e46:	mov	r2, r1
    1e48:	mov	r1, r0
    1e4a:	mov	r0, sp
      if (r.name[0]) return ret;
    }
  }

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    1e4c:	mov	r5, r3
    1e4e:	ldr	r6, [sp, #296]	; 0x128
    1e50:	ldr	r4, [sp, #300]	; 0x12c
    Record r = ReadIndexRecord(handle);
    1e52:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(name, r.name);
    1e56:	mov	r0, r7
    1e58:	add	r1, sp, #16
    1e5a:	bl	10510 <strcpy>
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    1e5e:	ldrb.w	r3, [sp, #12]

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    1e62:	ldr	r2, [sp, #0]
    1e64:	str	r2, [r6, #0]
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    1e66:	cbnz	r3, 1e76 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x36>
    1e68:	ldr	r3, [sp, #4]
    *store = r.store;
    1e6a:	ldrh.w	r2, [sp, #14]
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    1e6e:	str	r3, [r5, #0]
    *store = r.store;
    1e70:	strh	r2, [r4, #0]
  }
    1e72:	add	sp, #276	; 0x114
    1e74:	pop	{r4, r5, r6, r7, pc}
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    1e76:	mov.w	r3, #4294967295
    1e7a:	b.n	1e6a <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x2a>

00001e7c <MTPStorage_SD::GetSize(unsigned long)>:
    *store = r.store;
  }

  uint32_t MTPStorage_SD::GetSize(uint32_t handle) 
  {
    1e7c:	push	{lr}
    1e7e:	sub	sp, #276	; 0x114
    return ReadIndexRecord(handle).child;
    1e80:	mov	r2, r1
    1e82:	mov	r1, r0
    1e84:	mov	r0, sp
    1e86:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  }
    1e8a:	ldr	r0, [sp, #4]
    1e8c:	add	sp, #276	; 0x114
    1e8e:	ldr.w	pc, [sp], #4
    1e92:	nop

00001e94 <MTPStorage_SD::close()>:
      mtp_lock_storage(false);
      return ret;
  }

  void MTPStorage_SD::close() 
  {
    1e94:	push	{r4, r5, r6, lr}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    1e96:	ldr.w	r3, [r0, #204]	; 0xcc
    1e9a:	sub	sp, #272	; 0x110
    1e9c:	mov	r4, r0
    1e9e:	cmp	r3, #0
    1ea0:	beq.n	1f3c <MTPStorage_SD::close()+0xa8>
    1ea2:	ldr	r5, [r3, #0]
    1ea4:	ldr	r1, [pc, #384]	; (2028 <MTPStorage_SD::close()+0x194>)
    1ea6:	ldr	r2, [r5, #60]	; 0x3c
    1ea8:	cmp	r2, r1
    1eaa:	bne.w	201c <MTPStorage_SD::close()+0x188>
    1eae:	ldr	r2, [r3, #16]
    1eb0:	cmp	r2, #0
    1eb2:	beq.w	200c <MTPStorage_SD::close()+0x178>
    1eb6:	ldr	r0, [r2, #0]
    1eb8:	ldr	r6, [r0, #60]	; 0x3c
    1eba:	cmp	r6, r1
    1ebc:	bne.n	1f64 <MTPStorage_SD::close()+0xd0>
    1ebe:	ldr	r0, [r2, #16]
    1ec0:	cmp	r0, #0
    1ec2:	beq.n	1f2e <MTPStorage_SD::close()+0x9a>
    1ec4:	ldr	r6, [r0, #0]
    1ec6:	ldr	r6, [r6, #60]	; 0x3c
    1ec8:	cmp	r6, r1
    1eca:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1ecc:	ldr	r0, [r0, #16]
    1ece:	cmp	r0, #0
    1ed0:	beq.n	1f2e <MTPStorage_SD::close()+0x9a>
    1ed2:	ldr	r6, [r0, #0]
    1ed4:	ldr	r6, [r6, #60]	; 0x3c
    1ed6:	cmp	r6, r1
    1ed8:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1eda:	ldr	r0, [r0, #16]
    1edc:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1ede:	ldr	r6, [r0, #0]
    1ee0:	ldr	r6, [r6, #60]	; 0x3c
    1ee2:	cmp	r6, r1
    1ee4:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1ee6:	ldr	r0, [r0, #16]
    1ee8:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1eea:	ldr	r6, [r0, #0]
    1eec:	ldr	r6, [r6, #60]	; 0x3c
    1eee:	cmp	r6, r1
    1ef0:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1ef2:	ldr	r0, [r0, #16]
    1ef4:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1ef6:	ldr	r6, [r0, #0]
    1ef8:	ldr	r6, [r6, #60]	; 0x3c
    1efa:	cmp	r6, r1
    1efc:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1efe:	ldr	r0, [r0, #16]
    1f00:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1f02:	ldr	r6, [r0, #0]
    1f04:	ldr	r6, [r6, #60]	; 0x3c
    1f06:	cmp	r6, r1
    1f08:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1f0a:	ldr	r0, [r0, #16]
    1f0c:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1f0e:	ldr	r6, [r0, #0]
    1f10:	ldr	r6, [r6, #60]	; 0x3c
    1f12:	cmp	r6, r1
    1f14:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1f16:	ldr	r0, [r0, #16]
    1f18:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1f1a:	ldr	r6, [r0, #0]
    1f1c:	ldr	r6, [r6, #60]	; 0x3c
    1f1e:	cmp	r6, r1
    1f20:	bne.n	1f66 <MTPStorage_SD::close()+0xd2>
    1f22:	ldr	r0, [r0, #16]
    1f24:	cbz	r0, 1f2e <MTPStorage_SD::close()+0x9a>
    1f26:	ldr	r3, [r0, #0]
    1f28:	ldr	r3, [r3, #60]	; 0x3c
    1f2a:	blx	r3
    1f2c:	b.n	1f68 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    1f2e:	ldr	r6, [r5, #64]	; 0x40
    1f30:	ldr	r1, [pc, #248]	; (202c <MTPStorage_SD::close()+0x198>)
    1f32:	cmp	r6, r1
    1f34:	bne.n	2022 <MTPStorage_SD::close()+0x18e>
    1f36:	mov	r0, r2
    1f38:	movs	r5, #0
    1f3a:	b.n	1f82 <MTPStorage_SD::close()+0xee>
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    1f3c:	mov	r5, r3
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    1f3e:	mov	r0, sp
    1f40:	ldr.w	r2, [r4, #240]	; 0xf0
    1f44:	mov	r1, r4
    1f46:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    r.child = size;
    WriteIndexRecord(open_file_, r);
    1f4a:	mov	r2, sp
    1f4c:	ldr.w	r1, [r4, #240]	; 0xf0
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    r.child = size;
    1f50:	str	r5, [sp, #4]
    WriteIndexRecord(open_file_, r);
    1f52:	mov	r0, r4
    1f54:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    open_file_ = 0xFFFFFFFEUL;
    1f58:	mvn.w	r3, #1
    1f5c:	str.w	r3, [r4, #240]	; 0xf0
  }
    1f60:	add	sp, #272	; 0x110
    1f62:	pop	{r4, r5, r6, pc}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    1f64:	mov	r0, r2
    1f66:	blx	r6
	}
	virtual void close() {
		if (f) f->close();
    1f68:	ldr.w	r3, [r4, #204]	; 0xcc
  }

  void MTPStorage_SD::close() 
  {
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    1f6c:	mov	r5, r0
    1f6e:	cmp	r3, #0
    1f70:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1f72:	ldr	r2, [r3, #0]
    1f74:	ldr	r1, [pc, #180]	; (202c <MTPStorage_SD::close()+0x198>)
    1f76:	ldr	r6, [r2, #64]	; 0x40
    1f78:	cmp	r6, r1
    1f7a:	bne.n	2016 <MTPStorage_SD::close()+0x182>
    1f7c:	ldr	r0, [r3, #16]
    1f7e:	cmp	r0, #0
    1f80:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1f82:	ldr	r3, [r0, #0]
    1f84:	ldr	r3, [r3, #64]	; 0x40
    1f86:	cmp	r3, r1
    1f88:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1f8a:	ldr	r0, [r0, #16]
    1f8c:	cmp	r0, #0
    1f8e:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1f90:	ldr	r3, [r0, #0]
    1f92:	ldr	r3, [r3, #64]	; 0x40
    1f94:	cmp	r3, r1
    1f96:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1f98:	ldr	r0, [r0, #16]
    1f9a:	cmp	r0, #0
    1f9c:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1f9e:	ldr	r3, [r0, #0]
    1fa0:	ldr	r3, [r3, #64]	; 0x40
    1fa2:	cmp	r3, r1
    1fa4:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fa6:	ldr	r0, [r0, #16]
    1fa8:	cmp	r0, #0
    1faa:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1fac:	ldr	r3, [r0, #0]
    1fae:	ldr	r3, [r3, #64]	; 0x40
    1fb0:	cmp	r3, r1
    1fb2:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fb4:	ldr	r0, [r0, #16]
    1fb6:	cmp	r0, #0
    1fb8:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1fba:	ldr	r3, [r0, #0]
    1fbc:	ldr	r3, [r3, #64]	; 0x40
    1fbe:	cmp	r3, r1
    1fc0:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fc2:	ldr	r0, [r0, #16]
    1fc4:	cmp	r0, #0
    1fc6:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1fc8:	ldr	r3, [r0, #0]
    1fca:	ldr	r3, [r3, #64]	; 0x40
    1fcc:	cmp	r3, r1
    1fce:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fd0:	ldr	r0, [r0, #16]
    1fd2:	cmp	r0, #0
    1fd4:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1fd6:	ldr	r3, [r0, #0]
    1fd8:	ldr	r3, [r3, #64]	; 0x40
    1fda:	cmp	r3, r1
    1fdc:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fde:	ldr	r0, [r0, #16]
    1fe0:	cmp	r0, #0
    1fe2:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1fe4:	ldr	r3, [r0, #0]
    1fe6:	ldr	r3, [r3, #64]	; 0x40
    1fe8:	cmp	r3, r1
    1fea:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1fec:	ldr	r0, [r0, #16]
    1fee:	cmp	r0, #0
    1ff0:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    1ff2:	ldr	r3, [r0, #0]
    1ff4:	ldr	r3, [r3, #64]	; 0x40
    1ff6:	cmp	r3, r1
    1ff8:	bne.n	2008 <MTPStorage_SD::close()+0x174>
    1ffa:	ldr	r0, [r0, #16]
    1ffc:	cmp	r0, #0
    1ffe:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    2000:	ldr	r3, [r0, #0]
    2002:	ldr	r3, [r3, #64]	; 0x40
    2004:	blx	r3
    2006:	b.n	1f3e <MTPStorage_SD::close()+0xaa>
    2008:	blx	r3
    200a:	b.n	1f3e <MTPStorage_SD::close()+0xaa>
    200c:	ldr	r6, [r5, #64]	; 0x40
    200e:	ldr	r1, [pc, #28]	; (202c <MTPStorage_SD::close()+0x198>)
    2010:	cmp	r6, r1
    2012:	mov	r5, r2
    2014:	beq.n	1f3e <MTPStorage_SD::close()+0xaa>
    2016:	mov	r0, r3
    2018:	blx	r6
    201a:	b.n	1f3e <MTPStorage_SD::close()+0xaa>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    201c:	mov	r0, r3
    201e:	blx	r2
    2020:	b.n	1f68 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    2022:	movs	r5, #0
    2024:	b.n	2016 <MTPStorage_SD::close()+0x182>
    2026:	nop
    2028:	.word	0x00000101
    202c:	.word	0x00000111

00002030 <MTPStorage_SD::ConstructFilename(int, char*, int)>:

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    2030:	push	{r4, r5, r6, lr}
    2032:	mov	r6, r0
    2034:	sub	sp, #272	; 0x110
    2036:	mov	r4, r2
    Record tmp = ReadIndexRecord(i);
    2038:	mov	r0, sp
    203a:	mov	r2, r1
    203c:	mov	r1, r6

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    203e:	mov	r5, r3
    Record tmp = ReadIndexRecord(i);
    2040:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    2044:	ldr	r1, [sp, #0]
    2046:	adds	r3, r1, #1
    2048:	beq.n	2080 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x50>
    { strcpy(out, "/");
      return tmp.store;
    }
    else 
    { ConstructFilename(tmp.parent, out, len);
    204a:	mov	r3, r5
    204c:	mov	r2, r4
    204e:	mov	r0, r6
    2050:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
    2054:	mov	r0, r4
    2056:	bl	10680 <strlen>
    205a:	add	r0, r4
    205c:	ldrb.w	r3, [r0, #-1]
    2060:	cmp	r3, #47	; 0x2f
    2062:	beq.n	206e <MTPStorage_SD::ConstructFilename(int, char*, int)+0x3e>
    2064:	mov	r2, r5
    2066:	ldr	r1, [pc, #40]	; (2090 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
    2068:	mov	r0, r4
    206a:	bl	105cc <strlcat>
      strlcat(out, tmp.name,len);
    206e:	mov	r2, r5
    2070:	mov	r0, r4
    2072:	add	r1, sp, #16
    2074:	bl	105cc <strlcat>
      return tmp.store;
    2078:	ldrh.w	r0, [sp, #14]
    }
  }
    207c:	add	sp, #272	; 0x110
    207e:	pop	{r4, r5, r6, pc}
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2080:	ldr	r3, [pc, #12]	; (2090 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
      return tmp.store;
    2082:	ldrh.w	r0, [sp, #14]
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2086:	ldrh	r3, [r3, #0]
    2088:	strh	r3, [r4, #0]
    { ConstructFilename(tmp.parent, out, len);
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
      strlcat(out, tmp.name,len);
      return tmp.store;
    }
  }
    208a:	add	sp, #272	; 0x110
    208c:	pop	{r4, r5, r6, pc}
    208e:	nop
    2090:	.word	0x200002fc

00002094 <MTPStorage_SD::rename(unsigned long, char const*)>:
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2094:	push	{r4, r5, r6, r7, lr}
    2096:	subw	sp, sp, #1044	; 0x414
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    209a:	mov.w	r3, #256	; 0x100
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    209e:	mov	r7, r2
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    20a0:	mov	r2, sp
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    20a2:	mov	r5, r1
    20a4:	mov	r4, r0
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    20a6:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    20aa:	mov	r6, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    20ac:	mov	r0, sp
    20ae:	bl	10680 <strlen>
    20b2:	mov	r1, r0
    20b4:	mov	r0, sp
    20b6:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    20ba:	ldr	r0, [pc, #132]	; (2140 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    20bc:	bl	e960 <Print::println()>
    Serial.println(oldName);

    Record p1 = ReadIndexRecord(handle);
    20c0:	mov	r2, r5
    20c2:	mov	r1, r4
    20c4:	add	r0, sp, #768	; 0x300
    20c6:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strlcpy(temp,p1.name,MAX_FILENAME_LEN);
    20ca:	add	r1, sp, #784	; 0x310
    20cc:	mov.w	r2, #256	; 0x100
    20d0:	add	r0, sp, #512	; 0x200
    20d2:	bl	10620 <strlcpy>
    strlcpy(p1.name,name,MAX_FILENAME_LEN);
    20d6:	mov	r1, r7
    20d8:	mov.w	r2, #256	; 0x100
    20dc:	add	r0, sp, #784	; 0x310
    20de:	bl	10620 <strlcpy>

    WriteIndexRecord(handle, p1);
    20e2:	add	r2, sp, #768	; 0x300
    20e4:	mov	r1, r5
    20e6:	mov	r0, r4
    20e8:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    20ec:	add	r2, sp, #256	; 0x100
    20ee:	mov.w	r3, #256	; 0x100
    20f2:	mov	r1, r5
    20f4:	mov	r0, r4
    20f6:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    20fa:	add	r0, sp, #256	; 0x100
    20fc:	bl	10680 <strlen>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    2100:	add.w	r6, r4, r6, lsl #2
    2104:	mov	r1, r0
    2106:	add	r0, sp, #256	; 0x100
    2108:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    210c:	ldr	r0, [pc, #48]	; (2140 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    210e:	bl	e960 <Print::println()>
    2112:	ldr	r0, [r6, #88]	; 0x58
    2114:	ldr	r3, [r0, #0]
    2116:	add	r2, sp, #256	; 0x100
    2118:	mov	r1, sp
    211a:	ldr	r3, [r3, #12]
    211c:	blx	r3
    Serial.println(newName);

    if (sd_rename(store,oldName,newName)) return true;
    211e:	mov	r6, r0
    2120:	cbnz	r0, 2138 <MTPStorage_SD::rename(unsigned long, char const*)+0xa4>

    // rename failed; undo index update
    strlcpy(p1.name,temp,MAX_FILENAME_LEN);
    2122:	add	r1, sp, #512	; 0x200
    2124:	mov.w	r2, #256	; 0x100
    2128:	add	r0, sp, #784	; 0x310
    212a:	bl	10620 <strlcpy>
    WriteIndexRecord(handle, p1);
    212e:	add	r2, sp, #768	; 0x300
    2130:	mov	r1, r5
    2132:	mov	r0, r4
    2134:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
  }
    2138:	mov	r0, r6
    213a:	addw	sp, sp, #1044	; 0x414
    213e:	pop	{r4, r5, r6, r7, pc}
    2140:	.word	0x20000cdc

00002144 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>:
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    2144:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (open_file_ == i && mode_ == mode) return;
    2148:	ldr.w	r3, [r0, #240]	; 0xf0
    214c:	cmp	r3, r1
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    214e:	sub	sp, #292	; 0x124
    if (open_file_ == i && mode_ == mode) return;
    2150:	beq.w	2548 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x404>
    2154:	mov	r6, r2
    char filename[MAX_FILENAME_LEN];
    uint16_t store = ConstructFilename(i, filename, MAX_FILENAME_LEN);
    2156:	mov.w	r3, #256	; 0x100
    215a:	add	r2, sp, #32
    215c:	mov	r4, r0
    215e:	mov	r5, r1
    2160:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    2164:	mov	r7, r0
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2166:	ldr.w	r0, [r4, #204]	; 0xcc
    216a:	cmp	r0, #0
    216c:	beq.w	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2170:	ldr	r2, [r0, #0]
    2172:	ldr	r3, [pc, #348]	; (22d0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x18c>)
    2174:	ldr	r2, [r2, #68]	; 0x44
    2176:	cmp	r2, r3
    2178:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    217c:	ldr	r0, [r0, #16]
    217e:	cmp	r0, #0
    2180:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2182:	ldr	r2, [r0, #0]
    2184:	ldr	r2, [r2, #68]	; 0x44
    2186:	cmp	r2, r3
    2188:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    218c:	ldr	r0, [r0, #16]
    218e:	cmp	r0, #0
    2190:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2192:	ldr	r2, [r0, #0]
    2194:	ldr	r2, [r2, #68]	; 0x44
    2196:	cmp	r2, r3
    2198:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    219c:	ldr	r0, [r0, #16]
    219e:	cmp	r0, #0
    21a0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21a2:	ldr	r2, [r0, #0]
    21a4:	ldr	r2, [r2, #68]	; 0x44
    21a6:	cmp	r2, r3
    21a8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21ac:	ldr	r0, [r0, #16]
    21ae:	cmp	r0, #0
    21b0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21b2:	ldr	r2, [r0, #0]
    21b4:	ldr	r2, [r2, #68]	; 0x44
    21b6:	cmp	r2, r3
    21b8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21bc:	ldr	r0, [r0, #16]
    21be:	cmp	r0, #0
    21c0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21c2:	ldr	r2, [r0, #0]
    21c4:	ldr	r2, [r2, #68]	; 0x44
    21c6:	cmp	r2, r3
    21c8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21cc:	ldr	r0, [r0, #16]
    21ce:	cmp	r0, #0
    21d0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21d2:	ldr	r2, [r0, #0]
    21d4:	ldr	r2, [r2, #68]	; 0x44
    21d6:	cmp	r2, r3
    21d8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21dc:	ldr	r0, [r0, #16]
    21de:	cmp	r0, #0
    21e0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21e2:	ldr	r2, [r0, #0]
    21e4:	ldr	r2, [r2, #68]	; 0x44
    21e6:	cmp	r2, r3
    21e8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21ec:	ldr	r0, [r0, #16]
    21ee:	cmp	r0, #0
    21f0:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    21f2:	ldr	r2, [r0, #0]
    21f4:	ldr	r2, [r2, #68]	; 0x44
    21f6:	cmp	r2, r3
    21f8:	bne.w	2558 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    21fc:	ldr	r0, [r0, #16]
    21fe:	cmp	r0, #0
    2200:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2202:	ldr	r3, [r0, #0]
    2204:	ldr	r3, [r3, #68]	; 0x44
    2206:	blx	r3

    mtp_lock_storage(true);
    if(sd_isOpen(file_)) file_.close();
    2208:	cmp	r0, #0
    220a:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    220c:	ldr.w	r0, [r4, #204]	; 0xcc
    2210:	cmp	r0, #0
    2212:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2214:	ldr	r2, [r0, #0]
    2216:	ldr	r3, [pc, #188]	; (22d4 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x190>)
    2218:	ldr	r2, [r2, #64]	; 0x40
    221a:	cmp	r2, r3
    221c:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2220:	ldr	r0, [r0, #16]
    2222:	cmp	r0, #0
    2224:	beq.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2226:	ldr	r2, [r0, #0]
    2228:	ldr	r2, [r2, #64]	; 0x40
    222a:	cmp	r2, r3
    222c:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2230:	ldr	r0, [r0, #16]
    2232:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2234:	ldr	r2, [r0, #0]
    2236:	ldr	r2, [r2, #64]	; 0x40
    2238:	cmp	r2, r3
    223a:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    223e:	ldr	r0, [r0, #16]
    2240:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2242:	ldr	r2, [r0, #0]
    2244:	ldr	r2, [r2, #64]	; 0x40
    2246:	cmp	r2, r3
    2248:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    224c:	ldr	r0, [r0, #16]
    224e:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2250:	ldr	r2, [r0, #0]
    2252:	ldr	r2, [r2, #64]	; 0x40
    2254:	cmp	r2, r3
    2256:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    225a:	ldr	r0, [r0, #16]
    225c:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    225e:	ldr	r2, [r0, #0]
    2260:	ldr	r2, [r2, #64]	; 0x40
    2262:	cmp	r2, r3
    2264:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2268:	ldr	r0, [r0, #16]
    226a:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    226c:	ldr	r2, [r0, #0]
    226e:	ldr	r2, [r2, #64]	; 0x40
    2270:	cmp	r2, r3
    2272:	bne.w	255c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2276:	ldr	r0, [r0, #16]
    2278:	cbz	r0, 2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    227a:	ldr	r3, [r0, #0]
    227c:	ldr	r3, [r3, #64]	; 0x40
    227e:	blx	r3
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    2280:	add.w	r7, r4, r7, lsl #2
    2284:	add	r2, sp, #32
    2286:	ldr	r1, [r7, #88]	; 0x58
    2288:	ldr	r3, [r1, #0]
    228a:	add	r0, sp, #12
    228c:	ldr	r7, [r3, #0]
    228e:	uxtb	r3, r6
    2290:	blx	r7
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2292:	ldr.w	r2, [r4, #204]	; 0xcc
    2296:	cbz	r2, 22a0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2298:	ldr	r3, [r2, #16]
    229a:	subs	r3, #1
    229c:	str	r3, [r2, #16]
    229e:	cbz	r3, 22dc <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x198>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    22a0:	ldr	r2, [sp, #28]
    22a2:	str.w	r2, [r4, #204]	; 0xcc
		if (f) f->refcount++;
    22a6:	cbz	r2, 22c2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    22a8:	ldr	r1, [r2, #16]
		return *this;
	}
	virtual ~File() {
    22aa:	ldr	r3, [pc, #44]	; (22d8 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x194>)
    22ac:	str	r3, [sp, #12]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    22ae:	adds	r1, #1
    22b0:	str	r1, [r2, #16]
    22b2:	ldr	r1, [sp, #28]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22b4:	cbz	r1, 22c2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    22b6:	ldr	r2, [r1, #16]
    22b8:	subs	r2, #1
    22ba:	str	r2, [r1, #16]
    22bc:	cmp	r2, #0
    22be:	beq.w	2418 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2d4>
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    22c2:	str.w	r5, [r4, #240]	; 0xf0
    mode_ = mode;
    22c6:	str.w	r6, [r4, #236]	; 0xec
    mtp_lock_storage(false);
  }
    22ca:	add	sp, #292	; 0x124
    22cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    22d0:	.word	0x0000011d
    22d4:	.word	0x00000111
    22d8:	.word	0x20000074
    22dc:	ldr.w	r7, [r4, #204]	; 0xcc
    22e0:	cmp	r7, #0
    22e2:	beq.n	22a0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    22e4:	ldr	r3, [r7, #0]
    22e6:	ldr	r1, [pc, #680]	; (2590 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    22e8:	ldr	r3, [r3, #32]
    22ea:	cmp	r3, r1
    22ec:	bne.w	2560 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x41c>
    22f0:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22f2:	ldr	r3, [pc, #672]	; (2594 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
    22f4:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22f6:	cmp	r0, #0
    22f8:	beq.w	240e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    22fc:	ldr	r2, [r0, #16]
    22fe:	subs	r2, #1
    2300:	str	r2, [r0, #16]
    2302:	cmp	r2, #0
    2304:	bne.w	240e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2308:	ldr.w	r8, [r7, #16]
    230c:	cmp.w	r8, #0
    2310:	beq.n	240e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2312:	ldr.w	r2, [r8]
    2316:	ldr	r2, [r2, #32]
    2318:	cmp	r2, r1
    231a:	bne.w	257e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x43a>
    231e:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2322:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2326:	cmp	r0, #0
    2328:	beq.n	2406 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    232a:	ldr	r2, [r0, #16]
    232c:	subs	r2, #1
    232e:	str	r2, [r0, #16]
    2330:	cmp	r2, #0
    2332:	bne.n	2406 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2334:	ldr.w	r9, [r8, #16]
    2338:	cmp.w	r9, #0
    233c:	beq.n	2406 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    233e:	ldr.w	r2, [r9]
    2342:	ldr	r2, [r2, #32]
    2344:	cmp	r2, r1
    2346:	bne.w	2572 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x42e>
    234a:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    234e:	str.w	r3, [r9]
    2352:	ldr.w	lr, [pc, #576]	; 2594 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2356:	cmp	r0, #0
    2358:	beq.n	23fe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    235a:	ldr	r2, [r0, #16]
    235c:	subs	r2, #1
    235e:	str	r2, [r0, #16]
    2360:	cmp	r2, #0
    2362:	bne.n	23fe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2364:	ldr.w	sl, [r9, #16]
    2368:	cmp.w	sl, #0
    236c:	beq.n	23fe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    236e:	ldr.w	r2, [sl]
    2372:	ldr	r2, [r2, #32]
    2374:	cmp	r2, r1
    2376:	bne.w	258a <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x446>
    237a:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    237e:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2382:	cmp	r0, #0
    2384:	beq.n	23f6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2386:	ldr	r2, [r0, #16]
    2388:	subs	r2, #1
    238a:	str	r2, [r0, #16]
    238c:	cmp	r2, #0
    238e:	bne.n	23f6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2390:	ldr.w	fp, [sl, #16]
    2394:	cmp.w	fp, #0
    2398:	beq.n	23f6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    239a:	ldr.w	r2, [fp]
    239e:	ldr	r2, [r2, #32]
    23a0:	cmp	r2, r1
    23a2:	bne.w	259e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x45a>
    23a6:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23aa:	str.w	r3, [fp]
    23ae:	ldr	r0, [pc, #484]	; (2594 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23b0:	cbz	r2, 23ee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    23b2:	ldr	r3, [r2, #16]
    23b4:	subs	r3, #1
    23b6:	str	r3, [r2, #16]
    23b8:	cbnz	r3, 23ee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    23ba:	ldr.w	r2, [fp, #16]
    23be:	cbz	r2, 23ee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    23c0:	ldr	r3, [r2, #0]
    23c2:	ldr	r3, [r3, #32]
    23c4:	cmp	r3, r1
    23c6:	bne.w	25aa <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x466>
    23ca:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23cc:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23ce:	cbz	r1, 23e6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    23d0:	ldr	r3, [r1, #16]
    23d2:	subs	r3, #1
    23d4:	str	r3, [r1, #16]
    23d6:	cbnz	r3, 23e6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    23d8:	ldr	r0, [r2, #16]
    23da:	cbz	r0, 23e6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    23dc:	ldr	r3, [r0, #0]
    23de:	str	r2, [sp, #4]
    23e0:	ldr	r3, [r3, #32]
    23e2:	blx	r3
    23e4:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    23e6:	mov	r0, r2
    23e8:	movs	r1, #20
    23ea:	bl	ea80 <operator delete(void*, unsigned int)>
    23ee:	mov	r0, fp
    23f0:	movs	r1, #20
    23f2:	bl	ea80 <operator delete(void*, unsigned int)>
    23f6:	mov	r0, sl
    23f8:	movs	r1, #20
    23fa:	bl	ea80 <operator delete(void*, unsigned int)>
    23fe:	mov	r0, r9
    2400:	movs	r1, #20
    2402:	bl	ea80 <operator delete(void*, unsigned int)>
    2406:	mov	r0, r8
    2408:	movs	r1, #20
    240a:	bl	ea80 <operator delete(void*, unsigned int)>
    240e:	mov	r0, r7
    2410:	movs	r1, #20
    2412:	bl	ea80 <operator delete(void*, unsigned int)>
    2416:	b.n	22a0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2418:	ldr	r7, [sp, #28]
    241a:	cmp	r7, #0
    241c:	beq.w	22c2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2420:	ldr	r2, [r7, #0]
    2422:	ldr	r1, [pc, #364]	; (2590 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    2424:	ldr	r2, [r2, #32]
    2426:	cmp	r2, r1
    2428:	bne.w	2566 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x422>
    242c:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    242e:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2430:	cmp	r0, #0
    2432:	beq.w	253e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2436:	ldr	r2, [r0, #16]
    2438:	subs	r2, #1
    243a:	str	r2, [r0, #16]
    243c:	cmp	r2, #0
    243e:	bne.n	253e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2440:	ldr.w	r8, [r7, #16]
    2444:	cmp.w	r8, #0
    2448:	beq.n	253e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    244a:	ldr.w	r2, [r8]
    244e:	ldr	r2, [r2, #32]
    2450:	cmp	r2, r1
    2452:	bne.w	2578 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x434>
    2456:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    245a:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    245e:	cmp	r0, #0
    2460:	beq.n	2536 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2462:	ldr	r2, [r0, #16]
    2464:	subs	r2, #1
    2466:	str	r2, [r0, #16]
    2468:	cmp	r2, #0
    246a:	bne.n	2536 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    246c:	ldr.w	r9, [r8, #16]
    2470:	cmp.w	r9, #0
    2474:	beq.n	2536 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2476:	ldr.w	r2, [r9]
    247a:	ldr	r2, [r2, #32]
    247c:	cmp	r2, r1
    247e:	bne.n	256c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x428>
    2480:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2484:	str.w	r3, [r9]
    2488:	ldr.w	lr, [pc, #264]	; 2594 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    248c:	cmp	r0, #0
    248e:	beq.n	252e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2490:	ldr	r2, [r0, #16]
    2492:	subs	r2, #1
    2494:	str	r2, [r0, #16]
    2496:	cmp	r2, #0
    2498:	bne.n	252e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    249a:	ldr.w	sl, [r9, #16]
    249e:	cmp.w	sl, #0
    24a2:	beq.n	252e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    24a4:	ldr.w	r2, [sl]
    24a8:	ldr	r2, [r2, #32]
    24aa:	cmp	r2, r1
    24ac:	bne.n	2584 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x440>
    24ae:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    24b2:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    24b6:	cmp	r0, #0
    24b8:	beq.n	2526 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    24ba:	ldr	r2, [r0, #16]
    24bc:	subs	r2, #1
    24be:	str	r2, [r0, #16]
    24c0:	cmp	r2, #0
    24c2:	bne.n	2526 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    24c4:	ldr.w	fp, [sl, #16]
    24c8:	cmp.w	fp, #0
    24cc:	beq.n	2526 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    24ce:	ldr.w	r2, [fp]
    24d2:	ldr	r2, [r2, #32]
    24d4:	cmp	r2, r1
    24d6:	bne.n	2598 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x454>
    24d8:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    24dc:	str.w	r3, [fp]
    24e0:	ldr	r0, [pc, #176]	; (2594 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    24e2:	cbz	r2, 251e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    24e4:	ldr	r3, [r2, #16]
    24e6:	subs	r3, #1
    24e8:	str	r3, [r2, #16]
    24ea:	cbnz	r3, 251e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    24ec:	ldr.w	r2, [fp, #16]
    24f0:	cbz	r2, 251e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    24f2:	ldr	r3, [r2, #0]
    24f4:	ldr	r3, [r3, #32]
    24f6:	cmp	r3, r1
    24f8:	bne.n	25a4 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x460>
    24fa:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    24fc:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    24fe:	cbz	r1, 2516 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2500:	ldr	r3, [r1, #16]
    2502:	subs	r3, #1
    2504:	str	r3, [r1, #16]
    2506:	cbnz	r3, 2516 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2508:	ldr	r0, [r2, #16]
    250a:	cbz	r0, 2516 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    250c:	ldr	r3, [r0, #0]
    250e:	str	r2, [sp, #4]
    2510:	ldr	r3, [r3, #32]
    2512:	blx	r3
    2514:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2516:	mov	r0, r2
    2518:	movs	r1, #20
    251a:	bl	ea80 <operator delete(void*, unsigned int)>
    251e:	mov	r0, fp
    2520:	movs	r1, #20
    2522:	bl	ea80 <operator delete(void*, unsigned int)>
    2526:	mov	r0, sl
    2528:	movs	r1, #20
    252a:	bl	ea80 <operator delete(void*, unsigned int)>
    252e:	mov	r0, r9
    2530:	movs	r1, #20
    2532:	bl	ea80 <operator delete(void*, unsigned int)>
    2536:	mov	r0, r8
    2538:	movs	r1, #20
    253a:	bl	ea80 <operator delete(void*, unsigned int)>
    253e:	mov	r0, r7
    2540:	movs	r1, #20
    2542:	bl	ea80 <operator delete(void*, unsigned int)>
    2546:	b.n	22c2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    if (open_file_ == i && mode_ == mode) return;
    2548:	ldr.w	r3, [r0, #236]	; 0xec
    254c:	cmp	r3, r2
    254e:	bne.w	2154 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x10>
    if(sd_isOpen(file_)) file_.close();
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    mode_ = mode;
    mtp_lock_storage(false);
  }
    2552:	add	sp, #292	; 0x124
    2554:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2558:	blx	r2
    255a:	b.n	2208 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0xc4>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    255c:	blx	r2
    255e:	b.n	2280 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2560:	mov	r0, r7
    2562:	blx	r3
    2564:	b.n	22a0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2566:	mov	r0, r7
    2568:	blx	r2
    256a:	b.n	22c2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    256c:	mov	r0, r9
    256e:	blx	r2
    2570:	b.n	2536 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2572:	mov	r0, r9
    2574:	blx	r2
    2576:	b.n	2406 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2578:	mov	r0, r8
    257a:	blx	r2
    257c:	b.n	253e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    257e:	mov	r0, r8
    2580:	blx	r2
    2582:	b.n	240e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2584:	mov	r0, sl
    2586:	blx	r2
    2588:	b.n	252e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    258a:	mov	r0, sl
    258c:	blx	r2
    258e:	b.n	23fe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2590:	.word	0x00000acd
    2594:	.word	0x20000074
    2598:	mov	r0, fp
    259a:	blx	r2
    259c:	b.n	2526 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    259e:	mov	r0, fp
    25a0:	blx	r2
    25a2:	b.n	23f6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    25a4:	mov	r0, r2
    25a6:	blx	r3
    25a8:	b.n	251e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    25aa:	mov	r0, r2
    25ac:	blx	r3
    25ae:	b.n	23ee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>

000025b0 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)>:
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    25b0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    25b4:	mov	r5, r0
    25b6:	sub	sp, #8
    25b8:	mov	r7, r2
    OpenFileByIndex(handle);
    25ba:	movs	r2, #0
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    25bc:	mov	r8, r3
    25be:	ldr.w	r9, [sp, #40]	; 0x28
    OpenFileByIndex(handle);
    25c2:	bl	2144 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    25c6:	ldr.w	r4, [r5, #204]	; 0xcc
    25ca:	cmp	r4, #0
    25cc:	beq.n	26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    25ce:	ldr	r0, [r4, #0]
    25d0:	ldr	r2, [pc, #308]	; (2708 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x158>)
    25d2:	ldr	r6, [r0, #52]	; 0x34
    25d4:	cmp	r6, r2
    25d6:	mov.w	r3, #0
    25da:	bne.n	26d4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x124>
    25dc:	ldr	r1, [r4, #16]
    25de:	cmp	r1, #0
    25e0:	beq.n	269c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xec>
    25e2:	ldr	r2, [r1, #0]
    25e4:	ldr.w	sl, [r2, #52]	; 0x34
    25e8:	cmp	sl, r6
    25ea:	bne.n	26de <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x12e>
    25ec:	ldr.w	lr, [r1, #16]
    25f0:	cmp.w	lr, #0
    25f4:	beq.n	26aa <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    25f6:	ldr.w	r2, [lr]
    25fa:	ldr	r6, [r2, #52]	; 0x34
    25fc:	cmp	r6, sl
    25fe:	bne.n	26e8 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x138>
    2600:	ldr.w	lr, [lr, #16]
    2604:	cmp.w	lr, #0
    2608:	beq.n	26aa <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    260a:	ldr.w	r2, [lr]
    260e:	ldr.w	sl, [r2, #52]	; 0x34
    2612:	cmp	sl, r6
    2614:	bne.n	26f2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x142>
    2616:	ldr.w	lr, [lr, #16]
    261a:	cmp.w	lr, #0
    261e:	beq.n	26aa <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    2620:	ldr.w	r3, [lr]
    2624:	ldr	r6, [r3, #52]	; 0x34
    2626:	cmp	r6, sl
    2628:	bne.n	26fc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x14c>
    262a:	ldr.w	r6, [lr, #16]
    262e:	cmp	r6, #0
    2630:	beq.n	26aa <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    2632:	ldr	r1, [r6, #0]
    2634:	movs	r3, #0
    2636:	str	r3, [sp, #0]
    2638:	mov	r2, r7
    263a:	mov	r0, r6
    263c:	ldr	r1, [r1, #52]	; 0x34
    263e:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    2640:	ldr.w	r4, [r5, #204]	; 0xcc
    2644:	cmp	r4, #0
    2646:	beq.n	26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    2648:	ldr	r2, [r4, #0]
    264a:	ldr	r3, [pc, #192]	; (270c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    264c:	ldr	r5, [r2, #40]	; 0x28
    264e:	cmp	r5, r3
    2650:	bne.n	26b6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    2652:	ldr	r0, [r4, #16]
    2654:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    2656:	ldr	r2, [r0, #0]
    2658:	ldr	r4, [r2, #40]	; 0x28
    265a:	cmp	r4, r3
    265c:	bne.n	26c6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    265e:	ldr	r0, [r0, #16]
    2660:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    2662:	ldr	r2, [r0, #0]
    2664:	ldr	r4, [r2, #40]	; 0x28
    2666:	cmp	r4, r3
    2668:	bne.n	26c6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    266a:	ldr	r0, [r0, #16]
    266c:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    266e:	ldr	r2, [r0, #0]
    2670:	ldr	r4, [r2, #40]	; 0x28
    2672:	cmp	r4, r3
    2674:	bne.n	26c6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    2676:	ldr	r0, [r0, #16]
    2678:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    267a:	ldr	r2, [r0, #0]
    267c:	ldr	r4, [r2, #40]	; 0x28
    267e:	cmp	r4, r3
    2680:	bne.n	26c6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    2682:	ldr	r0, [r0, #16]
    2684:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    2686:	ldr	r2, [r0, #0]
    2688:	ldr	r4, [r2, #40]	; 0x28
    268a:	cmp	r4, r3
    268c:	bne.n	26c6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    268e:	ldr	r0, [r0, #16]
    2690:	cbz	r0, 26a4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    2692:	ldr	r3, [r0, #0]
    2694:	mov	r2, r9
    2696:	mov	r1, r8
    2698:	ldr	r3, [r3, #40]	; 0x28
    269a:	b.n	26be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x10e>
    269c:	ldr	r5, [r0, #40]	; 0x28
    269e:	ldr	r3, [pc, #108]	; (270c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    26a0:	cmp	r5, r3
    26a2:	bne.n	26b6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    mtp_lock_storage(true);
    file_.seek(pos);
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }
    26a4:	add	sp, #8
    26a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    26aa:	ldr	r5, [r0, #40]	; 0x28
    26ac:	ldr	r3, [pc, #92]	; (270c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    26ae:	cmp	r5, r3
    26b0:	bne.n	26b6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    26b2:	mov	r0, r1
    26b4:	b.n	2656 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xa6>
    26b6:	mov	r2, r9
    26b8:	mov	r1, r8
    26ba:	mov	r0, r4
    26bc:	mov	r3, r5
    26be:	add	sp, #8
    26c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    26c4:	bx	r3
    26c6:	mov	r2, r9
    26c8:	mov	r1, r8
    26ca:	mov	r3, r4
    26cc:	add	sp, #8
    26ce:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    26d2:	bx	r3
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    26d4:	str	r3, [sp, #0]
    26d6:	mov	r2, r7
    26d8:	mov	r0, r4
    26da:	blx	r6
    26dc:	b.n	2640 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    26de:	str	r3, [sp, #0]
    26e0:	mov	r2, r7
    26e2:	mov	r0, r1
    26e4:	blx	sl
    26e6:	b.n	2640 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    26e8:	str	r3, [sp, #0]
    26ea:	mov	r2, r7
    26ec:	mov	r0, lr
    26ee:	blx	r6
    26f0:	b.n	2640 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    26f2:	str	r3, [sp, #0]
    26f4:	mov	r2, r7
    26f6:	mov	r0, lr
    26f8:	blx	sl
    26fa:	b.n	2640 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    26fc:	movs	r3, #0
    26fe:	mov	r2, r7
    2700:	mov	r0, lr
    2702:	str	r3, [sp, #0]
    2704:	blx	r6
    2706:	b.n	2640 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    2708:	.word	0x000000d9
    270c:	.word	0x0000008d

00002710 <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)>:
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    2710:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    2714:	cmp.w	r2, #4294967295
    2718:	ite	ne
    271a:	movne	r6, r2
    271c:	moveq	r6, r1
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    271e:	sub.w	sp, sp, #800	; 0x320
    2722:	mov	r4, r0
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    2724:	mov	r2, r6
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    2726:	mov	r7, r1
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    2728:	mov	r1, r0
    272a:	add	r0, sp, #256	; 0x100
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    272c:	mov	r8, r3
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    272e:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    2732:	ldr	r1, [sp, #824]	; 0x338
    2734:	mov.w	r2, #256	; 0x100
    2738:	add	r0, sp, #544	; 0x220
    273a:	bl	10620 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    273e:	ldr.w	r5, [r4, #244]	; 0xf4
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    2742:	ldrh.w	r3, [sp, #270]	; 0x10e
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    2746:	ldr	r2, [sp, #260]	; 0x104
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    2748:	strh.w	r3, [sp, #542]	; 0x21e
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    274c:	adds	r1, r5, #1
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    274e:	movs	r3, #0
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    2750:	str.w	r1, [r4, #244]	; 0xf4
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    2754:	str	r3, [sp, #532]	; 0x214
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    2756:	mov	r1, r5
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    2758:	movs	r3, #1
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    275a:	str	r2, [sp, #536]	; 0x218
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    275c:	mov	r0, r4
    275e:	add	r2, sp, #528	; 0x210
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    2760:	str	r6, [sp, #528]	; 0x210
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    2762:	strb.w	r8, [sp, #540]	; 0x21c
    // New folder is empty, scanned = true.
    r.scanned = 1;
    2766:	strb.w	r3, [sp, #541]	; 0x21d
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    276a:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    276e:	mov	r1, r6
    2770:	add	r2, sp, #256	; 0x100
    2772:	mov	r0, r4
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    2774:	str	r5, [sp, #260]	; 0x104
    WriteIndexRecord(parent, p);
    2776:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    if (folder) 
    277a:	cmp.w	r8, #0
    277e:	bne.n	2794 <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)+0x84>
      sd_mkdir(store,filename);
      mtp_lock_storage(false);
    } 
    else 
    {
      OpenFileByIndex(ret, FILE_WRITE_BEGIN);
    2780:	mov	r0, r4
    2782:	movs	r2, #2
    2784:	mov	r1, r5
    2786:	bl	2144 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    278a:	mov	r0, r5
    278c:	add.w	sp, sp, #800	; 0x320
    2790:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    if (folder) 
    {
      char filename[MAX_FILENAME_LEN];
      ConstructFilename(ret, filename, MAX_FILENAME_LEN);
    2794:	mov	r0, r4
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    2796:	add.w	r4, r4, r7, lsl #2
    279a:	mov	r2, sp
    279c:	mov	r1, r5
    279e:	mov.w	r3, #256	; 0x100
    27a2:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    27a6:	ldr	r0, [r4, #88]	; 0x58
    27a8:	ldr	r3, [r0, #0]
    27aa:	mov	r1, sp
    27ac:	ldr	r3, [r3, #8]
    27ae:	blx	r3
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    27b0:	mov	r0, r5
    27b2:	add.w	sp, sp, #800	; 0x320
    27b6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    27ba:	nop

000027bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>:
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    27bc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27c0:	cmp.w	r2, #4294967295
    27c4:	ite	ne
    27c6:	movne	r6, r2
    27c8:	moveq	r6, r1
    27ca:	sub.w	sp, sp, #564	; 0x234
    
    Record record = ReadIndexRecord(i);
    27ce:	mov	r1, r0
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    27d0:	mov	r4, r0
    
    Record record = ReadIndexRecord(i);
    27d2:	mov	r2, r6
    27d4:	add	r0, sp, #16
    27d6:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if (record.isdir && !record.scanned) {
    27da:	ldrb.w	r3, [sp, #28]
    27de:	cbz	r3, 27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    27e0:	ldrb.w	r2, [sp, #29]
    27e4:	cbz	r2, 27ee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x32>
      }
      record.scanned = true;
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }
    27e6:	add.w	sp, sp, #564	; 0x234
    27ea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    
    Record record = ReadIndexRecord(i);
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
    27ee:	mov	r0, r4
    27f0:	mov	r1, r6
    27f2:	bl	2144 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    27f6:	ldr.w	r0, [r4, #204]	; 0xcc
    27fa:	cmp	r0, #0
    27fc:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    27fe:	ldr	r3, [r0, #0]
    2800:	ldr.w	r8, [pc, #892]	; 2b80 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c4>
    2804:	ldr	r3, [r3, #68]	; 0x44
    2806:	cmp	r3, r8
    2808:	bne.n	28c4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    280a:	ldr	r0, [r0, #16]
    280c:	cmp	r0, #0
    280e:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    2810:	ldr	r3, [r0, #0]
    2812:	ldr	r3, [r3, #68]	; 0x44
    2814:	cmp	r3, r8
    2816:	bne.n	28c4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    2818:	ldr	r0, [r0, #16]
    281a:	cmp	r0, #0
    281c:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    281e:	ldr	r3, [r0, #0]
    2820:	ldr	r3, [r3, #68]	; 0x44
    2822:	cmp	r3, r8
    2824:	bne.n	28c4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    2826:	ldr	r0, [r0, #16]
    2828:	cmp	r0, #0
    282a:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    282c:	ldr	r3, [r0, #0]
    282e:	ldr	r3, [r3, #68]	; 0x44
    2830:	cmp	r3, r8
    2832:	bne.n	28c4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    2834:	ldr	r0, [r0, #16]
    2836:	cmp	r0, #0
    2838:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    283a:	ldr	r3, [r0, #0]
    283c:	ldr	r3, [r3, #68]	; 0x44
    283e:	cmp	r3, r8
    2840:	bne.n	28c4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    2842:	ldr	r0, [r0, #16]
    2844:	cmp	r0, #0
    2846:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    2848:	ldr	r3, [r0, #0]
    284a:	ldr	r3, [r3, #68]	; 0x44
    284c:	blx	r3
      if (!sd_isOpen(file_)) return;
    284e:	cmp	r0, #0
    2850:	beq.n	27e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    2852:	ldr.w	r9, [pc, #804]	; 2b78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>
    2856:	ldr.w	fp, [pc, #812]	; 2b84 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c8>
    285a:	movs	r5, #0
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    285c:	ldr.w	r1, [r4, #204]	; 0xcc
    2860:	cmp	r1, #0
    2862:	beq.n	28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    2864:	ldr	r3, [r1, #0]
    2866:	ldr	r3, [r3, #80]	; 0x50
    2868:	cmp	r3, fp
    286a:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    286e:	ldr	r1, [r1, #16]
    2870:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    2872:	ldr	r3, [r1, #0]
    2874:	ldr	r3, [r3, #80]	; 0x50
    2876:	cmp	r3, fp
    2878:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    287c:	ldr	r1, [r1, #16]
    287e:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    2880:	ldr	r3, [r1, #0]
    2882:	ldr	r3, [r3, #80]	; 0x50
    2884:	cmp	r3, fp
    2886:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    288a:	ldr	r1, [r1, #16]
    288c:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    288e:	ldr	r3, [r1, #0]
    2890:	ldr	r3, [r3, #80]	; 0x50
    2892:	cmp	r3, fp
    2894:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    2898:	ldr	r1, [r1, #16]
    289a:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    289c:	ldr	r3, [r1, #0]
    289e:	ldr	r3, [r3, #80]	; 0x50
    28a0:	cmp	r3, fp
    28a2:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    28a6:	ldr	r1, [r1, #16]
    28a8:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    28aa:	ldr	r3, [r1, #0]
    28ac:	ldr	r3, [r3, #80]	; 0x50
    28ae:	cmp	r3, fp
    28b0:	bne.w	2d7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    28b4:	ldr	r1, [r1, #16]
    28b6:	cbz	r1, 28c8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    28b8:	ldr	r3, [r1, #0]
    28ba:	movs	r2, #0
    28bc:	ldr	r3, [r3, #80]	; 0x50
    28be:	add	r0, sp, #288	; 0x120
    28c0:	blx	r3
    28c2:	b.n	28de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    28c4:	blx	r3
    28c6:	b.n	284e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x92>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    28c8:	movs	r3, #0
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    28ca:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    28ce:	str.w	r9, [sp, #288]	; 0x120
    28d2:	strb.w	r3, [sp, #292]	; 0x124
    28d6:	strb.w	r3, [sp, #300]	; 0x12c
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    28da:	str	r3, [sp, #304]	; 0x130
    28dc:	str	r2, [sp, #296]	; 0x128
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    28de:	ldr.w	r2, [r4, #224]	; 0xe0
    28e2:	cmp	r2, #0
    28e4:	beq.n	297a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    28e6:	ldr	r3, [r2, #16]
    28e8:	subs	r3, #1
    28ea:	str	r3, [r2, #16]
    28ec:	cmp	r3, #0
    28ee:	bne.n	297a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    28f0:	ldr.w	r7, [r4, #224]	; 0xe0
    28f4:	cmp	r7, #0
    28f6:	beq.n	297a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    28f8:	ldr	r3, [r7, #0]
    28fa:	ldr	r0, [pc, #632]	; (2b74 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    28fc:	ldr	r3, [r3, #32]
    28fe:	cmp	r3, r0
    2900:	bne.w	2da0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5e4>
    2904:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2906:	str.w	r9, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    290a:	cbz	r2, 2972 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    290c:	ldr	r3, [r2, #16]
    290e:	subs	r3, #1
    2910:	str	r3, [r2, #16]
    2912:	cbnz	r3, 2972 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    2914:	ldr.w	sl, [r7, #16]
    2918:	cmp.w	sl, #0
    291c:	beq.n	2972 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    291e:	ldr.w	r3, [sl]
    2922:	ldr	r3, [r3, #32]
    2924:	cmp	r3, r0
    2926:	bne.w	2f6e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b2>
    292a:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    292e:	ldr	r3, [pc, #584]	; (2b78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    2930:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2934:	cbz	r2, 296a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    2936:	ldr	r3, [r2, #16]
    2938:	subs	r3, #1
    293a:	str	r3, [r2, #16]
    293c:	cbnz	r3, 296a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    293e:	ldr.w	r3, [sl, #16]
    2942:	cbz	r3, 296a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    2944:	ldr	r2, [r3, #0]
    2946:	ldr	r2, [r2, #32]
    2948:	cmp	r2, r0
    294a:	bne.w	2f80 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7c4>
    294e:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2950:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2954:	cbz	r1, 2962 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    2956:	ldr	r2, [r1, #16]
    2958:	subs	r2, #1
    295a:	str	r2, [r1, #16]
    295c:	cmp	r2, #0
    295e:	beq.w	2db8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5fc>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2962:	mov	r0, r3
    2964:	movs	r1, #20
    2966:	bl	ea80 <operator delete(void*, unsigned int)>
    296a:	mov	r0, sl
    296c:	movs	r1, #20
    296e:	bl	ea80 <operator delete(void*, unsigned int)>
    2972:	mov	r0, r7
    2974:	movs	r1, #20
    2976:	bl	ea80 <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    297a:	ldr	r3, [sp, #304]	; 0x130
    297c:	str.w	r3, [r4, #224]	; 0xe0
		if (f) f->refcount++;
    2980:	cmp	r3, #0
    2982:	beq.n	2a26 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    2984:	ldr	r2, [r3, #16]
    2986:	adds	r2, #1
    2988:	str	r2, [r3, #16]
    298a:	ldr	r2, [sp, #304]	; 0x130
		return *this;
	}
	virtual ~File() {
    298c:	str.w	r9, [sp, #288]	; 0x120
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2990:	cmp	r2, #0
    2992:	beq.n	2a26 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    2994:	ldr	r3, [r2, #16]
    2996:	subs	r3, #1
    2998:	str	r3, [r2, #16]
    299a:	cmp	r3, #0
    299c:	bne.n	2a26 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    299e:	ldr	r7, [sp, #304]	; 0x130
    29a0:	cmp	r7, #0
    29a2:	beq.n	2a26 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    29a4:	ldr	r3, [r7, #0]
    29a6:	ldr	r0, [pc, #460]	; (2b74 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    29a8:	ldr	r3, [r3, #32]
    29aa:	cmp	r3, r0
    29ac:	bne.w	2d9a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5de>
    29b0:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    29b2:	ldr	r3, [pc, #452]	; (2b78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    29b4:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    29b6:	cbz	r2, 2a1e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    29b8:	ldr	r3, [r2, #16]
    29ba:	subs	r3, #1
    29bc:	str	r3, [r2, #16]
    29be:	cbnz	r3, 2a1e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    29c0:	ldr.w	sl, [r7, #16]
    29c4:	cmp.w	sl, #0
    29c8:	beq.n	2a1e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    29ca:	ldr.w	r3, [sl]
    29ce:	ldr	r3, [r3, #32]
    29d0:	cmp	r3, r0
    29d2:	bne.w	2f74 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b8>
    29d6:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    29da:	ldr	r3, [pc, #412]	; (2b78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    29dc:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    29e0:	cbz	r2, 2a16 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    29e2:	ldr	r3, [r2, #16]
    29e4:	subs	r3, #1
    29e6:	str	r3, [r2, #16]
    29e8:	cbnz	r3, 2a16 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    29ea:	ldr.w	r3, [sl, #16]
    29ee:	cbz	r3, 2a16 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    29f0:	ldr	r2, [r3, #0]
    29f2:	ldr	r2, [r2, #32]
    29f4:	cmp	r2, r0
    29f6:	bne.w	2f7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7be>
    29fa:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    29fc:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2a00:	cbz	r1, 2a0e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    2a02:	ldr	r2, [r1, #16]
    2a04:	subs	r2, #1
    2a06:	str	r2, [r1, #16]
    2a08:	cmp	r2, #0
    2a0a:	beq.w	2e96 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6da>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2a0e:	mov	r0, r3
    2a10:	movs	r1, #20
    2a12:	bl	ea80 <operator delete(void*, unsigned int)>
    2a16:	mov	r0, sl
    2a18:	movs	r1, #20
    2a1a:	bl	ea80 <operator delete(void*, unsigned int)>
    2a1e:	mov	r0, r7
    2a20:	movs	r1, #20
    2a22:	bl	ea80 <operator delete(void*, unsigned int)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2a26:	ldr.w	r0, [r4, #224]	; 0xe0
    2a2a:	cmp	r0, #0
    2a2c:	beq.w	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a30:	ldr	r3, [r0, #0]
    2a32:	ldr	r3, [r3, #68]	; 0x44
    2a34:	cmp	r3, r8
    2a36:	bne.w	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a3a:	ldr	r0, [r0, #16]
    2a3c:	cmp	r0, #0
    2a3e:	beq.w	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a42:	ldr	r3, [r0, #0]
    2a44:	ldr	r3, [r3, #68]	; 0x44
    2a46:	cmp	r3, r8
    2a48:	bne.w	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a4c:	ldr	r0, [r0, #16]
    2a4e:	cmp	r0, #0
    2a50:	beq.w	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a54:	ldr	r3, [r0, #0]
    2a56:	ldr	r3, [r3, #68]	; 0x44
    2a58:	cmp	r3, r8
    2a5a:	bne.w	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a5e:	ldr	r0, [r0, #16]
    2a60:	cmp	r0, #0
    2a62:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a64:	ldr	r3, [r0, #0]
    2a66:	ldr	r3, [r3, #68]	; 0x44
    2a68:	cmp	r3, r8
    2a6a:	bne.w	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a6e:	ldr	r0, [r0, #16]
    2a70:	cmp	r0, #0
    2a72:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a74:	ldr	r3, [r0, #0]
    2a76:	ldr	r3, [r3, #68]	; 0x44
    2a78:	cmp	r3, r8
    2a7a:	bne.n	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a7c:	ldr	r0, [r0, #16]
    2a7e:	cmp	r0, #0
    2a80:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a82:	ldr	r3, [r0, #0]
    2a84:	ldr	r3, [r3, #68]	; 0x44
    2a86:	cmp	r3, r8
    2a88:	bne.n	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a8a:	ldr	r0, [r0, #16]
    2a8c:	cmp	r0, #0
    2a8e:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a90:	ldr	r3, [r0, #0]
    2a92:	ldr	r3, [r3, #68]	; 0x44
    2a94:	cmp	r3, r8
    2a96:	bne.n	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2a98:	ldr	r0, [r0, #16]
    2a9a:	cmp	r0, #0
    2a9c:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2a9e:	ldr	r3, [r0, #0]
    2aa0:	ldr	r3, [r3, #68]	; 0x44
    2aa2:	cmp	r3, r8
    2aa4:	bne.n	2b70 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    2aa6:	ldr	r0, [r0, #16]
    2aa8:	cmp	r0, #0
    2aaa:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    2aac:	ldr	r3, [r0, #0]
    2aae:	ldr	r3, [r3, #68]	; 0x44
    2ab0:	blx	r3
      int sibling = 0;
      while (true) 
      { mtp_lock_storage(true);
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;
    2ab2:	cmp	r0, #0
    2ab4:	beq.n	2b56 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    2ab6:	ldr.w	r3, [r4, #224]	; 0xe0

        Record r;
        r.store = record.store;
    2aba:	ldrh.w	r2, [sp, #30]
        r.parent = i;
    2abe:	str	r6, [sp, #288]	; 0x120
        r.sibling = sibling;
    2ac0:	str	r5, [sp, #296]	; 0x128
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;

        Record r;
        r.store = record.store;
    2ac2:	strh.w	r2, [sp, #302]	; 0x12e
    2ac6:	cmp	r3, #0
    2ac8:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2acc:	ldr	r1, [r3, #0]
    2ace:	ldr	r2, [pc, #172]	; (2b7c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c0>)
    2ad0:	ldr	r1, [r1, #76]	; 0x4c
    2ad2:	cmp	r1, r2
    2ad4:	bne.n	2b88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3cc>
    2ad6:	ldr	r0, [r3, #16]
    2ad8:	cmp	r0, #0
    2ada:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2ade:	ldr	r1, [r0, #0]
    2ae0:	ldr	r1, [r1, #76]	; 0x4c
    2ae2:	cmp	r1, r2
    2ae4:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2ae6:	ldr	r0, [r0, #16]
    2ae8:	cmp	r0, #0
    2aea:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2aee:	ldr	r1, [r0, #0]
    2af0:	ldr	r1, [r1, #76]	; 0x4c
    2af2:	cmp	r1, r2
    2af4:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2af6:	ldr	r0, [r0, #16]
    2af8:	cmp	r0, #0
    2afa:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2afe:	ldr	r1, [r0, #0]
    2b00:	ldr	r1, [r1, #76]	; 0x4c
    2b02:	cmp	r1, r2
    2b04:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2b06:	ldr	r0, [r0, #16]
    2b08:	cmp	r0, #0
    2b0a:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2b0e:	ldr	r1, [r0, #0]
    2b10:	ldr	r1, [r1, #76]	; 0x4c
    2b12:	cmp	r1, r2
    2b14:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2b16:	ldr	r0, [r0, #16]
    2b18:	cmp	r0, #0
    2b1a:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2b1e:	ldr	r1, [r0, #0]
    2b20:	ldr	r1, [r1, #76]	; 0x4c
    2b22:	cmp	r1, r2
    2b24:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2b26:	ldr	r0, [r0, #16]
    2b28:	cmp	r0, #0
    2b2a:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2b2e:	ldr	r1, [r0, #0]
    2b30:	ldr	r1, [r1, #76]	; 0x4c
    2b32:	cmp	r1, r2
    2b34:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2b36:	ldr	r0, [r0, #16]
    2b38:	cmp	r0, #0
    2b3a:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2b3e:	ldr	r1, [r0, #0]
    2b40:	ldr	r1, [r1, #76]	; 0x4c
    2b42:	cmp	r1, r2
    2b44:	bne.n	2b8a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    2b46:	ldr	r0, [r0, #16]
    2b48:	cmp	r0, #0
    2b4a:	beq.w	2cf2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    2b4e:	ldr	r3, [r0, #0]
    2b50:	ldr	r3, [r3, #76]	; 0x4c
    2b52:	blx	r3
    2b54:	b.n	2b8c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3d0>
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    2b56:	movs	r3, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    2b58:	mov	r1, r6
    2b5a:	mov	r0, r4
    2b5c:	add	r2, sp, #16
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
      record.child = sibling;
    2b5e:	str	r5, [sp, #20]
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    2b60:	strb.w	r3, [sp, #29]
      record.child = sibling;
      WriteIndexRecord(i, record);
    2b64:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
  }
    2b68:	add.w	sp, sp, #564	; 0x234
    2b6c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2b70:	blx	r3
    2b72:	b.n	2ab2 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2f6>
    2b74:	.word	0x00000acd
    2b78:	.word	0x20000074
    2b7c:	.word	0x0000013d
    2b80:	.word	0x0000011d
    2b84:	.word	0x00000149
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    2b88:	mov	r0, r3
    2b8a:	blx	r1

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    2b8c:	strb.w	r0, [sp, #300]	; 0x12c
    2b90:	ldr.w	r3, [r4, #224]	; 0xe0
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    2b94:	cmp	r0, #0
    2b96:	beq.w	2cf8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x53c>
    2b9a:	movs	r0, #0
        r.scanned = false;
    2b9c:	movs	r2, #0
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    2b9e:	str	r0, [sp, #292]	; 0x124
        r.scanned = false;
    2ba0:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    2ba4:	cmp	r3, #0
    2ba6:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2baa:	ldr	r1, [r3, #0]
    2bac:	ldr	r2, [pc, #504]	; (2da8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    2bae:	ldr	r1, [r1, #72]	; 0x48
    2bb0:	cmp	r1, r2
    2bb2:	bne.w	2d72 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5b6>
    2bb6:	ldr	r0, [r3, #16]
    2bb8:	cmp	r0, #0
    2bba:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2bbe:	ldr	r3, [r0, #0]
    2bc0:	ldr	r3, [r3, #72]	; 0x48
    2bc2:	cmp	r3, r2
    2bc4:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2bc6:	ldr	r0, [r0, #16]
    2bc8:	cmp	r0, #0
    2bca:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2bce:	ldr	r3, [r0, #0]
    2bd0:	ldr	r3, [r3, #72]	; 0x48
    2bd2:	cmp	r3, r2
    2bd4:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2bd6:	ldr	r0, [r0, #16]
    2bd8:	cmp	r0, #0
    2bda:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2bde:	ldr	r3, [r0, #0]
    2be0:	ldr	r3, [r3, #72]	; 0x48
    2be2:	cmp	r3, r2
    2be4:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2be6:	ldr	r0, [r0, #16]
    2be8:	cmp	r0, #0
    2bea:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2bee:	ldr	r3, [r0, #0]
    2bf0:	ldr	r3, [r3, #72]	; 0x48
    2bf2:	cmp	r3, r2
    2bf4:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2bf6:	ldr	r0, [r0, #16]
    2bf8:	cmp	r0, #0
    2bfa:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2bfe:	ldr	r3, [r0, #0]
    2c00:	ldr	r3, [r3, #72]	; 0x48
    2c02:	cmp	r3, r2
    2c04:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2c06:	ldr	r0, [r0, #16]
    2c08:	cmp	r0, #0
    2c0a:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2c0e:	ldr	r3, [r0, #0]
    2c10:	ldr	r3, [r3, #72]	; 0x48
    2c12:	cmp	r3, r2
    2c14:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2c16:	ldr	r0, [r0, #16]
    2c18:	cmp	r0, #0
    2c1a:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2c1e:	ldr	r3, [r0, #0]
    2c20:	ldr	r3, [r3, #72]	; 0x48
    2c22:	cmp	r3, r2
    2c24:	bne.n	2c38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    2c26:	ldr	r0, [r0, #16]
    2c28:	cmp	r0, #0
    2c2a:	beq.w	2d7a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    2c2e:	ldr	r3, [r0, #0]
    2c30:	ldr	r3, [r3, #72]	; 0x48
    2c32:	blx	r3
    2c34:	mov	r1, r0
    2c36:	b.n	2c3c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    2c38:	blx	r3
    2c3a:	mov	r1, r0
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
    2c3c:	mov.w	r2, #256	; 0x100
    2c40:	add	r0, sp, #304	; 0x130
    2c42:	bl	10620 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    2c46:	ldr.w	r5, [r4, #244]	; 0xf4
    2c4a:	adds	r3, r5, #1
    WriteIndexRecord(new_record, r);
    2c4c:	mov	r0, r4
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    2c4e:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    2c52:	mov	r1, r5
    2c54:	add	r2, sp, #288	; 0x120
    2c56:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    2c5a:	ldr.w	r0, [r4, #224]	; 0xe0
    2c5e:	cmp	r0, #0
    2c60:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2c64:	ldr	r2, [r0, #0]
    2c66:	ldr	r3, [pc, #324]	; (2dac <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f0>)
    2c68:	ldr	r2, [r2, #64]	; 0x40
    2c6a:	cmp	r2, r3
    2c6c:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2c6e:	ldr	r0, [r0, #16]
    2c70:	cmp	r0, #0
    2c72:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2c76:	ldr	r2, [r0, #0]
    2c78:	ldr	r2, [r2, #64]	; 0x40
    2c7a:	cmp	r2, r3
    2c7c:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2c7e:	ldr	r0, [r0, #16]
    2c80:	cmp	r0, #0
    2c82:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2c86:	ldr	r2, [r0, #0]
    2c88:	ldr	r2, [r2, #64]	; 0x40
    2c8a:	cmp	r2, r3
    2c8c:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2c8e:	ldr	r0, [r0, #16]
    2c90:	cmp	r0, #0
    2c92:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2c96:	ldr	r2, [r0, #0]
    2c98:	ldr	r2, [r2, #64]	; 0x40
    2c9a:	cmp	r2, r3
    2c9c:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2c9e:	ldr	r0, [r0, #16]
    2ca0:	cmp	r0, #0
    2ca2:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2ca6:	ldr	r2, [r0, #0]
    2ca8:	ldr	r2, [r2, #64]	; 0x40
    2caa:	cmp	r2, r3
    2cac:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2cae:	ldr	r0, [r0, #16]
    2cb0:	cmp	r0, #0
    2cb2:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2cb6:	ldr	r2, [r0, #0]
    2cb8:	ldr	r2, [r2, #64]	; 0x40
    2cba:	cmp	r2, r3
    2cbc:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2cbe:	ldr	r0, [r0, #16]
    2cc0:	cmp	r0, #0
    2cc2:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2cc6:	ldr	r2, [r0, #0]
    2cc8:	ldr	r2, [r2, #64]	; 0x40
    2cca:	cmp	r2, r3
    2ccc:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2cce:	ldr	r0, [r0, #16]
    2cd0:	cmp	r0, #0
    2cd2:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2cd6:	ldr	r2, [r0, #0]
    2cd8:	ldr	r2, [r2, #64]	; 0x40
    2cda:	cmp	r2, r3
    2cdc:	bne.n	2cee <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    2cde:	ldr	r0, [r0, #16]
    2ce0:	cmp	r0, #0
    2ce2:	beq.w	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2ce6:	ldr	r3, [r0, #0]
    2ce8:	ldr	r3, [r3, #64]	; 0x40
    2cea:	blx	r3
    2cec:	b.n	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    2cee:	blx	r2
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
      if (!sd_isOpen(file_)) return;
    
      int sibling = 0;
      while (true) 
    2cf0:	b.n	285c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    2cf2:	movs	r2, #0
    2cf4:	strb.w	r2, [sp, #300]	; 0x12c
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2cf8:	cmp	r3, #0
    2cfa:	beq.n	2d90 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5d4>
    2cfc:	ldr	r1, [r3, #0]
    2cfe:	ldr	r2, [pc, #176]	; (2db0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f4>)
    2d00:	ldr	r1, [r1, #60]	; 0x3c
    2d02:	cmp	r1, r2
    2d04:	bne.n	2d86 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ca>
    2d06:	ldr	r0, [r3, #16]
    2d08:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d0a:	ldr	r1, [r0, #0]
    2d0c:	ldr	r1, [r1, #60]	; 0x3c
    2d0e:	cmp	r1, r2
    2d10:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d12:	ldr	r0, [r0, #16]
    2d14:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d16:	ldr	r1, [r0, #0]
    2d18:	ldr	r1, [r1, #60]	; 0x3c
    2d1a:	cmp	r1, r2
    2d1c:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d1e:	ldr	r0, [r0, #16]
    2d20:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d22:	ldr	r1, [r0, #0]
    2d24:	ldr	r1, [r1, #60]	; 0x3c
    2d26:	cmp	r1, r2
    2d28:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d2a:	ldr	r0, [r0, #16]
    2d2c:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d2e:	ldr	r1, [r0, #0]
    2d30:	ldr	r1, [r1, #60]	; 0x3c
    2d32:	cmp	r1, r2
    2d34:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d36:	ldr	r0, [r0, #16]
    2d38:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d3a:	ldr	r1, [r0, #0]
    2d3c:	ldr	r1, [r1, #60]	; 0x3c
    2d3e:	cmp	r1, r2
    2d40:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d42:	ldr	r0, [r0, #16]
    2d44:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d46:	ldr	r1, [r0, #0]
    2d48:	ldr	r1, [r1, #60]	; 0x3c
    2d4a:	cmp	r1, r2
    2d4c:	bne.n	2d88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    2d4e:	ldr	r0, [r0, #16]
    2d50:	cbz	r0, 2d5e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    2d52:	ldr	r3, [r0, #0]
    2d54:	ldr	r3, [r3, #60]	; 0x3c
    2d56:	blx	r3
    2d58:	ldr.w	r3, [r4, #224]	; 0xe0
    2d5c:	b.n	2b9c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    2d5e:	movs	r2, #0
        r.scanned = false;
    2d60:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    2d64:	ldr	r1, [r3, #0]
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    2d66:	str	r2, [sp, #292]	; 0x124
    2d68:	ldr	r1, [r1, #72]	; 0x48
    2d6a:	ldr	r2, [pc, #60]	; (2da8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    2d6c:	cmp	r1, r2
    2d6e:	beq.w	2bb6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3fa>
    2d72:	mov	r0, r3
    2d74:	blx	r1
    2d76:	mov	r1, r0
    2d78:	b.n	2c3c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    2d7a:	ldr	r1, [pc, #56]	; (2db4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    2d7c:	b.n	2c3c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    2d7e:	movs	r2, #0
    2d80:	add	r0, sp, #288	; 0x120
    2d82:	blx	r3
    2d84:	b.n	28de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2d86:	mov	r0, r3
    2d88:	blx	r1
    2d8a:	ldr.w	r3, [r4, #224]	; 0xe0
    2d8e:	b.n	2b9c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
    2d90:	str	r3, [sp, #292]	; 0x124
        r.scanned = false;
    2d92:	strb.w	r3, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    2d96:	ldr	r1, [pc, #28]	; (2db4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    2d98:	b.n	2c3c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2d9a:	mov	r0, r7
    2d9c:	blx	r3
    2d9e:	b.n	2a26 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    2da0:	mov	r0, r7
    2da2:	blx	r3
    2da4:	b.n	297a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    2da6:	nop
    2da8:	.word	0x00000129
    2dac:	.word	0x00000111
    2db0:	.word	0x00000101
    2db4:	.word	0x2000016c
    2db8:	ldr	r2, [r3, #16]
    2dba:	cmp	r2, #0
    2dbc:	beq.w	2962 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    2dc0:	ldr	r1, [r2, #0]
    2dc2:	ldr	r1, [r1, #32]
    2dc4:	cmp	r1, r0
    2dc6:	bne.w	2f90 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7d4>
    2dca:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2dce:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2dd2:	cmp.w	lr, #0
    2dd6:	beq.n	2e88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    2dd8:	ldr.w	r1, [lr, #16]
    2ddc:	subs	r1, #1
    2dde:	str.w	r1, [lr, #16]
    2de2:	cmp	r1, #0
    2de4:	bne.n	2e88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    2de6:	ldr	r1, [r2, #16]
    2de8:	str	r1, [sp, #0]
    2dea:	cmp	r1, #0
    2dec:	beq.n	2e88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    2dee:	ldr	r1, [sp, #0]
    2df0:	ldr	r1, [r1, #0]
    2df2:	ldr	r1, [r1, #32]
    2df4:	cmp	r1, r0
    2df6:	bne.w	2fa8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ec>
    2dfa:	ldr	r1, [sp, #0]
    2dfc:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e00:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e04:	cmp.w	lr, #0
    2e08:	beq.n	2e78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    2e0a:	ldr.w	r1, [lr, #16]
    2e0e:	subs	r1, #1
    2e10:	str.w	r1, [lr, #16]
    2e14:	cbnz	r1, 2e78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    2e16:	ldr	r1, [sp, #0]
    2e18:	ldr.w	ip, [r1, #16]
    2e1c:	cmp.w	ip, #0
    2e20:	beq.n	2e78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    2e22:	ldr.w	r1, [ip]
    2e26:	ldr	r1, [r1, #32]
    2e28:	cmp	r1, r0
    2e2a:	bne.w	2fc4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x808>
    2e2e:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e32:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e36:	cbz	r0, 2e68 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    2e38:	ldr	r1, [r0, #16]
    2e3a:	add.w	lr, r1, #4294967295
    2e3e:	str.w	lr, [r0, #16]
    2e42:	cmp.w	lr, #0
    2e46:	bne.n	2e68 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    2e48:	ldr.w	r0, [ip, #16]
    2e4c:	cbz	r0, 2e68 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    2e4e:	ldr.w	lr, [r0]
    2e52:	str.w	ip, [sp, #12]
    2e56:	str	r2, [sp, #8]
    2e58:	str	r3, [sp, #4]
    2e5a:	ldr.w	r3, [lr, #32]
    2e5e:	blx	r3
    2e60:	ldr.w	ip, [sp, #12]
    2e64:	ldr	r2, [sp, #8]
    2e66:	ldr	r3, [sp, #4]
    2e68:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2e6a:	mov	r0, ip
    2e6c:	movs	r1, #20
    2e6e:	str	r3, [sp, #4]
    2e70:	bl	ea80 <operator delete(void*, unsigned int)>
    2e74:	ldr	r3, [sp, #4]
    2e76:	ldr	r2, [sp, #8]
    2e78:	ldr	r0, [sp, #0]
    2e7a:	str	r2, [sp, #8]
    2e7c:	movs	r1, #20
    2e7e:	str	r3, [sp, #4]
    2e80:	bl	ea80 <operator delete(void*, unsigned int)>
    2e84:	ldr	r3, [sp, #4]
    2e86:	ldr	r2, [sp, #8]
    2e88:	str	r3, [sp, #0]
    2e8a:	mov	r0, r2
    2e8c:	movs	r1, #20
    2e8e:	bl	ea80 <operator delete(void*, unsigned int)>
    2e92:	ldr	r3, [sp, #0]
    2e94:	b.n	2962 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e96:	ldr	r2, [r3, #16]
    2e98:	cmp	r2, #0
    2e9a:	beq.w	2a0e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    2e9e:	ldr	r1, [r2, #0]
    2ea0:	ldr	r1, [r1, #32]
    2ea2:	cmp	r1, r0
    2ea4:	bne.n	2f86 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ca>
    2ea6:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2eaa:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2eae:	cmp.w	lr, #0
    2eb2:	beq.n	2f60 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    2eb4:	ldr.w	r1, [lr, #16]
    2eb8:	subs	r1, #1
    2eba:	str.w	r1, [lr, #16]
    2ebe:	cmp	r1, #0
    2ec0:	bne.n	2f60 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    2ec2:	ldr	r1, [r2, #16]
    2ec4:	str	r1, [sp, #0]
    2ec6:	cmp	r1, #0
    2ec8:	beq.n	2f60 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    2eca:	ldr	r1, [sp, #0]
    2ecc:	ldr	r1, [r1, #0]
    2ece:	ldr	r1, [r1, #32]
    2ed0:	cmp	r1, r0
    2ed2:	bne.n	2f9a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7de>
    2ed4:	ldr	r1, [sp, #0]
    2ed6:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2eda:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2ede:	cmp.w	lr, #0
    2ee2:	beq.n	2f50 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    2ee4:	ldr.w	r1, [lr, #16]
    2ee8:	subs	r1, #1
    2eea:	str.w	r1, [lr, #16]
    2eee:	cbnz	r1, 2f50 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    2ef0:	ldr	r1, [sp, #0]
    2ef2:	ldr.w	ip, [r1, #16]
    2ef6:	cmp.w	ip, #0
    2efa:	beq.n	2f50 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    2efc:	ldr.w	r1, [ip]
    2f00:	ldr	r1, [r1, #32]
    2f02:	cmp	r1, r0
    2f04:	bne.n	2fb6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7fa>
    2f06:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f0a:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f0e:	cbz	r0, 2f40 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    2f10:	ldr	r1, [r0, #16]
    2f12:	add.w	lr, r1, #4294967295
    2f16:	str.w	lr, [r0, #16]
    2f1a:	cmp.w	lr, #0
    2f1e:	bne.n	2f40 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    2f20:	ldr.w	r0, [ip, #16]
    2f24:	cbz	r0, 2f40 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    2f26:	ldr.w	lr, [r0]
    2f2a:	str.w	ip, [sp, #12]
    2f2e:	str	r2, [sp, #8]
    2f30:	str	r3, [sp, #4]
    2f32:	ldr.w	r3, [lr, #32]
    2f36:	blx	r3
    2f38:	ldr.w	ip, [sp, #12]
    2f3c:	ldr	r2, [sp, #8]
    2f3e:	ldr	r3, [sp, #4]
    2f40:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2f42:	mov	r0, ip
    2f44:	movs	r1, #20
    2f46:	str	r3, [sp, #4]
    2f48:	bl	ea80 <operator delete(void*, unsigned int)>
    2f4c:	ldr	r3, [sp, #4]
    2f4e:	ldr	r2, [sp, #8]
    2f50:	ldr	r0, [sp, #0]
    2f52:	str	r2, [sp, #8]
    2f54:	movs	r1, #20
    2f56:	str	r3, [sp, #4]
    2f58:	bl	ea80 <operator delete(void*, unsigned int)>
    2f5c:	ldr	r3, [sp, #4]
    2f5e:	ldr	r2, [sp, #8]
    2f60:	str	r3, [sp, #0]
    2f62:	mov	r0, r2
    2f64:	movs	r1, #20
    2f66:	bl	ea80 <operator delete(void*, unsigned int)>
    2f6a:	ldr	r3, [sp, #0]
    2f6c:	b.n	2a0e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f6e:	mov	r0, sl
    2f70:	blx	r3
    2f72:	b.n	2972 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    2f74:	mov	r0, sl
    2f76:	blx	r3
    2f78:	b.n	2a1e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    2f7a:	mov	r0, r3
    2f7c:	blx	r2
    2f7e:	b.n	2a16 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    2f80:	mov	r0, r3
    2f82:	blx	r2
    2f84:	b.n	296a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    2f86:	str	r3, [sp, #0]
    2f88:	mov	r0, r2
    2f8a:	blx	r1
    2f8c:	ldr	r3, [sp, #0]
    2f8e:	b.n	2a0e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    2f90:	str	r3, [sp, #0]
    2f92:	mov	r0, r2
    2f94:	blx	r1
    2f96:	ldr	r3, [sp, #0]
    2f98:	b.n	2962 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    2f9a:	str	r2, [sp, #8]
    2f9c:	str	r3, [sp, #4]
    2f9e:	ldr	r0, [sp, #0]
    2fa0:	blx	r1
    2fa2:	ldr	r2, [sp, #8]
    2fa4:	ldr	r3, [sp, #4]
    2fa6:	b.n	2f60 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    2fa8:	str	r2, [sp, #8]
    2faa:	str	r3, [sp, #4]
    2fac:	ldr	r0, [sp, #0]
    2fae:	blx	r1
    2fb0:	ldr	r2, [sp, #8]
    2fb2:	ldr	r3, [sp, #4]
    2fb4:	b.n	2e88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    2fb6:	str	r2, [sp, #8]
    2fb8:	str	r3, [sp, #4]
    2fba:	mov	r0, ip
    2fbc:	blx	r1
    2fbe:	ldr	r2, [sp, #8]
    2fc0:	ldr	r3, [sp, #4]
    2fc2:	b.n	2f50 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    2fc4:	str	r2, [sp, #8]
    2fc6:	str	r3, [sp, #4]
    2fc8:	mov	r0, ip
    2fca:	blx	r1
    2fcc:	ldr	r2, [sp, #8]
    2fce:	ldr	r3, [sp, #4]
    2fd0:	b.n	2e78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    2fd2:	nop

00002fd4 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>:

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    2fd4:	ldrb.w	r3, [r0, #248]	; 0xf8
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;
    2fd8:	movs	r2, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    2fda:	push	{r4, r5, r6, lr}
    2fdc:	mov	r5, r0
  { if (all_scanned_) return;
    all_scanned_ = true;
    2fde:	strb.w	r2, [r0, #249]	; 0xf9
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    2fe2:	mov	r6, r1

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    2fe4:	cbz	r3, 3004 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x30>
  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
    2fe6:	ldr.w	r3, [r5, #244]	; 0xf4
    2fea:	cbz	r3, 3002 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x2e>
    2fec:	movs	r4, #0
    2fee:	mov	r2, r4
    2ff0:	mov	r1, r6
    2ff2:	mov	r0, r5
    2ff4:	bl	27bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
    2ff8:	ldr.w	r3, [r5, #244]	; 0xf4
    2ffc:	adds	r4, #1
    2ffe:	cmp	r3, r4
    3000:	bhi.n	2fee <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x1a>
    3002:	pop	{r4, r5, r6, pc}
    3004:	bl	1b4c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3008:	b.n	2fe6 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x12>
    300a:	nop

0000300c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>:
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    300c:	push	{r4, r5, lr}
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization
    300e:	cmp.w	r2, #4294967295
    3012:	ite	ne
    3014:	movne	r5, r2
    3016:	moveq	r5, r1

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    3018:	mov	r4, r0
    301a:	sub	sp, #276	; 0x114
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization

      ScanDir(store, parent);
    301c:	mov	r2, r5
    301e:	bl	27bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      follow_sibling_ = true;
    3022:	movs	r3, #1
    3024:	strb.w	r3, [r4, #256]	; 0x100
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    3028:	mov	r2, r5
    302a:	mov	r1, r4
    302c:	mov	r0, sp
    302e:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    3032:	ldr	r3, [sp, #4]
    3034:	str.w	r3, [r4, #252]	; 0xfc
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    3038:	add	sp, #276	; 0x114
    303a:	pop	{r4, r5, pc}

0000303c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)>:
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    303c:	push	{r4, lr}

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    303e:	ldrb.w	r3, [r0, #248]	; 0xf8
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    3042:	sub	sp, #8
    3044:	mov	r4, r0

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3046:	cbz	r3, 306c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x30>
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    GenerateIndex(store);
    if (parent) 
    3048:	cbz	r2, 3056 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x1a>
    304a:	mov	r0, r4
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    304c:	add	sp, #8
    304e:	ldmia.w	sp!, {r4, lr}
    3052:	b.w	300c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    3056:	ldrb.w	r3, [r4, #249]	; 0xf9
    305a:	cbz	r3, 307a <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x3e>
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    305c:	movs	r2, #0
      next_ = 1;
    305e:	movs	r3, #1
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    3060:	strb.w	r2, [r4, #256]	; 0x100
      next_ = 1;
    3064:	str.w	r3, [r4, #252]	; 0xfc
    }
  }
    3068:	add	sp, #8
    306a:	pop	{r4, pc}
    306c:	stmia.w	sp, {r1, r2}
    3070:	bl	1b4c <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3074:	ldmia.w	sp, {r1, r2}
    3078:	b.n	3048 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0xc>
    307a:	mov	r0, r4
    307c:	bl	2fd4 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>
    3080:	b.n	305c <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x20>
    3082:	nop

00003084 <MTPStorage_SD::removeFile(unsigned long, char*)>:
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }

void MTPStorage_SD::removeFile(uint32_t store, char *file)
{ 
    3084:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3088:	add.w	r9, r0, r1, lsl #2
    308c:	sub	sp, #340	; 0x154
    308e:	str	r1, [sp, #12]
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    3090:	ldr.w	r1, [r9, #88]	; 0x58
    3094:	str	r0, [sp, #8]
    3096:	ldr	r3, [r1, #0]
    3098:	str	r2, [sp, #4]
    309a:	ldr	r4, [r3, #0]
    309c:	add	r0, sp, #40	; 0x28
    309e:	movs	r3, #0
    30a0:	blx	r4
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    30a2:	ldr	r0, [sp, #56]	; 0x38
    30a4:	cmp	r0, #0
    30a6:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    30aa:	ldr	r3, [r0, #0]
    30ac:	ldr.w	sl, [pc, #868]	; 3414 <MTPStorage_SD::removeFile(unsigned long, char*)+0x390>
    30b0:	ldr	r3, [r3, #76]	; 0x4c
    30b2:	cmp	r3, sl
    30b4:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    30b8:	ldr	r0, [r0, #16]
    30ba:	cmp	r0, #0
    30bc:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    30c0:	ldr	r3, [r0, #0]
    30c2:	ldr	r3, [r3, #76]	; 0x4c
    30c4:	cmp	r3, sl
    30c6:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    30ca:	ldr	r0, [r0, #16]
    30cc:	cmp	r0, #0
    30ce:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    30d2:	ldr	r3, [r0, #0]
    30d4:	ldr	r3, [r3, #76]	; 0x4c
    30d6:	cmp	r3, sl
    30d8:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    30dc:	ldr	r0, [r0, #16]
    30de:	cmp	r0, #0
    30e0:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    30e4:	ldr	r3, [r0, #0]
    30e6:	ldr	r3, [r3, #76]	; 0x4c
    30e8:	cmp	r3, sl
    30ea:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    30ee:	ldr	r0, [r0, #16]
    30f0:	cmp	r0, #0
    30f2:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    30f6:	ldr	r3, [r0, #0]
    30f8:	ldr	r3, [r3, #76]	; 0x4c
    30fa:	cmp	r3, sl
    30fc:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3100:	ldr	r0, [r0, #16]
    3102:	cmp	r0, #0
    3104:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3108:	ldr	r3, [r0, #0]
    310a:	ldr	r3, [r3, #76]	; 0x4c
    310c:	cmp	r3, sl
    310e:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3112:	ldr	r0, [r0, #16]
    3114:	cmp	r0, #0
    3116:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    311a:	ldr	r3, [r0, #0]
    311c:	ldr	r3, [r3, #76]	; 0x4c
    311e:	cmp	r3, sl
    3120:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3124:	ldr	r0, [r0, #16]
    3126:	cmp	r0, #0
    3128:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    312c:	ldr	r3, [r0, #0]
    312e:	ldr	r3, [r3, #76]	; 0x4c
    3130:	cmp	r3, sl
    3132:	bne.w	35b4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3136:	ldr	r0, [r0, #16]
    3138:	cmp	r0, #0
    313a:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    313e:	ldr	r3, [r0, #0]
    3140:	ldr	r3, [r3, #76]	; 0x4c
    3142:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
    3144:	cmp	r0, #0
    3146:	beq.w	3450 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    314a:	ldr.w	fp, [pc, #700]	; 3408 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
    314e:	ldr.w	r8, [pc, #712]	; 3418 <MTPStorage_SD::removeFile(unsigned long, char*)+0x394>
    3152:	movs	r4, #0
    3154:	mov	r7, fp
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3156:	ldr	r1, [sp, #56]	; 0x38
    3158:	cmp	r1, #0
    315a:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    315e:	ldr	r3, [r1, #0]
    3160:	ldr	r2, [pc, #668]	; (3400 <MTPStorage_SD::removeFile(unsigned long, char*)+0x37c>)
    3162:	ldr	r3, [r3, #80]	; 0x50
    3164:	cmp	r3, r2
    3166:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    316a:	ldr	r1, [r1, #16]
    316c:	cmp	r1, #0
    316e:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3172:	ldr	r3, [r1, #0]
    3174:	ldr	r3, [r3, #80]	; 0x50
    3176:	cmp	r3, r2
    3178:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    317c:	ldr	r1, [r1, #16]
    317e:	cmp	r1, #0
    3180:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3184:	ldr	r3, [r1, #0]
    3186:	ldr	r3, [r3, #80]	; 0x50
    3188:	cmp	r3, r2
    318a:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    318e:	ldr	r1, [r1, #16]
    3190:	cmp	r1, #0
    3192:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3196:	ldr	r3, [r1, #0]
    3198:	ldr	r3, [r3, #80]	; 0x50
    319a:	cmp	r3, r2
    319c:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    31a0:	ldr	r1, [r1, #16]
    31a2:	cmp	r1, #0
    31a4:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    31a8:	ldr	r3, [r1, #0]
    31aa:	ldr	r3, [r3, #80]	; 0x50
    31ac:	cmp	r3, r2
    31ae:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    31b2:	ldr	r1, [r1, #16]
    31b4:	cmp	r1, #0
    31b6:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    31ba:	ldr	r3, [r1, #0]
    31bc:	ldr	r3, [r3, #80]	; 0x50
    31be:	cmp	r3, r2
    31c0:	bne.w	35b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    31c4:	ldr	r1, [r1, #16]
    31c6:	cmp	r1, #0
    31c8:	beq.w	343a <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    31cc:	ldr	r3, [r1, #0]
    31ce:	movs	r2, #0
    31d0:	ldr	r3, [r3, #80]	; 0x50
    31d2:	add	r0, sp, #60	; 0x3c
    31d4:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    31d6:	cbz	r4, 31f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    31d8:	ldr	r3, [r4, #16]
    31da:	subs	r3, #1
    31dc:	str	r3, [r4, #16]
    31de:	cbnz	r3, 31f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    31e0:	ldr	r3, [r4, #0]
    31e2:	ldr	r2, [pc, #544]	; (3404 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    31e4:	ldr	r3, [r3, #32]
    31e6:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    31e8:	mov	r0, r4
    31ea:	bne.w	37a8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x724>
    31ee:	movs	r1, #20
    31f0:	bl	ea80 <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    31f4:	ldr	r4, [sp, #76]	; 0x4c
		if (f) f->refcount++;
    31f6:	cmp	r4, #0
    31f8:	beq.w	3774 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
    31fc:	ldr	r3, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    31fe:	ldr	r2, [r4, #0]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    3200:	adds	r0, r3, #1
    3202:	str	r0, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3204:	ldr	r2, [r2, #68]	; 0x44
    3206:	cmp	r2, r8
    3208:	bne.w	3760 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6dc>
    320c:	cmp	r0, #0
    320e:	beq.w	3740 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3212:	ldr.w	r3, [r3, #1]
    3216:	ldr	r3, [r3, #68]	; 0x44
    3218:	cmp	r3, r8
    321a:	bne.w	3758 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    321e:	ldr	r0, [r0, #16]
    3220:	cmp	r0, #0
    3222:	beq.w	3740 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3226:	ldr	r3, [r0, #0]
    3228:	ldr	r3, [r3, #68]	; 0x44
    322a:	cmp	r3, r8
    322c:	bne.w	3758 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3230:	ldr	r0, [r0, #16]
    3232:	cmp	r0, #0
    3234:	beq.w	3740 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3238:	ldr	r3, [r0, #0]
    323a:	ldr	r3, [r3, #68]	; 0x44
    323c:	cmp	r3, r8
    323e:	bne.w	3758 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3242:	ldr	r0, [r0, #16]
    3244:	cmp	r0, #0
    3246:	beq.w	3740 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    324a:	ldr	r3, [r0, #0]
    324c:	ldr	r3, [r3, #68]	; 0x44
    324e:	cmp	r3, r8
    3250:	bne.w	3758 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3254:	ldr	r0, [r0, #16]
    3256:	cmp	r0, #0
    3258:	beq.w	3740 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    325c:	ldr	r3, [r0, #0]
    325e:	ldr	r3, [r3, #68]	; 0x44
    3260:	blx	r3
    3262:	ldr	r2, [sp, #76]	; 0x4c
    3264:	mov	r6, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3266:	str	r7, [sp, #60]	; 0x3c
    3268:	ldr	r1, [pc, #412]	; (3408 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    326a:	cmp	r2, #0
    326c:	beq.n	3304 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    326e:	ldr	r3, [r2, #16]
    3270:	subs	r3, #1
    3272:	str	r3, [r2, #16]
    3274:	cmp	r3, #0
    3276:	bne.n	3304 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3278:	ldr	r5, [sp, #76]	; 0x4c
    327a:	cmp	r5, #0
    327c:	beq.n	3304 <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    327e:	ldr	r3, [r5, #0]
    3280:	ldr	r2, [pc, #384]	; (3404 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3282:	ldr	r3, [r3, #32]
    3284:	cmp	r3, r2
    3286:	bne.w	376a <MTPStorage_SD::removeFile(unsigned long, char*)+0x6e6>
    328a:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    328c:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    328e:	cmp	r2, #0
    3290:	beq.n	32fc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3292:	ldr	r3, [r2, #16]
    3294:	subs	r3, #1
    3296:	str	r3, [r2, #16]
    3298:	cbnz	r3, 32fc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    329a:	ldr.w	fp, [r5, #16]
    329e:	cmp.w	fp, #0
    32a2:	beq.n	32fc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    32a4:	ldr.w	r3, [fp]
    32a8:	ldr	r2, [pc, #344]	; (3404 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    32aa:	ldr	r3, [r3, #32]
    32ac:	cmp	r3, r2
    32ae:	bne.w	37ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x728>
    32b2:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    32b6:	str.w	r1, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    32ba:	cbz	r2, 32f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    32bc:	ldr	r3, [r2, #16]
    32be:	subs	r3, #1
    32c0:	str	r3, [r2, #16]
    32c2:	cbnz	r3, 32f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    32c4:	ldr.w	r3, [fp, #16]
    32c8:	cbz	r3, 32f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    32ca:	ldr	r2, [r3, #0]
    32cc:	ldr	r1, [pc, #308]	; (3404 <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    32ce:	ldr	r2, [r2, #32]
    32d0:	cmp	r2, r1
    32d2:	bne.w	37b2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x72e>
    32d6:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    32d8:	str	r7, [r3, #0]
    32da:	ldr.w	ip, [pc, #300]	; 3408 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    32de:	cbz	r1, 32ec <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    32e0:	ldr	r2, [r1, #16]
    32e2:	subs	r2, #1
    32e4:	str	r2, [r1, #16]
    32e6:	cmp	r2, #0
    32e8:	beq.w	35cc <MTPStorage_SD::removeFile(unsigned long, char*)+0x548>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    32ec:	mov	r0, r3
    32ee:	movs	r1, #20
    32f0:	bl	ea80 <operator delete(void*, unsigned int)>
    32f4:	mov	r0, fp
    32f6:	movs	r1, #20
    32f8:	bl	ea80 <operator delete(void*, unsigned int)>
    32fc:	mov	r0, r5
    32fe:	movs	r1, #20
    3300:	bl	ea80 <operator delete(void*, unsigned int)>
  {
    File f2;
    while(f2=f1.openNextFile())
    3304:	cmp	r6, #0
    3306:	beq.w	3774 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    330a:	cmp	r4, #0
    330c:	beq.w	3710 <MTPStorage_SD::removeFile(unsigned long, char*)+0x68c>
    3310:	ldr	r2, [r4, #0]
    3312:	ldr	r3, [pc, #248]	; (340c <MTPStorage_SD::removeFile(unsigned long, char*)+0x388>)
    3314:	ldr	r2, [r2, #72]	; 0x48
    3316:	cmp	r2, r3
    3318:	bne.w	374c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c8>
    331c:	ldr	r0, [r4, #16]
    331e:	cmp	r0, #0
    3320:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3324:	ldr	r2, [r0, #0]
    3326:	ldr	r2, [r2, #72]	; 0x48
    3328:	cmp	r2, r3
    332a:	bne.w	374e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    332e:	ldr	r0, [r0, #16]
    3330:	cmp	r0, #0
    3332:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3336:	ldr	r2, [r0, #0]
    3338:	ldr	r2, [r2, #72]	; 0x48
    333a:	cmp	r2, r3
    333c:	bne.w	374e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3340:	ldr	r0, [r0, #16]
    3342:	cmp	r0, #0
    3344:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3348:	ldr	r2, [r0, #0]
    334a:	ldr	r2, [r2, #72]	; 0x48
    334c:	cmp	r2, r3
    334e:	bne.w	374e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3352:	ldr	r0, [r0, #16]
    3354:	cmp	r0, #0
    3356:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    335a:	ldr	r2, [r0, #0]
    335c:	ldr	r2, [r2, #72]	; 0x48
    335e:	cmp	r2, r3
    3360:	bne.w	374e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3364:	ldr	r0, [r0, #16]
    3366:	cmp	r0, #0
    3368:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    336c:	ldr	r2, [r0, #0]
    336e:	ldr	r2, [r2, #72]	; 0x48
    3370:	cmp	r2, r3
    3372:	bne.w	374e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3376:	ldr	r0, [r0, #16]
    3378:	cmp	r0, #0
    337a:	beq.w	3754 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    337e:	ldr	r3, [r0, #0]
    3380:	ldr	r3, [r3, #72]	; 0x48
    3382:	blx	r3
    3384:	mov	r3, r0
    { sprintf(tname,"%s/%s",file,f2.name());
    3386:	add	r5, sp, #80	; 0x50
    3388:	ldr	r1, [pc, #132]	; (3410 <MTPStorage_SD::removeFile(unsigned long, char*)+0x38c>)
    338a:	ldr	r2, [sp, #4]
    338c:	mov	r0, r5
    338e:	bl	104c4 <sprintf>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3392:	ldr	r3, [r4, #0]
    3394:	ldr	r3, [r3, #76]	; 0x4c
    3396:	cmp	r3, sl
    3398:	bne.w	3746 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c2>
    339c:	ldr	r0, [r4, #16]
    339e:	cmp	r0, #0
    33a0:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33a4:	ldr	r3, [r0, #0]
    33a6:	ldr	r3, [r3, #76]	; 0x4c
    33a8:	cmp	r3, sl
    33aa:	bne.w	3748 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    33ae:	ldr	r0, [r0, #16]
    33b0:	cmp	r0, #0
    33b2:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33b6:	ldr	r3, [r0, #0]
    33b8:	ldr	r3, [r3, #76]	; 0x4c
    33ba:	cmp	r3, sl
    33bc:	bne.w	3748 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    33c0:	ldr	r0, [r0, #16]
    33c2:	cmp	r0, #0
    33c4:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33c8:	ldr	r3, [r0, #0]
    33ca:	ldr	r3, [r3, #76]	; 0x4c
    33cc:	cmp	r3, sl
    33ce:	bne.w	3748 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    33d2:	ldr	r0, [r0, #16]
    33d4:	cmp	r0, #0
    33d6:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33da:	ldr	r3, [r0, #0]
    33dc:	ldr	r3, [r3, #76]	; 0x4c
    33de:	cmp	r3, sl
    33e0:	bne.w	3748 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    33e4:	ldr	r0, [r0, #16]
    33e6:	cmp	r0, #0
    33e8:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33ec:	ldr	r3, [r0, #0]
    33ee:	ldr	r3, [r3, #76]	; 0x4c
    33f0:	cmp	r3, sl
    33f2:	bne.w	3748 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    33f6:	ldr	r0, [r0, #16]
    33f8:	cmp	r0, #0
    33fa:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    33fe:	b.n	341c <MTPStorage_SD::removeFile(unsigned long, char*)+0x398>
    3400:	.word	0x00000149
    3404:	.word	0x00000acd
    3408:	.word	0x20000074
    340c:	.word	0x00000129
    3410:	.word	0x20000300
    3414:	.word	0x0000013d
    3418:	.word	0x0000011d
    341c:	ldr	r3, [r0, #0]
    341e:	ldr	r3, [r3, #76]	; 0x4c
    3420:	blx	r3
      if(f2.isDirectory()) removeFile(store,tname); else sd_remove(store,tname);
    3422:	cmp	r0, #0
    3424:	beq.w	371e <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3428:	ldr	r1, [sp, #12]
    342a:	ldr	r0, [sp, #8]
    342c:	mov	r2, r5
    342e:	bl	3084 <MTPStorage_SD::removeFile(unsigned long, char*)>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3432:	ldr	r1, [sp, #56]	; 0x38
    3434:	cmp	r1, #0
    3436:	bne.w	315e <MTPStorage_SD::removeFile(unsigned long, char*)+0xda>
    343a:	movs	r3, #0
    343c:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    3440:	str	r7, [sp, #60]	; 0x3c
    3442:	strb.w	r3, [sp, #64]	; 0x40
    3446:	strb.w	r3, [sp, #72]	; 0x48
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    344a:	str	r3, [sp, #76]	; 0x4c
    344c:	str	r2, [sp, #68]	; 0x44
    344e:	b.n	31d6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    3450:	ldr	r4, [sp, #4]
    3452:	ldr.w	fp, [pc, #368]	; 35c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>
    3456:	mov	r0, r4
    3458:	bl	10680 <strlen>
    345c:	mov	r1, r0
    345e:	mov	r0, r4
    3460:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    3464:	ldr	r0, [pc, #344]	; (35c0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x53c>)
    3466:	bl	e960 <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    346a:	ldr.w	r0, [r9, #88]	; 0x58
    346e:	ldr	r3, [r0, #0]
    3470:	mov	r1, r4
    3472:	ldr	r3, [r3, #16]
    3474:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3476:	ldr	r2, [sp, #56]	; 0x38
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3478:	str.w	fp, [sp, #40]	; 0x28
    347c:	ldr	r1, [pc, #324]	; (35c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    347e:	cmp	r2, #0
    3480:	beq.w	35ae <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3484:	ldr	r3, [r2, #16]
    3486:	subs	r3, #1
    3488:	str	r3, [r2, #16]
    348a:	cmp	r3, #0
    348c:	bne.w	35ae <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3490:	ldr	r4, [sp, #56]	; 0x38
    3492:	cmp	r4, #0
    3494:	beq.w	35ae <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3498:	ldr	r3, [r4, #0]
    349a:	ldr	r0, [pc, #300]	; (35c8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x544>)
    349c:	ldr	r3, [r3, #32]
    349e:	cmp	r3, r0
    34a0:	bne.w	37b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x734>
    34a4:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34a6:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34a8:	cmp	r2, #0
    34aa:	beq.n	35a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    34ac:	ldr	r3, [r2, #16]
    34ae:	subs	r3, #1
    34b0:	str	r3, [r2, #16]
    34b2:	cmp	r3, #0
    34b4:	bne.n	35a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    34b6:	ldr	r5, [r4, #16]
    34b8:	cmp	r5, #0
    34ba:	beq.n	35a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    34bc:	ldr	r3, [r5, #0]
    34be:	ldr	r3, [r3, #32]
    34c0:	cmp	r3, r0
    34c2:	bne.w	37cc <MTPStorage_SD::removeFile(unsigned long, char*)+0x748>
    34c6:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34c8:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34ca:	cmp	r2, #0
    34cc:	beq.n	359e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    34ce:	ldr	r3, [r2, #16]
    34d0:	subs	r3, #1
    34d2:	str	r3, [r2, #16]
    34d4:	cmp	r3, #0
    34d6:	bne.n	359e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    34d8:	ldr	r6, [r5, #16]
    34da:	cmp	r6, #0
    34dc:	beq.n	359e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    34de:	ldr	r3, [r6, #0]
    34e0:	ldr	r3, [r3, #32]
    34e2:	cmp	r3, r0
    34e4:	bne.w	37e0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x75c>
    34e8:	ldr	r2, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34ea:	str.w	fp, [r6]
    34ee:	ldr	r1, [pc, #212]	; (35c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34f0:	cmp	r2, #0
    34f2:	beq.n	3596 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    34f4:	ldr	r3, [r2, #16]
    34f6:	subs	r3, #1
    34f8:	str	r3, [r2, #16]
    34fa:	cmp	r3, #0
    34fc:	bne.n	3596 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    34fe:	ldr	r7, [r6, #16]
    3500:	cmp	r7, #0
    3502:	beq.n	3596 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3504:	ldr	r3, [r7, #0]
    3506:	ldr	r3, [r3, #32]
    3508:	cmp	r3, r0
    350a:	bne.w	37e6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x762>
    350e:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3510:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3512:	cmp	r2, #0
    3514:	beq.n	358e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    3516:	ldr	r3, [r2, #16]
    3518:	subs	r3, #1
    351a:	str	r3, [r2, #16]
    351c:	cmp	r3, #0
    351e:	bne.n	358e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    3520:	ldr.w	r8, [r7, #16]
    3524:	cmp.w	r8, #0
    3528:	beq.n	358e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    352a:	ldr.w	r3, [r8]
    352e:	ldr	r3, [r3, #32]
    3530:	cmp	r3, r0
    3532:	bne.w	3808 <MTPStorage_SD::removeFile(unsigned long, char*)+0x784>
    3536:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    353a:	str.w	fp, [r8]
    353e:	ldr	r1, [pc, #132]	; (35c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3540:	cbz	r2, 3586 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    3542:	ldr	r3, [r2, #16]
    3544:	subs	r3, #1
    3546:	str	r3, [r2, #16]
    3548:	cbnz	r3, 3586 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    354a:	ldr.w	r9, [r8, #16]
    354e:	cmp.w	r9, #0
    3552:	beq.n	3586 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    3554:	ldr.w	r3, [r9]
    3558:	ldr	r3, [r3, #32]
    355a:	cmp	r3, r0
    355c:	bne.w	381e <MTPStorage_SD::removeFile(unsigned long, char*)+0x79a>
    3560:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3564:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3568:	cbz	r2, 357e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    356a:	ldr	r3, [r2, #16]
    356c:	subs	r3, #1
    356e:	str	r3, [r2, #16]
    3570:	cbnz	r3, 357e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    3572:	ldr.w	r0, [r9, #16]
    3576:	cbz	r0, 357e <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    3578:	ldr	r3, [r0, #0]
    357a:	ldr	r3, [r3, #32]
    357c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    357e:	mov	r0, r9
    3580:	movs	r1, #20
    3582:	bl	ea80 <operator delete(void*, unsigned int)>
    3586:	mov	r0, r8
    3588:	movs	r1, #20
    358a:	bl	ea80 <operator delete(void*, unsigned int)>
    358e:	mov	r0, r7
    3590:	movs	r1, #20
    3592:	bl	ea80 <operator delete(void*, unsigned int)>
    3596:	mov	r0, r6
    3598:	movs	r1, #20
    359a:	bl	ea80 <operator delete(void*, unsigned int)>
    359e:	mov	r0, r5
    35a0:	movs	r1, #20
    35a2:	bl	ea80 <operator delete(void*, unsigned int)>
    35a6:	mov	r0, r4
    35a8:	movs	r1, #20
    35aa:	bl	ea80 <operator delete(void*, unsigned int)>
  }
  else
  {
    sd_remove(store,file);
  }
}
    35ae:	add	sp, #340	; 0x154
    35b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    35b4:	blx	r3
    35b6:	b.n	3144 <MTPStorage_SD::removeFile(unsigned long, char*)+0xc0>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    35b8:	movs	r2, #0
    35ba:	add	r0, sp, #60	; 0x3c
    35bc:	blx	r3
    35be:	b.n	31d6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
    35c0:	.word	0x20000cdc
    35c4:	.word	0x20000074
    35c8:	.word	0x00000acd
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    35cc:	ldr	r2, [r3, #16]
    35ce:	cmp	r2, #0
    35d0:	beq.w	32ec <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    35d4:	ldr	r1, [r2, #0]
    35d6:	ldr	r0, [pc, #588]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    35d8:	ldr	r1, [r1, #32]
    35da:	cmp	r1, r0
    35dc:	bne.w	37c2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x73e>
    35e0:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    35e4:	str.w	ip, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    35e8:	cmp.w	lr, #0
    35ec:	beq.w	3702 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    35f0:	ldr.w	r1, [lr, #16]
    35f4:	subs	r1, #1
    35f6:	str.w	r1, [lr, #16]
    35fa:	cmp	r1, #0
    35fc:	bne.w	3702 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    3600:	ldr	r1, [r2, #16]
    3602:	str	r1, [sp, #16]
    3604:	cmp	r1, #0
    3606:	beq.n	3702 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    3608:	ldr	r1, [sp, #16]
    360a:	ldr	r0, [pc, #536]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    360c:	ldr	r1, [r1, #0]
    360e:	ldr	r1, [r1, #32]
    3610:	cmp	r1, r0
    3612:	bne.w	37d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x74e>
    3616:	ldr	r1, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3618:	ldr.w	ip, [pc, #536]	; 3834 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7b0>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    361c:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3620:	str	r7, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3622:	cmp.w	lr, #0
    3626:	beq.n	36f2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    3628:	ldr.w	r1, [lr, #16]
    362c:	subs	r1, #1
    362e:	str.w	r1, [lr, #16]
    3632:	cmp	r1, #0
    3634:	bne.n	36f2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    3636:	ldr	r1, [sp, #16]
    3638:	ldr	r1, [r1, #16]
    363a:	str	r1, [sp, #20]
    363c:	cmp	r1, #0
    363e:	beq.n	36f2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    3640:	ldr	r1, [sp, #20]
    3642:	ldr	r0, [pc, #480]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    3644:	ldr	r1, [r1, #0]
    3646:	ldr	r1, [r1, #32]
    3648:	cmp	r1, r0
    364a:	bne.w	37ec <MTPStorage_SD::removeFile(unsigned long, char*)+0x768>
    364e:	ldr	r0, [sp, #20]
    3650:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3654:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3658:	cmp.w	lr, #0
    365c:	beq.n	36e2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    365e:	ldr.w	r1, [lr, #16]
    3662:	subs	r1, #1
    3664:	str.w	r1, [lr, #16]
    3668:	cmp	r1, #0
    366a:	bne.n	36e2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    366c:	ldr	r1, [sp, #20]
    366e:	ldr	r1, [r1, #16]
    3670:	str	r1, [sp, #24]
    3672:	cmp	r1, #0
    3674:	beq.n	36e2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    3676:	ldr	r1, [sp, #24]
    3678:	ldr	r0, [pc, #424]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    367a:	ldr	r1, [r1, #0]
    367c:	ldr	r1, [r1, #32]
    367e:	cmp	r1, r0
    3680:	bne.w	37fa <MTPStorage_SD::removeFile(unsigned long, char*)+0x776>
    3684:	ldr	r0, [sp, #24]
    3686:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    368a:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    368e:	cmp.w	lr, #0
    3692:	beq.n	36d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    3694:	ldr.w	r1, [lr, #16]
    3698:	subs	r1, #1
    369a:	str.w	r1, [lr, #16]
    369e:	cbnz	r1, 36d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    36a0:	ldr	r1, [sp, #24]
    36a2:	ldr	r1, [r1, #16]
    36a4:	cbz	r1, 36d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    36a6:	ldr	r0, [r1, #0]
    36a8:	ldr	r0, [r0, #32]
    36aa:	mov	lr, r0
    36ac:	ldr	r0, [pc, #372]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    36ae:	cmp	lr, r0
    36b0:	bne.w	380e <MTPStorage_SD::removeFile(unsigned long, char*)+0x78a>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    36b4:	mov	r0, r1
    36b6:	str	r2, [sp, #36]	; 0x24
    36b8:	str.w	r7, [r0], #16
    36bc:	str	r3, [sp, #32]
    36be:	str	r1, [sp, #28]
		invalidate();
    36c0:	bl	15b8 <File::invalidate() [clone .isra.1]>
	}
    36c4:	ldr	r1, [sp, #28]
    36c6:	mov	r0, r1
    36c8:	movs	r1, #20
    36ca:	bl	ea80 <operator delete(void*, unsigned int)>
    36ce:	ldr	r3, [sp, #32]
    36d0:	ldr	r2, [sp, #36]	; 0x24
    36d2:	ldr	r0, [sp, #24]
    36d4:	str	r2, [sp, #32]
    36d6:	movs	r1, #20
    36d8:	str	r3, [sp, #28]
    36da:	bl	ea80 <operator delete(void*, unsigned int)>
    36de:	ldr	r3, [sp, #28]
    36e0:	ldr	r2, [sp, #32]
    36e2:	ldr	r0, [sp, #20]
    36e4:	str	r2, [sp, #28]
    36e6:	movs	r1, #20
    36e8:	str	r3, [sp, #24]
    36ea:	bl	ea80 <operator delete(void*, unsigned int)>
    36ee:	ldr	r3, [sp, #24]
    36f0:	ldr	r2, [sp, #28]
    36f2:	ldr	r0, [sp, #16]
    36f4:	str	r2, [sp, #24]
    36f6:	movs	r1, #20
    36f8:	str	r3, [sp, #20]
    36fa:	bl	ea80 <operator delete(void*, unsigned int)>
    36fe:	ldr	r3, [sp, #20]
    3700:	ldr	r2, [sp, #24]
    3702:	str	r3, [sp, #16]
    3704:	mov	r0, r2
    3706:	movs	r1, #20
    3708:	bl	ea80 <operator delete(void*, unsigned int)>
    370c:	ldr	r3, [sp, #16]
    370e:	b.n	32ec <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    { sprintf(tname,"%s/%s",file,f2.name());
    3710:	add	r5, sp, #80	; 0x50
    3712:	mov	r0, r5
    3714:	ldr	r3, [pc, #272]	; (3828 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    3716:	ldr	r1, [pc, #276]	; (382c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a8>)
    3718:	ldr	r2, [sp, #4]
    371a:	bl	104c4 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    371e:	mov	r0, r5
    3720:	bl	10680 <strlen>
    3724:	mov	r1, r0
    3726:	mov	r0, r5
    3728:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    372c:	ldr	r0, [pc, #256]	; (3830 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7ac>)
    372e:	bl	e960 <Print::println()>
    3732:	ldr.w	r0, [r9, #88]	; 0x58
    3736:	ldr	r3, [r0, #0]
    3738:	mov	r1, r5
    373a:	ldr	r3, [r3, #16]
    373c:	blx	r3
    373e:	b.n	3156 <MTPStorage_SD::removeFile(unsigned long, char*)+0xd2>
    3740:	ldr	r2, [sp, #76]	; 0x4c
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3742:	movs	r6, #0
    3744:	b.n	3266 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3746:	mov	r0, r4
    3748:	blx	r3
    374a:	b.n	3422 <MTPStorage_SD::removeFile(unsigned long, char*)+0x39e>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    374c:	mov	r0, r4
    374e:	blx	r2
    3750:	mov	r3, r0
    3752:	b.n	3386 <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
    3754:	ldr	r3, [pc, #208]	; (3828 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    3756:	b.n	3386 <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3758:	blx	r3
    375a:	ldr	r2, [sp, #76]	; 0x4c
    375c:	mov	r6, r0
    375e:	b.n	3266 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
    3760:	mov	r0, r4
    3762:	blx	r2
    3764:	ldr	r2, [sp, #76]	; 0x4c
    3766:	mov	r6, r0
    3768:	b.n	3266 <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    376a:	mov	r0, r5
    376c:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    376e:	cmp	r6, #0
    3770:	bne.w	330a <MTPStorage_SD::removeFile(unsigned long, char*)+0x286>
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    3774:	ldr.w	r0, [r9, #88]	; 0x58
    3778:	ldr	r1, [sp, #4]
    377a:	ldr	r3, [r0, #0]
    377c:	ldr	r3, [r3, #20]
    377e:	mov	fp, r7
    3780:	blx	r3
    3782:	cmp	r4, #0
    3784:	beq.w	3476 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    3788:	ldr	r3, [r4, #16]
    378a:	subs	r3, #1
    378c:	str	r3, [r4, #16]
    378e:	cmp	r3, #0
    3790:	bne.w	3476 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    3794:	ldr	r3, [r4, #0]
    3796:	ldr	r2, [pc, #140]	; (3824 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    3798:	ldr	r3, [r3, #32]
    379a:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    379c:	mov	r0, r4
    379e:	bne.n	37be <MTPStorage_SD::removeFile(unsigned long, char*)+0x73a>
    37a0:	movs	r1, #20
    37a2:	bl	ea80 <operator delete(void*, unsigned int)>
    37a6:	b.n	3476 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    37a8:	blx	r3
    37aa:	b.n	31f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    37ac:	mov	r0, fp
    37ae:	blx	r3
    37b0:	b.n	32fc <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    37b2:	mov	r0, r3
    37b4:	blx	r2
    37b6:	b.n	32f4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    37b8:	mov	r0, r4
    37ba:	blx	r3
  }
  else
  {
    sd_remove(store,file);
  }
}
    37bc:	b.n	35ae <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    37be:	blx	r3
    37c0:	b.n	3476 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    37c2:	str	r3, [sp, #16]
    37c4:	mov	r0, r2
    37c6:	blx	r1
    37c8:	ldr	r3, [sp, #16]
    37ca:	b.n	32ec <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    37cc:	mov	r0, r5
    37ce:	blx	r3
    37d0:	b.n	35a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    37d2:	str	r2, [sp, #24]
    37d4:	str	r3, [sp, #20]
    37d6:	ldr	r0, [sp, #16]
    37d8:	blx	r1
    37da:	ldr	r2, [sp, #24]
    37dc:	ldr	r3, [sp, #20]
    37de:	b.n	3702 <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    37e0:	mov	r0, r6
    37e2:	blx	r3
    37e4:	b.n	359e <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    37e6:	mov	r0, r7
    37e8:	blx	r3
    37ea:	b.n	3596 <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    37ec:	str	r2, [sp, #28]
    37ee:	str	r3, [sp, #24]
    37f0:	ldr	r0, [sp, #20]
    37f2:	blx	r1
    37f4:	ldr	r2, [sp, #28]
    37f6:	ldr	r3, [sp, #24]
    37f8:	b.n	36f2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    37fa:	str	r2, [sp, #32]
    37fc:	str	r3, [sp, #28]
    37fe:	ldr	r0, [sp, #24]
    3800:	blx	r1
    3802:	ldr	r2, [sp, #32]
    3804:	ldr	r3, [sp, #28]
    3806:	b.n	36e2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    3808:	mov	r0, r8
    380a:	blx	r3
    380c:	b.n	358e <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    380e:	str	r2, [sp, #32]
    3810:	str	r3, [sp, #28]
    3812:	mov	r0, r1
    3814:	mov	r3, lr
    3816:	blx	r3
    3818:	ldr	r2, [sp, #32]
    381a:	ldr	r3, [sp, #28]
    381c:	b.n	36d2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    381e:	mov	r0, r9
    3820:	blx	r3
    3822:	b.n	3586 <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    3824:	.word	0x00000acd
    3828:	.word	0x2000016c
    382c:	.word	0x20000300
    3830:	.word	0x20000cdc
    3834:	.word	0x20000074

00003838 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>:

  bool MTPStorage_SD::DeleteObject(uint32_t object)
    3838:	push	{r4, r5, r6, r7, lr}
    383a:	subw	sp, sp, #1348	; 0x544
    383e:	mov	r5, r0
    3840:	mov	r6, r1
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below

    // first create full filename
    char filename[MAX_FILENAME_LEN];
    ConstructFilename(object, filename, MAX_FILENAME_LEN);
    3842:	mov.w	r3, #256	; 0x100
    3846:	add	r2, sp, #272	; 0x110
    3848:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    Record r = ReadIndexRecord(object);
    384c:	mov	r2, r6
    384e:	mov	r1, r5
    3850:	add	r0, sp, #528	; 0x210
    3852:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    // remove file from storage (assume it is always working)
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    3856:	add	r2, sp, #272	; 0x110
    3858:	ldrh.w	r1, [sp, #542]	; 0x21e
    385c:	mov	r0, r5
    385e:	bl	3084 <MTPStorage_SD::removeFile(unsigned long, char*)>
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    3862:	movs	r3, #0
    WriteIndexRecord(object, r);
    3864:	add	r2, sp, #528	; 0x210
    3866:	mov	r1, r6
    3868:	mov	r0, r5
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    386a:	strb.w	r3, [sp, #544]	; 0x220
    WriteIndexRecord(object, r);
    386e:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    3872:	ldr	r2, [sp, #528]	; 0x210
    3874:	mov	r1, r5
    3876:	add	r0, sp, #800	; 0x320
    3878:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if(t.child==object)
    387c:	ldr	r7, [sp, #804]	; 0x324
    387e:	cmp	r6, r7
    3880:	beq.n	38d2 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x9a>
    }
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
    3882:	add.w	r0, sp, #1072	; 0x430
    3886:	mov	r2, r7
    3888:	mov	r1, r5
    388a:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    388e:	ldr.w	r4, [sp, #1080]	; 0x438
    3892:	cmp	r6, r4
    3894:	bne.n	389a <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x62>
    3896:	b.n	38e6 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0xae>
    3898:	mov	r4, r3
    389a:	mov	r2, r4
    389c:	mov	r1, r5
    389e:	mov	r0, sp
    38a0:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    38a4:	mov.w	r2, #272	; 0x110
    38a8:	mov	r1, sp
    38aa:	add.w	r0, sp, #1072	; 0x430
    38ae:	bl	cfd4 <memcpy>
    38b2:	ldr.w	r3, [sp, #1080]	; 0x438
    38b6:	cmp	r6, r3
    38b8:	bne.n	3898 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x60>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    38ba:	mov	r0, r5
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
      // is points now to junder sibling
      x.sibling = r.sibling;
    38bc:	ldr	r3, [sp, #536]	; 0x218
    38be:	str.w	r3, [sp, #1080]	; 0x438
      WriteIndexRecord(is, x);
    38c2:	add.w	r2, sp, #1072	; 0x430
    38c6:	mov	r1, r4
    38c8:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
    return 1;
  }
    38cc:	addw	sp, sp, #1348	; 0x544
    38d0:	pop	{r4, r5, r6, r7, pc}
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
      WriteIndexRecord(r.parent, t);
    38d2:	mov	r0, r5
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    38d4:	ldr	r3, [sp, #536]	; 0x218
      WriteIndexRecord(r.parent, t);
    38d6:	ldr	r1, [sp, #528]	; 0x210
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    38d8:	str	r3, [sp, #804]	; 0x324
      WriteIndexRecord(r.parent, t);
    38da:	add	r2, sp, #800	; 0x320
    38dc:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    38e0:	addw	sp, sp, #1348	; 0x544
    38e4:	pop	{r4, r5, r6, r7, pc}
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    38e6:	mov	r4, r7
    38e8:	b.n	38ba <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x82>
    38ea:	nop

000038ec <MTPStorage_SD::DeleteObject(unsigned long)>:
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below
    38ec:	adds	r2, r1, #1
    38ee:	beq.n	38fa <MTPStorage_SD::DeleteObject(unsigned long)+0xe>
    sd_remove(store,file);
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    38f0:	push	{r3, lr}
    38f2:	bl	3838 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    38f6:	movs	r0, #1
    38f8:	pop	{r3, pc}
    38fa:	movs	r0, #1
    38fc:	bx	lr
    38fe:	nop

00003900 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>:
  WriteIndexRecord(newHandle,p2);
  return true;
}
/************************************** mSD_Base *******************************/
bool mSD_Base::sd_copy(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{
    3900:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    3904:	add.w	r1, r0, r1, lsl #2
    3908:	mov	r6, r0
    390a:	ldr	r1, [r1, #84]	; 0x54
    390c:	ldr	r0, [r1, #0]
    390e:	subw	sp, sp, #2092	; 0x82c
    3912:	ldr	r4, [r0, #0]
    3914:	mov	r7, r3
    3916:	mov	r0, sp
    3918:	movs	r3, #0
    391a:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    391c:	ldr	r3, [sp, #16]
    391e:	cmp	r3, #0
    3920:	beq.w	3d4a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x44a>
    3924:	ldr	r2, [r3, #0]
    3926:	ldr	r5, [pc, #624]	; (3b98 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x298>)
    3928:	ldr	r2, [r2, #68]	; 0x44
    392a:	cmp	r2, r5
    392c:	bne.w	3ca8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3a8>
    3930:	ldr	r0, [r3, #16]
    3932:	cmp	r0, #0
    3934:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    3938:	ldr	r2, [r0, #0]
    393a:	ldr	r2, [r2, #68]	; 0x44
    393c:	cmp	r2, r5
    393e:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    3942:	ldr	r0, [r0, #16]
    3944:	cmp	r0, #0
    3946:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    394a:	ldr	r2, [r0, #0]
    394c:	ldr	r2, [r2, #68]	; 0x44
    394e:	cmp	r2, r5
    3950:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    3954:	ldr	r0, [r0, #16]
    3956:	cmp	r0, #0
    3958:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    395c:	ldr	r2, [r0, #0]
    395e:	ldr	r2, [r2, #68]	; 0x44
    3960:	cmp	r2, r5
    3962:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    3966:	ldr	r0, [r0, #16]
    3968:	cmp	r0, #0
    396a:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    396e:	ldr	r2, [r0, #0]
    3970:	ldr	r2, [r2, #68]	; 0x44
    3972:	cmp	r2, r5
    3974:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    3978:	ldr	r0, [r0, #16]
    397a:	cmp	r0, #0
    397c:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    3980:	ldr	r2, [r0, #0]
    3982:	ldr	r2, [r2, #68]	; 0x44
    3984:	cmp	r2, r5
    3986:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    398a:	ldr	r0, [r0, #16]
    398c:	cmp	r0, #0
    398e:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    3992:	ldr	r2, [r0, #0]
    3994:	ldr	r2, [r2, #68]	; 0x44
    3996:	cmp	r2, r5
    3998:	bne.w	3caa <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    399c:	ldr	r0, [r0, #16]
    399e:	cmp	r0, #0
    39a0:	beq.w	3b58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    39a4:	ldr	r3, [r0, #0]
    39a6:	ldr	r3, [r3, #68]	; 0x44
    39a8:	blx	r3
    39aa:	mov	r4, r0
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    39ac:	cmp	r4, #0
    39ae:	beq.w	4192 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x892>
    39b2:	add.w	r6, r6, r7, lsl #2
    39b6:	add	r0, sp, #20
    39b8:	ldr	r1, [r6, #84]	; 0x54
    39ba:	ldr.w	r2, [sp, #2128]	; 0x850
    39be:	ldr	r3, [r1, #0]
    39c0:	ldr	r4, [r3, #0]
    39c2:	movs	r3, #2
    39c4:	blx	r4
    39c6:	ldr	r0, [sp, #36]	; 0x24
    39c8:	cmp	r0, #0
    39ca:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    39ce:	ldr	r3, [r0, #0]
    39d0:	ldr	r3, [r3, #68]	; 0x44
    39d2:	cmp	r3, r5
    39d4:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    39d8:	ldr	r0, [r0, #16]
    39da:	cmp	r0, #0
    39dc:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    39e0:	ldr	r3, [r0, #0]
    39e2:	ldr	r3, [r3, #68]	; 0x44
    39e4:	cmp	r3, r5
    39e6:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    39ea:	ldr	r0, [r0, #16]
    39ec:	cmp	r0, #0
    39ee:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    39f2:	ldr	r3, [r0, #0]
    39f4:	ldr	r3, [r3, #68]	; 0x44
    39f6:	cmp	r3, r5
    39f8:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    39fc:	ldr	r0, [r0, #16]
    39fe:	cmp	r0, #0
    3a00:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a04:	ldr	r3, [r0, #0]
    3a06:	ldr	r3, [r3, #68]	; 0x44
    3a08:	cmp	r3, r5
    3a0a:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a0e:	ldr	r0, [r0, #16]
    3a10:	cmp	r0, #0
    3a12:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a16:	ldr	r3, [r0, #0]
    3a18:	ldr	r3, [r3, #68]	; 0x44
    3a1a:	cmp	r3, r5
    3a1c:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a20:	ldr	r0, [r0, #16]
    3a22:	cmp	r0, #0
    3a24:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a28:	ldr	r3, [r0, #0]
    3a2a:	ldr	r3, [r3, #68]	; 0x44
    3a2c:	cmp	r3, r5
    3a2e:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a32:	ldr	r0, [r0, #16]
    3a34:	cmp	r0, #0
    3a36:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a3a:	ldr	r3, [r0, #0]
    3a3c:	ldr	r3, [r3, #68]	; 0x44
    3a3e:	cmp	r3, r5
    3a40:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a44:	ldr	r0, [r0, #16]
    3a46:	cmp	r0, #0
    3a48:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a4c:	ldr	r3, [r0, #0]
    3a4e:	ldr	r3, [r3, #68]	; 0x44
    3a50:	cmp	r3, r5
    3a52:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a56:	ldr	r0, [r0, #16]
    3a58:	cmp	r0, #0
    3a5a:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a5e:	ldr	r3, [r0, #0]
    3a60:	ldr	r3, [r3, #68]	; 0x44
    3a62:	cmp	r3, r5
    3a64:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a68:	ldr	r0, [r0, #16]
    3a6a:	cmp	r0, #0
    3a6c:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a70:	ldr	r3, [r0, #0]
    3a72:	ldr	r3, [r3, #68]	; 0x44
    3a74:	cmp	r3, r5
    3a76:	bne.w	3e7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    3a7a:	ldr	r0, [r0, #16]
    3a7c:	cmp	r0, #0
    3a7e:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a82:	ldr	r3, [r0, #0]
    3a84:	ldr	r3, [r3, #68]	; 0x44
    3a86:	blx	r3
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    3a88:	cmp	r0, #0
    3a8a:	beq.w	3cb0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    3a8e:	ldr	r5, [pc, #268]	; (3b9c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x29c>)
    3a90:	mov.w	r4, #4294967295
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    3a94:	ldr	r3, [sp, #16]
    3a96:	cmp	r3, #0
    3a98:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3a9c:	ldr	r1, [r3, #0]
    3a9e:	ldr	r2, [r1, #16]
    3aa0:	cmp	r2, r5
    3aa2:	bne.w	4088 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x788>
    3aa6:	ldr	r2, [r3, #16]
    3aa8:	cmp	r2, #0
    3aaa:	beq.w	408e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x78e>
    3aae:	ldr	r0, [r2, #0]
    3ab0:	ldr	r6, [r0, #16]
    3ab2:	cmp	r6, r5
    3ab4:	bne.w	3f30 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x630>
    3ab8:	ldr	r0, [r2, #16]
    3aba:	cmp	r0, #0
    3abc:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3ac0:	ldr	r6, [r0, #0]
    3ac2:	ldr	r6, [r6, #16]
    3ac4:	cmp	r6, r5
    3ac6:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3aca:	ldr	r0, [r0, #16]
    3acc:	cmp	r0, #0
    3ace:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3ad2:	ldr	r6, [r0, #0]
    3ad4:	ldr	r6, [r6, #16]
    3ad6:	cmp	r6, r5
    3ad8:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3adc:	ldr	r0, [r0, #16]
    3ade:	cmp	r0, #0
    3ae0:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3ae4:	ldr	r6, [r0, #0]
    3ae6:	ldr	r6, [r6, #16]
    3ae8:	cmp	r6, r5
    3aea:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3aee:	ldr	r0, [r0, #16]
    3af0:	cmp	r0, #0
    3af2:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3af6:	ldr	r6, [r0, #0]
    3af8:	ldr	r6, [r6, #16]
    3afa:	cmp	r6, r5
    3afc:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3b00:	ldr	r0, [r0, #16]
    3b02:	cmp	r0, #0
    3b04:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3b08:	ldr	r6, [r0, #0]
    3b0a:	ldr	r6, [r6, #16]
    3b0c:	cmp	r6, r5
    3b0e:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3b12:	ldr	r0, [r0, #16]
    3b14:	cmp	r0, #0
    3b16:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3b1a:	ldr	r6, [r0, #0]
    3b1c:	ldr	r6, [r6, #16]
    3b1e:	cmp	r6, r5
    3b20:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3b24:	ldr	r0, [r0, #16]
    3b26:	cmp	r0, #0
    3b28:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3b2c:	ldr	r6, [r0, #0]
    3b2e:	ldr	r6, [r6, #16]
    3b30:	cmp	r6, r5
    3b32:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3b36:	ldr	r0, [r0, #16]
    3b38:	cmp	r0, #0
    3b3a:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3b3e:	ldr	r6, [r0, #0]
    3b40:	ldr	r6, [r6, #16]
    3b42:	cmp	r6, r5
    3b44:	bne.w	3f32 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    3b48:	ldr	r0, [r0, #16]
    3b4a:	cmp	r0, #0
    3b4c:	beq.w	3e7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    3b50:	ldr	r3, [r0, #0]
    3b52:	ldr	r3, [r3, #16]
    3b54:	blx	r3
    3b56:	b.n	3f34 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3b58:	ldr	r6, [pc, #68]	; (3ba0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a0>)
    3b5a:	str	r6, [sp, #0]
    3b5c:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3b5e:	ldr	r2, [r3, #16]
    3b60:	subs	r2, #1
    3b62:	str	r2, [r3, #16]
    3b64:	cbnz	r2, 3b8c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    3b66:	ldr	r5, [sp, #16]
    3b68:	cbz	r5, 3b8c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    3b6a:	ldr	r3, [r5, #0]
    3b6c:	ldr	r2, [pc, #52]	; (3ba4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a4>)
    3b6e:	ldr	r3, [r3, #32]
    3b70:	cmp	r3, r2
    3b72:	bne.w	4126 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x826>
    3b76:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3b78:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3b7a:	cbz	r1, 3b84 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    3b7c:	ldr	r3, [r1, #16]
    3b7e:	subs	r3, #1
    3b80:	str	r3, [r1, #16]
    3b82:	cbz	r3, 3ba8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a8>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3b84:	mov	r0, r5
    3b86:	movs	r1, #20
    3b88:	bl	ea80 <operator delete(void*, unsigned int)>
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    3b8c:	mov	r0, r4
    3b8e:	addw	sp, sp, #2092	; 0x82c
    3b92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3b96:	nop
    3b98:	.word	0x0000011d
    3b9c:	.word	0x000000a5
    3ba0:	.word	0x20000074
    3ba4:	.word	0x00000acd
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3ba8:	ldr	r7, [r5, #16]
    3baa:	cmp	r7, #0
    3bac:	beq.n	3b84 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    3bae:	ldr	r3, [r7, #0]
    3bb0:	ldr	r3, [r3, #32]
    3bb2:	cmp	r3, r2
    3bb4:	bne.w	4148 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x848>
    3bb8:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3bba:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3bbc:	cmp	r1, #0
    3bbe:	beq.n	3c9e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    3bc0:	ldr	r3, [r1, #16]
    3bc2:	subs	r3, #1
    3bc4:	str	r3, [r1, #16]
    3bc6:	cmp	r3, #0
    3bc8:	bne.n	3c9e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    3bca:	ldr.w	r8, [r7, #16]
    3bce:	cmp.w	r8, #0
    3bd2:	beq.n	3c9e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    3bd4:	ldr.w	r3, [r8]
    3bd8:	ldr	r3, [r3, #32]
    3bda:	cmp	r3, r2
    3bdc:	bne.w	416e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x86e>
    3be0:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3be4:	str.w	r6, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3be8:	cmp	r1, #0
    3bea:	beq.n	3c96 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    3bec:	ldr	r3, [r1, #16]
    3bee:	subs	r3, #1
    3bf0:	str	r3, [r1, #16]
    3bf2:	cmp	r3, #0
    3bf4:	bne.n	3c96 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    3bf6:	ldr.w	r9, [r8, #16]
    3bfa:	cmp.w	r9, #0
    3bfe:	beq.n	3c96 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    3c00:	ldr.w	r3, [r9]
    3c04:	ldr	r3, [r3, #32]
    3c06:	cmp	r3, r2
    3c08:	bne.w	4174 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x874>
    3c0c:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3c10:	str.w	r6, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3c14:	cmp	r1, #0
    3c16:	beq.n	3c8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    3c18:	ldr	r3, [r1, #16]
    3c1a:	subs	r3, #1
    3c1c:	str	r3, [r1, #16]
    3c1e:	cmp	r3, #0
    3c20:	bne.n	3c8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    3c22:	ldr.w	sl, [r9, #16]
    3c26:	cmp.w	sl, #0
    3c2a:	beq.n	3c8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    3c2c:	ldr.w	r3, [sl]
    3c30:	ldr	r3, [r3, #32]
    3c32:	cmp	r3, r2
    3c34:	bne.w	4186 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x886>
    3c38:	ldr.w	r1, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3c3c:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3c40:	cbz	r1, 3c86 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    3c42:	ldr	r3, [r1, #16]
    3c44:	subs	r3, #1
    3c46:	str	r3, [r1, #16]
    3c48:	cbnz	r3, 3c86 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    3c4a:	ldr.w	fp, [sl, #16]
    3c4e:	cmp.w	fp, #0
    3c52:	beq.n	3c86 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    3c54:	ldr.w	r3, [fp]
    3c58:	ldr	r3, [r3, #32]
    3c5a:	cmp	r3, r2
    3c5c:	bne.w	418c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x88c>
    3c60:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3c64:	str.w	r6, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3c68:	cbz	r2, 3c7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    3c6a:	ldr	r3, [r2, #16]
    3c6c:	subs	r3, #1
    3c6e:	str	r3, [r2, #16]
    3c70:	cbnz	r3, 3c7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    3c72:	ldr.w	r0, [fp, #16]
    3c76:	cbz	r0, 3c7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    3c78:	ldr	r3, [r0, #0]
    3c7a:	ldr	r3, [r3, #32]
    3c7c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3c7e:	mov	r0, fp
    3c80:	movs	r1, #20
    3c82:	bl	ea80 <operator delete(void*, unsigned int)>
    3c86:	mov	r0, sl
    3c88:	movs	r1, #20
    3c8a:	bl	ea80 <operator delete(void*, unsigned int)>
    3c8e:	mov	r0, r9
    3c90:	movs	r1, #20
    3c92:	bl	ea80 <operator delete(void*, unsigned int)>
    3c96:	mov	r0, r8
    3c98:	movs	r1, #20
    3c9a:	bl	ea80 <operator delete(void*, unsigned int)>
    3c9e:	mov	r0, r7
    3ca0:	movs	r1, #20
    3ca2:	bl	ea80 <operator delete(void*, unsigned int)>
    3ca6:	b.n	3b84 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3ca8:	mov	r0, r3
    3caa:	blx	r2
    3cac:	mov	r4, r0
    3cae:	b.n	39ac <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0xac>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3cb0:	ldr	r0, [sp, #16]
    3cb2:	cmp	r0, #0
    3cb4:	beq.n	3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3cb6:	ldr	r3, [r0, #0]
    3cb8:	ldr	r1, [pc, #616]	; (3f24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    3cba:	ldr	r3, [r3, #64]	; 0x40
    3cbc:	cmp	r3, r1
    3cbe:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3cc2:	ldr	r0, [r0, #16]
    3cc4:	cmp	r0, #0
    3cc6:	beq.n	3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3cc8:	ldr	r3, [r0, #0]
    3cca:	ldr	r3, [r3, #64]	; 0x40
    3ccc:	cmp	r3, r1
    3cce:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3cd2:	ldr	r0, [r0, #16]
    3cd4:	cmp	r0, #0
    3cd6:	beq.n	3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3cd8:	ldr	r3, [r0, #0]
    3cda:	ldr	r3, [r3, #64]	; 0x40
    3cdc:	cmp	r3, r1
    3cde:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3ce2:	ldr	r0, [r0, #16]
    3ce4:	cmp	r0, #0
    3ce6:	beq.n	3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3ce8:	ldr	r3, [r0, #0]
    3cea:	ldr	r3, [r3, #64]	; 0x40
    3cec:	cmp	r3, r1
    3cee:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3cf2:	ldr	r0, [r0, #16]
    3cf4:	cmp	r0, #0
    3cf6:	beq.n	3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3cf8:	ldr	r3, [r0, #0]
    3cfa:	ldr	r3, [r3, #64]	; 0x40
    3cfc:	cmp	r3, r1
    3cfe:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3d02:	ldr	r0, [r0, #16]
    3d04:	cbz	r0, 3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3d06:	ldr	r3, [r0, #0]
    3d08:	ldr	r3, [r3, #64]	; 0x40
    3d0a:	cmp	r3, r1
    3d0c:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3d10:	ldr	r0, [r0, #16]
    3d12:	cbz	r0, 3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3d14:	ldr	r3, [r0, #0]
    3d16:	ldr	r3, [r3, #64]	; 0x40
    3d18:	cmp	r3, r1
    3d1a:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3d1e:	ldr	r0, [r0, #16]
    3d20:	cbz	r0, 3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3d22:	ldr	r3, [r0, #0]
    3d24:	ldr	r3, [r3, #64]	; 0x40
    3d26:	cmp	r3, r1
    3d28:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3d2c:	ldr	r0, [r0, #16]
    3d2e:	cbz	r0, 3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3d30:	ldr	r3, [r0, #0]
    3d32:	ldr	r3, [r3, #64]	; 0x40
    3d34:	cmp	r3, r1
    3d36:	bne.w	3e72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    3d3a:	ldr	r0, [r0, #16]
    3d3c:	cbz	r0, 3d56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    3d3e:	ldr	r3, [r0, #0]
    3d40:	ldr	r3, [r3, #64]	; 0x40
    3d42:	blx	r3
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    3d44:	movs	r4, #0
    3d46:	ldr	r3, [sp, #36]	; 0x24
    3d48:	b.n	3d5a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    3d4a:	mov	r4, r3
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    3d4c:	mov	r0, r4
    3d4e:	addw	sp, sp, #2092	; 0x82c
    3d52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3d56:	ldr	r3, [sp, #36]	; 0x24
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    3d58:	movs	r4, #0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d5a:	ldr	r6, [pc, #460]	; (3f28 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
    3d5c:	str	r6, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d5e:	cmp	r3, #0
    3d60:	beq.w	3e66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    3d64:	ldr	r2, [r3, #16]
    3d66:	subs	r2, #1
    3d68:	str	r2, [r3, #16]
    3d6a:	cmp	r2, #0
    3d6c:	bne.n	3e66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    3d6e:	ldr	r5, [sp, #36]	; 0x24
    3d70:	cmp	r5, #0
    3d72:	beq.n	3e66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    3d74:	ldr	r3, [r5, #0]
    3d76:	ldr	r2, [pc, #436]	; (3f2c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x62c>)
    3d78:	ldr	r3, [r3, #32]
    3d7a:	cmp	r3, r2
    3d7c:	bne.w	414e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x84e>
    3d80:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d82:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d84:	cmp	r1, #0
    3d86:	beq.n	3e5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    3d88:	ldr	r3, [r1, #16]
    3d8a:	subs	r3, #1
    3d8c:	str	r3, [r1, #16]
    3d8e:	cmp	r3, #0
    3d90:	bne.n	3e5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    3d92:	ldr	r7, [r5, #16]
    3d94:	cmp	r7, #0
    3d96:	beq.n	3e5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    3d98:	ldr	r3, [r7, #0]
    3d9a:	ldr	r3, [r3, #32]
    3d9c:	cmp	r3, r2
    3d9e:	bne.w	4168 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x868>
    3da2:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3da4:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3da6:	cmp	r1, #0
    3da8:	beq.n	3e56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    3daa:	ldr	r3, [r1, #16]
    3dac:	subs	r3, #1
    3dae:	str	r3, [r1, #16]
    3db0:	cmp	r3, #0
    3db2:	bne.n	3e56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    3db4:	ldr.w	r8, [r7, #16]
    3db8:	cmp.w	r8, #0
    3dbc:	beq.n	3e56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    3dbe:	ldr.w	r3, [r8]
    3dc2:	ldr	r3, [r3, #32]
    3dc4:	cmp	r3, r2
    3dc6:	bne.w	417a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x87a>
    3dca:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3dce:	str.w	r6, [r8]
    3dd2:	ldr	r0, [pc, #340]	; (3f28 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3dd4:	cmp	r1, #0
    3dd6:	beq.n	3e4e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    3dd8:	ldr	r3, [r1, #16]
    3dda:	subs	r3, #1
    3ddc:	str	r3, [r1, #16]
    3dde:	cmp	r3, #0
    3de0:	bne.n	3e4e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    3de2:	ldr.w	r9, [r8, #16]
    3de6:	cmp.w	r9, #0
    3dea:	beq.n	3e4e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    3dec:	ldr.w	r3, [r9]
    3df0:	ldr	r3, [r3, #32]
    3df2:	cmp	r3, r2
    3df4:	bne.w	4180 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x880>
    3df8:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3dfc:	str.w	r0, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3e00:	cbz	r1, 3e46 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    3e02:	ldr	r3, [r1, #16]
    3e04:	subs	r3, #1
    3e06:	str	r3, [r1, #16]
    3e08:	cbnz	r3, 3e46 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    3e0a:	ldr.w	sl, [r9, #16]
    3e0e:	cmp.w	sl, #0
    3e12:	beq.n	3e46 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    3e14:	ldr.w	r3, [sl]
    3e18:	ldr	r3, [r3, #32]
    3e1a:	cmp	r3, r2
    3e1c:	bne.w	419c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x89c>
    3e20:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3e24:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3e28:	cbz	r2, 3e3e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    3e2a:	ldr	r3, [r2, #16]
    3e2c:	subs	r3, #1
    3e2e:	str	r3, [r2, #16]
    3e30:	cbnz	r3, 3e3e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    3e32:	ldr.w	r0, [sl, #16]
    3e36:	cbz	r0, 3e3e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    3e38:	ldr	r3, [r0, #0]
    3e3a:	ldr	r3, [r3, #32]
    3e3c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3e3e:	mov	r0, sl
    3e40:	movs	r1, #20
    3e42:	bl	ea80 <operator delete(void*, unsigned int)>
    3e46:	mov	r0, r9
    3e48:	movs	r1, #20
    3e4a:	bl	ea80 <operator delete(void*, unsigned int)>
    3e4e:	mov	r0, r8
    3e50:	movs	r1, #20
    3e52:	bl	ea80 <operator delete(void*, unsigned int)>
    3e56:	mov	r0, r7
    3e58:	movs	r1, #20
    3e5a:	bl	ea80 <operator delete(void*, unsigned int)>
    3e5e:	mov	r0, r5
    3e60:	movs	r1, #20
    3e62:	bl	ea80 <operator delete(void*, unsigned int)>
    3e66:	ldr	r3, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3e68:	str	r6, [sp, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3e6a:	cmp	r3, #0
    3e6c:	bne.w	3b5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x25e>
    3e70:	b.n	3b8c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3e72:	blx	r3
    3e74:	movs	r4, #0
    3e76:	ldr	r3, [sp, #36]	; 0x24
    3e78:	b.n	3d5a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3e7a:	blx	r3
    3e7c:	b.n	3a88 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x188>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3e7e:	ldr	r5, [r1, #64]	; 0x40
    3e80:	ldr	r1, [pc, #160]	; (3f24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    3e82:	cmp	r5, r1
    3e84:	bne.w	4154 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    3e88:	mov	r0, r2
    3e8a:	ldr	r3, [r0, #0]
    3e8c:	ldr	r3, [r3, #64]	; 0x40
    3e8e:	cmp	r3, r1
    3e90:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3e94:	ldr	r0, [r0, #16]
    3e96:	cmp	r0, #0
    3e98:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3e9c:	ldr	r3, [r0, #0]
    3e9e:	ldr	r3, [r3, #64]	; 0x40
    3ea0:	cmp	r3, r1
    3ea2:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3ea6:	ldr	r0, [r0, #16]
    3ea8:	cmp	r0, #0
    3eaa:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3eae:	ldr	r3, [r0, #0]
    3eb0:	ldr	r3, [r3, #64]	; 0x40
    3eb2:	cmp	r3, r1
    3eb4:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3eb8:	ldr	r0, [r0, #16]
    3eba:	cmp	r0, #0
    3ebc:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3ec0:	ldr	r3, [r0, #0]
    3ec2:	ldr	r3, [r3, #64]	; 0x40
    3ec4:	cmp	r3, r1
    3ec6:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3eca:	ldr	r0, [r0, #16]
    3ecc:	cmp	r0, #0
    3ece:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3ed2:	ldr	r3, [r0, #0]
    3ed4:	ldr	r3, [r3, #64]	; 0x40
    3ed6:	cmp	r3, r1
    3ed8:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3edc:	ldr	r0, [r0, #16]
    3ede:	cmp	r0, #0
    3ee0:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3ee4:	ldr	r3, [r0, #0]
    3ee6:	ldr	r3, [r3, #64]	; 0x40
    3ee8:	cmp	r3, r1
    3eea:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3eee:	ldr	r0, [r0, #16]
    3ef0:	cmp	r0, #0
    3ef2:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3ef6:	ldr	r3, [r0, #0]
    3ef8:	ldr	r3, [r3, #64]	; 0x40
    3efa:	cmp	r3, r1
    3efc:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3f00:	ldr	r0, [r0, #16]
    3f02:	cmp	r0, #0
    3f04:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3f08:	ldr	r3, [r0, #0]
    3f0a:	ldr	r3, [r3, #64]	; 0x40
    3f0c:	cmp	r3, r1
    3f0e:	bne.w	4144 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    3f12:	ldr	r0, [r0, #16]
    3f14:	cmp	r0, #0
    3f16:	beq.w	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3f1a:	ldr	r3, [r0, #0]
    3f1c:	ldr	r3, [r3, #64]	; 0x40
    3f1e:	blx	r3
    3f20:	b.n	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    3f22:	nop
    3f24:	.word	0x00000111
    3f28:	.word	0x20000074
    3f2c:	.word	0x00000acd
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    3f30:	mov	r0, r2
    3f32:	blx	r6

  while(f1.available()>0)
    3f34:	cmp	r0, #0
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    3f36:	ldr	r3, [sp, #16]
    3f38:	ble.n	3fe4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e4>
    3f3a:	cmp	r3, #0
    3f3c:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f3e:	ldr	r1, [r3, #0]
    3f40:	ldr	r2, [pc, #536]	; (415c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x85c>)
    3f42:	ldr	r4, [r1, #40]	; 0x28
    3f44:	cmp	r4, r2
    3f46:	bne.n	3fc6 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c6>
    3f48:	ldr	r0, [r3, #16]
    3f4a:	cmp	r0, #0
    3f4c:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f4e:	ldr	r1, [r0, #0]
    3f50:	ldr	r4, [r1, #40]	; 0x28
    3f52:	cmp	r4, r2
    3f54:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f56:	ldr	r0, [r0, #16]
    3f58:	cmp	r0, #0
    3f5a:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f5c:	ldr	r1, [r0, #0]
    3f5e:	ldr	r4, [r1, #40]	; 0x28
    3f60:	cmp	r4, r2
    3f62:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f64:	ldr	r0, [r0, #16]
    3f66:	cmp	r0, #0
    3f68:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f6a:	ldr	r1, [r0, #0]
    3f6c:	ldr	r4, [r1, #40]	; 0x28
    3f6e:	cmp	r4, r2
    3f70:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f72:	ldr	r0, [r0, #16]
    3f74:	cmp	r0, #0
    3f76:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f78:	ldr	r1, [r0, #0]
    3f7a:	ldr	r4, [r1, #40]	; 0x28
    3f7c:	cmp	r4, r2
    3f7e:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f80:	ldr	r0, [r0, #16]
    3f82:	cmp	r0, #0
    3f84:	beq.n	3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f86:	ldr	r1, [r0, #0]
    3f88:	ldr	r4, [r1, #40]	; 0x28
    3f8a:	cmp	r4, r2
    3f8c:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f8e:	ldr	r0, [r0, #16]
    3f90:	cbz	r0, 3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f92:	ldr	r1, [r0, #0]
    3f94:	ldr	r4, [r1, #40]	; 0x28
    3f96:	cmp	r4, r2
    3f98:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3f9a:	ldr	r0, [r0, #16]
    3f9c:	cbz	r0, 3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3f9e:	ldr	r1, [r0, #0]
    3fa0:	ldr	r4, [r1, #40]	; 0x28
    3fa2:	cmp	r4, r2
    3fa4:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3fa6:	ldr	r0, [r0, #16]
    3fa8:	cbz	r0, 3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3faa:	ldr	r1, [r0, #0]
    3fac:	ldr	r4, [r1, #40]	; 0x28
    3fae:	cmp	r4, r2
    3fb0:	bne.n	3fc8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    3fb2:	ldr	r0, [r0, #16]
    3fb4:	cbz	r0, 3fec <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    3fb6:	ldr	r3, [r0, #0]
    3fb8:	mov.w	r2, #2048	; 0x800
    3fbc:	ldr	r3, [r3, #40]	; 0x28
    3fbe:	add	r1, sp, #40	; 0x28
    3fc0:	blx	r3
    3fc2:	mov	r2, r0
    3fc4:	b.n	3fd2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6d2>
    3fc6:	mov	r0, r3
    3fc8:	mov.w	r2, #2048	; 0x800
    3fcc:	add	r1, sp, #40	; 0x28
    3fce:	blx	r4
    3fd0:	mov	r2, r0
  {
    nd=f1.read(buffer,nbuf);
    if(nd<0) break;     // read error
    3fd2:	subs	r4, r2, #0
    3fd4:	blt.n	3fe2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e2>
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    3fd6:	ldr	r0, [sp, #36]	; 0x24
    3fd8:	cbnz	r0, 3ff8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6f8>
    f2.write(buffer,nd);
    if(nd<nbuf) break;  // end of file
    3fda:	cmp.w	r4, #2048	; 0x800
    3fde:	bge.w	3a94 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x194>
    3fe2:	ldr	r3, [sp, #16]
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3fe4:	cmp	r3, #0
    3fe6:	bne.w	4132 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x832>
    3fea:	b.n	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    3fec:	ldr	r0, [sp, #36]	; 0x24
    3fee:	cmp	r0, #0
    3ff0:	beq.w	412c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x82c>
    3ff4:	movs	r2, #0
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    3ff6:	mov	r4, r2
    3ff8:	ldr	r1, [r0, #0]
    3ffa:	ldr	r3, [pc, #356]	; (4160 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x860>)
    3ffc:	ldr	r6, [r1, #44]	; 0x2c
    3ffe:	cmp	r6, r3
    4000:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4002:	ldr	r0, [r0, #16]
    4004:	cmp	r0, #0
    4006:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4008:	ldr	r1, [r0, #0]
    400a:	ldr	r6, [r1, #44]	; 0x2c
    400c:	cmp	r6, r3
    400e:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4010:	ldr	r0, [r0, #16]
    4012:	cmp	r0, #0
    4014:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4016:	ldr	r1, [r0, #0]
    4018:	ldr	r6, [r1, #44]	; 0x2c
    401a:	cmp	r6, r3
    401c:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    401e:	ldr	r0, [r0, #16]
    4020:	cmp	r0, #0
    4022:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4024:	ldr	r1, [r0, #0]
    4026:	ldr	r6, [r1, #44]	; 0x2c
    4028:	cmp	r6, r3
    402a:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    402c:	ldr	r0, [r0, #16]
    402e:	cmp	r0, #0
    4030:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4032:	ldr	r1, [r0, #0]
    4034:	ldr	r6, [r1, #44]	; 0x2c
    4036:	cmp	r6, r3
    4038:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    403a:	ldr	r0, [r0, #16]
    403c:	cmp	r0, #0
    403e:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4040:	ldr	r1, [r0, #0]
    4042:	ldr	r6, [r1, #44]	; 0x2c
    4044:	cmp	r6, r3
    4046:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4048:	ldr	r0, [r0, #16]
    404a:	cmp	r0, #0
    404c:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    404e:	ldr	r1, [r0, #0]
    4050:	ldr	r6, [r1, #44]	; 0x2c
    4052:	cmp	r6, r3
    4054:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4056:	ldr	r0, [r0, #16]
    4058:	cmp	r0, #0
    405a:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    405c:	ldr	r1, [r0, #0]
    405e:	ldr	r6, [r1, #44]	; 0x2c
    4060:	cmp	r6, r3
    4062:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4064:	ldr	r0, [r0, #16]
    4066:	cmp	r0, #0
    4068:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    406a:	ldr	r1, [r0, #0]
    406c:	ldr	r6, [r1, #44]	; 0x2c
    406e:	cmp	r6, r3
    4070:	bne.n	4082 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4072:	ldr	r0, [r0, #16]
    4074:	cmp	r0, #0
    4076:	beq.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4078:	ldr	r3, [r0, #0]
    407a:	add	r1, sp, #40	; 0x28
    407c:	ldr	r3, [r3, #44]	; 0x2c
    407e:	blx	r3
    4080:	b.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4082:	add	r1, sp, #40	; 0x28
    4084:	blx	r6
    4086:	b.n	3fda <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4088:	mov	r0, r3
    408a:	blx	r2
    408c:	b.n	3f34 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    408e:	ldr	r5, [r1, #64]	; 0x40
    4090:	ldr	r2, [pc, #208]	; (4164 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4092:	cmp	r5, r2
    4094:	bne.n	4154 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4096:	ldr	r3, [sp, #36]	; 0x24
    4098:	cmp	r3, #0
    409a:	beq.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    409c:	ldr	r2, [r3, #0]
    409e:	ldr	r1, [pc, #196]	; (4164 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    40a0:	ldr	r2, [r2, #64]	; 0x40
    40a2:	cmp	r2, r1
    40a4:	bne.n	411a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81a>
    40a6:	ldr	r0, [r3, #16]
    40a8:	cmp	r0, #0
    40aa:	beq.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40ac:	ldr	r2, [r0, #0]
    40ae:	ldr	r2, [r2, #64]	; 0x40
    40b0:	cmp	r2, r1
    40b2:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40b4:	ldr	r0, [r0, #16]
    40b6:	cmp	r0, #0
    40b8:	beq.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40ba:	ldr	r2, [r0, #0]
    40bc:	ldr	r2, [r2, #64]	; 0x40
    40be:	cmp	r2, r1
    40c0:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40c2:	ldr	r0, [r0, #16]
    40c4:	cmp	r0, #0
    40c6:	beq.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40c8:	ldr	r2, [r0, #0]
    40ca:	ldr	r2, [r2, #64]	; 0x40
    40cc:	cmp	r2, r1
    40ce:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40d0:	ldr	r0, [r0, #16]
    40d2:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40d4:	ldr	r2, [r0, #0]
    40d6:	ldr	r2, [r2, #64]	; 0x40
    40d8:	cmp	r2, r1
    40da:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40dc:	ldr	r0, [r0, #16]
    40de:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40e0:	ldr	r2, [r0, #0]
    40e2:	ldr	r2, [r2, #64]	; 0x40
    40e4:	cmp	r2, r1
    40e6:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40e8:	ldr	r0, [r0, #16]
    40ea:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40ec:	ldr	r2, [r0, #0]
    40ee:	ldr	r2, [r2, #64]	; 0x40
    40f0:	cmp	r2, r1
    40f2:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    40f4:	ldr	r0, [r0, #16]
    40f6:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    40f8:	ldr	r2, [r0, #0]
    40fa:	ldr	r2, [r2, #64]	; 0x40
    40fc:	cmp	r2, r1
    40fe:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4100:	ldr	r0, [r0, #16]
    4102:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4104:	ldr	r2, [r0, #0]
    4106:	ldr	r2, [r2, #64]	; 0x40
    4108:	cmp	r2, r1
    410a:	bne.n	411c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    410c:	ldr	r0, [r0, #16]
    410e:	cbz	r0, 4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4110:	ldr	r3, [r0, #0]
    4112:	ldr	r3, [r3, #64]	; 0x40
    4114:	blx	r3
    4116:	ldr	r3, [sp, #36]	; 0x24
    4118:	b.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    411a:	mov	r0, r3
    411c:	blx	r2
    411e:	ldr	r3, [sp, #36]	; 0x24
    if(nd<nbuf) break;  // end of file
  }
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
    4120:	mvns	r4, r4
    4122:	lsrs	r4, r4, #31
    4124:	b.n	3d5a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4126:	mov	r0, r5
    4128:	blx	r3
    412a:	b.n	3b8c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    412c:	mov	r4, r0
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    412e:	cmp	r3, #0
    4130:	beq.n	4198 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x898>
    4132:	ldr	r2, [r3, #0]
    4134:	ldr	r1, [pc, #44]	; (4164 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4136:	ldr	r5, [r2, #64]	; 0x40
    4138:	cmp	r5, r1
    413a:	bne.n	4154 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    413c:	ldr	r0, [r3, #16]
    413e:	cmp	r0, #0
    4140:	beq.n	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4142:	b.n	3e8a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x58a>
    4144:	blx	r3
    4146:	b.n	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4148:	mov	r0, r7
    414a:	blx	r3
    414c:	b.n	3b84 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    414e:	mov	r0, r5
    4150:	blx	r3
    4152:	b.n	3e66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4154:	mov	r0, r3
    4156:	blx	r5
    4158:	b.n	4096 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    415a:	nop
    415c:	.word	0x0000008d
    4160:	.word	0x00000099
    4164:	.word	0x00000111
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4168:	mov	r0, r7
    416a:	blx	r3
    416c:	b.n	3e5e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    416e:	mov	r0, r8
    4170:	blx	r3
    4172:	b.n	3c9e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    4174:	mov	r0, r9
    4176:	blx	r3
    4178:	b.n	3c96 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    417a:	mov	r0, r8
    417c:	blx	r3
    417e:	b.n	3e56 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    4180:	mov	r0, r9
    4182:	blx	r3
    4184:	b.n	3e4e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    4186:	mov	r0, sl
    4188:	blx	r3
    418a:	b.n	3c8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    418c:	mov	r0, fp
    418e:	blx	r3
    4190:	b.n	3c86 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4192:	ldr	r3, [sp, #16]
    4194:	ldr	r6, [pc, #12]	; (41a4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x8a4>)
    4196:	b.n	3e68 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x568>
    4198:	mov	r4, r3
    419a:	b.n	4120 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    419c:	mov	r0, sl
    419e:	blx	r3
    41a0:	b.n	3e46 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    41a2:	nop
    41a4:	.word	0x20000074

000041a8 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)>:
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    41a8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    41ac:	mov	r8, r1
    41ae:	sub.w	sp, sp, #1336	; 0x538
    if(newParent==0xFFFFFFFFUL) newParent=newStore;
    41b2:	cmp.w	r3, #4294967295
    41b6:	ite	ne
    41b8:	movne	r7, r3
    41ba:	moveq	r7, r2

    Record p1 = ReadIndexRecord(handle);
    41bc:	mov	r1, r0
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    41be:	mov	r4, r0
    if(newParent==0xFFFFFFFFUL) newParent=newStore;

    Record p1 = ReadIndexRecord(handle);
    41c0:	mov	r2, r8
    41c2:	add	r0, sp, #520	; 0x208
    41c4:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    41c8:	mov	r2, r7
    41ca:	mov	r1, r4
    41cc:	add	r0, sp, #792	; 0x318
    41ce:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    uint32_t newHandle;
    if(p1.isdir)
    41d2:	ldrb.w	r6, [sp, #532]	; 0x214
    41d6:	cmp	r6, #0
    41d8:	bne.n	4260 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)+0xb8>
      CopyFiles(handle, p2.store, newHandle);
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
    41da:	add	r1, sp, #536	; 0x218
    41dc:	mov.w	r2, #256	; 0x100
    41e0:	add.w	r0, sp, #1080	; 0x438
    41e4:	bl	10620 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    41e8:	ldr.w	r5, [r4, #244]	; 0xf4
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    41ec:	ldrh.w	r0, [sp, #806]	; 0x326
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    41f0:	ldr	r3, [sp, #796]	; 0x31c
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    41f2:	strh.w	r0, [sp, #1078]	; 0x436
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    41f6:	adds	r2, r5, #1
    41f8:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    41fc:	mov	r1, r5
    41fe:	add.w	r2, sp, #1064	; 0x428
    4202:	mov	r0, r4
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    4204:	str.w	r3, [sp, #1072]	; 0x430
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
    4208:	str.w	r7, [sp, #1064]	; 0x428
      r.child = 0;
    420c:	str.w	r6, [sp, #1068]	; 0x42c
      r.sibling = p2.child;
      r.isdir = 0;
    4210:	strb.w	r6, [sp, #1076]	; 0x434
      r.scanned = 0;
    4214:	strb.w	r6, [sp, #1077]	; 0x435
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4218:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);
    421c:	add	r2, sp, #792	; 0x318
    421e:	mov	r1, r7
    4220:	mov	r0, r4
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
    4222:	str	r5, [sp, #796]	; 0x31c
      WriteIndexRecord(newParent, p2);
    4224:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4228:	mov	r1, r8
    422a:	add	r2, sp, #8
    422c:	mov.w	r3, #256	; 0x100
    4230:	mov	r0, r4
    4232:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    4236:	add	r6, sp, #264	; 0x108
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4238:	mov	r7, r0
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    423a:	mov	r1, r5
    423c:	mov	r2, r6
    423e:	mov.w	r3, #256	; 0x100
    4242:	mov	r0, r4
    4244:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>

      sd_copy(store0,oldfilename,store1,newfilename);
    4248:	str	r6, [sp, #0]
    424a:	mov	r3, r0
    424c:	add	r2, sp, #8
    424e:	mov	r1, r7
    4250:	adds	r0, r4, #4
    4252:	bl	3900 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }

    return newHandle;
  }
    4256:	mov	r0, r5
    4258:	add.w	sp, sp, #1336	; 0x538
    425c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
    4260:	ldrh.w	r1, [sp, #534]	; 0x216
    4264:	mov	r2, r8
    4266:	mov	r0, r4
    4268:	adds	r1, #1
    426a:	bl	27bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    426e:	ldrb.w	r3, [sp, #532]	; 0x214
    4272:	ldr	r0, [r4, #0]
    4274:	ldrh.w	r1, [sp, #806]	; 0x326
    4278:	add	r2, sp, #536	; 0x218
    427a:	adds	r3, #0
    427c:	str	r2, [sp, #0]
    427e:	it	ne
    4280:	movne	r3, #1
    4282:	mov	r2, r7
    4284:	ldr	r5, [r0, #44]	; 0x2c
    4286:	mov	r0, r4
    4288:	blx	r5
      CopyFiles(handle, p2.store, newHandle);
    428a:	ldr	r3, [r4, #0]
    428c:	ldrh.w	r2, [sp, #806]	; 0x326
    4290:	ldr	r6, [r3, #84]	; 0x54

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    4292:	mov	r5, r0
      CopyFiles(handle, p2.store, newHandle);
    4294:	mov	r3, r0
    4296:	mov	r1, r8
    4298:	mov	r0, r4
    429a:	blx	r6

      sd_copy(store0,oldfilename,store1,newfilename);
    }

    return newHandle;
  }
    429c:	mov	r0, r5
    429e:	add.w	sp, sp, #1336	; 0x538
    42a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    42a6:	nop

000042a8 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)>:

bool MTPStorage_SD::CopyFiles(uint32_t handle, uint32_t store, uint32_t newHandle)
{ // assume handle and newHandle point to existing directories
    42a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    42ac:	mov	r4, r0
    42ae:	subw	sp, sp, #1612	; 0x64c
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
    42b2:	cmp.w	r3, #4294967295
    42b6:	ite	ne
    42b8:	movne	r8, r3
    42ba:	moveq	r8, r2
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    42bc:	add	r0, sp, #520	; 0x208
    42be:	mov	r2, r1
    42c0:	mov	r1, r4
    42c2:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  Record p2=ReadIndexRecord(newHandle);
    42c6:	mov	r2, r8
    42c8:	mov	r1, r4
    42ca:	add	r0, sp, #792	; 0x318
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    42cc:	ldrh.w	r9, [sp, #534]	; 0x216
  Record p2=ReadIndexRecord(newHandle);
    42d0:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  uint32_t ix= p1.child;
    42d4:	ldr	r6, [sp, #524]	; 0x20c
  uint32_t iy= 0;
  while(ix)
    42d6:	cmp	r6, #0
    42d8:	beq.n	43ae <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x106>
    42da:	movs	r5, #0
    42dc:	add	r7, sp, #264	; 0x108

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    42de:	add.w	sl, r4, #4
    42e2:	b.n	4318 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    42e4:	ldrh.w	r3, [sp, #1350]	; 0x546
    42e8:	add.w	r3, r4, r3, lsl #2
    42ec:	ldr	r0, [r3, #88]	; 0x58
    42ee:	ldr	r3, [r0, #0]
    42f0:	ldr	r3, [r3, #8]
    42f2:	blx	r3

    if(py.isdir) 
    { 
      sd_mkdir(py.store,newfilename);

      ScanDir(p1.store,ix); 
    42f4:	mov	r2, r6
    42f6:	mov	r1, r9
    42f8:	mov	r0, r4
    42fa:	bl	27bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      CopyFiles(ix,p2.store,iy); 
    42fe:	ldr	r3, [r4, #0]
    4300:	ldrh.w	r2, [sp, #806]	; 0x326
    4304:	ldr.w	fp, [r3, #84]	; 0x54
    4308:	mov	r1, r6
    430a:	mov	r3, r5
    430c:	mov	r0, r4
    430e:	blx	fp
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
    4310:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4314:	cmp	r6, #0
    4316:	beq.n	4398 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
  { // get child
    Record px = ReadIndexRecord(ix) ;
    4318:	mov	r2, r6
    431a:	mov	r1, r4
    431c:	add.w	r0, sp, #1064	; 0x428
    4320:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record py = px;
    4324:	mov.w	r2, #272	; 0x110
    4328:	add.w	r1, sp, #1064	; 0x428
    432c:	add.w	r0, sp, #1336	; 0x538
    4330:	bl	cfd4 <memcpy>
    py.store = p2.store;
    py.parent = newHandle;
    py.sibling = iy;
    4334:	str.w	r5, [sp, #1344]	; 0x540
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4338:	ldr.w	r5, [r4, #244]	; 0xf4
  uint32_t iy= 0;
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    433c:	ldrh.w	r3, [sp, #806]	; 0x326
    4340:	strh.w	r3, [sp, #1350]	; 0x546
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4344:	adds	r2, r5, #1
    4346:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    434a:	mov	r1, r5
    434c:	add.w	r2, sp, #1336	; 0x538
    4350:	mov	r0, r4
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    py.parent = newHandle;
    4352:	str.w	r8, [sp, #1336]	; 0x538
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4356:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    py.sibling = iy;
    iy = AppendIndexRecord(py);

    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    435a:	mov.w	r3, #256	; 0x100
    435e:	add	r2, sp, #8
    4360:	mov	r1, r6
    4362:	mov	r0, r4
    4364:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);
    4368:	mov	r1, r5
    436a:	mov.w	r3, #256	; 0x100
    436e:	mov	r2, r7
    4370:	mov	r0, r4
    4372:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    if(py.isdir) 
    4376:	ldrb.w	r3, [sp, #1348]	; 0x544
    437a:	mov	r1, r7

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    437c:	add	r2, sp, #8
    437e:	mov	r0, sl
    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);

    if(py.isdir) 
    4380:	cmp	r3, #0
    4382:	bne.n	42e4 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x3c>

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4384:	ldrh.w	r3, [sp, #1350]	; 0x546
    4388:	str	r7, [sp, #0]
    438a:	mov	r1, r9
    438c:	bl	3900 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }
    ix = px.sibling;
    4390:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4394:	cmp	r6, #0
    4396:	bne.n	4318 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
  WriteIndexRecord(newHandle,p2);
    4398:	mov	r0, r4
    439a:	mov	r1, r8
    439c:	add	r2, sp, #792	; 0x318
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
    439e:	str	r5, [sp, #796]	; 0x31c
  WriteIndexRecord(newHandle,p2);
    43a0:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
  return true;
}
    43a4:	movs	r0, #1
    43a6:	addw	sp, sp, #1612	; 0x64c
    43aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  #endif

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
    43ae:	mov	r5, r6
    43b0:	b.n	4398 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
    43b2:	nop

000043b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>:
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{ // old and new are directory paths
    43b4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    43b8:	mov	r5, r3
    43ba:	add.w	r3, r0, r3, lsl #2
    43be:	mov	r4, r0
    43c0:	ldr	r0, [r3, #84]	; 0x54
    43c2:	ldr	r6, [sp, #24]
    43c4:	ldr	r3, [r0, #0]
    43c6:	mov	r7, r1
    43c8:	ldr	r3, [r3, #8]
    43ca:	mov	r1, r6
    43cc:	mov	r8, r2
    43ce:	blx	r3

  char tmp0Name[MAX_FILENAME_LEN];
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}
    43d0:	cbnz	r0, 43d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)+0x22>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    43d2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    43d6:	str	r6, [sp, #24]
    43d8:	mov	r3, r5
    43da:	mov	r2, r8
    43dc:	mov	r1, r7
    43de:	mov	r0, r4
    43e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    43e4:	b.w	43e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>

000043e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>:
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
    43e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43ec:	add.w	sl, r0, r1, lsl #2
    43f0:	mov	r8, r1
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    43f2:	ldr.w	r1, [sl, #84]	; 0x54
    43f6:	sub.w	sp, sp, #596	; 0x254
    43fa:	mov	r9, r0
    43fc:	ldr	r0, [r1, #0]
    43fe:	str	r3, [sp, #8]
    4400:	ldr	r4, [r0, #0]
    4402:	str	r2, [sp, #12]
    4404:	movs	r3, #0
    4406:	add	r0, sp, #40	; 0x28
    4408:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    440a:	ldr	r3, [sp, #56]	; 0x38
    440c:	cmp	r3, #0
    440e:	beq.w	4d66 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x97e>
    4412:	ldr	r2, [r3, #0]
    4414:	ldr	r6, [pc, #460]	; (45e4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1fc>)
    4416:	ldr	r2, [r2, #68]	; 0x44
    4418:	cmp	r2, r6
    441a:	bne.w	46f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30a>
    441e:	ldr	r0, [r3, #16]
    4420:	cmp	r0, #0
    4422:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4426:	ldr	r2, [r0, #0]
    4428:	ldr	r2, [r2, #68]	; 0x44
    442a:	cmp	r2, r6
    442c:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4430:	ldr	r0, [r0, #16]
    4432:	cmp	r0, #0
    4434:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4438:	ldr	r2, [r0, #0]
    443a:	ldr	r2, [r2, #68]	; 0x44
    443c:	cmp	r2, r6
    443e:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4442:	ldr	r0, [r0, #16]
    4444:	cmp	r0, #0
    4446:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    444a:	ldr	r2, [r0, #0]
    444c:	ldr	r2, [r2, #68]	; 0x44
    444e:	cmp	r2, r6
    4450:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4454:	ldr	r0, [r0, #16]
    4456:	cmp	r0, #0
    4458:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    445c:	ldr	r2, [r0, #0]
    445e:	ldr	r2, [r2, #68]	; 0x44
    4460:	cmp	r2, r6
    4462:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4466:	ldr	r0, [r0, #16]
    4468:	cmp	r0, #0
    446a:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    446e:	ldr	r2, [r0, #0]
    4470:	ldr	r2, [r2, #68]	; 0x44
    4472:	cmp	r2, r6
    4474:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4478:	ldr	r0, [r0, #16]
    447a:	cmp	r0, #0
    447c:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4480:	ldr	r2, [r0, #0]
    4482:	ldr	r2, [r2, #68]	; 0x44
    4484:	cmp	r2, r6
    4486:	bne.w	46f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    448a:	ldr	r0, [r0, #16]
    448c:	cmp	r0, #0
    448e:	beq.w	45a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4492:	ldr	r3, [r0, #0]
    4494:	ldr	r3, [r3, #68]	; 0x44
    4496:	blx	r3
    4498:	mov	r4, r0
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    449a:	cmp	r4, #0
    449c:	beq.w	4e1c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa34>
    44a0:	ldr.w	fp, [pc, #336]	; 45f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    44a4:	add	r4, sp, #336	; 0x150
  { while(1)
    {
      strlcpy(tmp0Name,oldfilename,MAX_FILENAME_LEN);
    44a6:	mov.w	r2, #256	; 0x100
    44aa:	ldr	r1, [sp, #12]
    44ac:	add	r0, sp, #80	; 0x50
    44ae:	bl	10620 <strlcpy>
      if(tmp0Name[strlen(tmp0Name)-1]!='/') strlcat(tmp0Name,"/",MAX_FILENAME_LEN);
    44b2:	add	r0, sp, #80	; 0x50
    44b4:	bl	10680 <strlen>
    44b8:	add	r3, sp, #80	; 0x50
    44ba:	add	r0, r3
    44bc:	ldrb.w	r3, [r0, #-1]
    44c0:	cmp	r3, #47	; 0x2f
    44c2:	beq.n	44d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xe8>
    44c4:	mov.w	r2, #256	; 0x100
    44c8:	ldr	r1, [pc, #284]	; (45e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    44ca:	add	r0, sp, #80	; 0x50
    44cc:	bl	105cc <strlcat>

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
    44d0:	mov.w	r2, #256	; 0x100
    44d4:	ldr	r1, [sp, #632]	; 0x278
    44d6:	mov	r0, r4
    44d8:	bl	10620 <strlcpy>
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);
    44dc:	mov	r0, r4
    44de:	bl	10680 <strlen>
    44e2:	add	r0, r4
    44e4:	ldrb.w	r3, [r0, #-1]
    44e8:	cmp	r3, #47	; 0x2f
    44ea:	beq.n	44f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x110>
    44ec:	mov.w	r2, #256	; 0x100
    44f0:	ldr	r1, [pc, #244]	; (45e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    44f2:	mov	r0, r4
    44f4:	bl	105cc <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    44f8:	ldr	r1, [sp, #56]	; 0x38
    44fa:	cmp	r1, #0
    44fc:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4500:	ldr	r3, [r1, #0]
    4502:	ldr	r2, [pc, #232]	; (45ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x204>)
    4504:	ldr	r3, [r3, #80]	; 0x50
    4506:	cmp	r3, r2
    4508:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    450c:	ldr	r1, [r1, #16]
    450e:	cmp	r1, #0
    4510:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4514:	ldr	r3, [r1, #0]
    4516:	ldr	r3, [r3, #80]	; 0x50
    4518:	cmp	r3, r2
    451a:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    451e:	ldr	r1, [r1, #16]
    4520:	cmp	r1, #0
    4522:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4526:	ldr	r3, [r1, #0]
    4528:	ldr	r3, [r3, #80]	; 0x50
    452a:	cmp	r3, r2
    452c:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4530:	ldr	r1, [r1, #16]
    4532:	cmp	r1, #0
    4534:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4538:	ldr	r3, [r1, #0]
    453a:	ldr	r3, [r3, #80]	; 0x50
    453c:	cmp	r3, r2
    453e:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4542:	ldr	r1, [r1, #16]
    4544:	cmp	r1, #0
    4546:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    454a:	ldr	r3, [r1, #0]
    454c:	ldr	r3, [r3, #80]	; 0x50
    454e:	cmp	r3, r2
    4550:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4554:	ldr	r1, [r1, #16]
    4556:	cmp	r1, #0
    4558:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    455c:	ldr	r3, [r1, #0]
    455e:	ldr	r3, [r3, #80]	; 0x50
    4560:	cmp	r3, r2
    4562:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4566:	ldr	r1, [r1, #16]
    4568:	cmp	r1, #0
    456a:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    456e:	ldr	r3, [r1, #0]
    4570:	ldr	r3, [r3, #80]	; 0x50
    4572:	cmp	r3, r2
    4574:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    4578:	ldr	r1, [r1, #16]
    457a:	cmp	r1, #0
    457c:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4580:	ldr	r3, [r1, #0]
    4582:	ldr	r3, [r3, #80]	; 0x50
    4584:	cmp	r3, r2
    4586:	bne.w	47dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    458a:	ldr	r1, [r1, #16]
    458c:	cmp	r1, #0
    458e:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4592:	ldr	r3, [r1, #0]
    4594:	add	r5, sp, #60	; 0x3c
    4596:	ldr	r3, [r3, #80]	; 0x50
    4598:	mov	r0, r5
    459a:	movs	r2, #0
    459c:	blx	r3
    459e:	b.n	47e4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3fc>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    45a0:	ldr.w	fp, [pc, #80]	; 45f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    45a4:	str.w	fp, [sp, #40]	; 0x28
    45a8:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    45aa:	ldr	r2, [r3, #16]
    45ac:	subs	r2, #1
    45ae:	str	r2, [r3, #16]
    45b0:	cbnz	r2, 45da <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    45b2:	ldr	r5, [sp, #56]	; 0x38
    45b4:	cbz	r5, 45da <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    45b6:	ldr	r2, [r5, #0]
    45b8:	ldr	r3, [pc, #52]	; (45f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x208>)
    45ba:	ldr	r2, [r2, #32]
    45bc:	cmp	r2, r3
    45be:	bne.w	4d80 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x998>
    45c2:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    45c4:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    45c8:	cbz	r1, 45d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    45ca:	ldr	r2, [r1, #16]
    45cc:	subs	r2, #1
    45ce:	str	r2, [r1, #16]
    45d0:	cbz	r2, 45f8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x210>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    45d2:	mov	r0, r5
    45d4:	movs	r1, #20
    45d6:	bl	ea80 <operator delete(void*, unsigned int)>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    45da:	mov	r0, r4
    45dc:	add.w	sp, sp, #596	; 0x254
    45e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    45e4:	.word	0x0000011d
    45e8:	.word	0x200002fc
    45ec:	.word	0x00000149
    45f0:	.word	0x00000acd
    45f4:	.word	0x20000074
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    45f8:	ldr	r6, [r5, #16]
    45fa:	cmp	r6, #0
    45fc:	beq.n	45d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    45fe:	ldr	r2, [r6, #0]
    4600:	ldr	r2, [r2, #32]
    4602:	cmp	r2, r3
    4604:	bne.w	4d96 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ae>
    4608:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    460a:	str.w	fp, [r6]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    460e:	cmp	r1, #0
    4610:	beq.n	46e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    4612:	ldr	r2, [r1, #16]
    4614:	subs	r2, #1
    4616:	str	r2, [r1, #16]
    4618:	cmp	r2, #0
    461a:	bne.n	46e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    461c:	ldr	r7, [r6, #16]
    461e:	cmp	r7, #0
    4620:	beq.n	46e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    4622:	ldr	r2, [r7, #0]
    4624:	ldr	r2, [r2, #32]
    4626:	cmp	r2, r3
    4628:	bne.w	4db2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ca>
    462c:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    462e:	str.w	fp, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4632:	cmp	r1, #0
    4634:	beq.n	46e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    4636:	ldr	r2, [r1, #16]
    4638:	subs	r2, #1
    463a:	str	r2, [r1, #16]
    463c:	cmp	r2, #0
    463e:	bne.n	46e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    4640:	ldr.w	r8, [r7, #16]
    4644:	cmp.w	r8, #0
    4648:	beq.n	46e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    464a:	ldr.w	r2, [r8]
    464e:	ldr	r2, [r2, #32]
    4650:	cmp	r2, r3
    4652:	bne.w	4dc8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e0>
    4656:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    465a:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    465e:	cmp	r1, #0
    4660:	beq.n	46d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    4662:	ldr	r2, [r1, #16]
    4664:	subs	r2, #1
    4666:	str	r2, [r1, #16]
    4668:	cmp	r2, #0
    466a:	bne.n	46d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    466c:	ldr.w	r9, [r8, #16]
    4670:	cmp.w	r9, #0
    4674:	beq.n	46d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    4676:	ldr.w	r2, [r9]
    467a:	ldr	r2, [r2, #32]
    467c:	cmp	r2, r3
    467e:	bne.w	4df0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa08>
    4682:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4686:	str.w	fp, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    468a:	cbz	r1, 46d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    468c:	ldr	r2, [r1, #16]
    468e:	subs	r2, #1
    4690:	str	r2, [r1, #16]
    4692:	cbnz	r2, 46d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    4694:	ldr.w	sl, [r9, #16]
    4698:	cmp.w	sl, #0
    469c:	beq.n	46d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    469e:	ldr.w	r2, [sl]
    46a2:	ldr	r2, [r2, #32]
    46a4:	cmp	r2, r3
    46a6:	bne.w	4df6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa0e>
    46aa:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46ae:	str.w	fp, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46b2:	cbz	r2, 46c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    46b4:	ldr	r3, [r2, #16]
    46b6:	subs	r3, #1
    46b8:	str	r3, [r2, #16]
    46ba:	cbnz	r3, 46c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    46bc:	ldr.w	r0, [sl, #16]
    46c0:	cbz	r0, 46c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    46c2:	ldr	r3, [r0, #0]
    46c4:	ldr	r3, [r3, #32]
    46c6:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    46c8:	mov	r0, sl
    46ca:	movs	r1, #20
    46cc:	bl	ea80 <operator delete(void*, unsigned int)>
    46d0:	mov	r0, r9
    46d2:	movs	r1, #20
    46d4:	bl	ea80 <operator delete(void*, unsigned int)>
    46d8:	mov	r0, r8
    46da:	movs	r1, #20
    46dc:	bl	ea80 <operator delete(void*, unsigned int)>
    46e0:	mov	r0, r7
    46e2:	movs	r1, #20
    46e4:	bl	ea80 <operator delete(void*, unsigned int)>
    46e8:	mov	r0, r6
    46ea:	movs	r1, #20
    46ec:	bl	ea80 <operator delete(void*, unsigned int)>
    46f0:	b.n	45d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    46f2:	mov	r0, r3
    46f4:	blx	r2
    46f6:	mov	r4, r0
    46f8:	b.n	449a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xb2>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46fa:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46fe:	ldr	r3, [r2, #16]
    4700:	subs	r3, #1
    4702:	str	r3, [r2, #16]
    4704:	cmp	r3, #0
    4706:	bne.n	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4708:	ldr	r4, [r5, #16]
    470a:	cmp	r4, #0
    470c:	beq.n	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    470e:	ldr	r2, [r4, #0]
    4710:	ldr	r3, [pc, #192]	; (47d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ec>)
    4712:	ldr	r2, [r2, #32]
    4714:	cmp	r2, r3
    4716:	bne.w	4da2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ba>
    471a:	ldr	r1, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    471c:	str.w	fp, [r4]
    4720:	ldr	r0, [pc, #180]	; (47d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4722:	cmp	r1, #0
    4724:	beq.n	47ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    4726:	ldr	r2, [r1, #16]
    4728:	subs	r2, #1
    472a:	str	r2, [r1, #16]
    472c:	cmp	r2, #0
    472e:	bne.n	47ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    4730:	ldr	r5, [r4, #16]
    4732:	cmp	r5, #0
    4734:	beq.n	47ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    4736:	ldr	r2, [r5, #0]
    4738:	ldr	r2, [r2, #32]
    473a:	cmp	r2, r3
    473c:	bne.w	4db8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d0>
    4740:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4742:	str	r0, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4744:	cmp	r1, #0
    4746:	beq.n	47a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    4748:	ldr	r2, [r1, #16]
    474a:	subs	r2, #1
    474c:	str	r2, [r1, #16]
    474e:	cbnz	r2, 47a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    4750:	ldr	r6, [r5, #16]
    4752:	cbz	r6, 47a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    4754:	ldr	r2, [r6, #0]
    4756:	ldr	r2, [r2, #32]
    4758:	cmp	r2, r3
    475a:	bne.w	4dde <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9f6>
    475e:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4760:	str.w	fp, [r6]
    4764:	ldr	r0, [pc, #112]	; (47d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4766:	cbz	r1, 479e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    4768:	ldr	r2, [r1, #16]
    476a:	subs	r2, #1
    476c:	str	r2, [r1, #16]
    476e:	cbnz	r2, 479e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    4770:	ldr	r7, [r6, #16]
    4772:	cbz	r7, 479e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    4774:	ldr	r2, [r7, #0]
    4776:	ldr	r2, [r2, #32]
    4778:	cmp	r2, r3
    477a:	bne.w	4de4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9fc>
    477e:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4780:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4782:	cbz	r2, 4796 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    4784:	ldr	r3, [r2, #16]
    4786:	subs	r3, #1
    4788:	str	r3, [r2, #16]
    478a:	cbnz	r3, 4796 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    478c:	ldr	r0, [r7, #16]
    478e:	cbz	r0, 4796 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    4790:	ldr	r3, [r0, #0]
    4792:	ldr	r3, [r3, #32]
    4794:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4796:	mov	r0, r7
    4798:	movs	r1, #20
    479a:	bl	ea80 <operator delete(void*, unsigned int)>
    479e:	mov	r0, r6
    47a0:	movs	r1, #20
    47a2:	bl	ea80 <operator delete(void*, unsigned int)>
    47a6:	mov	r0, r5
    47a8:	movs	r1, #20
    47aa:	bl	ea80 <operator delete(void*, unsigned int)>
    47ae:	mov	r0, r4
    47b0:	movs	r1, #20
    47b2:	bl	ea80 <operator delete(void*, unsigned int)>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    47b6:	ldr.w	r0, [sl, #84]	; 0x54
    47ba:	ldr	r1, [sp, #12]
    47bc:	ldr	r3, [r0, #0]
    47be:	ldr	r3, [r3, #20]
    47c0:	blx	r3
    47c2:	ldr	r3, [sp, #56]	; 0x38
    47c4:	mov	r4, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    47c6:	str.w	fp, [sp, #40]	; 0x28
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    47ca:	cmp	r3, #0
    47cc:	bne.w	45aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1c2>
    47d0:	b.n	45da <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    47d2:	nop
    47d4:	.word	0x00000acd
    47d8:	.word	0x20000074
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    47dc:	add	r5, sp, #60	; 0x3c
    47de:	mov	r0, r5
    47e0:	movs	r2, #0
    47e2:	blx	r3
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    47e4:	ldr	r2, [r5, #16]
    47e6:	cmp	r2, #0
    47e8:	beq.n	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    47ea:	ldr	r3, [r2, #0]
    47ec:	ldr	r3, [r3, #68]	; 0x44
    47ee:	cmp	r3, r6
    47f0:	bne.w	4d34 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94c>
    47f4:	ldr	r0, [r2, #16]
    47f6:	cmp	r0, #0
    47f8:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    47fc:	ldr	r1, [r0, #0]
    47fe:	ldr	r1, [r1, #68]	; 0x44
    4800:	cmp	r1, r6
    4802:	bne.w	4d4a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x962>
    4806:	ldr	r0, [r0, #16]
    4808:	cmp	r0, #0
    480a:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    480e:	ldr	r3, [r0, #0]
    4810:	ldr	r3, [r3, #68]	; 0x44
    4812:	cmp	r3, r6
    4814:	bne.w	4d36 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    4818:	ldr	r0, [r0, #16]
    481a:	cmp	r0, #0
    481c:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    4820:	ldr	r3, [r0, #0]
    4822:	ldr	r3, [r3, #68]	; 0x44
    4824:	cmp	r3, r6
    4826:	bne.w	4d36 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    482a:	ldr	r0, [r0, #16]
    482c:	cmp	r0, #0
    482e:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    4832:	ldr	r3, [r0, #0]
    4834:	ldr	r3, [r3, #68]	; 0x44
    4836:	cmp	r3, r6
    4838:	bne.w	4d36 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    483c:	ldr	r0, [r0, #16]
    483e:	cmp	r0, #0
    4840:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    4844:	ldr	r3, [r0, #0]
    4846:	ldr	r3, [r3, #68]	; 0x44
    4848:	cmp	r3, r6
    484a:	bne.w	4d36 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    484e:	ldr	r0, [r0, #16]
    4850:	cmp	r0, #0
    4852:	beq.w	46fa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    4856:	ldr	r3, [r0, #0]
    4858:	ldr	r3, [r3, #68]	; 0x44
    485a:	blx	r3

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);

      File f2=f1.openNextFile();
      if(!f2) break;
    485c:	cmp	r0, #0
    485e:	beq.w	4e0e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa26>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    4862:	ldr	r0, [r5, #16]
    4864:	cmp	r0, #0
    4866:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    486a:	ldr	r2, [r0, #0]
    486c:	ldr	r3, [pc, #696]	; (4b28 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    486e:	ldr	r2, [r2, #72]	; 0x48
    4870:	cmp	r2, r3
    4872:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    4876:	ldr	r0, [r0, #16]
    4878:	cmp	r0, #0
    487a:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    487e:	ldr	r2, [r0, #0]
    4880:	ldr	r2, [r2, #72]	; 0x48
    4882:	cmp	r2, r3
    4884:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    4888:	ldr	r0, [r0, #16]
    488a:	cmp	r0, #0
    488c:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    4890:	ldr	r2, [r0, #0]
    4892:	ldr	r2, [r2, #72]	; 0x48
    4894:	cmp	r2, r3
    4896:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    489a:	ldr	r0, [r0, #16]
    489c:	cmp	r0, #0
    489e:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    48a2:	ldr	r2, [r0, #0]
    48a4:	ldr	r2, [r2, #72]	; 0x48
    48a6:	cmp	r2, r3
    48a8:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    48ac:	ldr	r0, [r0, #16]
    48ae:	cmp	r0, #0
    48b0:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    48b4:	ldr	r2, [r0, #0]
    48b6:	ldr	r2, [r2, #72]	; 0x48
    48b8:	cmp	r2, r3
    48ba:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    48be:	ldr	r0, [r0, #16]
    48c0:	cmp	r0, #0
    48c2:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    48c6:	ldr	r2, [r0, #0]
    48c8:	ldr	r2, [r2, #72]	; 0x48
    48ca:	cmp	r2, r3
    48cc:	bne.w	4d3a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    48d0:	ldr	r0, [r0, #16]
    48d2:	cmp	r0, #0
    48d4:	beq.w	4d30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    48d8:	ldr	r3, [r0, #0]
    48da:	ldr	r3, [r3, #72]	; 0x48
    48dc:	blx	r3
    48de:	mov	r1, r0
      { // generate filenames
        strlcat(tmp0Name,f2.name(),MAX_FILENAME_LEN);
    48e0:	mov.w	r2, #256	; 0x100
    48e4:	add	r0, sp, #80	; 0x50
    48e6:	bl	105cc <strlcat>
    48ea:	ldr	r0, [r5, #16]
    48ec:	cmp	r0, #0
    48ee:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    48f2:	ldr	r2, [r0, #0]
    48f4:	ldr	r3, [pc, #560]	; (4b28 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    48f6:	ldr	r2, [r2, #72]	; 0x48
    48f8:	cmp	r2, r3
    48fa:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    48fe:	ldr	r0, [r0, #16]
    4900:	cmp	r0, #0
    4902:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    4906:	ldr	r2, [r0, #0]
    4908:	ldr	r2, [r2, #72]	; 0x48
    490a:	cmp	r2, r3
    490c:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    4910:	ldr	r0, [r0, #16]
    4912:	cmp	r0, #0
    4914:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    4918:	ldr	r2, [r0, #0]
    491a:	ldr	r2, [r2, #72]	; 0x48
    491c:	cmp	r2, r3
    491e:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    4922:	ldr	r0, [r0, #16]
    4924:	cmp	r0, #0
    4926:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    492a:	ldr	r2, [r0, #0]
    492c:	ldr	r2, [r2, #72]	; 0x48
    492e:	cmp	r2, r3
    4930:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    4934:	ldr	r0, [r0, #16]
    4936:	cmp	r0, #0
    4938:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    493c:	ldr	r2, [r0, #0]
    493e:	ldr	r2, [r2, #72]	; 0x48
    4940:	cmp	r2, r3
    4942:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    4946:	ldr	r0, [r0, #16]
    4948:	cmp	r0, #0
    494a:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    494e:	ldr	r2, [r0, #0]
    4950:	ldr	r2, [r2, #72]	; 0x48
    4952:	cmp	r2, r3
    4954:	bne.w	4d44 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    4958:	ldr	r0, [r0, #16]
    495a:	cmp	r0, #0
    495c:	beq.w	4d2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    4960:	ldr	r3, [r0, #0]
    4962:	ldr	r3, [r3, #72]	; 0x48
    4964:	blx	r3
    4966:	mov	r1, r0
        strlcat(tmp1Name,f2.name(),MAX_FILENAME_LEN);
    4968:	mov.w	r2, #256	; 0x100
    496c:	mov	r0, r4
    496e:	bl	105cc <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    4972:	ldr	r0, [r5, #16]
    4974:	cmp	r0, #0
    4976:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    497a:	ldr	r2, [r0, #0]
    497c:	ldr	r3, [pc, #428]	; (4b2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x744>)
    497e:	ldr	r2, [r2, #76]	; 0x4c
    4980:	cmp	r2, r3
    4982:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    4986:	ldr	r0, [r0, #16]
    4988:	cmp	r0, #0
    498a:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    498e:	ldr	r2, [r0, #0]
    4990:	ldr	r2, [r2, #76]	; 0x4c
    4992:	cmp	r2, r3
    4994:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    4998:	ldr	r0, [r0, #16]
    499a:	cmp	r0, #0
    499c:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    49a0:	ldr	r2, [r0, #0]
    49a2:	ldr	r2, [r2, #76]	; 0x4c
    49a4:	cmp	r2, r3
    49a6:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    49aa:	ldr	r0, [r0, #16]
    49ac:	cmp	r0, #0
    49ae:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    49b2:	ldr	r2, [r0, #0]
    49b4:	ldr	r2, [r2, #76]	; 0x4c
    49b6:	cmp	r2, r3
    49b8:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    49bc:	ldr	r0, [r0, #16]
    49be:	cmp	r0, #0
    49c0:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    49c4:	ldr	r2, [r0, #0]
    49c6:	ldr	r2, [r2, #76]	; 0x4c
    49c8:	cmp	r2, r3
    49ca:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    49ce:	ldr	r0, [r0, #16]
    49d0:	cmp	r0, #0
    49d2:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    49d6:	ldr	r2, [r0, #0]
    49d8:	ldr	r2, [r2, #76]	; 0x4c
    49da:	cmp	r2, r3
    49dc:	bne.w	4d40 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    49e0:	ldr	r0, [r0, #16]
    49e2:	cmp	r0, #0
    49e4:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    49e8:	ldr	r3, [r0, #0]
    49ea:	ldr	r3, [r3, #76]	; 0x4c
    49ec:	blx	r3

        if(f2.isDirectory())
    49ee:	cmp	r0, #0
    49f0:	beq.w	4bf8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
        { 
          if(!sd_moveDir(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    49f4:	str	r4, [sp, #0]
    49f6:	ldr	r3, [sp, #8]
    49f8:	add	r2, sp, #80	; 0x50
    49fa:	mov	r1, r8
    49fc:	mov	r0, r9
    49fe:	bl	43b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    4a02:	cmp	r0, #0
    4a04:	beq.w	4c2e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4a08:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4a0a:	str.w	fp, [r5]
    4a0e:	ldr	r1, [pc, #288]	; (4b30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4a10:	cmp	r2, #0
    4a12:	beq.w	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    4a16:	ldr	r3, [r2, #16]
    4a18:	subs	r3, #1
    4a1a:	str	r3, [r2, #16]
    4a1c:	cmp	r3, #0
    4a1e:	bne.w	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    4a22:	ldr	r5, [r5, #16]
    4a24:	cmp	r5, #0
    4a26:	beq.w	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    4a2a:	ldr	r2, [r5, #0]
    4a2c:	ldr	r3, [pc, #260]	; (4b34 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x74c>)
    4a2e:	ldr	r2, [r2, #32]
    4a30:	cmp	r2, r3
    4a32:	bne.w	4d4e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x966>
    4a36:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4a38:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4a3a:	cmp	r0, #0
    4a3c:	beq.w	4bee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    4a40:	ldr	r2, [r0, #16]
    4a42:	subs	r2, #1
    4a44:	str	r2, [r0, #16]
    4a46:	cmp	r2, #0
    4a48:	bne.w	4bee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    4a4c:	ldr	r7, [r5, #16]
    4a4e:	cmp	r7, #0
    4a50:	beq.w	4bee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    4a54:	ldr	r2, [r7, #0]
    4a56:	ldr	r2, [r2, #32]
    4a58:	cmp	r2, r3
    4a5a:	bne.w	4d56 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x96e>
    4a5e:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4a60:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4a62:	cmp	r0, #0
    4a64:	beq.w	4be6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    4a68:	ldr	r2, [r0, #16]
    4a6a:	subs	r2, #1
    4a6c:	str	r2, [r0, #16]
    4a6e:	cmp	r2, #0
    4a70:	bne.w	4be6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    4a74:	ldr	r2, [r7, #16]
    4a76:	cmp	r2, #0
    4a78:	beq.w	4be6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    4a7c:	ldr	r1, [r2, #0]
    4a7e:	ldr	r1, [r1, #32]
    4a80:	cmp	r1, r3
    4a82:	bne.w	4d72 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x98a>
    4a86:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4a8a:	str.w	fp, [r2]
    4a8e:	ldr	r0, [pc, #160]	; (4b30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4a90:	cmp.w	lr, #0
    4a94:	beq.w	4bde <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    4a98:	ldr.w	r1, [lr, #16]
    4a9c:	subs	r1, #1
    4a9e:	str.w	r1, [lr, #16]
    4aa2:	cmp	r1, #0
    4aa4:	bne.w	4bde <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    4aa8:	ldr	r1, [r2, #16]
    4aaa:	str	r1, [sp, #16]
    4aac:	cmp	r1, #0
    4aae:	beq.w	4bde <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    4ab2:	ldr	r1, [sp, #16]
    4ab4:	ldr	r1, [r1, #0]
    4ab6:	ldr	r1, [r1, #32]
    4ab8:	cmp	r1, r3
    4aba:	bne.w	4d86 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x99e>
    4abe:	ldr	r1, [sp, #16]
    4ac0:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4ac4:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4ac6:	cmp.w	lr, #0
    4aca:	beq.w	4bd2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    4ace:	ldr.w	r1, [lr, #16]
    4ad2:	subs	r1, #1
    4ad4:	str.w	r1, [lr, #16]
    4ad8:	cmp	r1, #0
    4ada:	bne.n	4bd2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    4adc:	ldr	r1, [sp, #16]
    4ade:	ldr	r1, [r1, #16]
    4ae0:	str	r1, [sp, #20]
    4ae2:	cmp	r1, #0
    4ae4:	beq.n	4bd2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    4ae6:	ldr	r0, [sp, #20]
    4ae8:	ldr	r1, [r0, #0]
    4aea:	ldr	r1, [r1, #32]
    4aec:	cmp	r1, r3
    4aee:	bne.w	4da8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9c0>
    4af2:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4af6:	str.w	fp, [r0]
    4afa:	ldr	r0, [pc, #52]	; (4b30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4afc:	cmp.w	lr, #0
    4b00:	beq.n	4bc6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    4b02:	ldr.w	r1, [lr, #16]
    4b06:	subs	r1, #1
    4b08:	str.w	r1, [lr, #16]
    4b0c:	cmp	r1, #0
    4b0e:	bne.n	4bc6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    4b10:	ldr	r1, [sp, #20]
    4b12:	ldr	r1, [r1, #16]
    4b14:	str	r1, [sp, #24]
    4b16:	cmp	r1, #0
    4b18:	beq.n	4bc6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    4b1a:	ldr	r1, [sp, #24]
    4b1c:	ldr	r1, [r1, #0]
    4b1e:	ldr	r1, [r1, #32]
    4b20:	cmp	r1, r3
    4b22:	bne.w	4dbe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d6>
    4b26:	b.n	4b38 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x750>
    4b28:	.word	0x00000129
    4b2c:	.word	0x0000013d
    4b30:	.word	0x20000074
    4b34:	.word	0x00000acd
    4b38:	ldr	r1, [sp, #24]
    4b3a:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4b3e:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4b40:	cmp.w	lr, #0
    4b44:	beq.n	4bba <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    4b46:	ldr.w	r1, [lr, #16]
    4b4a:	subs	r1, #1
    4b4c:	str.w	r1, [lr, #16]
    4b50:	cmp	r1, #0
    4b52:	bne.n	4bba <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    4b54:	ldr	r1, [sp, #24]
    4b56:	ldr	r1, [r1, #16]
    4b58:	str	r1, [sp, #28]
    4b5a:	cbz	r1, 4bba <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    4b5c:	ldr	r1, [sp, #28]
    4b5e:	ldr	r1, [r1, #0]
    4b60:	ldr	r1, [r1, #32]
    4b62:	cmp	r1, r3
    4b64:	bne.w	4dd4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ec>
    4b68:	ldr	r1, [sp, #28]
    4b6a:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4b6e:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4b70:	cmp.w	lr, #0
    4b74:	beq.n	4bae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    4b76:	ldr.w	r1, [lr, #16]
    4b7a:	subs	r1, #1
    4b7c:	str.w	r1, [lr, #16]
    4b80:	cbnz	r1, 4bae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    4b82:	ldr	r1, [sp, #28]
    4b84:	ldr	r1, [r1, #16]
    4b86:	cbz	r1, 4bae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    4b88:	ldr	r0, [r1, #0]
    4b8a:	ldr	r0, [r0, #32]
    4b8c:	cmp	r0, r3
    4b8e:	mov	lr, r0
    4b90:	bne.w	4dfc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa14>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4b94:	mov	r0, r1
    4b96:	str	r2, [sp, #36]	; 0x24
    4b98:	str.w	fp, [r0], #16
    4b9c:	str	r1, [sp, #32]
		invalidate();
    4b9e:	bl	15b8 <File::invalidate() [clone .isra.1]>
	}
    4ba2:	ldr	r1, [sp, #32]
    4ba4:	mov	r0, r1
    4ba6:	movs	r1, #20
    4ba8:	bl	ea80 <operator delete(void*, unsigned int)>
    4bac:	ldr	r2, [sp, #36]	; 0x24
    4bae:	ldr	r0, [sp, #28]
    4bb0:	str	r2, [sp, #32]
    4bb2:	movs	r1, #20
    4bb4:	bl	ea80 <operator delete(void*, unsigned int)>
    4bb8:	ldr	r2, [sp, #32]
    4bba:	ldr	r0, [sp, #24]
    4bbc:	str	r2, [sp, #28]
    4bbe:	movs	r1, #20
    4bc0:	bl	ea80 <operator delete(void*, unsigned int)>
    4bc4:	ldr	r2, [sp, #28]
    4bc6:	ldr	r0, [sp, #20]
    4bc8:	str	r2, [sp, #24]
    4bca:	movs	r1, #20
    4bcc:	bl	ea80 <operator delete(void*, unsigned int)>
    4bd0:	ldr	r2, [sp, #24]
    4bd2:	ldr	r0, [sp, #16]
    4bd4:	str	r2, [sp, #20]
    4bd6:	movs	r1, #20
    4bd8:	bl	ea80 <operator delete(void*, unsigned int)>
    4bdc:	ldr	r2, [sp, #20]
    4bde:	mov	r0, r2
    4be0:	movs	r1, #20
    4be2:	bl	ea80 <operator delete(void*, unsigned int)>
    4be6:	mov	r0, r7
    4be8:	movs	r1, #20
    4bea:	bl	ea80 <operator delete(void*, unsigned int)>
    4bee:	mov	r0, r5
    4bf0:	movs	r1, #20
    4bf2:	bl	ea80 <operator delete(void*, unsigned int)>
    4bf6:	b.n	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
        }
        else
        { 
          if(!sd_copy(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    4bf8:	str	r4, [sp, #0]
    4bfa:	ldr	r3, [sp, #8]
    4bfc:	add	r2, sp, #80	; 0x50
    4bfe:	mov	r1, r8
    4c00:	mov	r0, r9
    4c02:	bl	3900 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    4c06:	cbz	r0, 4c2e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    4c08:	add	r0, sp, #80	; 0x50
    4c0a:	bl	10680 <strlen>
    4c0e:	mov	r1, r0
    4c10:	add	r0, sp, #80	; 0x50
    4c12:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    4c16:	ldr	r0, [pc, #524]	; (4e24 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa3c>)
    4c18:	bl	e960 <Print::println()>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    4c1c:	ldr.w	r0, [sl, #84]	; 0x54
    4c20:	ldr	r3, [r0, #0]
    4c22:	add	r1, sp, #80	; 0x50
    4c24:	ldr	r3, [r3, #16]
    4c26:	blx	r3
          if(!sd_remove(store0,tmp0Name)) {DBG_FAIL_MACRO; return false;}
    4c28:	cmp	r0, #0
    4c2a:	bne.w	4a08 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x620>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c2e:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4c30:	str.w	fp, [r5]
    4c34:	ldr	r1, [pc, #496]	; (4e28 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c36:	cmp	r2, #0
    4c38:	beq.n	4d26 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    4c3a:	ldr	r3, [r2, #16]
    4c3c:	subs	r3, #1
    4c3e:	str	r3, [r2, #16]
    4c40:	cmp	r3, #0
    4c42:	bne.n	4d26 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    4c44:	ldr	r4, [r5, #16]
    4c46:	cmp	r4, #0
    4c48:	beq.n	4d26 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    4c4a:	ldr	r2, [r4, #0]
    4c4c:	ldr	r3, [pc, #476]	; (4e2c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa44>)
    4c4e:	ldr	r2, [r2, #32]
    4c50:	cmp	r2, r3
    4c52:	bne.w	4d9c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9b4>
    4c56:	ldr	r0, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4c58:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c5a:	cmp	r0, #0
    4c5c:	beq.n	4d1e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    4c5e:	ldr	r2, [r0, #16]
    4c60:	subs	r2, #1
    4c62:	str	r2, [r0, #16]
    4c64:	cmp	r2, #0
    4c66:	bne.n	4d1e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    4c68:	ldr	r5, [r4, #16]
    4c6a:	cmp	r5, #0
    4c6c:	beq.n	4d1e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    4c6e:	ldr	r2, [r5, #0]
    4c70:	ldr	r2, [r2, #32]
    4c72:	cmp	r2, r3
    4c74:	bne.w	4d90 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9a8>
    4c78:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4c7a:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c7c:	cmp	r0, #0
    4c7e:	beq.n	4d16 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    4c80:	ldr	r2, [r0, #16]
    4c82:	subs	r2, #1
    4c84:	str	r2, [r0, #16]
    4c86:	cmp	r2, #0
    4c88:	bne.n	4d16 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    4c8a:	ldr	r6, [r5, #16]
    4c8c:	cmp	r6, #0
    4c8e:	beq.n	4d16 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    4c90:	ldr	r2, [r6, #0]
    4c92:	ldr	r2, [r2, #32]
    4c94:	cmp	r2, r3
    4c96:	bne.w	4dce <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e6>
    4c9a:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4c9c:	str.w	fp, [r6]
    4ca0:	ldr	r0, [pc, #388]	; (4e28 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4ca2:	cmp	r1, #0
    4ca4:	beq.n	4d0e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    4ca6:	ldr	r2, [r1, #16]
    4ca8:	subs	r2, #1
    4caa:	str	r2, [r1, #16]
    4cac:	cbnz	r2, 4d0e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    4cae:	ldr	r7, [r6, #16]
    4cb0:	cbz	r7, 4d0e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    4cb2:	ldr	r2, [r7, #0]
    4cb4:	ldr	r2, [r2, #32]
    4cb6:	cmp	r2, r3
    4cb8:	bne.w	4dea <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa02>
    4cbc:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4cbe:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4cc0:	cbz	r1, 4d06 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    4cc2:	ldr	r2, [r1, #16]
    4cc4:	subs	r2, #1
    4cc6:	str	r2, [r1, #16]
    4cc8:	cbnz	r2, 4d06 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    4cca:	ldr.w	r8, [r7, #16]
    4cce:	cmp.w	r8, #0
    4cd2:	beq.n	4d06 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    4cd4:	ldr.w	r2, [r8]
    4cd8:	ldr	r2, [r2, #32]
    4cda:	cmp	r2, r3
    4cdc:	bne.w	4e08 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa20>
    4ce0:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4ce4:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4ce8:	cbz	r2, 4cfe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    4cea:	ldr	r3, [r2, #16]
    4cec:	subs	r3, #1
    4cee:	str	r3, [r2, #16]
    4cf0:	cbnz	r3, 4cfe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    4cf2:	ldr.w	r0, [r8, #16]
    4cf6:	cbz	r0, 4cfe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    4cf8:	ldr	r3, [r0, #0]
    4cfa:	ldr	r3, [r3, #32]
    4cfc:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4cfe:	mov	r0, r8
    4d00:	movs	r1, #20
    4d02:	bl	ea80 <operator delete(void*, unsigned int)>
    4d06:	mov	r0, r7
    4d08:	movs	r1, #20
    4d0a:	bl	ea80 <operator delete(void*, unsigned int)>
    4d0e:	mov	r0, r6
    4d10:	movs	r1, #20
    4d12:	bl	ea80 <operator delete(void*, unsigned int)>
    4d16:	mov	r0, r5
    4d18:	movs	r1, #20
    4d1a:	bl	ea80 <operator delete(void*, unsigned int)>
    4d1e:	mov	r0, r4
    4d20:	movs	r1, #20
    4d22:	bl	ea80 <operator delete(void*, unsigned int)>
    4d26:	ldr	r3, [sp, #56]	; 0x38
    4d28:	movs	r4, #0
    4d2a:	b.n	47c6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    4d2c:	ldr	r1, [pc, #256]	; (4e30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    4d2e:	b.n	4968 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
    4d30:	ldr	r1, [pc, #252]	; (4e30 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    4d32:	b.n	48e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4d34:	mov	r0, r2
    4d36:	blx	r3
    4d38:	b.n	485c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    4d3a:	blx	r2
    4d3c:	mov	r1, r0
    4d3e:	b.n	48e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    4d40:	blx	r2
    4d42:	b.n	49ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x606>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    4d44:	blx	r2
    4d46:	mov	r1, r0
    4d48:	b.n	4968 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4d4a:	blx	r1
    4d4c:	b.n	485c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4d4e:	mov	r0, r5
    4d50:	blx	r2
    4d52:	b.w	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    4d56:	mov	r0, r7
    4d58:	blx	r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4d5a:	mov	r0, r5
    4d5c:	movs	r1, #20
    4d5e:	bl	ea80 <operator delete(void*, unsigned int)>
    4d62:	b.w	44a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    4d66:	mov	r4, r3
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    4d68:	mov	r0, r4
    4d6a:	add.w	sp, sp, #596	; 0x254
    4d6e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4d72:	mov	r0, r2
    4d74:	blx	r1
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4d76:	mov	r0, r7
    4d78:	movs	r1, #20
    4d7a:	bl	ea80 <operator delete(void*, unsigned int)>
    4d7e:	b.n	4bee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4d80:	mov	r0, r5
    4d82:	blx	r2
    4d84:	b.n	45da <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    4d86:	str	r2, [sp, #20]
    4d88:	ldr	r0, [sp, #16]
    4d8a:	blx	r1
    4d8c:	ldr	r2, [sp, #20]
    4d8e:	b.n	4bde <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    4d90:	mov	r0, r5
    4d92:	blx	r2
    4d94:	b.n	4d1e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    4d96:	mov	r0, r6
    4d98:	blx	r2
    4d9a:	b.n	45d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    4d9c:	mov	r0, r4
    4d9e:	blx	r2
    4da0:	b.n	4d26 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    4da2:	mov	r0, r4
    4da4:	blx	r2
    4da6:	b.n	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4da8:	str	r2, [sp, #24]
    4daa:	ldr	r0, [sp, #20]
    4dac:	blx	r1
    4dae:	ldr	r2, [sp, #24]
    4db0:	b.n	4bd2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    4db2:	mov	r0, r7
    4db4:	blx	r2
    4db6:	b.n	46e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    4db8:	mov	r0, r5
    4dba:	blx	r2
    4dbc:	b.n	47ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    4dbe:	str	r2, [sp, #28]
    4dc0:	ldr	r0, [sp, #24]
    4dc2:	blx	r1
    4dc4:	ldr	r2, [sp, #28]
    4dc6:	b.n	4bc6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    4dc8:	mov	r0, r8
    4dca:	blx	r2
    4dcc:	b.n	46e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    4dce:	mov	r0, r6
    4dd0:	blx	r2
    4dd2:	b.n	4d16 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    4dd4:	str	r2, [sp, #32]
    4dd6:	ldr	r0, [sp, #28]
    4dd8:	blx	r1
    4dda:	ldr	r2, [sp, #32]
    4ddc:	b.n	4bba <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    4dde:	mov	r0, r6
    4de0:	blx	r2
    4de2:	b.n	47a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    4de4:	mov	r0, r7
    4de6:	blx	r2
    4de8:	b.n	479e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    4dea:	mov	r0, r7
    4dec:	blx	r2
    4dee:	b.n	4d0e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    4df0:	mov	r0, r9
    4df2:	blx	r2
    4df4:	b.n	46d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    4df6:	mov	r0, sl
    4df8:	blx	r2
    4dfa:	b.n	46d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    4dfc:	str	r2, [sp, #32]
    4dfe:	mov	r0, r1
    4e00:	mov	r3, lr
    4e02:	blx	r3
    4e04:	ldr	r2, [sp, #32]
    4e06:	b.n	4bae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    4e08:	mov	r0, r8
    4e0a:	blx	r2
    4e0c:	b.n	4d06 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    4e0e:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4e10:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4e14:	cmp	r2, #0
    4e16:	beq.w	47b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4e1a:	b.n	46fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x316>
    4e1c:	ldr	r3, [sp, #56]	; 0x38
    4e1e:	ldr.w	fp, [pc, #8]	; 4e28 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>
    4e22:	b.n	47c6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
    4e24:	.word	0x20000cdc
    4e28:	.word	0x20000074
    4e2c:	.word	0x00000acd
    4e30:	.word	0x2000016c

00004e34 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)>:
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4e34:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4e38:	mov	r6, r1
    4e3a:	subw	sp, sp, #2696	; 0xa88
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0
    4e3e:	cmp.w	r3, #4294967295
    4e42:	ite	ne
    4e44:	movne	r7, r3
    4e46:	moveq	r7, r2
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4e48:	mov	r4, r0
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0

    Record p1 = ReadIndexRecord(handle);
    4e4a:	mov	r1, r0
    4e4c:	mov	r2, r6
    4e4e:	add	r0, sp, #792	; 0x318
    4e50:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    4e54:	mov	r2, r7
    4e56:	mov	r1, r4
    4e58:	add.w	r0, sp, #1064	; 0x428
    4e5c:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p3 = ReadIndexRecord(p1.parent); 
    4e60:	ldr	r2, [sp, #792]	; 0x318
    4e62:	mov	r1, r4
    4e64:	add.w	r0, sp, #1336	; 0x538
    4e68:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    if(p1.isdir) 
    4e6c:	ldrb.w	r3, [sp, #804]	; 0x324
    4e70:	cbz	r3, 4e7c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
    { if(!p1.scanned) 
    4e72:	ldrb.w	r3, [sp, #805]	; 0x325
    4e76:	cmp	r3, #0
    4e78:	beq.w	5028 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1f4>
      { ScanDir(p1.store, handle) ; // in case scan directory
        WriteIndexRecord(handle, p1);
      }
    }

    Record p1o = p1;
    4e7c:	mov.w	r2, #272	; 0x110
    4e80:	add	r1, sp, #792	; 0x318
    4e82:	add.w	r0, sp, #1608	; 0x648
    4e86:	bl	cfd4 <memcpy>
    Record p2o = p2;
    4e8a:	mov.w	r2, #272	; 0x110
    4e8e:	add.w	r1, sp, #1064	; 0x428
    4e92:	add.w	r0, sp, #1880	; 0x758
    4e96:	bl	cfd4 <memcpy>
    Record p3o = p3;

    char oldName[MAX_FILENAME_LEN];
    ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    4e9a:	add	r2, sp, #280	; 0x118
    4e9c:	mov.w	r3, #256	; 0x100
    4ea0:	mov	r1, r6
    4ea2:	mov	r0, r4
    4ea4:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    uint32_t jx=-1;
    Record pxo;

      // remove index from old parent
      Record px;
      if(p3.child==handle)
    4ea8:	ldr.w	r8, [sp, #1340]	; 0x53c
    4eac:	cmp	r6, r8
    4eae:	beq.w	4fee <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1ba>
        p3.child = p1.sibling;
        WriteIndexRecord(p1.parent, p3);    
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
    4eb2:	add	r0, sp, #8
    4eb4:	mov	r2, r8
    4eb6:	mov	r1, r4
    4eb8:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    4ebc:	add	r1, sp, #8
    4ebe:	mov.w	r2, #272	; 0x110
    4ec2:	addw	r0, sp, #2424	; 0x978
    4ec6:	bl	cfd4 <memcpy>
        pxo = px;
    4eca:	addw	r1, sp, #2424	; 0x978
    4ece:	addw	r0, sp, #2152	; 0x868
    4ed2:	mov.w	r2, #272	; 0x110
    4ed6:	bl	cfd4 <memcpy>
        while(handle != px.sibling)
    4eda:	ldr.w	r5, [sp, #2432]	; 0x980
    4ede:	cmp	r6, r5
    4ee0:	bne.n	4ee6 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb2>
    4ee2:	b.n	5040 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x20c>
    4ee4:	mov	r5, r3
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
    4ee6:	mov	r2, r5
    4ee8:	mov	r1, r4
    4eea:	add	r0, sp, #8
    4eec:	bl	1bd0 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    4ef0:	mov.w	r2, #272	; 0x110
    4ef4:	add	r1, sp, #8
    4ef6:	addw	r0, sp, #2424	; 0x978
    4efa:	bl	cfd4 <memcpy>
          pxo = px;
    4efe:	mov.w	r2, #272	; 0x110
    4f02:	addw	r1, sp, #2424	; 0x978
    4f06:	addw	r0, sp, #2152	; 0x868
    4f0a:	bl	cfd4 <memcpy>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    4f0e:	ldr.w	r3, [sp, #2432]	; 0x980
    4f12:	cmp	r6, r3
    4f14:	bne.n	4ee4 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb0>
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
          pxo = px;
        }
        px.sibling = p1.sibling;
    4f16:	ldr	r3, [sp, #800]	; 0x320
    4f18:	str.w	r3, [sp, #2432]	; 0x980
        WriteIndexRecord(jx, px);
    4f1c:	addw	r2, sp, #2424	; 0x978
    4f20:	mov	r1, r5
    4f22:	mov	r0, r4
    4f24:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    4f28:	ldrh.w	r0, [sp, #1078]	; 0x436
      p1.sibling = p2.child;
    4f2c:	ldr.w	r3, [sp, #1068]	; 0x42c
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    4f30:	strh.w	r0, [sp, #806]	; 0x326
      p1.sibling = p2.child;
      p2.child = handle;
      WriteIndexRecord(handle, p1);
    4f34:	add	r2, sp, #792	; 0x318
    4f36:	mov	r1, r6
    4f38:	mov	r0, r4
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
      p1.sibling = p2.child;
    4f3a:	str	r3, [sp, #800]	; 0x320
        px.sibling = p1.sibling;
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
    4f3c:	str	r7, [sp, #792]	; 0x318
      p1.store = p2.store;
      p1.sibling = p2.child;
      p2.child = handle;
    4f3e:	str.w	r6, [sp, #1068]	; 0x42c
      WriteIndexRecord(handle, p1);
    4f42:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      WriteIndexRecord(newParent,p2);
    4f46:	add.w	r2, sp, #1064	; 0x428
    4f4a:	mov	r1, r7
    4f4c:	mov	r0, r4
    4f4e:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      // now working on disk storage
      char newName[MAX_FILENAME_LEN];
      ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    4f52:	mov.w	r3, #256	; 0x100
    4f56:	mov	r1, r6
    4f58:	add	r2, sp, #536	; 0x218
    4f5a:	mov	r0, r4
    4f5c:	bl	2030 <MTPStorage_SD::ConstructFilename(int, char*, int)>
        Serial.print(p1.store); Serial.print(": ");Serial.println(newName);
        dumpIndexList();
      #endif


    if(p1o.store == p2o.store)
    4f60:	ldrh.w	r1, [sp, #1622]	; 0x656
    4f64:	ldrh.w	r3, [sp, #1894]	; 0x766
    4f68:	cmp	r1, r3
    4f6a:	beq.n	5006 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1d2>
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    4f6c:	ldrb.w	r2, [sp, #1620]	; 0x654
    4f70:	cbz	r2, 4fb4 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x180>
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    }
    else
    { // move directory cross mtp-disks
      if(sd_moveDir(p1o.store,oldName,p2o.store,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    4f72:	add	r2, sp, #536	; 0x218
    4f74:	str	r2, [sp, #0]
    4f76:	adds	r0, r4, #4
    4f78:	add	r2, sp, #280	; 0x118
    4f7a:	bl	43b4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    4f7e:	cmp	r0, #0
    4f80:	bne.n	501a <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1e6>
    }

  fail:
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    4f82:	mov	r1, r5
    4f84:	addw	r2, sp, #2152	; 0x868
    4f88:	mov	r0, r4
    4f8a:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(handle, p1o);
    4f8e:	add.w	r2, sp, #1608	; 0x648
    4f92:	mov	r1, r6
    4f94:	mov	r0, r4
    4f96:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(newParent,p2o);      
    4f9a:	add.w	r2, sp, #1880	; 0x758
    4f9e:	mov	r1, r7
    4fa0:	mov	r0, r4
    4fa2:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
    4fa6:	mov.w	r8, #0
  }
    4faa:	mov	r0, r8
    4fac:	addw	sp, sp, #2696	; 0xa88
    4fb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
    4fb4:	add	r2, sp, #536	; 0x218
    4fb6:	str	r2, [sp, #0]
    4fb8:	adds	r0, r4, #4
    4fba:	add	r2, sp, #280	; 0x118
    4fbc:	bl	3900 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    4fc0:	mov	r8, r0
    4fc2:	cmp	r0, #0
    4fc4:	beq.n	4f82 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    4fc6:	add	r0, sp, #280	; 0x118
    4fc8:	bl	10680 <strlen>
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    4fcc:	ldrh.w	r5, [sp, #1894]	; 0x766
    4fd0:	mov	r1, r0
    4fd2:	add.w	r4, r4, r5, lsl #2
    4fd6:	add	r0, sp, #280	; 0x118
    4fd8:	bl	d248 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    4fdc:	ldr	r0, [pc, #100]	; (5044 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x210>)
    4fde:	bl	e960 <Print::println()>
    4fe2:	ldr	r0, [r4, #88]	; 0x58
    4fe4:	ldr	r3, [r0, #0]
    4fe6:	add	r1, sp, #280	; 0x118
    4fe8:	ldr	r3, [r3, #16]
    4fea:	blx	r3
    4fec:	b.n	4faa <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x176>

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    4fee:	ldr	r3, [sp, #800]	; 0x320
        WriteIndexRecord(p1.parent, p3);    
    4ff0:	ldr	r1, [sp, #792]	; 0x318

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    4ff2:	str.w	r3, [sp, #1340]	; 0x53c
        WriteIndexRecord(p1.parent, p3);    
    4ff6:	add.w	r2, sp, #1336	; 0x538
    4ffa:	mov	r0, r4
    4ffc:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    #if DEBUG>1
      Serial.print(p1.store); Serial.print(": "); Serial.println(oldName);
      dumpIndexList();
    #endif

    uint32_t jx=-1;
    5000:	mov.w	r5, #4294967295
    5004:	b.n	4f28 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xf4>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    5006:	add.w	r1, r4, r1, lsl #2
    500a:	add	r2, sp, #536	; 0x218
    500c:	ldr	r0, [r1, #88]	; 0x58
    500e:	ldr	r3, [r0, #0]
    5010:	add	r1, sp, #280	; 0x118
    5012:	ldr	r3, [r3, #12]
    5014:	blx	r3
      #endif


    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    5016:	cmp	r0, #0
    5018:	beq.n	4f82 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
    501a:	mov.w	r8, #1
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    WriteIndexRecord(handle, p1o);
    WriteIndexRecord(newParent,p2o);      
    return false;
  }
    501e:	mov	r0, r8
    5020:	addw	sp, sp, #2696	; 0xa88
    5024:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);
    Record p3 = ReadIndexRecord(p1.parent); 

    if(p1.isdir) 
    { if(!p1.scanned) 
      { ScanDir(p1.store, handle) ; // in case scan directory
    5028:	mov	r2, r6
    502a:	ldrh.w	r1, [sp, #806]	; 0x326
    502e:	mov	r0, r4
    5030:	bl	27bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
        WriteIndexRecord(handle, p1);
    5034:	add	r2, sp, #792	; 0x318
    5036:	mov	r1, r6
    5038:	mov	r0, r4
    503a:	bl	19f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    503e:	b.n	4e7c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    5040:	mov	r5, r8
    5042:	b.n	4f16 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xe2>
    5044:	.word	0x20000cdc

00005048 <MTPD::GetNumObjects(unsigned long, unsigned long)>:

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5048:	push	{r4, r5, r6, lr}
    504a:	mov	r6, r0
    storage_->StartGetObjectHandles(store, parent);
    504c:	ldr	r0, [r0, #0]
    504e:	ldr	r3, [r0, #0]

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5050:	subs	r5, r1, #1
    storage_->StartGetObjectHandles(store, parent);
    5052:	ldr	r3, [r3, #28]
    5054:	mov	r1, r5
    5056:	blx	r3
    int num = 0;
    5058:	movs	r4, #0
    505a:	b.n	505e <MTPD::GetNumObjects(unsigned long, unsigned long)+0x16>
    while (storage_->GetNextObjectHandle(store)) num++;
    505c:	adds	r4, #1
    505e:	ldr	r0, [r6, #0]
    5060:	ldr	r3, [r0, #0]
    5062:	mov	r1, r5
    5064:	ldr	r3, [r3, #32]
    5066:	blx	r3
    5068:	cmp	r0, #0
    506a:	bne.n	505c <MTPD::GetNumObjects(unsigned long, unsigned long)+0x14>
    return num;
  }
    506c:	mov	r0, r4
    506e:	pop	{r4, r5, r6, pc}

00005070 <MTPD::get_buffer()>:


#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

//  usb_packet_t *data_buffer_ = NULL;
  void MTPD::get_buffer() {
    5070:	push	{r4, lr}
    5072:	mov	r4, r0
    5074:	ldr	r0, [r4, #4]
    while (!data_buffer_) {
    5076:	cbnz	r0, 5080 <MTPD::get_buffer()+0x10>
      data_buffer_ = usb_malloc();
    5078:	bl	dc14 <usb_malloc>
    507c:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    507e:	cbz	r0, 5082 <MTPD::get_buffer()+0x12>
    5080:	pop	{r4, pc}
    5082:	bl	1658 <mtp_yield()>
    5086:	b.n	5074 <MTPD::get_buffer()+0x4>

00005088 <MTPD::write(char const*, int) [clone .part.2]>:
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5088:	cmp	r2, #0
    508a:	ble.n	50ea <MTPD::write(char const*, int) [clone .part.2]+0x62>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    508c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5090:	mov.w	r9, #0
    5094:	mov	r6, r2
    5096:	mov	r7, r1
    5098:	mov	r5, r0
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    509a:	mov	r8, r9
    509c:	b.n	50a2 <MTPD::write(char const*, int) [clone .part.2]+0x1a>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    509e:	cmp	r6, r9
    50a0:	ble.n	50e6 <MTPD::write(char const*, int) [clone .part.2]+0x5e>
        get_buffer();
    50a2:	mov	r0, r5
    50a4:	bl	5070 <MTPD::get_buffer()>
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    50a8:	ldr	r3, [r5, #4]
    50aa:	ldrh.w	r0, [r3], #8
    50ae:	rsb	r2, r9, r6
    50b2:	rsb	r4, r0, #64	; 0x40
    50b6:	cmp	r4, r2
    50b8:	it	ge
    50ba:	movge	r4, r2
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
    50bc:	add.w	r1, r7, r9
    50c0:	add	r0, r3
    50c2:	mov	r2, r4
    50c4:	bl	cfd4 <memcpy>
        data_buffer_->len += to_copy;
    50c8:	ldr	r1, [r5, #4]
    50ca:	ldrh	r3, [r1, #0]
    50cc:	add	r3, r4
    50ce:	uxth	r3, r3
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    50d0:	cmp	r3, #64	; 0x40
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
    50d2:	add	r9, r4
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
    50d4:	strh	r3, [r1, #0]
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    50d6:	bne.n	509e <MTPD::write(char const*, int) [clone .part.2]+0x16>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    50d8:	movs	r0, #4
    50da:	bl	dd8c <usb_tx>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    50de:	cmp	r6, r9
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    50e0:	str.w	r8, [r5, #4]
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    50e4:	bgt.n	50a2 <MTPD::write(char const*, int) [clone .part.2]+0x1a>
    50e6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    50ea:	bx	lr

000050ec <MTPD::writestring(char const*)>:
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    50ec:	push	{r4, r5, lr}
    if (*str) 
    50ee:	ldrb	r3, [r1, #0]
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    50f0:	sub	sp, #12
    50f2:	mov	r4, r0
    if (*str) 
    50f4:	cbz	r3, 5150 <MTPD::writestring(char const*)+0x64>
    { write8(strlen(str) + 1);
    50f6:	mov	r0, r1
    50f8:	mov	r5, r1
    50fa:	bl	10680 <strlen>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    50fe:	ldrb	r1, [r4, #8]
    5100:	adds	r0, #1
    5102:	strb.w	r0, [sp, #3]
    5106:	cbz	r1, 5162 <MTPD::writestring(char const*)+0x76>
      write_length_ += len;
    5108:	ldr	r3, [r4, #12]
    510a:	adds	r3, #1
    510c:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    510e:	ldrb	r2, [r5, #0]
    5110:	cbnz	r2, 5120 <MTPD::writestring(char const*)+0x34>
    5112:	b.n	5148 <MTPD::writestring(char const*)+0x5c>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5114:	ldr	r3, [r4, #12]
    5116:	adds	r3, #2
    5118:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    511a:	ldrb.w	r2, [r5, #1]!
    511e:	cbz	r2, 513e <MTPD::writestring(char const*)+0x52>
    5120:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5124:	cmp	r1, #0
    5126:	bne.n	5114 <MTPD::writestring(char const*)+0x28>
    5128:	movs	r2, #2
    512a:	add.w	r1, sp, #6
    512e:	mov	r0, r4
    5130:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5134:	ldrb.w	r2, [r5, #1]!
    5138:	ldrb	r1, [r4, #8]
    513a:	cmp	r2, #0
    513c:	bne.n	5120 <MTPD::writestring(char const*)+0x34>
    513e:	movs	r3, #0
    5140:	strh.w	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5144:	cbz	r1, 5186 <MTPD::writestring(char const*)+0x9a>
    5146:	ldr	r3, [r4, #12]
      write_length_ += len;
    5148:	adds	r3, #2
    514a:	str	r3, [r4, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    514c:	add	sp, #12
    514e:	pop	{r4, r5, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5150:	ldrb	r2, [r0, #8]
    5152:	strb.w	r3, [sp, #2]
    5156:	cbz	r2, 5178 <MTPD::writestring(char const*)+0x8c>
      write_length_ += len;
    5158:	ldr	r3, [r0, #12]
    515a:	adds	r3, #1
    515c:	str	r3, [r0, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    515e:	add	sp, #12
    5160:	pop	{r4, r5, pc}
    5162:	movs	r2, #1
    5164:	add.w	r1, sp, #3
    5168:	mov	r0, r4
    516a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    516e:	ldrb	r2, [r5, #0]
    5170:	ldrb	r1, [r4, #8]
    5172:	cmp	r2, #0
    5174:	bne.n	5120 <MTPD::writestring(char const*)+0x34>
    5176:	b.n	513e <MTPD::writestring(char const*)+0x52>
    5178:	movs	r2, #1
    517a:	add.w	r1, sp, #2
    517e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    } else 
    { write8(0);
    }
  }
    5182:	add	sp, #12
    5184:	pop	{r4, r5, pc}
    5186:	mov	r0, r4
    5188:	movs	r2, #2
    518a:	add	r1, sp, #4
    518c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5190:	add	sp, #12
    5192:	pop	{r4, r5, pc}

00005194 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>:
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5194:	push	{r4, r5, r6, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5196:	ldrb	r3, [r0, #8]
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5198:	sub	sp, #8
    519a:	mov	r4, r0
    519c:	mov	r5, r1
    519e:	strh.w	r1, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    51a2:	cbz	r3, 51dc <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x48>
      write_length_ += len;
    51a4:	ldr	r3, [r0, #12]
    51a6:	movw	r2, #65535	; 0xffff
    51aa:	adds	r3, #2
    51ac:	str	r3, [r0, #12]
    51ae:	strh.w	r2, [sp, #6]
    51b2:	adds	r3, #2
    51b4:	movs	r2, #0
    51b6:	str	r3, [r4, #12]
    51b8:	strb.w	r2, [sp, #2]
    51bc:	adds	r3, #1
    51be:	str	r3, [r4, #12]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    51c0:	movw	r3, #54274	; 0xd402
    51c4:	cmp	r5, r3
    51c6:	beq.n	5218 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x84>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    51c8:	ldrb	r3, [r4, #8]
    51ca:	movs	r2, #0
    51cc:	strb.w	r2, [sp, #3]
    51d0:	cbz	r3, 5234 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xa0>
      write_length_ += len;
    51d2:	ldr	r3, [r4, #12]
    51d4:	adds	r3, #1
    51d6:	str	r3, [r4, #12]
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    51d8:	add	sp, #8
    51da:	pop	{r4, r5, r6, pc}
    51dc:	movs	r2, #2
    51de:	add	r1, sp, #4
    51e0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    51e4:	ldrb	r6, [r4, #8]
    51e6:	movw	r3, #65535	; 0xffff
    51ea:	strh.w	r3, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    51ee:	cbnz	r6, 5244 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb0>
    51f0:	movs	r2, #2
    51f2:	add.w	r1, sp, #6
    51f6:	mov	r0, r4
    51f8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    51fc:	ldrb	r3, [r4, #8]
    51fe:	strb.w	r6, [sp, #2]
    5202:	cbnz	r3, 5248 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb4>
    5204:	movs	r2, #1
    5206:	add.w	r1, sp, #2
    520a:	mov	r0, r4
    520c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5210:	movw	r3, #54274	; 0xd402
    5214:	cmp	r5, r3
    5216:	bne.n	51c8 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x34>
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5218:	ldr	r1, [pc, #48]	; (524c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    521a:	mov	r0, r4
    521c:	bl	50ec <MTPD::writestring(char const*)>
    5220:	ldr	r1, [pc, #40]	; (524c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    5222:	mov	r0, r4
    5224:	bl	50ec <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5228:	ldrb	r3, [r4, #8]
    522a:	movs	r2, #0
    522c:	strb.w	r2, [sp, #3]
    5230:	cmp	r3, #0
    5232:	bne.n	51d2 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x3e>
    5234:	mov	r0, r4
    5236:	movs	r2, #1
    5238:	add.w	r1, sp, #3
    523c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    5240:	add	sp, #8
    5242:	pop	{r4, r5, r6, pc}
    5244:	ldr	r3, [r4, #12]
    5246:	b.n	51b2 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x1e>
    5248:	ldr	r3, [r4, #12]
    524a:	b.n	51bc <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x28>
    524c:	.word	0x2000036c

00005250 <MTPD::WriteDescriptor()>:
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5250:	push	{r4, r5, r6, r7, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5252:	ldrb	r3, [r0, #8]
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5254:	sub	sp, #68	; 0x44
    5256:	movs	r5, #100	; 0x64
    5258:	mov	r4, r0
    525a:	strh.w	r5, [sp, #8]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    525e:	cmp	r3, #0
    5260:	beq.w	53b0 <MTPD::WriteDescriptor()+0x160>
      write_length_ += len;
    5264:	ldr	r3, [r0, #12]
    5266:	movs	r2, #6
    5268:	adds	r3, #2
    526a:	str	r3, [r0, #12]
    526c:	str	r2, [sp, #24]
    526e:	adds	r3, #4
    5270:	movs	r2, #100	; 0x64
    5272:	str	r3, [r4, #12]
    5274:	strh.w	r2, [sp, #6]
    5278:	adds	r3, #2
    527a:	str	r3, [r4, #12]
  void MTPD::WriteDescriptor() {
    write16(100);  // MTP version
    write32(6);    // MTP extension
//    write32(0xFFFFFFFFUL);    // MTP extension
    write16(100);  // MTP version
    writestring("microsoft.com: 1.0;");
    527c:	ldr	r1, [pc, #556]	; (54ac <MTPD::WriteDescriptor()+0x25c>)
    527e:	mov	r0, r4
    5280:	bl	50ec <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5284:	ldrb	r3, [r4, #8]
    5286:	movs	r2, #0
    5288:	strh.w	r2, [sp, #4]
    528c:	cmp	r3, #0
    528e:	beq.w	546a <MTPD::WriteDescriptor()+0x21a>
      write_length_ += len;
    5292:	ldr	r3, [r4, #12]
    5294:	movs	r2, #20
    5296:	adds	r3, #2
    5298:	str	r3, [r4, #12]
    529a:	str	r2, [sp, #20]
    529c:	adds	r3, #4
    529e:	str	r3, [r4, #12]
    52a0:	movs	r6, #1
    52a2:	ldr	r5, [pc, #524]	; (54b0 <MTPD::WriteDescriptor()+0x260>)
    52a4:	movw	r3, #4097	; 0x1001
    52a8:	add.w	r7, r5, #38	; 0x26
    52ac:	b.n	52be <MTPD::WriteDescriptor()+0x6e>
    52ae:	ldr	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    52b0:	cmp	r5, r7
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    52b2:	add.w	r3, r3, #2
    52b6:	str	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    52b8:	beq.n	52d8 <MTPD::WriteDescriptor()+0x88>
    52ba:	ldrh.w	r3, [r5, #2]!
    52be:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    52c2:	cmp	r6, #0
    52c4:	bne.n	52ae <MTPD::WriteDescriptor()+0x5e>
    52c6:	movs	r2, #2
    52c8:	add.w	r1, sp, #10
    52cc:	mov	r0, r4
    52ce:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    52d2:	cmp	r5, r7
    52d4:	ldrb	r6, [r4, #8]
    52d6:	bne.n	52ba <MTPD::WriteDescriptor()+0x6a>
    52d8:	movs	r2, #4
    52da:	str	r2, [sp, #28]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    52dc:	cmp	r6, #0
    52de:	beq.w	545e <MTPD::WriteDescriptor()+0x20e>
      write_length_ += len;
    52e2:	ldr	r3, [r4, #12]
    52e4:	adds	r3, #4
    52e6:	str	r3, [r4, #12]
    52e8:	ldr	r5, [pc, #456]	; (54b4 <MTPD::WriteDescriptor()+0x264>)
    52ea:	movw	r3, #16388	; 0x4004
    52ee:	adds	r7, r5, #6
    52f0:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    52f4:	cbz	r6, 530e <MTPD::WriteDescriptor()+0xbe>
      write_length_ += len;
    52f6:	ldr	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    52f8:	cmp	r7, r5
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    52fa:	add.w	r3, r3, #2
    52fe:	str	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5300:	beq.n	531e <MTPD::WriteDescriptor()+0xce>
    5302:	ldrh.w	r3, [r5, #2]!
    5306:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    530a:	cmp	r6, #0
    530c:	bne.n	52f6 <MTPD::WriteDescriptor()+0xa6>
    530e:	movs	r2, #2
    5310:	add	r1, sp, #12
    5312:	mov	r0, r4
    5314:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5318:	cmp	r7, r5
    531a:	ldrb	r6, [r4, #8]
    531c:	bne.n	5302 <MTPD::WriteDescriptor()+0xb2>
    531e:	movs	r3, #1
    5320:	str	r3, [sp, #40]	; 0x28
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5322:	cmp	r6, #0
    5324:	beq.n	53e4 <MTPD::WriteDescriptor()+0x194>
      write_length_ += len;
    5326:	ldr	r3, [r4, #12]
    5328:	movw	r2, #54274	; 0xd402
    532c:	adds	r3, #4
    532e:	str	r3, [r4, #12]
    5330:	strh.w	r2, [sp, #18]
    5334:	adds	r3, #2
    5336:	movs	r2, #0
    5338:	str	r3, [r4, #12]
    533a:	str	r2, [sp, #36]	; 0x24
    533c:	adds	r3, #4
    533e:	movs	r2, #2
    5340:	str	r3, [r4, #12]
    5342:	str	r2, [sp, #32]
    5344:	adds	r3, #4
    5346:	mov.w	r2, #12288	; 0x3000
    534a:	str	r3, [r4, #12]
    534c:	strh.w	r2, [sp, #16]
    5350:	adds	r3, #2
    5352:	movw	r2, #12289	; 0x3001
    5356:	str	r3, [r4, #12]
    5358:	strh.w	r2, [sp, #14]
    535c:	adds	r3, #2
    535e:	str	r3, [r4, #12]

    write32(2);       // Playback formats (array of uint16)
    write16(0x3000);  // Undefined format
    write16(0x3001);  // Folders (associations)

    writestring(MTP_MANUF);     // Manufacturer
    5360:	ldr	r1, [pc, #340]	; (54b8 <MTPD::WriteDescriptor()+0x268>)
    5362:	mov	r0, r4
    5364:	bl	50ec <MTPD::writestring(char const*)>
    writestring(MTP_MODEL);     // Model
    5368:	ldr	r1, [pc, #336]	; (54bc <MTPD::WriteDescriptor()+0x26c>)
    536a:	mov	r0, r4
    536c:	bl	50ec <MTPD::writestring(char const*)>
    //writestring(MTP_VERS);      // version
    //writestring(MTP_SERNR);     // serial
    
    char buf[20];    
    dtostrf( (float)(TEENSYDUINO / 100.0f), 3, 2, buf);
    5370:	vldr	s0, [pc, #332]	; 54c0 <MTPD::WriteDescriptor()+0x270>
    5374:	add	r2, sp, #44	; 0x2c
    5376:	movs	r1, #2
    5378:	movs	r0, #3
    537a:	bl	d5a8 <dtostrf>
    strlcat(buf, " / MTP " MTP_VERS, sizeof(buf) );
    537e:	movs	r2, #20
    5380:	ldr	r1, [pc, #320]	; (54c4 <MTPD::WriteDescriptor()+0x274>)
    5382:	add	r0, sp, #44	; 0x2c
    5384:	bl	105cc <strlcat>
    writestring( buf );    
    5388:	mov	r0, r4
    538a:	add	r1, sp, #44	; 0x2c
    538c:	bl	50ec <MTPD::writestring(char const*)>
    5390:	ldr	r2, [pc, #308]	; (54c8 <MTPD::WriteDescriptor()+0x278>)
    5392:	add	r3, sp, #44	; 0x2c
    5394:	add.w	r0, sp, #54	; 0x36
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    5398:	ldrh.w	r1, [r2, #2]!
    539c:	strb.w	r1, [r3], #1
    53a0:	cmp	r3, r0
    53a2:	bne.n	5398 <MTPD::WriteDescriptor()+0x148>
    #pragma GCC diagnostic pop
    writestring(buf);    
    53a4:	add	r1, sp, #44	; 0x2c
    53a6:	mov	r0, r4
    53a8:	bl	50ec <MTPD::writestring(char const*)>
  }
    53ac:	add	sp, #68	; 0x44
    53ae:	pop	{r4, r5, r6, r7, pc}
    53b0:	movs	r2, #2
    53b2:	add	r1, sp, #8
    53b4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    53b8:	ldrb	r3, [r4, #8]
    53ba:	movs	r2, #6
    53bc:	str	r2, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    53be:	cmp	r3, #0
    53c0:	bne.n	548a <MTPD::WriteDescriptor()+0x23a>
    53c2:	movs	r2, #4
    53c4:	add	r1, sp, #24
    53c6:	mov	r0, r4
    53c8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    53cc:	ldrb	r3, [r4, #8]
    53ce:	strh.w	r5, [sp, #6]
    53d2:	cmp	r3, #0
    53d4:	bne.n	548e <MTPD::WriteDescriptor()+0x23e>
    53d6:	movs	r2, #2
    53d8:	add.w	r1, sp, #6
    53dc:	mov	r0, r4
    53de:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    53e2:	b.n	527c <MTPD::WriteDescriptor()+0x2c>
    53e4:	movs	r2, #4
    53e6:	add	r1, sp, #40	; 0x28
    53e8:	mov	r0, r4
    53ea:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    53ee:	ldrb	r3, [r4, #8]
    53f0:	movw	r2, #54274	; 0xd402
    53f4:	strh.w	r2, [sp, #18]
    53f8:	cmp	r3, #0
    53fa:	bne.n	5492 <MTPD::WriteDescriptor()+0x242>
    53fc:	movs	r2, #2
    53fe:	add.w	r1, sp, #18
    5402:	mov	r0, r4
    5404:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5408:	ldrb	r3, [r4, #8]
    540a:	str	r6, [sp, #36]	; 0x24
    540c:	cmp	r3, #0
    540e:	bne.n	5496 <MTPD::WriteDescriptor()+0x246>
    5410:	movs	r2, #4
    5412:	add	r1, sp, #36	; 0x24
    5414:	mov	r0, r4
    5416:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    541a:	ldrb	r3, [r4, #8]
    541c:	movs	r5, #2
    541e:	str	r5, [sp, #32]
    5420:	cmp	r3, #0
    5422:	bne.n	549a <MTPD::WriteDescriptor()+0x24a>
    5424:	movs	r2, #4
    5426:	add	r1, sp, #32
    5428:	mov	r0, r4
    542a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    542e:	ldrb	r3, [r4, #8]
    5430:	mov.w	r2, #12288	; 0x3000
    5434:	strh.w	r2, [sp, #16]
    5438:	cbnz	r3, 549e <MTPD::WriteDescriptor()+0x24e>
    543a:	mov	r2, r5
    543c:	add	r1, sp, #16
    543e:	mov	r0, r4
    5440:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5444:	ldrb	r3, [r4, #8]
    5446:	movw	r2, #12289	; 0x3001
    544a:	strh.w	r2, [sp, #14]
    544e:	cbnz	r3, 54a2 <MTPD::WriteDescriptor()+0x252>
    5450:	mov	r2, r5
    5452:	add.w	r1, sp, #14
    5456:	mov	r0, r4
    5458:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    545c:	b.n	5360 <MTPD::WriteDescriptor()+0x110>
    545e:	add	r1, sp, #28
    5460:	mov	r0, r4
    5462:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5466:	ldrb	r6, [r4, #8]
    5468:	b.n	52e8 <MTPD::WriteDescriptor()+0x98>
    546a:	movs	r2, #2
    546c:	add	r1, sp, #4
    546e:	mov	r0, r4
    5470:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5474:	ldrb	r3, [r4, #8]
    5476:	movs	r2, #20
    5478:	str	r2, [sp, #20]
    547a:	cbnz	r3, 54a6 <MTPD::WriteDescriptor()+0x256>
    547c:	movs	r2, #4
    547e:	add	r1, sp, #20
    5480:	mov	r0, r4
    5482:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5486:	ldrb	r6, [r4, #8]
    5488:	b.n	52a2 <MTPD::WriteDescriptor()+0x52>
    548a:	ldr	r3, [r4, #12]
    548c:	b.n	526e <MTPD::WriteDescriptor()+0x1e>
    548e:	ldr	r3, [r4, #12]
    5490:	b.n	5278 <MTPD::WriteDescriptor()+0x28>
    5492:	ldr	r3, [r4, #12]
    5494:	b.n	5334 <MTPD::WriteDescriptor()+0xe4>
    5496:	ldr	r3, [r4, #12]
    5498:	b.n	533c <MTPD::WriteDescriptor()+0xec>
    549a:	ldr	r3, [r4, #12]
    549c:	b.n	5344 <MTPD::WriteDescriptor()+0xf4>
    549e:	ldr	r3, [r4, #12]
    54a0:	b.n	5350 <MTPD::WriteDescriptor()+0x100>
    54a2:	ldr	r3, [r4, #12]
    54a4:	b.n	535c <MTPD::WriteDescriptor()+0x10c>
    54a6:	ldr	r3, [r4, #12]
    54a8:	b.n	529c <MTPD::WriteDescriptor()+0x4c>
    54aa:	nop
    54ac:	.word	0x20000374
    54b0:	.word	0x20000334
    54b4:	.word	0x200003bc
    54b8:	.word	0x20000388
    54bc:	.word	0x2000036c
    54c0:	.word	0x3fc51eb8
    54c4:	.word	0x20000390
    54c8:	.word	0x20000cbc

000054cc <MTPD::WriteStorageIDs()>:
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    54cc:	push	{r4, r5, r6, lr}
    54ce:	mov	r5, r0
    uint32_t num=storage_->get_FSCount();
    54d0:	ldr	r0, [r0, #0]
    54d2:	ldr	r2, [pc, #92]	; (5530 <MTPD::WriteStorageIDs()+0x64>)
    54d4:	ldr	r3, [r0, #0]
    54d6:	ldr	r3, [r3, #4]
    54d8:	cmp	r3, r2
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    54da:	sub	sp, #8
    54dc:	bne.n	5528 <MTPD::WriteStorageIDs()+0x5c>
    {
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    54de:	ldr	r6, [r0, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    54e0:	ldrb	r3, [r5, #8]
    54e2:	str	r6, [sp, #0]
    54e4:	cbz	r3, 551c <MTPD::WriteStorageIDs()+0x50>
      write_length_ += len;
    54e6:	ldr	r3, [r5, #12]
    54e8:	adds	r3, #4
    54ea:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    54ec:	cbz	r6, 5518 <MTPD::WriteStorageIDs()+0x4c>
    54ee:	movs	r4, #0
    54f0:	b.n	54fe <MTPD::WriteStorageIDs()+0x32>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    54f2:	ldr	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    54f4:	cmp	r6, r4
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    54f6:	add.w	r3, r3, #4
    54fa:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    54fc:	beq.n	5518 <MTPD::WriteStorageIDs()+0x4c>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    54fe:	ldrb	r3, [r5, #8]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5500:	adds	r4, #1
    5502:	str	r4, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5504:	cmp	r3, #0
    5506:	bne.n	54f2 <MTPD::WriteStorageIDs()+0x26>
    5508:	movs	r2, #4
    550a:	add.w	r1, sp, r2
    550e:	mov	r0, r5
    5510:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5514:	cmp	r6, r4
    5516:	bne.n	54fe <MTPD::WriteStorageIDs()+0x32>
  }
    5518:	add	sp, #8
    551a:	pop	{r4, r5, r6, pc}
    551c:	movs	r2, #4
    551e:	mov	r1, sp
    5520:	mov	r0, r5
    5522:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5526:	b.n	54ec <MTPD::WriteStorageIDs()+0x20>
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    5528:	blx	r3
    552a:	mov	r6, r0
    552c:	b.n	54e0 <MTPD::WriteStorageIDs()+0x14>
    552e:	nop
    5530:	.word	0x00001379

00005534 <MTPD::GetObjectHandles(unsigned long, unsigned long)>:
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5534:	push	{r4, r5, r6, lr}
    if (write_get_length_) {
    5536:	ldrb	r3, [r0, #8]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5538:	sub	sp, #8
    553a:	mov	r4, r0
    if (write_get_length_) {
    553c:	cbnz	r3, 5588 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x54>
    553e:	mov	r5, r1
    5540:	mov	r6, r2
      write_length_ = GetNumObjects(storage, parent);
      write_length_++;
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
    5542:	bl	5048 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5546:	ldrb	r3, [r4, #8]
    5548:	str	r0, [sp, #0]
    554a:	cbz	r3, 5596 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x62>
      write_length_ += len;
    554c:	ldr	r3, [r4, #12]
    554e:	adds	r3, #4
    5550:	str	r3, [r4, #12]
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    5552:	ldr	r0, [r4, #0]
    5554:	ldr	r3, [r0, #0]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5556:	subs	r5, #1
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    5558:	mov	r2, r6
    555a:	ldr	r3, [r3, #28]
    555c:	mov	r1, r5
    555e:	blx	r3
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    5560:	ldr	r0, [r4, #0]
    5562:	ldr	r3, [r0, #0]
    5564:	mov	r1, r5
    5566:	ldr	r3, [r3, #32]
    5568:	blx	r3
    556a:	cbz	r0, 5592 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x5e>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    556c:	ldrb	r3, [r4, #8]
    556e:	str	r0, [sp, #4]
    5570:	cbz	r3, 557a <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x46>
      write_length_ += len;
    5572:	ldr	r3, [r4, #12]
    5574:	adds	r3, #4
    5576:	str	r3, [r4, #12]
    5578:	b.n	5560 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
    557a:	movs	r2, #4
    557c:	add.w	r1, sp, r2
    5580:	mov	r0, r4
    5582:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5586:	b.n	5560 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    if (write_get_length_) {
      write_length_ = GetNumObjects(storage, parent);
    5588:	bl	5048 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      write_length_++;
      write_length_ *= 4;
    558c:	adds	r0, #1
    558e:	lsls	r0, r0, #2
    5590:	str	r0, [r4, #12]
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    }
  }
    5592:	add	sp, #8
    5594:	pop	{r4, r5, r6, pc}
    5596:	movs	r2, #4
    5598:	mov	r1, sp
    559a:	mov	r0, r4
    559c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    55a0:	b.n	5552 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x1e>
    55a2:	nop

000055a4 <MTPD::GetObjectInfo(unsigned long)>:
  
  void MTPD::GetObjectInfo(uint32_t handle) 
  {
    55a4:	push	{r4, r5, r6, r7, lr}
    55a6:	mov	r4, r0
    55a8:	sub	sp, #332	; 0x14c
    char filename[MAX_FILENAME_LEN];
    uint32_t size, parent;
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);
    55aa:	ldr	r0, [r0, #0]
    55ac:	add.w	r6, sp, #10
    55b0:	add	r5, sp, #24
    55b2:	ldr	r3, [r0, #0]
    55b4:	stmia.w	sp, {r5, r6}
    55b8:	add	r2, sp, #72	; 0x48
    55ba:	ldr	r7, [r3, #36]	; 0x24
    55bc:	add	r3, sp, #20
    55be:	blx	r7
    55c0:	ldrh	r3, [r6, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    55c2:	ldrb	r2, [r4, #8]
    55c4:	adds	r3, #1
    55c6:	str	r3, [sp, #28]
    55c8:	cmp	r2, #0
    55ca:	beq.n	5680 <MTPD::GetObjectInfo(unsigned long)+0xdc>
      write_length_ += len;
    55cc:	ldr	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    55ce:	ldr	r2, [sp, #20]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    55d0:	adds	r3, #4
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    55d2:	adds	r2, #1
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    55d4:	str	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    55d6:	beq.w	57b0 <MTPD::GetObjectInfo(unsigned long)+0x20c>
    55da:	movs	r2, #0
    55dc:	strh.w	r2, [sp, #16]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    55e0:	adds	r3, #2
    55e2:	movs	r2, #0
    55e4:	str	r3, [r4, #12]
    55e6:	strh.w	r2, [sp, #14]
    55ea:	adds	r3, #2
    55ec:	ldr	r2, [sp, #20]
    55ee:	str	r3, [r4, #12]
    55f0:	str	r2, [sp, #60]	; 0x3c
    55f2:	adds	r3, #4
    55f4:	movs	r2, #0
    55f6:	str	r3, [r4, #12]
    55f8:	strh.w	r2, [sp, #12]
    55fc:	adds	r3, #2
    55fe:	movs	r2, #0
    5600:	str	r3, [r4, #12]
    5602:	str	r2, [sp, #56]	; 0x38
    5604:	adds	r3, #4
    5606:	movs	r2, #0
    5608:	str	r3, [r4, #12]
    560a:	str	r2, [sp, #52]	; 0x34
    560c:	adds	r3, #4
    560e:	movs	r2, #0
    5610:	str	r3, [r4, #12]
    5612:	str	r2, [sp, #48]	; 0x30
    5614:	adds	r3, #4
    5616:	movs	r2, #0
    5618:	str	r3, [r4, #12]
    561a:	str	r2, [sp, #44]	; 0x2c
    561c:	adds	r3, #4
    561e:	movs	r2, #0
    5620:	str	r3, [r4, #12]
    5622:	str	r2, [sp, #40]	; 0x28
    5624:	adds	r3, #4
    5626:	movs	r2, #0
    5628:	str	r3, [r4, #12]
    562a:	str	r2, [sp, #36]	; 0x24
    562c:	adds	r3, #4
    562e:	ldr	r2, [r5, #0]
    5630:	str	r3, [r4, #12]
    5632:	str	r2, [sp, #32]
    5634:	ldr	r2, [sp, #20]
    5636:	sub.w	r2, r2, #4294967295
    563a:	clz	r2, r2
    563e:	lsrs	r2, r2, #5
    5640:	adds	r3, #4
    5642:	str	r3, [r4, #12]
    5644:	strh.w	r2, [sp, #18]
    5648:	adds	r3, #2
    564a:	movs	r2, #0
    564c:	str	r3, [r4, #12]
    564e:	str	r2, [sp, #68]	; 0x44
    5650:	adds	r3, #4
    5652:	movs	r2, #0
    5654:	str	r3, [r4, #12]
    5656:	str	r2, [sp, #64]	; 0x40
    5658:	adds	r3, #4
    565a:	str	r3, [r4, #12]
    write32(0); // bit depth
    write32(parent); // parent
    write16(size == 0xFFFFFFFFUL ? 1 : 0); // association type
    write32(0); // association description
    write32(0);  // sequence number
    writestring(filename);
    565c:	add	r1, sp, #72	; 0x48
    565e:	mov	r0, r4
    5660:	bl	50ec <MTPD::writestring(char const*)>
    writestring("");  // date created
    5664:	mov	r0, r4
    5666:	ldr	r1, [pc, #396]	; (57f4 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    5668:	bl	50ec <MTPD::writestring(char const*)>
    writestring("");  // date modified
    566c:	mov	r0, r4
    566e:	ldr	r1, [pc, #388]	; (57f4 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    5670:	bl	50ec <MTPD::writestring(char const*)>
    writestring("");  // keywords
    5674:	mov	r0, r4
    5676:	ldr	r1, [pc, #380]	; (57f4 <MTPD::GetObjectInfo(unsigned long)+0x250>)
    5678:	bl	50ec <MTPD::writestring(char const*)>
  }
    567c:	add	sp, #332	; 0x14c
    567e:	pop	{r4, r5, r6, r7, pc}
    5680:	add	r1, sp, #28
    5682:	movs	r2, #4
    5684:	mov	r0, r4
    5686:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    568a:	ldr	r3, [sp, #20]
    568c:	ldrb	r6, [r4, #8]
    568e:	adds	r3, #1
    5690:	movw	r3, #12289	; 0x3001
    5694:	it	ne
    5696:	movne	r3, #0
    5698:	strh.w	r3, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    569c:	cmp	r6, #0
    569e:	bne.w	57c2 <MTPD::GetObjectInfo(unsigned long)+0x21e>
    56a2:	add	r1, sp, #16
    56a4:	movs	r2, #2
    56a6:	mov	r0, r4
    56a8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    56ac:	ldrb	r3, [r4, #8]
    56ae:	strh.w	r6, [sp, #14]
    56b2:	cmp	r3, #0
    56b4:	bne.w	57c6 <MTPD::GetObjectInfo(unsigned long)+0x222>
    56b8:	movs	r2, #2
    56ba:	add.w	r1, sp, #14
    56be:	mov	r0, r4
    56c0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    56c4:	ldrb	r3, [r4, #8]
    56c6:	ldr	r2, [sp, #20]
    56c8:	str	r2, [sp, #60]	; 0x3c
    56ca:	cmp	r3, #0
    56cc:	bne.n	57ca <MTPD::GetObjectInfo(unsigned long)+0x226>
    56ce:	add	r1, sp, #60	; 0x3c
    56d0:	movs	r2, #4
    56d2:	mov	r0, r4
    56d4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    56d8:	ldrb	r3, [r4, #8]
    56da:	strh.w	r6, [sp, #12]
    56de:	cmp	r3, #0
    56e0:	bne.n	57ce <MTPD::GetObjectInfo(unsigned long)+0x22a>
    56e2:	add	r1, sp, #12
    56e4:	movs	r2, #2
    56e6:	mov	r0, r4
    56e8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    56ec:	ldrb	r3, [r4, #8]
    56ee:	str	r6, [sp, #56]	; 0x38
    56f0:	cmp	r3, #0
    56f2:	bne.n	57d2 <MTPD::GetObjectInfo(unsigned long)+0x22e>
    56f4:	add	r1, sp, #56	; 0x38
    56f6:	movs	r2, #4
    56f8:	mov	r0, r4
    56fa:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    56fe:	ldrb	r3, [r4, #8]
    5700:	str	r6, [sp, #52]	; 0x34
    5702:	cmp	r3, #0
    5704:	bne.n	57d6 <MTPD::GetObjectInfo(unsigned long)+0x232>
    5706:	add	r1, sp, #52	; 0x34
    5708:	movs	r2, #4
    570a:	mov	r0, r4
    570c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5710:	ldrb	r3, [r4, #8]
    5712:	str	r6, [sp, #48]	; 0x30
    5714:	cmp	r3, #0
    5716:	bne.n	57da <MTPD::GetObjectInfo(unsigned long)+0x236>
    5718:	add	r1, sp, #48	; 0x30
    571a:	movs	r2, #4
    571c:	mov	r0, r4
    571e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5722:	ldrb	r3, [r4, #8]
    5724:	str	r6, [sp, #44]	; 0x2c
    5726:	cmp	r3, #0
    5728:	bne.n	57de <MTPD::GetObjectInfo(unsigned long)+0x23a>
    572a:	add	r1, sp, #44	; 0x2c
    572c:	movs	r2, #4
    572e:	mov	r0, r4
    5730:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5734:	ldrb	r3, [r4, #8]
    5736:	str	r6, [sp, #40]	; 0x28
    5738:	cmp	r3, #0
    573a:	bne.n	57e2 <MTPD::GetObjectInfo(unsigned long)+0x23e>
    573c:	add	r1, sp, #40	; 0x28
    573e:	movs	r2, #4
    5740:	mov	r0, r4
    5742:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5746:	ldrb	r3, [r4, #8]
    5748:	str	r6, [sp, #36]	; 0x24
    574a:	cmp	r3, #0
    574c:	bne.n	57e6 <MTPD::GetObjectInfo(unsigned long)+0x242>
    574e:	movs	r2, #4
    5750:	add	r1, sp, #36	; 0x24
    5752:	mov	r0, r4
    5754:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5758:	ldrb	r3, [r4, #8]
    575a:	ldr	r2, [r5, #0]
    575c:	str	r2, [sp, #32]
    575e:	cmp	r3, #0
    5760:	bne.n	57ea <MTPD::GetObjectInfo(unsigned long)+0x246>
    5762:	add	r1, sp, #32
    5764:	movs	r2, #4
    5766:	mov	r0, r4
    5768:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    576c:	ldr	r3, [sp, #20]
    576e:	ldrb	r6, [r4, #8]
    5770:	sub.w	r3, r3, #4294967295
    5774:	clz	r3, r3
    5778:	lsrs	r3, r3, #5
    577a:	strh.w	r3, [sp, #18]
    577e:	cmp	r6, #0
    5780:	bne.n	57ee <MTPD::GetObjectInfo(unsigned long)+0x24a>
    5782:	add.w	r1, sp, #18
    5786:	movs	r2, #2
    5788:	mov	r0, r4
    578a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    578e:	ldrb	r5, [r4, #8]
    5790:	str	r6, [sp, #68]	; 0x44
    5792:	cbnz	r5, 57be <MTPD::GetObjectInfo(unsigned long)+0x21a>
    5794:	add	r1, sp, #68	; 0x44
    5796:	movs	r2, #4
    5798:	mov	r0, r4
    579a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    579e:	ldrb	r3, [r4, #8]
    57a0:	str	r5, [sp, #64]	; 0x40
    57a2:	cbnz	r3, 57ba <MTPD::GetObjectInfo(unsigned long)+0x216>
    57a4:	add	r1, sp, #64	; 0x40
    57a6:	movs	r2, #4
    57a8:	mov	r0, r4
    57aa:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    57ae:	b.n	565c <MTPD::GetObjectInfo(unsigned long)+0xb8>
    57b0:	movw	r2, #12289	; 0x3001
    57b4:	strh.w	r2, [sp, #16]
    57b8:	b.n	55e0 <MTPD::GetObjectInfo(unsigned long)+0x3c>
    57ba:	ldr	r3, [r4, #12]
    57bc:	b.n	5658 <MTPD::GetObjectInfo(unsigned long)+0xb4>
    57be:	ldr	r3, [r4, #12]
    57c0:	b.n	5650 <MTPD::GetObjectInfo(unsigned long)+0xac>
    57c2:	ldr	r3, [r4, #12]
    57c4:	b.n	55e0 <MTPD::GetObjectInfo(unsigned long)+0x3c>
    57c6:	ldr	r3, [r4, #12]
    57c8:	b.n	55ea <MTPD::GetObjectInfo(unsigned long)+0x46>
    57ca:	ldr	r3, [r4, #12]
    57cc:	b.n	55f2 <MTPD::GetObjectInfo(unsigned long)+0x4e>
    57ce:	ldr	r3, [r4, #12]
    57d0:	b.n	55fc <MTPD::GetObjectInfo(unsigned long)+0x58>
    57d2:	ldr	r3, [r4, #12]
    57d4:	b.n	5604 <MTPD::GetObjectInfo(unsigned long)+0x60>
    57d6:	ldr	r3, [r4, #12]
    57d8:	b.n	560c <MTPD::GetObjectInfo(unsigned long)+0x68>
    57da:	ldr	r3, [r4, #12]
    57dc:	b.n	5614 <MTPD::GetObjectInfo(unsigned long)+0x70>
    57de:	ldr	r3, [r4, #12]
    57e0:	b.n	561c <MTPD::GetObjectInfo(unsigned long)+0x78>
    57e2:	ldr	r3, [r4, #12]
    57e4:	b.n	5624 <MTPD::GetObjectInfo(unsigned long)+0x80>
    57e6:	ldr	r3, [r4, #12]
    57e8:	b.n	562c <MTPD::GetObjectInfo(unsigned long)+0x88>
    57ea:	ldr	r3, [r4, #12]
    57ec:	b.n	5634 <MTPD::GetObjectInfo(unsigned long)+0x90>
    57ee:	ldr	r3, [r4, #12]
    57f0:	b.n	5648 <MTPD::GetObjectInfo(unsigned long)+0xa4>
    57f2:	nop
    57f4:	.word	0x2000016c

000057f8 <MTPD::getObjectPropsSupported(unsigned long)>:
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    57f8:	push	{r4, r5, r6, r7, lr}
      write32(propertyListNum);
    57fa:	ldr	r7, [pc, #96]	; (585c <MTPD::getObjectPropsSupported(unsigned long)+0x64>)
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    57fc:	ldrb	r2, [r0, #8]
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    57fe:	ldr	r3, [r7, #0]
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    5800:	sub	sp, #12
    5802:	mov	r4, r0
    5804:	str	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5806:	cbz	r2, 584e <MTPD::getObjectPropsSupported(unsigned long)+0x56>
      write_length_ += len;
    5808:	ldr	r2, [r0, #12]
    580a:	adds	r2, #4
    580c:	str	r2, [r0, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    580e:	cbz	r3, 584a <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    5810:	ldr	r6, [pc, #76]	; (5860 <MTPD::getObjectPropsSupported(unsigned long)+0x68>)
    5812:	movw	r3, #56321	; 0xdc01
    5816:	movs	r5, #0
    5818:	b.n	582c <MTPD::getObjectPropsSupported(unsigned long)+0x34>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    581a:	ldr	r3, [r4, #12]
    581c:	adds	r3, #2
    581e:	str	r3, [r4, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    5820:	ldr	r3, [r7, #0]
    5822:	adds	r5, #1
    5824:	cmp	r3, r5
    5826:	bls.n	584a <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    5828:	ldrh.w	r3, [r6, #2]!
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    582c:	ldrb	r2, [r4, #8]
    582e:	strh.w	r3, [sp, #2]
    5832:	cmp	r2, #0
    5834:	bne.n	581a <MTPD::getObjectPropsSupported(unsigned long)+0x22>
    5836:	movs	r2, #2
    5838:	add.w	r1, sp, r2
    583c:	mov	r0, r4
    583e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    5842:	ldr	r3, [r7, #0]
    5844:	adds	r5, #1
    5846:	cmp	r3, r5
    5848:	bhi.n	5828 <MTPD::getObjectPropsSupported(unsigned long)+0x30>
    }
    584a:	add	sp, #12
    584c:	pop	{r4, r5, r6, r7, pc}
    584e:	movs	r2, #4
    5850:	add.w	r1, sp, r2
    5854:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5858:	ldr	r3, [r7, #0]
    585a:	b.n	580e <MTPD::getObjectPropsSupported(unsigned long)+0x16>
    585c:	.word	0x20000b68
    5860:	.word	0x2000035c

00005864 <MTPD::getObjectPropValue(unsigned long, unsigned long)>:
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    5864:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5868:	mov	r5, r0
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    586a:	ldr	r0, [r0, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    586c:	sub	sp, #316	; 0x13c
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    586e:	ldr	r3, [r0, #0]
    5870:	add.w	r6, sp, #10
    5874:	add	r7, sp, #20
    5876:	str	r6, [sp, #4]
    5878:	str	r7, [sp, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    587a:	mov	r4, r2
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    587c:	ldr.w	r8, [r3, #36]	; 0x24
    5880:	add	r2, sp, #56	; 0x38
    5882:	add	r3, sp, #16
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    5884:	mov	r9, r1
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    5886:	blx	r8
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
      switch(p2)
    5888:	sub.w	r2, r4, #56320	; 0xdc00
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    588c:	ldrh	r3, [r6, #0]
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
    588e:	ldr	r1, [sp, #16]
      uint32_t storage = Store2Storage(store);
      switch(p2)
    5890:	subs	r2, #1
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    5892:	adds	r4, r3, #1
      switch(p2)
    5894:	cmp	r2, #67	; 0x43
    5896:	bhi.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    5898:	tbb	[pc, r2]
    589c:	.word	0x776a4b41
    58a0:	.word	0x333a3030
    58a4:	.word	0x305c3033
    58a8:	.word	0x30303030
    58ac:	.word	0x30303030
    58b0:	.word	0x30303030
    58b4:	.word	0x30303030
    58b8:	.word	0x30303030
    58bc:	.word	0x30303030
    58c0:	.word	0x30303030
    58c4:	.word	0x30303030
    58c8:	.word	0x30303030
    58cc:	.word	0x30303030
    58d0:	.word	0x30303030
    58d4:	.word	0x30303030
    58d8:	.word	0x30303030
    58dc:	.word	0x3a303022
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    58e0:	ldrb	r3, [r5, #8]
    58e2:	str.w	r9, [sp, #52]	; 0x34
    58e6:	cmp	r3, #0
    58e8:	beq.n	599a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x136>
      write_length_ += len;
    58ea:	ldr	r3, [r5, #12]
    58ec:	adds	r3, #4
    58ee:	str	r3, [r5, #12]
    58f0:	adds	r3, #4
    58f2:	str	r3, [r5, #12]
    58f4:	adds	r3, #4
    58f6:	str	r3, [r5, #12]
    58f8:	adds	r3, #4
    58fa:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    58fc:	add	sp, #316	; 0x13c
    58fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_CREATED:       //0xDC08:
          writestring("");
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
    5902:	mov	r0, r5
    5904:	ldr	r1, [pc, #276]	; (5a1c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b8>)
    5906:	bl	50ec <MTPD::writestring(char const*)>
          writestring(name);
          break;
        default:
          break;
      }
    }
    590a:	add	sp, #316	; 0x13c
    590c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          write32(parent);
          write32(storage);
          write32(0);
          break;
        case MTP_PROPERTY_NAME:               //0xDC44:
          writestring(name);
    5910:	add	r1, sp, #56	; 0x38
    5912:	mov	r0, r5
    5914:	bl	50ec <MTPD::writestring(char const*)>
          break;
        default:
          break;
      }
    }
    5918:	add	sp, #316	; 0x13c
    591a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    591e:	ldrb	r3, [r5, #8]
    5920:	str	r4, [sp, #24]
    5922:	cmp	r3, #0
    5924:	beq.n	59e6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x182>
      write_length_ += len;
    5926:	ldr	r3, [r5, #12]
    5928:	adds	r3, #4
    592a:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    592c:	add	sp, #316	; 0x13c
    592e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    5932:	adds	r1, #1
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5934:	ldrb	r2, [r5, #8]
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    5936:	movw	r3, #12289	; 0x3001
    593a:	it	ne
    593c:	movne.w	r3, #12288	; 0x3000
    5940:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5944:	cmp	r2, #0
    5946:	beq.n	59da <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x176>
      write_length_ += len;
    5948:	ldr	r3, [r5, #12]
    594a:	adds	r3, #2
    594c:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    594e:	add	sp, #316	; 0x13c
    5950:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    5954:	ldr	r2, [r7, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5956:	ldrb	r1, [r5, #8]
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    5958:	cmp	r3, r2
    595a:	it	eq
    595c:	moveq	r2, #0
    595e:	str	r2, [sp, #36]	; 0x24
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5960:	cmp	r1, #0
    5962:	bne.n	5926 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc2>
    5964:	add	r1, sp, #36	; 0x24
    5966:	mov	r0, r5
    5968:	movs	r2, #4
    596a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    596e:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    5970:	ldrb	r3, [r5, #8]
    5972:	movs	r2, #0
    5974:	strh.w	r2, [sp, #14]
    5978:	cmp	r3, #0
    597a:	bne.n	5948 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xe4>
    597c:	add.w	r1, sp, #14
    5980:	mov	r0, r5
    5982:	movs	r2, #2
    5984:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5988:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    598a:	ldrb	r4, [r5, #8]
    598c:	str	r1, [sp, #32]
    598e:	cmp	r4, #0
    5990:	beq.n	59f2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x18e>
      write_length_ += len;
    5992:	ldr	r3, [r5, #12]
    5994:	adds	r3, #4
    5996:	str	r3, [r5, #12]
    5998:	b.n	58f8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    599a:	movs	r2, #4
    599c:	add	r1, sp, #52	; 0x34
    599e:	mov	r0, r5
    59a0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59a4:	ldrb	r3, [r5, #8]
    59a6:	ldr	r2, [r7, #0]
    59a8:	str	r2, [sp, #48]	; 0x30
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    59aa:	cmp	r3, #0
    59ac:	bne.n	5a16 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b2>
    59ae:	add	r1, sp, #48	; 0x30
    59b0:	movs	r2, #4
    59b2:	mov	r0, r5
    59b4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59b8:	ldrb	r6, [r5, #8]
    59ba:	str	r4, [sp, #44]	; 0x2c
    59bc:	cbnz	r6, 5a12 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1ae>
    59be:	add	r1, sp, #44	; 0x2c
    59c0:	movs	r2, #4
    59c2:	mov	r0, r5
    59c4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59c8:	ldrb	r3, [r5, #8]
    59ca:	str	r6, [sp, #40]	; 0x28
    59cc:	cbnz	r3, 5a0e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    59ce:	add	r1, sp, #40	; 0x28
    59d0:	mov	r0, r5
    59d2:	movs	r2, #4
    59d4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59d8:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    59da:	add	r1, sp, #12
    59dc:	mov	r0, r5
    59de:	movs	r2, #2
    59e0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59e4:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    59e6:	add	r1, sp, #24
    59e8:	mov	r0, r5
    59ea:	movs	r2, #4
    59ec:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59f0:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    59f2:	add	r1, sp, #32
    59f4:	movs	r2, #4
    59f6:	mov	r0, r5
    59f8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    59fc:	ldrb	r3, [r5, #8]
    59fe:	str	r4, [sp, #28]
    5a00:	cbnz	r3, 5a0e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    5a02:	add	r1, sp, #28
    5a04:	mov	r0, r5
    5a06:	movs	r2, #4
    5a08:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5a0c:	b.n	58fc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    5a0e:	ldr	r3, [r5, #12]
    5a10:	b.n	58f8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    5a12:	ldr	r3, [r5, #12]
    5a14:	b.n	58f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x90>
    5a16:	ldr	r3, [r5, #12]
    5a18:	b.n	58f0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8c>
    5a1a:	nop
    5a1c:	.word	0x2000016c

00005a20 <MTPD::GetStorageInfo(unsigned long)>:
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    5a20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5a24:	mov	r4, r0
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    5a26:	ldr	r0, [r0, #0]
    5a28:	ldr	r3, [r0, #0]
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    5a2a:	subs	r5, r1, #1
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    5a2c:	sub	sp, #36	; 0x24
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    5a2e:	ldr	r3, [r3, #20]
    5a30:	mov	r1, r5
    5a32:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a34:	ldrb	r3, [r4, #8]
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    5a36:	cmp	r0, #0
    5a38:	ite	eq
    5a3a:	moveq	r2, #4
    5a3c:	movne	r2, #1
    5a3e:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a42:	cmp	r3, #0
    5a44:	beq.n	5ae0 <MTPD::GetStorageInfo(unsigned long)+0xc0>
      write_length_ += len;
    5a46:	ldr	r3, [r4, #12]
    5a48:	adds	r3, #2
    5a4a:	str	r3, [r4, #12]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    5a4c:	ldr	r0, [r4, #0]
    5a4e:	ldr	r3, [r0, #0]
    5a50:	mov	r1, r5
    5a52:	ldr	r3, [r3, #24]
    5a54:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a56:	ldrb	r6, [r4, #8]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    5a58:	cmp	r0, #0
    5a5a:	ite	eq
    5a5c:	moveq	r3, #1
    5a5e:	movne	r3, #2
    5a60:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a64:	cmp	r6, #0
    5a66:	beq.n	5b28 <MTPD::GetStorageInfo(unsigned long)+0x108>
      write_length_ += len;
    5a68:	ldr	r3, [r4, #12]
    5a6a:	movs	r2, #0
    5a6c:	adds	r3, #2
    5a6e:	str	r3, [r4, #12]
    5a70:	strh.w	r2, [sp, #8]
    5a74:	adds	r3, #2
    5a76:	str	r3, [r4, #12]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    5a78:	ldr	r0, [r4, #0]
    5a7a:	ldr	r3, [r0, #0]
    5a7c:	mov	r1, r5
    5a7e:	ldr	r3, [r3, #12]
    5a80:	blx	r3
    5a82:	mov	r6, r0
    uint64_t nused = storage_->usedSize(store) ; 
    5a84:	ldr	r0, [r4, #0]
    5a86:	ldr	r3, [r0, #0]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    5a88:	mov	r7, r1
    uint64_t nused = storage_->usedSize(store) ; 
    5a8a:	ldr	r3, [r3, #16]
    5a8c:	mov	r1, r5
    5a8e:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a90:	ldrb	r3, [r4, #8]
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    uint64_t nused = storage_->usedSize(store) ; 
    5a92:	mov	r8, r0
    5a94:	mov	r9, r1
    5a96:	strd	r6, r7, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5a9a:	cbz	r3, 5aee <MTPD::GetStorageInfo(unsigned long)+0xce>
    5a9c:	subs	r6, r6, r0
      write_length_ += len;
    5a9e:	ldr	r3, [r4, #12]
    5aa0:	sbc.w	r7, r7, r1
    5aa4:	strd	r6, r7, [sp, #16]
    5aa8:	adds	r3, #8
    5aaa:	str	r3, [r4, #12]
    5aac:	adds	r3, #8
    5aae:	mov.w	r2, #4294967295
    5ab2:	str	r3, [r4, #12]
    5ab4:	str	r2, [sp, #12]
    5ab6:	adds	r3, #4
    5ab8:	str	r3, [r4, #12]

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    5aba:	ldr	r0, [r4, #0]
    5abc:	ldr	r2, [pc, #156]	; (5b5c <MTPD::GetStorageInfo(unsigned long)+0x13c>)
    5abe:	ldr	r3, [r0, #0]
    5ac0:	ldr	r3, [r3, #8]
    5ac2:	cmp	r3, r2
    5ac4:	bne.n	5b48 <MTPD::GetStorageInfo(unsigned long)+0x128>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    5ac6:	add.w	r0, r0, r5, lsl #2
    5aca:	ldr	r1, [r0, #8]
    writestring(name);  // storage descriptor
    5acc:	mov	r0, r4
    5ace:	bl	50ec <MTPD::writestring(char const*)>
    writestring("");  // volume identifier
    5ad2:	mov	r0, r4
    5ad4:	ldr	r1, [pc, #136]	; (5b60 <MTPD::GetStorageInfo(unsigned long)+0x140>)
    5ad6:	bl	50ec <MTPD::writestring(char const*)>

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }
    5ada:	add	sp, #36	; 0x24
    5adc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5ae0:	movs	r2, #2
    5ae2:	add.w	r1, sp, #6
    5ae6:	mov	r0, r4
    5ae8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5aec:	b.n	5a4c <MTPD::GetStorageInfo(unsigned long)+0x2c>
    5aee:	movs	r2, #8
    5af0:	add	r1, sp, #24
    5af2:	mov	r0, r4
    5af4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5af8:	subs.w	r6, r6, r8
    5afc:	ldrb	r3, [r4, #8]
    5afe:	sbc.w	r7, r7, r9
    5b02:	strd	r6, r7, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5b06:	cbnz	r3, 5b54 <MTPD::GetStorageInfo(unsigned long)+0x134>
    5b08:	movs	r2, #8
    5b0a:	add	r1, sp, #16
    5b0c:	mov	r0, r4
    5b0e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5b12:	ldrb	r3, [r4, #8]
    5b14:	mov.w	r2, #4294967295
    5b18:	str	r2, [sp, #12]
    5b1a:	cbnz	r3, 5b50 <MTPD::GetStorageInfo(unsigned long)+0x130>
    5b1c:	movs	r2, #4
    5b1e:	add	r1, sp, #12
    5b20:	mov	r0, r4
    5b22:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5b26:	b.n	5aba <MTPD::GetStorageInfo(unsigned long)+0x9a>
    5b28:	movs	r2, #2
    5b2a:	add.w	r1, sp, #10
    5b2e:	mov	r0, r4
    5b30:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5b34:	ldrb	r3, [r4, #8]
    5b36:	strh.w	r6, [sp, #8]
    5b3a:	cbnz	r3, 5b58 <MTPD::GetStorageInfo(unsigned long)+0x138>
    5b3c:	movs	r2, #2
    5b3e:	add	r1, sp, #8
    5b40:	mov	r0, r4
    5b42:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5b46:	b.n	5a78 <MTPD::GetStorageInfo(unsigned long)+0x58>

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    5b48:	mov	r1, r5
    5b4a:	blx	r3
    5b4c:	mov	r1, r0
    5b4e:	b.n	5acc <MTPD::GetStorageInfo(unsigned long)+0xac>
    5b50:	ldr	r3, [r4, #12]
    5b52:	b.n	5ab6 <MTPD::GetStorageInfo(unsigned long)+0x96>
    5b54:	ldr	r3, [r4, #12]
    5b56:	b.n	5aac <MTPD::GetStorageInfo(unsigned long)+0x8c>
    5b58:	ldr	r3, [r4, #12]
    5b5a:	b.n	5a74 <MTPD::GetStorageInfo(unsigned long)+0x54>
    5b5c:	.word	0x0000137d
    5b60:	.word	0x2000016c

00005b64 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>:
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    5b64:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      switch(p1)
    5b68:	sub.w	r1, r1, #56320	; 0xdc00
    5b6c:	subs	r1, #1
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    5b6e:	sub	sp, #148	; 0x94
    5b70:	mov	r4, r0
      switch(p1)
    5b72:	cmp	r1, #67	; 0x43
    5b74:	bhi.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5b76:	tbh	[pc, r1, lsl #1]
    5b7a:	.short	0x005c
    5b7c:	.word	0x0080006e
    5b80:	.word	0x005900c6
    5b84:	.word	0x00d80059
    5b88:	.word	0x01690121
    5b8c:	.word	0x01b10059
    5b90:	.word	0x00590059
    5b94:	.word	0x00590059
    5b98:	.word	0x00590059
    5b9c:	.word	0x00590059
    5ba0:	.word	0x00590059
    5ba4:	.word	0x00590059
    5ba8:	.word	0x00590059
    5bac:	.word	0x00590059
    5bb0:	.word	0x00590059
    5bb4:	.word	0x00590059
    5bb8:	.word	0x00590059
    5bbc:	.word	0x00590059
    5bc0:	.word	0x00590059
    5bc4:	.word	0x00590059
    5bc8:	.word	0x00590059
    5bcc:	.word	0x00590059
    5bd0:	.word	0x00590059
    5bd4:	.word	0x00590059
    5bd8:	.word	0x00590059
    5bdc:	.word	0x00590059
    5be0:	.word	0x00590059
    5be4:	.word	0x00590059
    5be8:	.word	0x00590059
    5bec:	.word	0x00590059
    5bf0:	.word	0x00590059
    5bf4:	.word	0x00590059
    5bf8:	.word	0x01f70059
    5bfc:	.word	0x00590059
    5c00:	.short	0x0044
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c02:	ldrb	r3, [r0, #8]
    5c04:	movw	r2, #56388	; 0xdc44
    5c08:	strh.w	r2, [sp, #70]	; 0x46
    5c0c:	cmp	r3, #0
    5c0e:	beq.w	608c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x528>
      write_length_ += len;
    5c12:	ldr	r3, [r4, #12]
    5c14:	adds	r3, #2
    5c16:	str	r3, [r4, #12]
    5c18:	adds	r3, #2
    5c1a:	str	r3, [r4, #12]
    5c1c:	adds	r3, #1
    5c1e:	str	r3, [r4, #12]
    5c20:	adds	r3, #1
    5c22:	str	r3, [r4, #12]
    5c24:	adds	r3, #4
    5c26:	str	r3, [r4, #12]
    5c28:	adds	r3, #1
    5c2a:	str	r3, [r4, #12]
          write8(0);
          break;
        default:
          break;
      }
    }
    5c2c:	add	sp, #148	; 0x94
    5c2e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c32:	ldrb	r3, [r0, #8]
    5c34:	movw	r2, #56321	; 0xdc01
    5c38:	strh.w	r2, [sp, #30]
    5c3c:	cmp	r3, #0
    5c3e:	beq.w	61a0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x63c>
      write_length_ += len;
    5c42:	ldr	r3, [r4, #12]
    5c44:	adds	r3, #2
    5c46:	str	r3, [r4, #12]
    5c48:	adds	r3, #2
    5c4a:	str	r3, [r4, #12]
    5c4c:	adds	r3, #1
    5c4e:	str	r3, [r4, #12]
    5c50:	adds	r3, #4
    5c52:	str	r3, [r4, #12]
    5c54:	b.n	5c24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c56:	ldrb	r3, [r0, #8]
    5c58:	movw	r2, #56322	; 0xdc02
    5c5c:	strh.w	r2, [sp, #36]	; 0x24
    5c60:	cmp	r3, #0
    5c62:	beq.w	600e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4aa>
      write_length_ += len;
    5c66:	ldr	r3, [r4, #12]
    5c68:	adds	r3, #2
    5c6a:	str	r3, [r4, #12]
    5c6c:	adds	r3, #2
    5c6e:	str	r3, [r4, #12]
    5c70:	adds	r3, #1
    5c72:	str	r3, [r4, #12]
    5c74:	adds	r3, #2
    5c76:	str	r3, [r4, #12]
    5c78:	b.n	5c24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c7a:	ldrb	r3, [r0, #8]
    5c7c:	movw	r2, #56323	; 0xdc03
    5c80:	strh.w	r2, [sp, #42]	; 0x2a
    5c84:	cmp	r3, #0
    5c86:	bne.n	5c66 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x102>
    5c88:	movs	r2, #2
    5c8a:	add.w	r1, sp, #42	; 0x2a
    5c8e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5c92:	ldrb	r7, [r4, #8]
    5c94:	movs	r6, #4
    5c96:	strh.w	r6, [sp, #40]	; 0x28
    5c9a:	cmp	r7, #0
    5c9c:	bne.w	6236 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    5ca0:	movs	r2, #2
    5ca2:	add	r1, sp, #40	; 0x28
    5ca4:	mov	r0, r4
    5ca6:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5caa:	ldrb	r5, [r4, #8]
    5cac:	strb.w	r7, [sp, #9]
    5cb0:	cmp	r5, #0
    5cb2:	bne.w	6232 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    5cb6:	movs	r2, #1
    5cb8:	add.w	r1, sp, #9
    5cbc:	mov	r0, r4
    5cbe:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5cc2:	ldrb	r7, [r4, #8]
    5cc4:	strh.w	r5, [sp, #38]	; 0x26
    5cc8:	cmp	r7, #0
    5cca:	bne.w	622e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    5cce:	movs	r2, #2
    5cd0:	add.w	r1, sp, #38	; 0x26
    5cd4:	mov	r0, r4
    5cd6:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5cda:	ldrb	r5, [r4, #8]
    5cdc:	str	r7, [sp, #84]	; 0x54
    5cde:	cmp	r5, #0
    5ce0:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5ce4:	mov	r2, r6
    5ce6:	add	r1, sp, #84	; 0x54
    5ce8:	mov	r0, r4
    5cea:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5cee:	ldrb	r3, [r4, #8]
    5cf0:	strb.w	r5, [sp, #8]
    5cf4:	cmp	r3, #0
    5cf6:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    5cfa:	mov	r0, r4
    5cfc:	movs	r2, #1
    5cfe:	add	r1, sp, #8
    5d00:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5d04:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5d06:	ldrb	r3, [r0, #8]
    5d08:	movw	r2, #56324	; 0xdc04
    5d0c:	strh.w	r2, [sp, #46]	; 0x2e
    5d10:	cmp	r3, #0
    5d12:	beq.w	5f8c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x428>
      write_length_ += len;
    5d16:	ldr	r3, [r0, #12]
    5d18:	adds	r3, #2
    5d1a:	str	r3, [r0, #12]
    5d1c:	adds	r3, #2
    5d1e:	str	r3, [r4, #12]
    5d20:	adds	r3, #1
    5d22:	str	r3, [r4, #12]
    5d24:	adds	r3, #8
    5d26:	str	r3, [r4, #12]
    5d28:	b.n	5c24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d2a:	ldrb	r3, [r0, #8]
    5d2c:	movw	r2, #56327	; 0xdc07
    5d30:	strh.w	r2, [sp, #50]	; 0x32
    5d34:	cmp	r3, #0
    5d36:	bne.w	5c12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    5d3a:	movs	r2, #2
    5d3c:	add.w	r1, sp, #50	; 0x32
    5d40:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5d44:	ldrb	r3, [r4, #8]
    5d46:	movw	r2, #65535	; 0xffff
    5d4a:	strh.w	r2, [sp, #48]	; 0x30
    5d4e:	cmp	r3, #0
    5d50:	bne.w	621e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    5d54:	movs	r2, #2
    5d56:	add	r1, sp, #48	; 0x30
    5d58:	mov	r0, r4
    5d5a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5d5e:	ldrb	r6, [r4, #8]
    5d60:	movs	r5, #1
    5d62:	strb.w	r5, [sp, #14]
    5d66:	cmp	r6, #0
    5d68:	bne.w	621a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    5d6c:	mov	r2, r5
    5d6e:	add.w	r1, sp, #14
    5d72:	mov	r0, r4
    5d74:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5d78:	ldrb	r7, [r4, #8]
    5d7a:	strb.w	r6, [sp, #13]
    5d7e:	cmp	r7, #0
    5d80:	bne.w	622a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    5d84:	mov	r2, r5
    5d86:	add.w	r1, sp, #13
    5d8a:	mov	r0, r4
    5d8c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5d90:	ldrb	r6, [r4, #8]
    5d92:	str	r7, [sp, #92]	; 0x5c
    5d94:	cmp	r6, #0
    5d96:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5d9a:	movs	r2, #4
    5d9c:	add	r1, sp, #92	; 0x5c
    5d9e:	mov	r0, r4
    5da0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5da4:	ldrb	r3, [r4, #8]
    5da6:	strb.w	r6, [sp, #12]
    5daa:	cmp	r3, #0
    5dac:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    5db0:	mov	r2, r5
    5db2:	mov	r0, r4
    5db4:	add	r1, sp, #12
    5db6:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5dba:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5dbc:	ldrb	r3, [r0, #8]
    5dbe:	movw	r2, #56328	; 0xdc08
    5dc2:	strh.w	r2, [sp, #54]	; 0x36
    5dc6:	cmp	r3, #0
    5dc8:	bne.w	5c12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    5dcc:	movs	r2, #2
    5dce:	add.w	r1, sp, #54	; 0x36
    5dd2:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5dd6:	ldrb	r6, [r4, #8]
    5dd8:	movw	r3, #65535	; 0xffff
    5ddc:	strh.w	r3, [sp, #52]	; 0x34
    5de0:	cmp	r6, #0
    5de2:	bne.w	621e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    5de6:	movs	r2, #2
    5de8:	add	r1, sp, #52	; 0x34
    5dea:	mov	r0, r4
    5dec:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5df0:	ldrb	r5, [r4, #8]
    5df2:	strb.w	r6, [sp, #17]
    5df6:	cmp	r5, #0
    5df8:	bne.w	621a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    5dfc:	movs	r2, #1
    5dfe:	add.w	r1, sp, #17
    5e02:	mov	r0, r4
    5e04:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e08:	ldrb	r6, [r4, #8]
    5e0a:	strb.w	r5, [sp, #16]
    5e0e:	cmp	r6, #0
    5e10:	bne.w	622a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    5e14:	movs	r2, #1
    5e16:	add	r1, sp, #16
    5e18:	mov	r0, r4
    5e1a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e1e:	ldrb	r5, [r4, #8]
    5e20:	str	r6, [sp, #96]	; 0x60
    5e22:	cmp	r5, #0
    5e24:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5e28:	movs	r2, #4
    5e2a:	add	r1, sp, #96	; 0x60
    5e2c:	mov	r0, r4
    5e2e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e32:	ldrb	r3, [r4, #8]
    5e34:	strb.w	r5, [sp, #15]
    5e38:	cmp	r3, #0
    5e3a:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    5e3e:	mov	r0, r4
    5e40:	movs	r2, #1
    5e42:	add.w	r1, sp, #15
    5e46:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e4a:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5e4c:	ldrb	r3, [r0, #8]
    5e4e:	movw	r2, #56329	; 0xdc09
    5e52:	strh.w	r2, [sp, #58]	; 0x3a
    5e56:	cmp	r3, #0
    5e58:	bne.w	5c12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    5e5c:	movs	r2, #2
    5e5e:	add.w	r1, sp, #58	; 0x3a
    5e62:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e66:	ldrb	r6, [r4, #8]
    5e68:	movw	r3, #65535	; 0xffff
    5e6c:	strh.w	r3, [sp, #56]	; 0x38
    5e70:	cmp	r6, #0
    5e72:	bne.w	621e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    5e76:	movs	r2, #2
    5e78:	add	r1, sp, #56	; 0x38
    5e7a:	mov	r0, r4
    5e7c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e80:	ldrb	r5, [r4, #8]
    5e82:	strb.w	r6, [sp, #20]
    5e86:	cmp	r5, #0
    5e88:	bne.w	621a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    5e8c:	movs	r2, #1
    5e8e:	add	r1, sp, #20
    5e90:	mov	r0, r4
    5e92:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5e96:	ldrb	r6, [r4, #8]
    5e98:	strb.w	r5, [sp, #19]
    5e9c:	cmp	r6, #0
    5e9e:	bne.w	622a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    5ea2:	movs	r2, #1
    5ea4:	add.w	r1, sp, #19
    5ea8:	mov	r0, r4
    5eaa:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5eae:	ldrb	r5, [r4, #8]
    5eb0:	str	r6, [sp, #100]	; 0x64
    5eb2:	cmp	r5, #0
    5eb4:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5eb8:	movs	r2, #4
    5eba:	add	r1, sp, #100	; 0x64
    5ebc:	mov	r0, r4
    5ebe:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5ec2:	ldrb	r3, [r4, #8]
    5ec4:	strb.w	r5, [sp, #18]
    5ec8:	cmp	r3, #0
    5eca:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    5ece:	mov	r0, r4
    5ed0:	movs	r2, #1
    5ed2:	add.w	r1, sp, #18
    5ed6:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5eda:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5edc:	ldrb	r3, [r0, #8]
    5ede:	movw	r2, #56331	; 0xdc0b
    5ee2:	strh.w	r2, [sp, #62]	; 0x3e
    5ee6:	cmp	r3, #0
    5ee8:	bne.w	5c42 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde>
    5eec:	movs	r2, #2
    5eee:	add.w	r1, sp, #62	; 0x3e
    5ef2:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5ef6:	ldrb	r6, [r4, #8]
    5ef8:	movs	r3, #6
    5efa:	strh.w	r3, [sp, #60]	; 0x3c
    5efe:	cmp	r6, #0
    5f00:	bne.w	6216 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    5f04:	movs	r2, #2
    5f06:	add	r1, sp, #60	; 0x3c
    5f08:	mov	r0, r4
    5f0a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f0e:	ldrb	r5, [r4, #8]
    5f10:	strb.w	r6, [sp, #22]
    5f14:	cmp	r5, #0
    5f16:	bne.w	6212 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    5f1a:	movs	r2, #1
    5f1c:	add.w	r1, sp, #22
    5f20:	mov	r0, r4
    5f22:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f26:	ldrb	r6, [r4, #8]
    5f28:	str	r5, [sp, #108]	; 0x6c
    5f2a:	cmp	r6, #0
    5f2c:	bne.w	620e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    5f30:	movs	r2, #4
    5f32:	add	r1, sp, #108	; 0x6c
    5f34:	mov	r0, r4
    5f36:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f3a:	ldrb	r5, [r4, #8]
    5f3c:	str	r6, [sp, #104]	; 0x68
    5f3e:	cmp	r5, #0
    5f40:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5f44:	movs	r2, #4
    5f46:	add	r1, sp, #104	; 0x68
    5f48:	mov	r0, r4
    5f4a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f4e:	ldrb	r3, [r4, #8]
    5f50:	strb.w	r5, [sp, #21]
    5f54:	cmp	r3, #0
    5f56:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    5f5a:	mov	r0, r4
    5f5c:	movs	r2, #1
    5f5e:	add.w	r1, sp, #21
    5f62:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f66:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    5f68:	ldrb	r3, [r0, #8]
    5f6a:	movw	r2, #56385	; 0xdc41
    5f6e:	strh.w	r2, [sp, #66]	; 0x42
    5f72:	cmp	r3, #0
    5f74:	beq.w	610e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5aa>
      write_length_ += len;
    5f78:	ldr	r3, [r0, #12]
    5f7a:	adds	r3, #2
    5f7c:	str	r3, [r0, #12]
    5f7e:	adds	r3, #2
    5f80:	str	r3, [r4, #12]
    5f82:	adds	r3, #1
    5f84:	str	r3, [r4, #12]
    5f86:	adds	r3, #8
    5f88:	str	r3, [r4, #12]
    5f8a:	b.n	5d24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    5f8c:	movs	r2, #2
    5f8e:	add.w	r1, sp, #46	; 0x2e
    5f92:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5f96:	ldrb	r6, [r4, #8]
    5f98:	movs	r5, #8
    5f9a:	strh.w	r5, [sp, #44]	; 0x2c
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5f9e:	cmp	r6, #0
    5fa0:	bne.w	6226 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c2>
    5fa4:	movs	r2, #2
    5fa6:	add	r1, sp, #44	; 0x2c
    5fa8:	mov	r0, r4
    5faa:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5fae:	ldrb	r3, [r4, #8]
    5fb0:	strb.w	r6, [sp, #11]
    5fb4:	cmp	r3, #0
    5fb6:	bne.w	6222 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6be>
    5fba:	movs	r2, #1
    5fbc:	add.w	r1, sp, #11
    5fc0:	mov	r0, r4
    5fc2:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5fc6:	ldrb	r6, [r4, #8]
    5fc8:	movs	r2, #0
    5fca:	movs	r3, #0
    5fcc:	strd	r2, r3, [sp, #120]	; 0x78
    5fd0:	cmp	r6, #0
    5fd2:	bne.w	623a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    5fd6:	mov	r2, r5
    5fd8:	add	r1, sp, #120	; 0x78
    5fda:	mov	r0, r4
    5fdc:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5fe0:	ldrb	r5, [r4, #8]
    5fe2:	str	r6, [sp, #88]	; 0x58
    5fe4:	cmp	r5, #0
    5fe6:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    5fea:	movs	r2, #4
    5fec:	add	r1, sp, #88	; 0x58
    5fee:	mov	r0, r4
    5ff0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    5ff4:	ldrb	r3, [r4, #8]
    5ff6:	strb.w	r5, [sp, #10]
    5ffa:	cmp	r3, #0
    5ffc:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6000:	mov	r0, r4
    6002:	movs	r2, #1
    6004:	add.w	r1, sp, #10
    6008:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    600c:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    600e:	movs	r2, #2
    6010:	add	r1, sp, #36	; 0x24
    6012:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6016:	ldrb	r7, [r4, #8]
    6018:	movs	r6, #4
    601a:	strh.w	r6, [sp, #34]	; 0x22
    601e:	cmp	r7, #0
    6020:	bne.w	6236 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    6024:	movs	r2, #2
    6026:	add.w	r1, sp, #34	; 0x22
    602a:	mov	r0, r4
    602c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6030:	ldrb	r5, [r4, #8]
    6032:	strb.w	r7, [sp, #7]
    6036:	cmp	r5, #0
    6038:	bne.w	6232 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    603c:	movs	r2, #1
    603e:	add.w	r1, sp, #7
    6042:	mov	r0, r4
    6044:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6048:	ldrb	r7, [r4, #8]
    604a:	strh.w	r5, [sp, #32]
    604e:	cmp	r7, #0
    6050:	bne.w	622e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    6054:	movs	r2, #2
    6056:	add	r1, sp, #32
    6058:	mov	r0, r4
    605a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    605e:	ldrb	r5, [r4, #8]
    6060:	str	r7, [sp, #80]	; 0x50
    6062:	cmp	r5, #0
    6064:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6068:	mov	r2, r6
    606a:	add	r1, sp, #80	; 0x50
    606c:	mov	r0, r4
    606e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6072:	ldrb	r3, [r4, #8]
    6074:	strb.w	r5, [sp, #6]
    6078:	cmp	r3, #0
    607a:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    607e:	mov	r0, r4
    6080:	movs	r2, #1
    6082:	add.w	r1, sp, #6
    6086:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    608a:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    608c:	movs	r2, #2
    608e:	add.w	r1, sp, #70	; 0x46
    6092:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6096:	ldrb	r6, [r4, #8]
    6098:	movw	r3, #65535	; 0xffff
    609c:	strh.w	r3, [sp, #68]	; 0x44
    60a0:	cmp	r6, #0
    60a2:	bne.w	621e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    60a6:	movs	r2, #2
    60a8:	add	r1, sp, #68	; 0x44
    60aa:	mov	r0, r4
    60ac:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    60b0:	ldrb	r5, [r4, #8]
    60b2:	strb.w	r6, [sp, #27]
    60b6:	cmp	r5, #0
    60b8:	bne.w	621a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    60bc:	movs	r2, #1
    60be:	add.w	r1, sp, #27
    60c2:	mov	r0, r4
    60c4:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    60c8:	ldrb	r6, [r4, #8]
    60ca:	strb.w	r5, [sp, #26]
    60ce:	cmp	r6, #0
    60d0:	bne.w	622a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    60d4:	movs	r2, #1
    60d6:	add.w	r1, sp, #26
    60da:	mov	r0, r4
    60dc:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    60e0:	ldrb	r5, [r4, #8]
    60e2:	str	r6, [sp, #116]	; 0x74
    60e4:	cmp	r5, #0
    60e6:	bne.w	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    60ea:	movs	r2, #4
    60ec:	add	r1, sp, #116	; 0x74
    60ee:	mov	r0, r4
    60f0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    60f4:	ldrb	r3, [r4, #8]
    60f6:	strb.w	r5, [sp, #25]
    60fa:	cmp	r3, #0
    60fc:	bne.w	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6100:	mov	r0, r4
    6102:	movs	r2, #1
    6104:	add.w	r1, sp, #25
    6108:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    610c:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    610e:	movs	r2, #2
    6110:	add.w	r1, sp, #66	; 0x42
    6114:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6118:	ldrb	r5, [r4, #8]
    611a:	movs	r3, #10
    611c:	strh.w	r3, [sp, #64]	; 0x40
    6120:	cmp	r5, #0
    6122:	bne.w	6246 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6e2>
    6126:	movs	r2, #2
    6128:	add	r1, sp, #64	; 0x40
    612a:	mov	r0, r4
    612c:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6130:	ldrb	r3, [r4, #8]
    6132:	strb.w	r5, [sp, #24]
    6136:	cmp	r3, #0
    6138:	bne.w	6242 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6de>
    613c:	movs	r2, #1
    613e:	add	r1, sp, #24
    6140:	mov	r0, r4
    6142:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6146:	ldrb	r3, [r4, #8]
    6148:	mov.w	r8, #0
    614c:	mov.w	r9, #0
    6150:	strd	r8, r9, [sp, #136]	; 0x88
    6154:	cmp	r3, #0
    6156:	bne.n	623e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6da>
    6158:	movs	r2, #8
    615a:	add	r1, sp, #136	; 0x88
    615c:	mov	r0, r4
    615e:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6162:	ldrb	r6, [r4, #8]
    6164:	strd	r8, r9, [sp, #128]	; 0x80
    6168:	cmp	r6, #0
    616a:	bne.n	623a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    616c:	movs	r2, #8
    616e:	add	r1, sp, #128	; 0x80
    6170:	mov	r0, r4
    6172:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6176:	ldrb	r5, [r4, #8]
    6178:	str	r6, [sp, #112]	; 0x70
    617a:	cmp	r5, #0
    617c:	bne.n	620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    617e:	movs	r2, #4
    6180:	add	r1, sp, #112	; 0x70
    6182:	mov	r0, r4
    6184:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6188:	ldrb	r3, [r4, #8]
    618a:	strb.w	r5, [sp, #23]
    618e:	cmp	r3, #0
    6190:	bne.n	6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6192:	mov	r0, r4
    6194:	movs	r2, #1
    6196:	add.w	r1, sp, #23
    619a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    619e:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    61a0:	movs	r2, #2
    61a2:	add.w	r1, sp, #30
    61a6:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    61aa:	ldrb	r6, [r4, #8]
    61ac:	movs	r3, #6
    61ae:	strh.w	r3, [sp, #28]
    61b2:	cbnz	r6, 6216 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    61b4:	movs	r2, #2
    61b6:	add	r1, sp, #28
    61b8:	mov	r0, r4
    61ba:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    61be:	ldrb	r5, [r4, #8]
    61c0:	strb.w	r6, [sp, #5]
    61c4:	cbnz	r5, 6212 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    61c6:	movs	r2, #1
    61c8:	add.w	r1, sp, #5
    61cc:	mov	r0, r4
    61ce:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    61d2:	ldrb	r6, [r4, #8]
    61d4:	str	r5, [sp, #76]	; 0x4c
    61d6:	cbnz	r6, 620e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    61d8:	movs	r2, #4
    61da:	add	r1, sp, #76	; 0x4c
    61dc:	mov	r0, r4
    61de:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    61e2:	ldrb	r5, [r4, #8]
    61e4:	str	r6, [sp, #72]	; 0x48
    61e6:	cbnz	r5, 620a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    61e8:	movs	r2, #4
    61ea:	add	r1, sp, #72	; 0x48
    61ec:	mov	r0, r4
    61ee:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    61f2:	ldrb	r3, [r4, #8]
    61f4:	strb.w	r5, [sp, #4]
    61f8:	cbnz	r3, 6206 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    61fa:	mov	r0, r4
    61fc:	movs	r2, #1
    61fe:	add	r1, sp, #4
    6200:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6204:	b.n	5c2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6206:	ldr	r3, [r4, #12]
    6208:	b.n	5c28 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc4>
    620a:	ldr	r3, [r4, #12]
    620c:	b.n	5c24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
    620e:	ldr	r3, [r4, #12]
    6210:	b.n	5c50 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xec>
    6212:	ldr	r3, [r4, #12]
    6214:	b.n	5c4c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe8>
    6216:	ldr	r3, [r4, #12]
    6218:	b.n	5c48 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4>
    621a:	ldr	r3, [r4, #12]
    621c:	b.n	5c1c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    621e:	ldr	r3, [r4, #12]
    6220:	b.n	5c18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
    6222:	ldr	r3, [r4, #12]
    6224:	b.n	5d20 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bc>
    6226:	ldr	r3, [r4, #12]
    6228:	b.n	5d1c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b8>
    622a:	ldr	r3, [r4, #12]
    622c:	b.n	5c20 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbc>
    622e:	ldr	r3, [r4, #12]
    6230:	b.n	5c74 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x110>
    6232:	ldr	r3, [r4, #12]
    6234:	b.n	5c70 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10c>
    6236:	ldr	r3, [r4, #12]
    6238:	b.n	5c6c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x108>
    623a:	ldr	r3, [r4, #12]
    623c:	b.n	5d24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    623e:	ldr	r3, [r4, #12]
    6240:	b.n	5f86 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x422>
    6242:	ldr	r3, [r4, #12]
    6244:	b.n	5f82 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41e>
    6246:	ldr	r3, [r4, #12]
    6248:	b.n	5f7e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41a>
    624a:	nop

0000624c <MTPD::receive_buffer()>:
      data_buffer_ = usb_malloc();
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    624c:	push	{r4, lr}
    624e:	mov	r4, r0
    6250:	ldr	r3, [r4, #4]
    while (!data_buffer_) {
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6252:	movs	r0, #5
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    while (!data_buffer_) {
    6254:	cbnz	r3, 625e <MTPD::receive_buffer()+0x12>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6256:	bl	dca0 <usb_rx>
    625a:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    625c:	cbz	r0, 6260 <MTPD::receive_buffer()+0x14>
    625e:	pop	{r4, pc}
    6260:	bl	1658 <mtp_yield()>
    6264:	b.n	6250 <MTPD::receive_buffer()+0x4>
    6266:	nop

00006268 <MTPD::GetObject(unsigned long)>:
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6268:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    626c:	mov	r6, r0
    uint32_t size = storage_->GetSize(object_id);
    626e:	ldr	r0, [r0, #0]
    6270:	ldr	r3, [r0, #0]
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6272:	sub	sp, #8
    uint32_t size = storage_->GetSize(object_id);
    6274:	ldr	r3, [r3, #40]	; 0x28
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6276:	mov	r8, r1
    uint32_t size = storage_->GetSize(object_id);
    6278:	blx	r3
    if (write_get_length_) {
    627a:	ldrb	r5, [r6, #8]
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    627c:	mov	r7, r0
    if (write_get_length_) {
    627e:	cbnz	r5, 62d8 <MTPD::GetObject(unsigned long)+0x70>
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6280:	cbz	r0, 62d2 <MTPD::GetObject(unsigned long)+0x6a>
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    6282:	mov	r9, r5
    6284:	b.n	628a <MTPD::GetObject(unsigned long)+0x22>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6286:	cmp	r7, r5
    6288:	bls.n	62d2 <MTPD::GetObject(unsigned long)+0x6a>
        get_buffer();
    628a:	mov	r0, r6
    628c:	bl	5070 <MTPD::get_buffer()>
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
    6290:	ldmia.w	r6, {r0, r3}
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
        get_buffer();
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    6294:	ldrh.w	r2, [r3], #8
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
    6298:	ldr	r1, [r0, #0]
    629a:	subs	r4, r7, r5
    629c:	rsb	lr, r2, #64	; 0x40
    62a0:	cmp	r4, lr
    62a2:	it	cs
    62a4:	movcs	r4, lr
    62a6:	str	r4, [sp, #0]
    62a8:	add	r3, r2
    62aa:	ldr.w	sl, [r1, #48]	; 0x30
    62ae:	mov	r2, r5
    62b0:	mov	r1, r8
    62b2:	blx	sl
        pos += to_copy;
        data_buffer_->len += to_copy;
    62b4:	ldr	r1, [r6, #4]
    62b6:	ldrh	r3, [r1, #0]
    62b8:	add	r3, r4
    62ba:	uxth	r3, r3
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    62bc:	cmp	r3, #64	; 0x40
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
    62be:	add	r5, r4
        data_buffer_->len += to_copy;
    62c0:	strh	r3, [r1, #0]
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    62c2:	bne.n	6286 <MTPD::GetObject(unsigned long)+0x1e>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    62c4:	movs	r0, #4
    62c6:	bl	dd8c <usb_tx>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    62ca:	cmp	r7, r5
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    62cc:	str.w	r9, [r6, #4]
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    62d0:	bhi.n	628a <MTPD::GetObject(unsigned long)+0x22>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    62d2:	add	sp, #8
    62d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    62d8:	ldr	r3, [r6, #12]
    62da:	add	r7, r3
    62dc:	str	r7, [r6, #12]
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    62de:	add	sp, #8
    62e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000062e4 <MTPD::read(char*, unsigned long)>:
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    62e4:	cbz	r2, 6350 <MTPD::read(char*, unsigned long)+0x6c>
      if(CONTAINER->len>20) printf(" %x", CONTAINER->params[2]); \
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    62e6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    62ea:	mov	r6, r0
    62ec:	mov	r5, r1
    while (size) {
    62ee:	mov	r8, r2
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    62f0:	movs	r7, #0
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
      receive_buffer();
    62f2:	mov	r0, r6
    62f4:	bl	624c <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    62f8:	ldr	r3, [r6, #4]
    62fa:	ldrh.w	lr, [r3, #2]
    62fe:	ldrh.w	ip, [r3]
    6302:	rsb	r4, lr, ip
    6306:	cmp	r4, r8
    6308:	it	cs
    630a:	movcs	r4, r8
      to_copy = min(to_copy, size);
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    630c:	add.w	r1, r3, #8
    6310:	add	r1, lr
    6312:	mov	r0, r5
    6314:	mov	r2, r4
        data += to_copy;
      }
      size -= to_copy;
    6316:	rsb	r8, r4, r8
  {
    while (size) {
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, size);
      if (data) {
    631a:	cbz	r5, 632c <MTPD::read(char*, unsigned long)+0x48>
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    631c:	bl	cfd4 <memcpy>
    6320:	ldr	r3, [r6, #4]
    6322:	ldrh.w	lr, [r3, #2]
    6326:	ldrh.w	ip, [r3]
        data += to_copy;
    632a:	add	r5, r4
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    632c:	add	r4, lr
    632e:	uxth	r4, r4
      if (data_buffer_->index == data_buffer_->len) {
    6330:	cmp	ip, r4
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    6332:	strh	r4, [r3, #2]
      if (data_buffer_->index == data_buffer_->len) {
    6334:	beq.n	6340 <MTPD::read(char*, unsigned long)+0x5c>
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6336:	cmp.w	r8, #0
    633a:	bne.n	62f2 <MTPD::read(char*, unsigned long)+0xe>
    633c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
    6340:	mov	r0, r3
    6342:	bl	dc54 <usb_free>
        data_buffer_ = NULL;
    6346:	str	r7, [r6, #4]
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6348:	cmp.w	r8, #0
    634c:	bne.n	62f2 <MTPD::read(char*, unsigned long)+0xe>
    634e:	b.n	633c <MTPD::read(char*, unsigned long)+0x58>
    6350:	bx	lr
    6352:	nop

00006354 <MTPD::readstring(char*)>:

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6354:	push	{r4, r5, r6, lr}
    6356:	sub	sp, #8
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6358:	movs	r2, #1
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    635a:	mov	r4, r1
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    635c:	add.w	r1, sp, #6
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6360:	mov	r6, r0
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6362:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6366:	ldrb.w	r2, [sp, #6]
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
    636a:	cbz	r4, 638c <MTPD::readstring(char*)+0x38>
    636c:	adds	r5, r4, r2
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    636e:	cbz	r2, 6388 <MTPD::readstring(char*)+0x34>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6370:	movs	r2, #2
    6372:	add.w	r1, sp, #6
    6376:	mov	r0, r6
    6378:	bl	62e4 <MTPD::read(char*, unsigned long)>
    637c:	ldrh.w	r3, [sp, #6]
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
        int16_t c2;
        *(buffer++) = c2 = read16();
    6380:	strb.w	r3, [r4], #1
  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    6384:	cmp	r5, r4
    6386:	bne.n	6370 <MTPD::readstring(char*)+0x1c>
        int16_t c2;
        *(buffer++) = c2 = read16();
      }
    }
  }
    6388:	add	sp, #8
    638a:	pop	{r4, r5, r6, pc}
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    638c:	lsls	r2, r2, #1
    638e:	mov	r1, r4
    6390:	mov	r0, r6
    6392:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6396:	b.n	6388 <MTPD::readstring(char*)+0x34>

00006398 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>:
    }
    storage_->close();
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    6398:	push	{r4, r5, lr}
    639a:	sub	sp, #260	; 0x104
    639c:	mov	r4, r0
    639e:	mov	r5, r1
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    63a0:	movs	r2, #12
    63a2:	mov	r1, sp
    63a4:	bl	62e4 <MTPD::read(char*, unsigned long)>
      receive_buffer();
      if(p2==0xDC07)
      {
        char filename[MAX_FILENAME_LEN];
        ReadMTPHeader();
        readstring(filename);
    63a8:	mov	r1, sp
    63aa:	mov	r0, r4
    63ac:	bl	6354 <MTPD::readstring(char*)>

        storage_->rename(p1,filename);
    63b0:	ldr	r0, [r4, #0]
    63b2:	ldr	r3, [r0, #0]
    63b4:	mov	r2, sp
    63b6:	mov	r1, r5
    63b8:	ldr	r3, [r3, #72]	; 0x48
    63ba:	blx	r3

        return 0x2001;
      }
      else
        return 0x2005;
    }
    63bc:	movw	r0, #8193	; 0x2001
    63c0:	add	sp, #260	; 0x104
    63c2:	pop	{r4, r5, pc}

000063c4 <MTPD::SendObjectInfo(unsigned long, unsigned long)>:
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    63c4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    63c8:	sub	sp, #276	; 0x114
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    63ca:	add	r7, sp, #16
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    63cc:	mov	r9, r1
    63ce:	mov	fp, r2
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    63d0:	mov	r1, r7
    63d2:	movs	r2, #12
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    63d4:	mov	r5, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    63d6:	bl	62e4 <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    63da:	ldrh	r3, [r7, #4]
    63dc:	cmp	r3, #2
    63de:	it	eq
    63e0:	ldreq	r4, [r7, #0]
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    63e2:	mov.w	r2, #4
    63e6:	mov	r1, r7
    63e8:	mov	r0, r5
    63ea:	ite	eq
    63ec:	subeq	r4, #65	; 0x41
  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
    63ee:	mvnne.w	r4, #52	; 0x34
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    63f2:	bl	62e4 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    63f6:	movs	r2, #2
    63f8:	mov	r1, r7
    63fa:	mov	r0, r5
    63fc:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6400:	ldrh.w	sl, [r7]
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6404:	movw	r3, #12289	; 0x3001
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6408:	movs	r2, #2
    640a:	mov	r1, r7
    640c:	mov	r0, r5
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    640e:	rsb	sl, r3, sl
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6412:	bl	62e4 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6416:	movs	r2, #4
    6418:	mov	r1, r7
    641a:	mov	r0, r5
    641c:	bl	62e4 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6420:	movs	r2, #2
    6422:	mov	r1, r7
    6424:	mov	r0, r5
    6426:	bl	62e4 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    642a:	movs	r2, #4
    642c:	mov	r1, r7
    642e:	mov	r0, r5
    6430:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6434:	movs	r2, #4
    6436:	mov	r1, r7
    6438:	mov	r0, r5
    643a:	bl	62e4 <MTPD::read(char*, unsigned long)>
    643e:	movs	r2, #4
    6440:	mov	r1, r7
    6442:	mov	r0, r5
    6444:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6448:	movs	r2, #4
    644a:	mov	r1, r7
    644c:	mov	r0, r5
    644e:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6452:	movs	r2, #4
    6454:	mov	r1, r7
    6456:	mov	r0, r5
    6458:	bl	62e4 <MTPD::read(char*, unsigned long)>
    645c:	movs	r2, #4
    645e:	mov	r1, r7
    6460:	mov	r0, r5
    6462:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6466:	movs	r2, #4
    6468:	mov	r1, r7
    646a:	mov	r0, r5
    646c:	bl	62e4 <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6470:	movs	r2, #2
    6472:	mov	r1, r7
    6474:	mov	r0, r5
    6476:	bl	62e4 <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    647a:	movs	r2, #4
    647c:	mov	r1, r7
    647e:	mov	r0, r5
    6480:	bl	62e4 <MTPD::read(char*, unsigned long)>
    6484:	movs	r2, #4
    6486:	mov	r1, r7
    6488:	mov	r0, r5
    648a:	bl	62e4 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // parent
    read16(); len-=2; // association type
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    648e:	mov	r1, r7
    6490:	mov	r0, r5
    6492:	bl	6354 <MTPD::readstring(char*)>
    6496:	mov	r0, r7
    6498:	bl	10680 <strlen>
    649c:	adds	r0, #1
    649e:	sub.w	r4, r4, r0, lsl #1
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    64a2:	clz	sl, sl
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    64a6:	cmp	r4, #3
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    64a8:	mov.w	sl, sl, lsr #5

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    uint32_t len = ReadMTPHeader();
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);
    64ac:	add.w	r9, r9, #4294967295
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    64b0:	bls.n	64cc <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x108>
    64b2:	mov	r6, r4
    64b4:	add.w	r8, sp, #12
    64b8:	subs	r6, #4
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    64ba:	movs	r2, #4
    64bc:	mov	r1, r8
    64be:	mov	r0, r5
    64c0:	bl	62e4 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    64c4:	cmp	r6, #3
    64c6:	bhi.n	64b8 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0xf4>
    64c8:	and.w	r4, r4, #3
    64cc:	add.w	r8, sp, #12
    while(len) {read8(); len--;}
    64d0:	cbz	r4, 64e0 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x11c>
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    64d2:	movs	r2, #1
    64d4:	mov	r1, r8
    64d6:	mov	r0, r5
    64d8:	bl	62e4 <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    while(len) {read8(); len--;}
    64dc:	subs	r4, #1
    64de:	bne.n	64d2 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x10e>
    
    return storage_->Create(store, parent, dir, filename);
    64e0:	ldr	r0, [r5, #0]
    64e2:	ldr	r4, [r0, #0]
    64e4:	str	r7, [sp, #0]
    64e6:	mov	r3, sl
    64e8:	mov	r2, fp
    64ea:	mov	r1, r9
    64ec:	ldr	r4, [r4, #44]	; 0x2c
    64ee:	blx	r4
  }
    64f0:	add	sp, #276	; 0x114
    64f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    64f6:	nop

000064f8 <MTPD::SendObject()>:

  bool MTPD::SendObject() {
    64f8:	push	{r4, r5, r6, r7, lr}
    64fa:	sub	sp, #20
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    64fc:	movs	r2, #12
    64fe:	add	r1, sp, #4
    while(len) {read8(); len--;}
    
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    6500:	mov	r6, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6502:	bl	62e4 <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    6506:	ldrh.w	r3, [sp, #8]
    650a:	cmp	r3, #2
    650c:	beq.n	651c <MTPD::SendObject()+0x24>
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
      }
    }
    storage_->close();
    650e:	ldr	r0, [r6, #0]
    6510:	ldr	r3, [r0, #0]
    6512:	ldr	r3, [r3, #56]	; 0x38
    6514:	blx	r3
    return true;
    6516:	movs	r0, #1
  }
    6518:	add	sp, #20
    651a:	pop	{r4, r5, r6, r7, pc}
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
      return header.len - 12;
    651c:	ldr	r7, [sp, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    651e:	subs	r7, #12
    6520:	beq.n	650e <MTPD::SendObject()+0x16>
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    6522:	movs	r5, #0

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
    6524:	mov	r0, r6
    6526:	bl	624c <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    652a:	ldmia.w	r6, {r0, r1}
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    652e:	ldrh	r2, [r1, #2]
    6530:	ldrh.w	r4, [r1], #8
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    6534:	ldr	r3, [r0, #0]
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    6536:	subs	r4, r4, r2
    6538:	cmp	r4, r7
    653a:	it	cs
    653c:	movcs	r4, r7
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    653e:	add	r1, r2
    6540:	ldr	r3, [r3, #52]	; 0x34
    6542:	mov	r2, r4
    6544:	blx	r3
      data_buffer_->index += to_copy;
      len -= to_copy;
    6546:	subs	r7, r7, r4
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    6548:	cmp	r0, #0
    654a:	beq.n	6518 <MTPD::SendObject()+0x20>
      data_buffer_->index += to_copy;
    654c:	ldr	r0, [r6, #4]
    654e:	ldrh	r3, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    6550:	ldrh	r2, [r0, #0]
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    6552:	add	r4, r3
    6554:	uxth	r4, r4
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    6556:	cmp	r2, r4
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    6558:	strh	r4, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    655a:	beq.n	6562 <MTPD::SendObject()+0x6a>
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    655c:	cmp	r7, #0
    655e:	bne.n	6524 <MTPD::SendObject()+0x2c>
    6560:	b.n	650e <MTPD::SendObject()+0x16>
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
    6562:	bl	dc54 <usb_free>
        data_buffer_ = NULL;
    6566:	str	r5, [r6, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    6568:	cmp	r7, #0
    656a:	bne.n	6524 <MTPD::SendObject()+0x2c>
    656c:	b.n	650e <MTPD::SendObject()+0x16>
    656e:	nop

00006570 <MTPD::loop()>:
      else
        return 0x2005;
    }

  void MTPD::loop(void) 
  {
    6570:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6574:	mov	r5, r0
    6576:	sub	sp, #36	; 0x24
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
    6578:	movs	r0, #5
    657a:	bl	dca0 <usb_rx>
    657e:	cmp	r0, #0
    6580:	beq.n	65e6 <MTPD::loop()+0x76>
      printContainer();
    6582:	ldr	r1, [r0, #16]
    6584:	ldr	r3, [r0, #8]
    6586:	ldrh	r2, [r0, #14]
    6588:	str	r1, [sp, #4]
    658a:	ldrh	r1, [r0, #12]
    658c:	str	r1, [sp, #0]
    658e:	mov	r4, r0
    6590:	ldr	r1, [pc, #764]	; (6890 <MTPD::loop()+0x320>)
    6592:	ldr	r0, [pc, #768]	; (6894 <MTPD::loop()+0x324>)
    6594:	bl	e990 <Print::printf(char const*, ...)>
    6598:	ldr	r3, [r4, #8]
    659a:	cmp	r3, #12
    659c:	bhi.n	662e <MTPD::loop()+0xbe>
    659e:	ldr	r1, [pc, #760]	; (6898 <MTPD::loop()+0x328>)
    65a0:	ldr	r0, [pc, #752]	; (6894 <MTPD::loop()+0x324>)
    65a2:	bl	e990 <Print::printf(char const*, ...)>
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    65a6:	ldrh	r2, [r4, #0]
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
    65a8:	ldr	r6, [r4, #16]
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
    65aa:	ldrh	r0, [r4, #14]
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
    65ac:	ldr	r7, [r4, #8]
        int typ= CONTAINER->type;
    65ae:	ldrh	r1, [r4, #12]
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    65b0:	add.w	r3, r4, #20
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    65b4:	cmp	r2, #11
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    65b6:	ldmia.w	r3, {r3, r9, fp}
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;
    65ba:	str	r6, [r5, #16]

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    65bc:	bls.n	6626 <MTPD::loop()+0xb6>
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    65be:	mov.w	sl, #12
        
        if (typ == 1) { // command
    65c2:	cmp	r1, #1
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    65c4:	strh.w	sl, [r4]
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    65c8:	mov	r8, r3
      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
    65ca:	beq.n	6686 <MTPD::loop()+0x116>
    65cc:	mov.w	r0, #8192	; 0x2000
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    65d0:	movs	r3, #3
        CONTAINER->len=len;
        CONTAINER->op=return_code;
    65d2:	strh	r0, [r4, #14]
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
        CONTAINER->len=len;
    65d4:	str	r7, [r4, #8]
        CONTAINER->op=return_code;
        CONTAINER->transaction_id=id;
    65d6:	str	r6, [r4, #16]
        CONTAINER->params[0]=p1;
    65d8:	str.w	r8, [r4, #20]
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    65dc:	strh	r3, [r4, #12]
        CONTAINER->params[0]=p1;
        #if DEBUG>1
          printContainer();
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
    65de:	mov	r1, r4
    65e0:	movs	r0, #4
    65e2:	bl	dd8c <usb_tx>
      } else {
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
    65e6:	movs	r0, #6
    65e8:	bl	dca0 <usb_rx>
    65ec:	mov	r4, r0
    65ee:	cbz	r0, 6620 <MTPD::loop()+0xb0>
      printf("Event: "); printContainer();
    65f0:	ldr	r1, [pc, #680]	; (689c <MTPD::loop()+0x32c>)
    65f2:	ldr	r0, [pc, #672]	; (6894 <MTPD::loop()+0x324>)
    65f4:	bl	e990 <Print::printf(char const*, ...)>
    65f8:	ldr	r1, [r4, #16]
    65fa:	ldr	r3, [r4, #8]
    65fc:	ldrh	r2, [r4, #14]
    65fe:	str	r1, [sp, #4]
    6600:	ldrh	r1, [r4, #12]
    6602:	str	r1, [sp, #0]
    6604:	ldr	r0, [pc, #652]	; (6894 <MTPD::loop()+0x324>)
    6606:	ldr	r1, [pc, #648]	; (6890 <MTPD::loop()+0x320>)
    6608:	bl	e990 <Print::printf(char const*, ...)>
    660c:	ldr	r3, [r4, #8]
    660e:	cmp	r3, #12
    6610:	bhi.n	665a <MTPD::loop()+0xea>
    6612:	ldr	r1, [pc, #644]	; (6898 <MTPD::loop()+0x328>)
    6614:	ldr	r0, [pc, #636]	; (6894 <MTPD::loop()+0x324>)
    6616:	bl	e990 <Print::printf(char const*, ...)>
      usb_free(receive_buffer);
    661a:	mov	r0, r4
    661c:	bl	dc54 <usb_free>
    }
  }
    6620:	add	sp, #36	; 0x24
    6622:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
        receive_buffer = 0;
      } else {
          usb_free(receive_buffer);
    6626:	mov	r0, r4
    6628:	bl	dc54 <usb_free>
    662c:	b.n	65e6 <MTPD::loop()+0x76>

  void MTPD::loop(void) 
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
    662e:	ldr	r2, [r4, #20]
    6630:	ldr	r1, [pc, #620]	; (68a0 <MTPD::loop()+0x330>)
    6632:	ldr	r0, [pc, #608]	; (6894 <MTPD::loop()+0x324>)
    6634:	bl	e990 <Print::printf(char const*, ...)>
    6638:	ldr	r3, [r4, #8]
    663a:	cmp	r3, #16
    663c:	bls.n	659e <MTPD::loop()+0x2e>
    663e:	ldr	r2, [r4, #24]
    6640:	ldr	r1, [pc, #604]	; (68a0 <MTPD::loop()+0x330>)
    6642:	ldr	r0, [pc, #592]	; (6894 <MTPD::loop()+0x324>)
    6644:	bl	e990 <Print::printf(char const*, ...)>
    6648:	ldr	r3, [r4, #8]
    664a:	cmp	r3, #20
    664c:	bls.n	659e <MTPD::loop()+0x2e>
    664e:	ldr	r2, [r4, #28]
    6650:	ldr	r1, [pc, #588]	; (68a0 <MTPD::loop()+0x330>)
    6652:	ldr	r0, [pc, #576]	; (6894 <MTPD::loop()+0x324>)
    6654:	bl	e990 <Print::printf(char const*, ...)>
    6658:	b.n	659e <MTPD::loop()+0x2e>
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
      printf("Event: "); printContainer();
    665a:	ldr	r2, [r4, #20]
    665c:	ldr	r1, [pc, #576]	; (68a0 <MTPD::loop()+0x330>)
    665e:	ldr	r0, [pc, #564]	; (6894 <MTPD::loop()+0x324>)
    6660:	bl	e990 <Print::printf(char const*, ...)>
    6664:	ldr	r3, [r4, #8]
    6666:	cmp	r3, #16
    6668:	bls.n	6612 <MTPD::loop()+0xa2>
    666a:	ldr	r2, [r4, #24]
    666c:	ldr	r1, [pc, #560]	; (68a0 <MTPD::loop()+0x330>)
    666e:	ldr	r0, [pc, #548]	; (6894 <MTPD::loop()+0x324>)
    6670:	bl	e990 <Print::printf(char const*, ...)>
    6674:	ldr	r3, [r4, #8]
    6676:	cmp	r3, #20
    6678:	bls.n	6612 <MTPD::loop()+0xa2>
    667a:	ldr	r2, [r4, #28]
    667c:	ldr	r1, [pc, #544]	; (68a0 <MTPD::loop()+0x330>)
    667e:	ldr	r0, [pc, #532]	; (6894 <MTPD::loop()+0x324>)
    6680:	bl	e990 <Print::printf(char const*, ...)>
    6684:	b.n	6612 <MTPD::loop()+0xa2>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    6686:	movw	r2, #4108	; 0x100c
    668a:	cmp	r0, r2
    668c:	beq.w	69ca <MTPD::loop()+0x45a>
    6690:	bhi.n	66ce <MTPD::loop()+0x15e>
    6692:	movw	r2, #4101	; 0x1005
    6696:	cmp	r0, r2
    6698:	beq.w	6ad0 <MTPD::loop()+0x560>
    669c:	bls.n	6758 <MTPD::loop()+0x1e8>
    669e:	movw	r2, #4104	; 0x1008
    66a2:	cmp	r0, r2
    66a4:	beq.w	6a90 <MTPD::loop()+0x520>
    66a8:	bhi.w	6824 <MTPD::loop()+0x2b4>
    66ac:	movw	r2, #4102	; 0x1006
    66b0:	cmp	r0, r2
    66b2:	beq.w	6910 <MTPD::loop()+0x3a0>
    66b6:	movw	r2, #4103	; 0x1007
    66ba:	cmp	r0, r2
    66bc:	bne.w	681e <MTPD::loop()+0x2ae>
              } else {
                p1 = GetNumObjects(p1, p3);
              }
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
    66c0:	cmp.w	r9, #0
    66c4:	beq.w	6b34 <MTPD::loop()+0x5c4>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    66c8:	movw	r0, #8212	; 0x2014
    66cc:	b.n	65d0 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    66ce:	movw	r2, #4121	; 0x1019
    66d2:	cmp	r0, r2
    66d4:	beq.w	6a68 <MTPD::loop()+0x4f8>
    66d8:	bls.n	67b4 <MTPD::loop()+0x244>
    66da:	movw	r2, #38914	; 0x9802
    66de:	cmp	r0, r2
    66e0:	beq.w	69e4 <MTPD::loop()+0x474>
    66e4:	bhi.w	685a <MTPD::loop()+0x2ea>
    66e8:	movw	r2, #4122	; 0x101a
    66ec:	cmp	r0, r2
    66ee:	beq.w	6b10 <MTPD::loop()+0x5a0>
    66f2:	movw	r2, #38913	; 0x9801
    66f6:	cmp	r0, r2
    66f8:	bne.w	681e <MTPD::loop()+0x2ae>
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
              else {p1 = return_code; return_code=0x2001;}
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    66fc:	movs	r2, #1
    66fe:	mov.w	r9, #0
    6702:	mov	r1, r3
    6704:	strb	r2, [r5, #8]
    6706:	mov	r0, r5
    6708:	str.w	r9, [r5, #12]
    670c:	str	r3, [sp, #12]
    670e:	bl	57f8 <MTPD::getObjectPropsSupported(unsigned long)>
    6712:	ldr	r2, [r5, #12]
    6714:	strb.w	r9, [r5, #8]
    6718:	adds	r2, #12
    671a:	movs	r1, #2
    671c:	strh.w	r1, [sp, #24]
    6720:	str	r2, [sp, #20]
    6722:	ldrh	r2, [r4, #14]
    6724:	strh.w	r2, [sp, #26]
    6728:	ldr	r2, [r4, #16]
    672a:	str	r2, [sp, #28]
    672c:	add	r1, sp, #20
    672e:	mov	r0, r5
    6730:	movs	r2, #12
    6732:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6736:	ldr	r3, [sp, #12]
    6738:	mov	r0, r5
    673a:	mov	r1, r3
    673c:	bl	57f8 <MTPD::getObjectPropsSupported(unsigned long)>
    6740:	mov	r0, r5
    6742:	bl	5070 <MTPD::get_buffer()>
    6746:	ldr	r1, [r5, #4]
    6748:	movs	r0, #4
    674a:	bl	dd8c <usb_tx>
    674e:	str.w	r9, [r5, #4]
              break;
    6752:	movw	r0, #8193	; 0x2001
    6756:	b.n	65d0 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    6758:	movw	r3, #4098	; 0x1002
    675c:	cmp	r0, r3
    675e:	beq.w	68fc <MTPD::loop()+0x38c>
    6762:	bls.w	68b8 <MTPD::loop()+0x348>
    6766:	movw	r3, #4099	; 0x1003
    676a:	cmp	r0, r3
    676c:	beq.n	6752 <MTPD::loop()+0x1e2>
    676e:	movw	r3, #4100	; 0x1004
    6772:	cmp	r0, r3
    6774:	bne.n	681e <MTPD::loop()+0x2ae>
              openSession(p1);
              break;
            case 0x1003:  // CloseSession
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    6776:	mov.w	r9, #0
    677a:	movs	r3, #1
    677c:	strb	r3, [r5, #8]
    677e:	mov	r0, r5
    6780:	str.w	r9, [r5, #12]
    6784:	bl	54cc <MTPD::WriteStorageIDs()>
    6788:	ldr	r3, [r5, #12]
    678a:	strb.w	r9, [r5, #8]
    678e:	adds	r3, #12
    6790:	movs	r2, #2
    6792:	strh.w	r2, [sp, #24]
    6796:	str	r3, [sp, #20]
    6798:	ldrh	r3, [r4, #14]
    679a:	strh.w	r3, [sp, #26]
    679e:	ldr	r3, [r4, #16]
    67a0:	str	r3, [sp, #28]
    67a2:	mov	r0, r5
    67a4:	movs	r2, #12
    67a6:	add	r1, sp, #20
    67a8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    67ac:	mov	r0, r5
    67ae:	bl	54cc <MTPD::WriteStorageIDs()>
    67b2:	b.n	6740 <MTPD::loop()+0x1d0>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    67b4:	movw	r2, #4112	; 0x1010
    67b8:	cmp	r0, r2
    67ba:	beq.n	681e <MTPD::loop()+0x2ae>
    67bc:	bls.n	68a4 <MTPD::loop()+0x334>
    67be:	movw	r2, #4116	; 0x1014
    67c2:	cmp	r0, r2
    67c4:	beq.w	692a <MTPD::loop()+0x3ba>
    67c8:	movw	r2, #4117	; 0x1015
    67cc:	cmp	r0, r2
    67ce:	bne.n	681e <MTPD::loop()+0x2ae>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    67d0:	movw	r2, #54274	; 0xd402
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    67d4:	mov.w	r9, #0
    67d8:	movs	r1, #1
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    67da:	cmp	r3, r2
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    67dc:	str.w	r9, [r5, #12]
    67e0:	strb	r1, [r5, #8]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    67e2:	beq.w	6b7a <MTPD::loop()+0x60a>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    67e6:	movs	r3, #2
    67e8:	movs	r2, #12
    67ea:	strb.w	r9, [r5, #8]
    67ee:	str	r2, [sp, #20]
    67f0:	strh.w	r3, [sp, #24]
    67f4:	ldrh	r3, [r4, #14]
    67f6:	strh.w	r3, [sp, #26]
    67fa:	ldr	r3, [r4, #16]
    67fc:	str	r3, [sp, #28]
    67fe:	add	r1, sp, #20
    6800:	mov	r0, r5
    6802:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6806:	mov	r0, r5
    6808:	bl	5070 <MTPD::get_buffer()>
    680c:	movs	r0, #4
    680e:	ldr	r1, [r5, #4]
    6810:	bl	dd8c <usb_tx>
    6814:	movs	r3, #0
    6816:	str	r3, [r5, #4]
              break;
    6818:	movw	r0, #8193	; 0x2001
    681c:	b.n	65d0 <MTPD::loop()+0x60>
              return_code = setObjectPropValue(p1,p2);
              break;
              
            default:
              return_code = 0x2005;  // operation not supported
              break;
    681e:	movw	r0, #8197	; 0x2005
    6822:	b.n	65d0 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    6824:	movw	r2, #4105	; 0x1009
    6828:	cmp	r0, r2
    682a:	beq.w	6a28 <MTPD::loop()+0x4b8>
    682e:	movw	r2, #4107	; 0x100b
    6832:	cmp	r0, r2
    6834:	bne.n	681e <MTPD::loop()+0x2ae>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    6836:	cmp.w	r9, #0
    683a:	bne.w	66c8 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                if (!storage_->DeleteObject(p1)) {
    683e:	ldr	r0, [r5, #0]
    6840:	ldr	r2, [r0, #0]
    6842:	mov	r1, r3
    6844:	ldr	r3, [r2, #60]	; 0x3c
    6846:	blx	r3
    6848:	movw	r3, #8210	; 0x2012
    684c:	movw	r2, #8193	; 0x2001
    6850:	cmp	r0, #0
    6852:	ite	eq
    6854:	moveq	r0, r3
    6856:	movne	r0, r2
    6858:	b.n	65d0 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    685a:	movw	r2, #38915	; 0x9803
    685e:	cmp	r0, r2
    6860:	beq.w	6974 <MTPD::loop()+0x404>
    6864:	movw	r2, #38916	; 0x9804
    6868:	cmp	r0, r2
    686a:	bne.n	681e <MTPD::loop()+0x2ae>
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    {
      receive_buffer();
    686c:	mov	r0, r5
    686e:	str	r3, [sp, #12]
    6870:	bl	624c <MTPD::receive_buffer()>
      if(p2==0xDC07)
    6874:	movw	r2, #56327	; 0xdc07
    6878:	cmp	r9, r2
    687a:	ldr	r3, [sp, #12]
    687c:	bne.n	681e <MTPD::loop()+0x2ae>
    687e:	mov	r1, r3
    6880:	mov	r0, r5
    6882:	bl	6398 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>
          }
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
    6886:	cmp	r0, #0
    6888:	beq.w	6626 <MTPD::loop()+0xb6>
    688c:	uxth	r0, r0
    688e:	b.n	65d0 <MTPD::loop()+0x60>
    6890:	.word	0x2000039c
    6894:	.word	0x20000cdc
    6898:	.word	0x200003b0
    689c:	.word	0x200003b4
    68a0:	.word	0x200003ac
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    68a4:	movw	r3, #4109	; 0x100d
    68a8:	cmp	r0, r3
    68aa:	bne.n	681e <MTPD::loop()+0x2ae>
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
              break;
            case 0x100D:  // SendObject
              SendObject();
    68ac:	mov	r0, r5
    68ae:	bl	64f8 <MTPD::SendObject()>
              break;
    68b2:	movw	r0, #8193	; 0x2001
    68b6:	b.n	65d0 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    68b8:	movw	r3, #4097	; 0x1001
    68bc:	cmp	r0, r3
    68be:	bne.n	681e <MTPD::loop()+0x2ae>
            case 0x1001: // GetDescription
              TRANSMIT(WriteDescriptor());
    68c0:	mov.w	r9, #0
    68c4:	strb	r1, [r5, #8]
    68c6:	mov	r0, r5
    68c8:	str.w	r9, [r5, #12]
    68cc:	bl	5250 <MTPD::WriteDescriptor()>
    68d0:	ldr	r3, [r5, #12]
    68d2:	strb.w	r9, [r5, #8]
    68d6:	adds	r3, #12
    68d8:	movs	r2, #2
    68da:	strh.w	r2, [sp, #24]
    68de:	str	r3, [sp, #20]
    68e0:	ldrh	r3, [r4, #14]
    68e2:	strh.w	r3, [sp, #26]
    68e6:	ldr	r3, [r4, #16]
    68e8:	str	r3, [sp, #28]
    68ea:	mov	r0, r5
    68ec:	mov	r2, sl
    68ee:	add	r1, sp, #20
    68f0:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    68f4:	mov	r0, r5
    68f6:	bl	5250 <MTPD::WriteDescriptor()>
    68fa:	b.n	6740 <MTPD::loop()+0x1d0>
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
      storage_->ResetIndex();
    68fc:	ldr	r0, [r5, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    68fe:	ldr	r2, [pc, #736]	; (6be0 <MTPD::loop()+0x670>)
      storage_->ResetIndex();
    6900:	ldr	r3, [r0, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    6902:	str.w	r8, [r2]
      storage_->ResetIndex();
    6906:	ldr	r3, [r3, #68]	; 0x44
    6908:	blx	r3
    690a:	movw	r0, #8193	; 0x2001
    690e:	b.n	65d0 <MTPD::loop()+0x60>
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
              break;
            case 0x1006:  // GetNumObjects
              if (p2) {
    6910:	cmp.w	r9, #0
    6914:	bne.w	66c8 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                p1 = GetNumObjects(p1, p3);
    6918:	mov	r2, fp
    691a:	mov	r1, r3
    691c:	mov	r0, r5
    691e:	bl	5048 <MTPD::GetNumObjects(unsigned long, unsigned long)>
    6922:	mov	r8, r0
    6924:	movw	r0, #8193	; 0x2001
    6928:	b.n	65d0 <MTPD::loop()+0x60>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    692a:	movw	r2, #54274	; 0xd402
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    692e:	movs	r0, #0
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    6930:	cmp	r3, r2
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    6932:	strb	r1, [r5, #8]
    6934:	str	r0, [r5, #12]
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    6936:	beq.w	6bb0 <MTPD::loop()+0x640>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    693a:	movs	r2, #12
    693c:	movs	r0, #0
    693e:	movs	r1, #2
    6940:	strb	r0, [r5, #8]
    6942:	str	r2, [sp, #20]
    6944:	strh.w	r1, [sp, #24]
    6948:	ldrh	r1, [r4, #14]
    694a:	strh.w	r1, [sp, #26]
    694e:	ldr	r1, [r4, #16]
    6950:	str	r1, [sp, #28]
    6952:	mov	r0, r5
    6954:	add	r1, sp, #20
    6956:	str	r3, [sp, #12]
    6958:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    695c:	ldr	r3, [sp, #12]
    695e:	movw	r2, #54274	; 0xd402
    6962:	cmp	r3, r2
    6964:	bne.w	6806 <MTPD::loop()+0x296>
    6968:	movw	r1, #54274	; 0xd402
    696c:	mov	r0, r5
    696e:	bl	5194 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
    6972:	b.n	6806 <MTPD::loop()+0x296>
          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
            TRANSMIT(getObjectPropValue(p1,p2));
    6974:	mov.w	fp, #0
    6978:	strb	r1, [r5, #8]
    697a:	mov	r2, r9
    697c:	mov	r1, r3
    697e:	mov	r0, r5
    6980:	str.w	fp, [r5, #12]
    6984:	bl	5864 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    6988:	ldr	r3, [r5, #12]
    698a:	strb.w	fp, [r5, #8]
    698e:	adds	r3, #12
    6990:	movs	r2, #2
    6992:	strh.w	r2, [sp, #24]
    6996:	str	r3, [sp, #20]
    6998:	ldrh	r3, [r4, #14]
    699a:	strh.w	r3, [sp, #26]
    699e:	mov	r2, sl
    69a0:	ldr	r3, [r4, #16]
    69a2:	str	r3, [sp, #28]
    69a4:	add	r1, sp, #20
    69a6:	mov	r0, r5
    69a8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    69ac:	mov	r2, r9
    69ae:	mov	r1, r8
    69b0:	mov	r0, r5
    69b2:	bl	5864 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    69b6:	mov	r0, r5
    69b8:	bl	5070 <MTPD::get_buffer()>
    69bc:	ldr	r1, [r5, #4]
    69be:	movs	r0, #4
    69c0:	bl	dd8c <usb_tx>
    69c4:	str.w	fp, [r5, #4]
    69c8:	b.n	6752 <MTPD::loop()+0x1e2>
                  return_code = 0x2012; // partial deletion
                }
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
    69ca:	mov	r0, r5
    69cc:	mov	r2, r9
    69ce:	mov	r1, r3
    69d0:	bl	63c4 <MTPD::SendObjectInfo(unsigned long, unsigned long)>
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    69d4:	movs	r7, #24
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
    69d6:	str	r0, [r4, #28]
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
    69d8:	str.w	r9, [r4, #24]
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    69dc:	strh	r7, [r4, #0]
              break;
    69de:	movw	r0, #8193	; 0x2001
    69e2:	b.n	65d0 <MTPD::loop()+0x60>
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
    69e4:	mov.w	fp, #0
    69e8:	strb	r1, [r5, #8]
    69ea:	mov	r2, r9
    69ec:	mov	r1, r3
    69ee:	mov	r0, r5
    69f0:	str.w	fp, [r5, #12]
    69f4:	bl	5b64 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    69f8:	ldr	r3, [r5, #12]
    69fa:	strb.w	fp, [r5, #8]
    69fe:	adds	r3, #12
    6a00:	movs	r2, #2
    6a02:	strh.w	r2, [sp, #24]
    6a06:	str	r3, [sp, #20]
    6a08:	ldrh	r3, [r4, #14]
    6a0a:	strh.w	r3, [sp, #26]
    6a0e:	mov	r2, sl
    6a10:	ldr	r3, [r4, #16]
    6a12:	str	r3, [sp, #28]
    6a14:	add	r1, sp, #20
    6a16:	mov	r0, r5
    6a18:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6a1c:	mov	r2, r9
    6a1e:	mov	r1, r8
    6a20:	mov	r0, r5
    6a22:	bl	5b64 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    6a26:	b.n	69b6 <MTPD::loop()+0x446>
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
    6a28:	mov.w	r9, #0
    6a2c:	strb	r1, [r5, #8]
    6a2e:	mov	r0, r5
    6a30:	mov	r1, r3
    6a32:	str.w	r9, [r5, #12]
    6a36:	bl	6268 <MTPD::GetObject(unsigned long)>
    6a3a:	ldr	r3, [r5, #12]
    6a3c:	strb.w	r9, [r5, #8]
    6a40:	adds	r3, #12
    6a42:	movs	r2, #2
    6a44:	strh.w	r2, [sp, #24]
    6a48:	str	r3, [sp, #20]
    6a4a:	ldrh	r3, [r4, #14]
    6a4c:	strh.w	r3, [sp, #26]
    6a50:	ldr	r3, [r4, #16]
    6a52:	str	r3, [sp, #28]
    6a54:	add	r1, sp, #20
    6a56:	mov	r0, r5
    6a58:	mov	r2, sl
    6a5a:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6a5e:	mov	r1, r8
    6a60:	mov	r0, r5
    6a62:	bl	6268 <MTPD::GetObject(unsigned long)>
    6a66:	b.n	6740 <MTPD::loop()+0x1d0>
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    6a68:	ldr	r0, [r5, #0]
    6a6a:	ldr	r1, [r0, #0]
    6a6c:	mov	r3, fp
    6a6e:	add.w	r2, r9, #4294967295
    6a72:	ldr	r5, [r1, #76]	; 0x4c
    6a74:	mov	r1, r8
    6a76:	blx	r5
    6a78:	movw	r3, #8197	; 0x2005
    6a7c:	movw	r2, #8193	; 0x2001
              return_code = 0x2005;
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
    6a80:	strh.w	sl, [r4]
              break;
    6a84:	mov	r7, sl
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    6a86:	cmp	r0, #0
    6a88:	ite	eq
    6a8a:	moveq	r0, r3
    6a8c:	movne	r0, r2
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
              break;
    6a8e:	b.n	65d0 <MTPD::loop()+0x60>
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
              }
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
    6a90:	mov.w	r9, #0
    6a94:	strb	r1, [r5, #8]
    6a96:	mov	r0, r5
    6a98:	mov	r1, r3
    6a9a:	str.w	r9, [r5, #12]
    6a9e:	bl	55a4 <MTPD::GetObjectInfo(unsigned long)>
    6aa2:	ldr	r3, [r5, #12]
    6aa4:	strb.w	r9, [r5, #8]
    6aa8:	adds	r3, #12
    6aaa:	movs	r2, #2
    6aac:	strh.w	r2, [sp, #24]
    6ab0:	str	r3, [sp, #20]
    6ab2:	ldrh	r3, [r4, #14]
    6ab4:	strh.w	r3, [sp, #26]
    6ab8:	ldr	r3, [r4, #16]
    6aba:	str	r3, [sp, #28]
    6abc:	add	r1, sp, #20
    6abe:	mov	r0, r5
    6ac0:	mov	r2, sl
    6ac2:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6ac6:	mov	r1, r8
    6ac8:	mov	r0, r5
    6aca:	bl	55a4 <MTPD::GetObjectInfo(unsigned long)>
    6ace:	b.n	6740 <MTPD::loop()+0x1d0>
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
    6ad0:	mov.w	r9, #0
    6ad4:	strb	r1, [r5, #8]
    6ad6:	mov	r0, r5
    6ad8:	mov	r1, r3
    6ada:	str.w	r9, [r5, #12]
    6ade:	bl	5a20 <MTPD::GetStorageInfo(unsigned long)>
    6ae2:	ldr	r3, [r5, #12]
    6ae4:	strb.w	r9, [r5, #8]
    6ae8:	adds	r3, #12
    6aea:	movs	r2, #2
    6aec:	strh.w	r2, [sp, #24]
    6af0:	str	r3, [sp, #20]
    6af2:	ldrh	r3, [r4, #14]
    6af4:	strh.w	r3, [sp, #26]
    6af8:	ldr	r3, [r4, #16]
    6afa:	str	r3, [sp, #28]
    6afc:	add	r1, sp, #20
    6afe:	mov	r0, r5
    6b00:	mov	r2, sl
    6b02:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6b06:	mov	r1, r8
    6b08:	mov	r0, r5
    6b0a:	bl	5a20 <MTPD::GetStorageInfo(unsigned long)>
    6b0e:	b.n	6740 <MTPD::loop()+0x1d0>
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    }
    
    uint32_t MTPD::copyObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      return storage_->copy(handle,store1,newHandle);
    6b10:	ldr	r0, [r5, #0]
    6b12:	ldr	r1, [r0, #0]
    6b14:	mov	r3, fp
    6b16:	ldr	r5, [r1, #80]	; 0x50
    6b18:	add.w	r2, r9, #4294967295
    6b1c:	mov	r1, r8
    6b1e:	blx	r5
              len  = receive_buffer->len = 12;
              break;

          case 0x101A:  // CopyObject
              return_code = copyObject(p1,p2,p3);
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
    6b20:	cbnz	r0, 6b2c <MTPD::loop()+0x5bc>
    6b22:	movs	r7, #12
    6b24:	strh	r7, [r4, #0]
    6b26:	movw	r0, #8197	; 0x2005
    6b2a:	b.n	65d0 <MTPD::loop()+0x60>
              else {p1 = return_code; return_code=0x2001;}
    6b2c:	mov	r8, r0
    6b2e:	movw	r0, #8193	; 0x2001
    6b32:	b.n	65d0 <MTPD::loop()+0x60>
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
                return_code = 0x2014; // spec by format unsupported
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
    6b34:	movs	r2, #1
    6b36:	mov	r1, r3
    6b38:	strb	r2, [r5, #8]
    6b3a:	mov	r0, r5
    6b3c:	mov	r2, fp
    6b3e:	str.w	r9, [r5, #12]
    6b42:	str	r3, [sp, #12]
    6b44:	bl	5534 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    6b48:	ldr	r2, [r5, #12]
    6b4a:	strb.w	r9, [r5, #8]
    6b4e:	adds	r2, #12
    6b50:	movs	r1, #2
    6b52:	strh.w	r1, [sp, #24]
    6b56:	str	r2, [sp, #20]
    6b58:	ldrh	r2, [r4, #14]
    6b5a:	strh.w	r2, [sp, #26]
    6b5e:	ldr	r2, [r4, #16]
    6b60:	str	r2, [sp, #28]
    6b62:	add	r1, sp, #20
    6b64:	mov	r0, r5
    6b66:	movs	r2, #12
    6b68:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6b6c:	ldr	r3, [sp, #12]
    6b6e:	mov	r2, fp
    6b70:	mov	r1, r3
    6b72:	mov	r0, r5
    6b74:	bl	5534 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    6b78:	b.n	6740 <MTPD::loop()+0x1d0>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    6b7a:	mov	r0, r5
    6b7c:	ldr	r1, [pc, #100]	; (6be4 <MTPD::loop()+0x674>)
    6b7e:	bl	50ec <MTPD::writestring(char const*)>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    6b82:	ldr	r3, [r5, #12]
    6b84:	strb.w	r9, [r5, #8]
    6b88:	adds	r3, #12
    6b8a:	movs	r2, #2
    6b8c:	strh.w	r2, [sp, #24]
    6b90:	str	r3, [sp, #20]
    6b92:	ldrh	r3, [r4, #14]
    6b94:	strh.w	r3, [sp, #26]
    6b98:	ldr	r3, [r4, #16]
    6b9a:	str	r3, [sp, #28]
    6b9c:	add	r1, sp, #20
    6b9e:	mov	r0, r5
    6ba0:	movs	r2, #12
    6ba2:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    6ba6:	ldr	r1, [pc, #60]	; (6be4 <MTPD::loop()+0x674>)
    6ba8:	mov	r0, r5
    6baa:	bl	50ec <MTPD::writestring(char const*)>
    6bae:	b.n	6806 <MTPD::loop()+0x296>
    6bb0:	mov	r1, r2
    6bb2:	mov	r0, r5
    6bb4:	bl	5194 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    6bb8:	ldr	r3, [r5, #12]
    6bba:	movs	r1, #0
    6bbc:	adds	r3, #12
    6bbe:	movs	r2, #2
    6bc0:	strb	r1, [r5, #8]
    6bc2:	strh.w	r2, [sp, #24]
    6bc6:	str	r3, [sp, #20]
    6bc8:	ldrh	r3, [r4, #14]
    6bca:	strh.w	r3, [sp, #26]
    6bce:	ldr	r3, [r4, #16]
    6bd0:	str	r3, [sp, #28]
    6bd2:	movs	r2, #12
    6bd4:	add	r1, sp, #20
    6bd6:	mov	r0, r5
    6bd8:	bl	5088 <MTPD::write(char const*, int) [clone .part.2]>
    6bdc:	b.n	6968 <MTPD::loop()+0x3f8>
    6bde:	nop
    6be0:	.word	0x20004c00
    6be4:	.word	0x2000036c

00006be8 <usb_init_events>:
  extern "C"
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
    6be8:	push	{r3, lr}
      tx_event_packet = usb_malloc();
    6bea:	bl	dc14 <usb_malloc>
    6bee:	ldr	r2, [pc, #12]	; (6bfc <usb_init_events+0x14>)
    6bf0:	mov	r3, r0
      if(tx_event_packet) return 1; else return 0; 
    }
    6bf2:	adds	r0, #0
    6bf4:	it	ne
    6bf6:	movne	r0, #1
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
      tx_event_packet = usb_malloc();
    6bf8:	str	r3, [r2, #0]
      if(tx_event_packet) return 1; else return 0; 
    }
    6bfa:	pop	{r3, pc}
    6bfc:	.word	0x20004c04

00006c00 <usb_mtp_sendEvent>:


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
    6c00:	push	{r3, r4, r5, lr}
      if (!usb_configuration) return -1;
    6c02:	ldr	r3, [pc, #44]	; (6c30 <usb_mtp_sendEvent+0x30>)
    6c04:	ldrb	r3, [r3, #0]
    6c06:	cbz	r3, 6c28 <usb_mtp_sendEvent+0x28>
      memcpy(tx_event_packet->buf, buffer, len);
    6c08:	ldr	r3, [pc, #40]	; (6c34 <usb_mtp_sendEvent+0x34>)
    6c0a:	ldr	r5, [r3, #0]
    6c0c:	mov	r4, r1
    6c0e:	mov	r2, r4
    6c10:	mov	r1, r0
    6c12:	add.w	r0, r5, #8
    6c16:	bl	cfd4 <memcpy>
      tx_event_packet->len = len;
    6c1a:	strh	r4, [r5, #0]
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
    6c1c:	mov	r1, r5
    6c1e:	movs	r0, #6
    6c20:	bl	dd8c <usb_tx>
      return len;
    6c24:	mov	r0, r4
    6c26:	pop	{r3, r4, r5, pc}
    }


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
      if (!usb_configuration) return -1;
    6c28:	mov.w	r0, #4294967295
      memcpy(tx_event_packet->buf, buffer, len);
      tx_event_packet->len = len;
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
      return len;
    }
    6c2c:	pop	{r3, r4, r5, pc}
    6c2e:	nop
    6c30:	.word	0x20005254
    6c34:	.word	0x20004c04

00006c38 <MTPD::send_Event(unsigned short)>:

  #endif
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    6c38:	push	{r4, r5, lr}
    6c3a:	sub	sp, #36	; 0x24
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    6c3c:	ldr	r3, [r0, #16]

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    6c3e:	strh.w	r1, [sp, #6]
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    6c42:	movs	r4, #12
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    6c44:	str	r3, [sp, #8]
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    6c46:	mov	r1, r4
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    event.params[0]=0;
    6c48:	movs	r3, #0
  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    6c4a:	movs	r5, #4
    event.transaction_id=TID;
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    6c4c:	movs	r2, #60	; 0x3c
    6c4e:	mov	r0, sp
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    6c50:	str	r4, [sp, #0]
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    6c52:	strh.w	r5, [sp, #4]
    event.transaction_id=TID;
    event.params[0]=0;
    6c56:	str	r3, [sp, #12]
    event.params[1]=0;
    6c58:	str	r3, [sp, #16]
    event.params[2]=0;
    6c5a:	str	r3, [sp, #20]
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    6c5c:	bl	6c00 <usb_mtp_sendEvent>
  }
    6c60:	add	sp, #36	; 0x24
    6c62:	pop	{r4, r5, pc}

00006c64 <MTPD::send_DeviceResetEvent()>:
    event.params[2]=p3;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
  }

  int MTPD::send_DeviceResetEvent(void) 
  { return send_Event(MTP_EVENT_DEVICE_RESET); } 
    6c64:	movw	r1, #16395	; 0x400b
    6c68:	b.w	6c38 <MTPD::send_Event(unsigned short)>

00006c6c <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    6c6c:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    6c6e:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    6c70:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    6c72:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    6c74:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    6c76:	beq.n	6c80 <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    6c78:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    6c7c:	b.w	e834 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6c80:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    6c82:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6c86:	bx	r3

00006c88 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    6c88:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6c8c:	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    6c8e:	ldr	r5, [r4, #12]
    6c90:	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    6c94:	ldr	r5, [pc, #484]	; (6e7c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    6c96:	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    6c98:	bne.n	6d40 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6c9a:	lsls	r7, r3, #31
    6c9c:	bpl.w	6e06 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    6ca0:	cmp	r1, #0
    6ca2:	beq.w	6e6c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6ca6:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    6ca8:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6caa:	it	ne
    6cac:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    6cb0:	str	r5, [r4, #52]	; 0x34
    6cb2:	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6cb4:	ldrb.w	r8, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    6cb8:	add.w	ip, r3, #4294967295
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6cbc:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    6cc0:	cmp.w	ip, #0
    6cc4:	beq.w	6e18 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    6cc8:	cbz	r1, 6cd4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    6cca:	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    6ccc:	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    6cd0:	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6cd4:	ldr	r5, [r0, #4]
    6cd6:	ldrb	r6, [r5, #8]
			if (count == 2)
    6cd8:	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6cdc:	add.w	r6, r6, #4294967295
    6ce0:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    6ce4:	ite	eq
    6ce6:	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6cea:	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6cee:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6cf0:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    6cf2:	sub.w	ip, ip, #2
    6cf6:	b.n	6d0a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    6cf8:	cbz	r2, 6cfe <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    6cfa:	strb	r4, [r2, #0]
    6cfc:	adds	r2, #1
						} 
						count_read--;
    6cfe:	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6d00:	and.w	r5, r5, #61440	; 0xf000
    6d04:	cmp	r5, r6
    6d06:	bls.n	6d36 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    6d08:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    6d0a:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    6d0c:	tst.w	r5, #240	; 0xf0
    6d10:	beq.n	6d00 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    6d12:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    6d14:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    6d18:	mov	r7, r2
    6d1a:	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    6d1e:	bne.n	6cf8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    6d20:	cbz	r2, 6d2a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    6d22:	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    6d26:	strb	r4, [r2, #1]
    6d28:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6d2a:	and.w	r5, r5, #61440	; 0xf000
    6d2e:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    6d30:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6d34:	bhi.n	6d08 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    6d36:	cmp.w	ip, #0
    6d3a:	beq.n	6e18 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    6d3c:	ldr	r4, [r0, #0]
    6d3e:	b.n	6cc8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6d40:	lsls	r5, r3, #31
    6d42:	bpl.n	6dde <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    6d44:	cmp	r1, #0
    6d46:	beq.w	6e5c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6d4a:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    6d4c:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6d4e:	it	ne
    6d50:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    6d54:	str	r5, [r4, #52]	; 0x34
    6d56:	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    6d58:	add.w	lr, r3, #4294967295
		}

	    uint16_t w = _transferWriteFill;
    6d5c:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    6d60:	cmp.w	lr, #0
    6d64:	beq.n	6dea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    6d66:	cbz	r1, 6d74 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    6d68:	ldrb.w	ip, [r1, #1]
    6d6c:	ldrb	r5, [r1, #0]
    6d6e:	adds	r1, #2
    6d70:	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6d74:	ldr	r5, [r0, #4]
    6d76:	ldrb	r6, [r5, #8]
			if (count == 2)
    6d78:	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6d7c:	add.w	r6, r6, #4294967295
    6d80:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    6d84:	ite	eq
    6d86:	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6d8a:	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6d8e:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6d90:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    6d92:	sub.w	lr, lr, #2
    6d96:	b.n	6daa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    6d98:	cbz	r2, 6d9e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    6d9a:	strb	r4, [r2, #0]
    6d9c:	adds	r2, #1
						} 
						count_read--;
    6d9e:	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6da0:	and.w	r5, r5, #61440	; 0xf000
    6da4:	cmp	r5, r6
    6da6:	bls.n	6dd4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    6da8:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    6daa:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    6dac:	tst.w	r5, #240	; 0xf0
    6db0:	beq.n	6da0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    6db2:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    6db6:	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    6db8:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    6dba:	bne.n	6d98 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    6dbc:	cbz	r2, 6dc8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    6dbe:	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    6dc2:	asrs	r4, r4, #8
    6dc4:	strb	r4, [r2, #1]
    6dc6:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6dc8:	and.w	r5, r5, #61440	; 0xf000
    6dcc:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    6dce:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6dd2:	bhi.n	6da8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    6dd4:	cmp.w	lr, #0
    6dd8:	beq.n	6dea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    6dda:	ldr	r4, [r0, #0]
    6ddc:	b.n	6d66 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6dde:	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    6de0:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    6de4:	cmp.w	lr, #0
    6de8:	bne.n	6d66 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    6dea:	cbz	r3, 6e34 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    6dec:	ldr	r4, [r0, #0]
			sr = port().SR;
    6dee:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    6df0:	tst.w	r1, #240	; 0xf0
    6df4:	beq.n	6dee <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6df6:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6df8:	lsls	r4, r3, #31
    6dfa:	bpl.n	6e38 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    6dfc:	cbz	r2, 6e02 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    6dfe:	strb	r1, [r2, #0]
    6e00:	adds	r2, #1
					count_read--;
    6e02:	subs	r3, #1
    6e04:	b.n	6dea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6e06:	ldrb.w	r8, [r0, #36]	; 0x24
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6e0a:	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6e0c:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    6e10:	cmp.w	ip, #0
    6e14:	bne.w	6cc8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    6e18:	cbz	r3, 6e34 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    6e1a:	ldr	r4, [r0, #0]
			sr = port().SR;
    6e1c:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    6e1e:	tst.w	r1, #240	; 0xf0
    6e22:	beq.n	6e1c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    6e24:	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6e26:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6e28:	bpl.n	6e4a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    6e2a:	cbz	r2, 6e30 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    6e2c:	strb	r1, [r2, #0]
    6e2e:	adds	r2, #1
					count_read--;
    6e30:	subs	r3, #1
    6e32:	b.n	6e18 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    6e34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    6e38:	cbz	r2, 6e46 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    6e3a:	mov	r4, r2
						*p_read++ = w >> 8;
    6e3c:	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    6e3e:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    6e42:	strb	r5, [r2, #1]
    6e44:	mov	r2, r4
					}
					count_read -= 2;
    6e46:	subs	r3, #2
    6e48:	b.n	6dea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    6e4a:	cbz	r2, 6e58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    6e4c:	mov	r4, r2
    6e4e:	asrs	r5, r1, #8
    6e50:	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    6e54:	strb	r1, [r2, #1]
    6e56:	mov	r2, r4
					}
					count_read -= 2;
    6e58:	subs	r3, #2
    6e5a:	b.n	6e18 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6e5c:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6e60:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6e62:	it	ne
    6e64:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6e68:	str	r5, [r4, #52]	; 0x34
    6e6a:	b.n	6d58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6e6c:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6e70:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6e72:	it	ne
    6e74:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6e78:	str	r5, [r4, #52]	; 0x34
    6e7a:	b.n	6cb4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    6e7c:	.word	0x801f0400

00006e80 <_spi_dma_rxISR1()>:
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    6e80:	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    6e82:	ldr	r3, [pc, #280]	; (6f9c <_spi_dma_rxISR1()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    6e84:	ldr	r2, [pc, #280]	; (6fa0 <_spi_dma_rxISR1()+0x120>)
    6e86:	ldr	r0, [r3, #48]	; 0x30
    6e88:	ldr	r4, [r3, #44]	; 0x2c
    6e8a:	ldrb	r1, [r0, #4]
    6e8c:	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    6e8e:	ldr	r1, [pc, #276]	; (6fa4 <_spi_dma_rxISR1()+0x124>)
    6e90:	ldrb	r2, [r4, #4]
    6e92:	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    6e94:	ldr	r2, [r3, #40]	; 0x28
    6e96:	ldrb	r0, [r0, #4]
    6e98:	strb	r0, [r1, #0]
    6e9a:	cmp	r2, #0
    6e9c:	beq.n	6f2c <_spi_dma_rxISR1()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    6e9e:	ldr	r1, [r3, #4]
    6ea0:	ldr	r1, [r1, #12]
    6ea2:	cmp	r2, r1
    6ea4:	bhi.n	6f24 <_spi_dma_rxISR1()+0xa4>
    6ea6:	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6ea8:	ldrh	r4, [r1, #30]
    6eaa:	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    6eac:	add.w	r0, r2, #4294967295

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6eb0:	bmi.n	6f7e <_spi_dma_rxISR1()+0xfe>
		tcd->BITER = len & 0x7fff;
    6eb2:	ubfx	r0, r0, #0, #15
    6eb6:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6eb8:	ldrh	r0, [r1, #30]
    6eba:	uxth	r0, r0
    6ebc:	strh	r0, [r1, #22]
    6ebe:	ldr	r1, [r3, #48]	; 0x30
    6ec0:	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6ec2:	ldrh	r0, [r1, #30]
    6ec4:	lsls	r0, r0, #16
    6ec6:	bmi.n	6f6e <_spi_dma_rxISR1()+0xee>
		tcd->BITER = len & 0x7fff;
    6ec8:	ubfx	r0, r2, #0, #15
    6ecc:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6ece:	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    6ed0:	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6ed2:	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6ed4:	adds.w	r2, r2, #4294967295
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6ed8:	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6eda:	it	ne
    6edc:	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    6ede:	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    6ee0:	ldr	r1, [r3, #44]	; 0x2c
    6ee2:	ldr	r0, [pc, #184]	; (6f9c <_spi_dma_rxISR1()+0x11c>)
    6ee4:	ldr	r1, [r1, #0]
    6ee6:	ldr	r5, [r1, #0]
    6ee8:	add.w	r4, r0, #36	; 0x24
    6eec:	cmp	r5, r4
    6eee:	beq.n	6f5e <_spi_dma_rxISR1()+0xde>
    6ef0:	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    6ef2:	ldr	r4, [r0, #12]
    6ef4:	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    6ef8:	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    6efa:	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    6efc:	itete	ne
    6efe:	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    6f00:	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    6f02:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    6f04:	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6f06:	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    6f0a:	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6f0c:	str	r4, [r0, #52]	; 0x34
    6f0e:	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    6f10:	ldr	r3, [pc, #148]	; (6fa8 <_spi_dma_rxISR1()+0x128>)
    6f12:	ldrb	r1, [r1, #4]
    6f14:	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    6f16:	ldr	r1, [pc, #132]	; (6f9c <_spi_dma_rxISR1()+0x11c>)
		if (should_reenable_tx)
    6f18:	cbz	r2, 6f20 <_spi_dma_rxISR1()+0xa0>
    6f1a:	ldr	r2, [r1, #44]	; 0x2c
    6f1c:	ldrb	r2, [r2, #4]
    6f1e:	strb	r2, [r3, #0]
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    6f20:	pop	{r4, r5, r6, r7}
    6f22:	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    6f24:	subs	r2, r2, r1
    6f26:	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6f28:	movs	r2, #1
    6f2a:	b.n	6ee0 <_spi_dma_rxISR1()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6f2c:	ldr	r0, [r3, #52]	; 0x34
    6f2e:	ldr	r1, [r3, #0]
    6f30:	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    6f32:	ldr	r4, [pc, #120]	; (6fac <_spi_dma_rxISR1()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    6f34:	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    6f36:	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6f38:	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6f3a:	ldr	r5, [r5, #0]
    6f3c:	ldr	r6, [pc, #112]	; (6fb0 <_spi_dma_rxISR1()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6f3e:	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    6f42:	movs	r7, #3
    6f44:	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6f46:	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    6f48:	strb.w	r7, [r3, #37]	; 0x25
    6f4c:	bne.n	6f8e <_spi_dma_rxISR1()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    6f4e:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    6f50:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    6f52:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    6f54:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    6f56:	beq.n	6f96 <_spi_dma_rxISR1()+0x116>
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    6f58:	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    6f5a:	b.w	e834 <EventResponder::triggerEventNotImmediate()>
    6f5e:	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6f60:	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    6f64:	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6f66:	orr.w	r0, r0, #2147483648	; 0x80000000
    6f6a:	str	r0, [r1, #52]	; 0x34
    6f6c:	b.n	6f0e <_spi_dma_rxISR1()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    6f6e:	ldrh	r4, [r1, #30]
    6f70:	ubfx	r0, r2, #0, #9
    6f74:	and.w	r4, r4, #65024	; 0xfe00
    6f78:	orrs	r0, r4
    6f7a:	strh	r0, [r1, #30]
    6f7c:	b.n	6ece <_spi_dma_rxISR1()+0x4e>
    6f7e:	ldrh	r4, [r1, #30]
    6f80:	ubfx	r0, r0, #0, #9
    6f84:	and.w	r4, r4, #65024	; 0xfe00
    6f88:	orrs	r0, r4
    6f8a:	strh	r0, [r1, #30]
    6f8c:	b.n	6eb8 <_spi_dma_rxISR1()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6f8e:	mov	r3, r5
    6f90:	mov	r1, r2
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    6f92:	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6f94:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6f96:	ldr	r3, [r0, #8]
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    6f98:	pop	{r4, r5, r6, r7}
    6f9a:	bx	r3
    6f9c:	.word	0x20000ba4
    6fa0:	.word	0x4000801f
    6fa4:	.word	0x4000801c
    6fa8:	.word	0x4000801b
    6fac:	.word	0xff0f0000
    6fb0:	.word	0x00006c6d

00006fb4 <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6fb4:	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    6fb6:	ldr	r3, [pc, #280]	; (70d0 <_spi_dma_rxISR0()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    6fb8:	ldr	r2, [pc, #280]	; (70d4 <_spi_dma_rxISR0()+0x120>)
    6fba:	ldr	r0, [r3, #48]	; 0x30
    6fbc:	ldr	r4, [r3, #44]	; 0x2c
    6fbe:	ldrb	r1, [r0, #4]
    6fc0:	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    6fc2:	ldr	r1, [pc, #276]	; (70d8 <_spi_dma_rxISR0()+0x124>)
    6fc4:	ldrb	r2, [r4, #4]
    6fc6:	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    6fc8:	ldr	r2, [r3, #40]	; 0x28
    6fca:	ldrb	r0, [r0, #4]
    6fcc:	strb	r0, [r1, #0]
    6fce:	cmp	r2, #0
    6fd0:	beq.n	7060 <_spi_dma_rxISR0()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    6fd2:	ldr	r1, [r3, #4]
    6fd4:	ldr	r1, [r1, #12]
    6fd6:	cmp	r2, r1
    6fd8:	bhi.n	7058 <_spi_dma_rxISR0()+0xa4>
    6fda:	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6fdc:	ldrh	r4, [r1, #30]
    6fde:	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    6fe0:	add.w	r0, r2, #4294967295

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6fe4:	bmi.n	70b2 <_spi_dma_rxISR0()+0xfe>
		tcd->BITER = len & 0x7fff;
    6fe6:	ubfx	r0, r0, #0, #15
    6fea:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6fec:	ldrh	r0, [r1, #30]
    6fee:	uxth	r0, r0
    6ff0:	strh	r0, [r1, #22]
    6ff2:	ldr	r1, [r3, #48]	; 0x30
    6ff4:	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6ff6:	ldrh	r0, [r1, #30]
    6ff8:	lsls	r0, r0, #16
    6ffa:	bmi.n	70a2 <_spi_dma_rxISR0()+0xee>
		tcd->BITER = len & 0x7fff;
    6ffc:	ubfx	r0, r2, #0, #15
    7000:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7002:	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    7004:	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7006:	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    7008:	adds.w	r2, r2, #4294967295
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    700c:	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    700e:	it	ne
    7010:	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    7012:	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    7014:	ldr	r1, [r3, #44]	; 0x2c
    7016:	ldr	r0, [pc, #184]	; (70d0 <_spi_dma_rxISR0()+0x11c>)
    7018:	ldr	r1, [r1, #0]
    701a:	ldr	r5, [r1, #0]
    701c:	add.w	r4, r0, #36	; 0x24
    7020:	cmp	r5, r4
    7022:	beq.n	7092 <_spi_dma_rxISR0()+0xde>
    7024:	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7026:	ldr	r4, [r0, #12]
    7028:	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    702c:	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    702e:	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    7030:	itete	ne
    7032:	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    7034:	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    7036:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    7038:	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    703a:	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    703e:	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7040:	str	r4, [r0, #52]	; 0x34
    7042:	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    7044:	ldr	r3, [pc, #148]	; (70dc <_spi_dma_rxISR0()+0x128>)
    7046:	ldrb	r1, [r1, #4]
    7048:	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    704a:	ldr	r1, [pc, #132]	; (70d0 <_spi_dma_rxISR0()+0x11c>)
		if (should_reenable_tx)
    704c:	cbz	r2, 7054 <_spi_dma_rxISR0()+0xa0>
    704e:	ldr	r2, [r1, #44]	; 0x2c
    7050:	ldrb	r2, [r2, #4]
    7052:	strb	r2, [r3, #0]
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7054:	pop	{r4, r5, r6, r7}
    7056:	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    7058:	subs	r2, r2, r1
    705a:	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    705c:	movs	r2, #1
    705e:	b.n	7014 <_spi_dma_rxISR0()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7060:	ldr	r0, [r3, #52]	; 0x34
    7062:	ldr	r1, [r3, #0]
    7064:	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    7066:	ldr	r4, [pc, #120]	; (70e0 <_spi_dma_rxISR0()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    7068:	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    706a:	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    706c:	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    706e:	ldr	r5, [r5, #0]
    7070:	ldr	r6, [pc, #112]	; (70e4 <_spi_dma_rxISR0()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7072:	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7076:	movs	r7, #3
    7078:	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    707a:	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    707c:	strb.w	r7, [r3, #37]	; 0x25
    7080:	bne.n	70c2 <_spi_dma_rxISR0()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    7082:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    7084:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    7086:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    7088:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    708a:	beq.n	70ca <_spi_dma_rxISR0()+0x116>
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    708c:	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    708e:	b.w	e834 <EventResponder::triggerEventNotImmediate()>
    7092:	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7094:	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7098:	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    709a:	orr.w	r0, r0, #2147483648	; 0x80000000
    709e:	str	r0, [r1, #52]	; 0x34
    70a0:	b.n	7042 <_spi_dma_rxISR0()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    70a2:	ldrh	r4, [r1, #30]
    70a4:	ubfx	r0, r2, #0, #9
    70a8:	and.w	r4, r4, #65024	; 0xfe00
    70ac:	orrs	r0, r4
    70ae:	strh	r0, [r1, #30]
    70b0:	b.n	7002 <_spi_dma_rxISR0()+0x4e>
    70b2:	ldrh	r4, [r1, #30]
    70b4:	ubfx	r0, r0, #0, #9
    70b8:	and.w	r4, r4, #65024	; 0xfe00
    70bc:	orrs	r0, r4
    70be:	strh	r0, [r1, #30]
    70c0:	b.n	6fec <_spi_dma_rxISR0()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    70c2:	mov	r3, r5
    70c4:	mov	r1, r2
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    70c6:	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    70c8:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    70ca:	ldr	r3, [r0, #8]
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    70cc:	pop	{r4, r5, r6, r7}
    70ce:	bx	r3
    70d0:	.word	0x20000b6c
    70d4:	.word	0x4000801f
    70d8:	.word	0x4000801c
    70dc:	.word	0x4000801b
    70e0:	.word	0xff0f0000
    70e4:	.word	0x00006c6d

000070e8 <SPIClass::begin()>:
    70e8:	ldmia.w	r0, {r2, r3}
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    70ec:	push	{r4, r5, r6, r7}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    70ee:	ldr	r4, [r3, #0]
    70f0:	ldr	r1, [r3, #4]
    70f2:	ldr	r5, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    70f4:	ldr	r7, [pc, #88]	; (7150 <SPIClass::begin()+0x68>)
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    70f6:	ldr	r6, [pc, #92]	; (7154 <SPIClass::begin()+0x6c>)

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    70f8:	orrs	r1, r5
    70fa:	str	r1, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    70fc:	ldr	r5, [pc, #88]	; (7158 <SPIClass::begin()+0x70>)
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    70fe:	ldr	r1, [pc, #92]	; (715c <SPIClass::begin()+0x74>)
void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    7100:	str	r7, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7102:	str	r6, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7104:	str	r5, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    7106:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7108:	ldrb	r1, [r0, #9]
    710a:	ldr	r2, [pc, #84]	; (7160 <SPIClass::begin()+0x78>)
    710c:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    710e:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7110:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    7114:	ldr.w	r5, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7118:	add.w	r1, r2, r4, lsl #3
    711c:	ldr	r1, [r1, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    711e:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7120:	ldrb	r1, [r0, #8]
    7122:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    7124:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7128:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    712a:	ldr	r5, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    712c:	add.w	r1, r2, r4, lsl #3
    7130:	ldr	r1, [r1, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    7132:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7134:	ldrb	r1, [r0, #10]
    7136:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    7138:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    713c:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    7140:	ldr	r1, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7142:	add.w	r2, r2, r0, lsl #3
	*reg = hardware().sck_mux[sck_pin_index];
}
    7146:	pop	{r4, r5, r6, r7}
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7148:	ldr	r3, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    714a:	str	r1, [r3, #0]
}
    714c:	bx	lr
    714e:	nop
    7150:	.word	0x001f4001
    7154:	.word	0x38001001
    7158:	.word	0x78001001
    715c:	.word	0x801f0000
    7160:	.word	0x200006ac

00007164 <SPIClass::setMOSI(unsigned char)>:
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    7164:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7166:	ldr	r3, [pc, #148]	; (71fc <SPIClass::setMOSI(unsigned char)+0x98>)
    7168:	ldr	r5, [r0, #4]
    716a:	cmp	r3, r5
    716c:	beq.n	7192 <SPIClass::setMOSI(unsigned char)+0x2e>
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    716e:	ldrb	r3, [r0, #9]
    7170:	add	r3, r5
    7172:	ldrb.w	r6, [r3, #44]	; 0x2c
    7176:	cmp	r1, r6
    7178:	beq.n	718e <SPIClass::setMOSI(unsigned char)+0x2a>
    717a:	add.w	r2, r5, #43	; 0x2b
    717e:	movs	r3, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    7180:	ldrb.w	r4, [r2, #1]!
    7184:	cmp	r4, r1
    7186:	beq.n	71be <SPIClass::setMOSI(unsigned char)+0x5a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    7188:	adds	r3, #1
    718a:	cmp	r3, #4
    718c:	bne.n	7180 <SPIClass::setMOSI(unsigned char)+0x1c>
				mosi_pin_index = i;
				return;
			}
		}
	}
}
    718e:	pop	{r4, r5, r6, r7}
    7190:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    7192:	cmp	r1, #11
    7194:	beq.n	71f0 <SPIClass::setMOSI(unsigned char)+0x8c>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    7196:	cmp	r1, #7
    7198:	beq.n	71ae <SPIClass::setMOSI(unsigned char)+0x4a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    719a:	cmp	r1, #28
    719c:	bne.n	716e <SPIClass::setMOSI(unsigned char)+0xa>
    719e:	ldr	r2, [pc, #96]	; (7200 <SPIClass::setMOSI(unsigned char)+0x9c>)
    71a0:	ldrb	r3, [r2, #0]
    71a2:	bic.w	r3, r3, #3
    71a6:	orr.w	r3, r3, #2
    71aa:	strb	r3, [r2, #0]
    71ac:	b.n	716e <SPIClass::setMOSI(unsigned char)+0xa>
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    71ae:	ldr	r2, [pc, #80]	; (7200 <SPIClass::setMOSI(unsigned char)+0x9c>)
    71b0:	ldrb	r3, [r2, #0]
    71b2:	bic.w	r3, r3, #3
    71b6:	orr.w	r3, r3, #1
    71ba:	strb	r3, [r2, #0]
    71bc:	b.n	716e <SPIClass::setMOSI(unsigned char)+0xa>
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    71be:	ldmia.w	r5, {r1, r2}
    71c2:	ldr	r1, [r1, #0]
    71c4:	tst	r1, r2
    71c6:	beq.n	71ea <SPIClass::setMOSI(unsigned char)+0x86>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    71c8:	ldr	r2, [pc, #56]	; (7204 <SPIClass::setMOSI(unsigned char)+0xa0>)
    71ca:	add.w	r6, r2, r6, lsl #3
					*reg = 0;
    71ce:	movs	r7, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    71d0:	ldr	r4, [r6, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    71d2:	adds	r1, r5, r3
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
    71d4:	str	r7, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    71d6:	ldrb.w	r1, [r1, #44]	; 0x2c
    71da:	add.w	r2, r2, r1, lsl #3
					*reg = hardware().mosi_mux[i];
    71de:	add.w	r1, r3, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    71e2:	ldr	r4, [r2, #4]
					*reg = hardware().mosi_mux[i];
    71e4:	ldr.w	r2, [r5, r1, lsl #2]
    71e8:	str	r2, [r4, #0]
				}	
				mosi_pin_index = i;
    71ea:	strb	r3, [r0, #9]
				return;
			}
		}
	}
}
    71ec:	pop	{r4, r5, r6, r7}
    71ee:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    71f0:	ldr	r2, [pc, #12]	; (7200 <SPIClass::setMOSI(unsigned char)+0x9c>)
    71f2:	ldrb	r3, [r2, #0]
    71f4:	bic.w	r3, r3, #3
    71f8:	strb	r3, [r2, #0]
    71fa:	b.n	716e <SPIClass::setMOSI(unsigned char)+0xa>
    71fc:	.word	0x20000488
    7200:	.word	0x20005271
    7204:	.word	0x200006ac

00007208 <SPIClass::setMISO(unsigned char)>:

void SPIClass::setMISO(uint8_t pin)
{
    7208:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    720a:	ldr	r3, [pc, #144]	; (729c <SPIClass::setMISO(unsigned char)+0x94>)
    720c:	ldr	r5, [r0, #4]
    720e:	cmp	r3, r5
    7210:	beq.n	7234 <SPIClass::setMISO(unsigned char)+0x2c>
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    7212:	ldrb	r3, [r0, #8]
    7214:	add	r3, r5
    7216:	ldrb	r6, [r3, #24]
    7218:	cmp	r1, r6
    721a:	beq.n	7230 <SPIClass::setMISO(unsigned char)+0x28>
    721c:	add.w	r2, r5, #23
    7220:	movs	r3, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    7222:	ldrb.w	r4, [r2, #1]!
    7226:	cmp	r4, r1
    7228:	beq.n	7260 <SPIClass::setMISO(unsigned char)+0x58>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    722a:	adds	r3, #1
    722c:	cmp	r3, #4
    722e:	bne.n	7222 <SPIClass::setMISO(unsigned char)+0x1a>
				miso_pin_index = i;
				return;
			}
		}
	}
}
    7230:	pop	{r4, r5, r6, r7}
    7232:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    7234:	cmp	r1, #12
    7236:	beq.n	728e <SPIClass::setMISO(unsigned char)+0x86>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    7238:	cmp	r1, #8
    723a:	beq.n	7250 <SPIClass::setMISO(unsigned char)+0x48>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    723c:	cmp	r1, #39	; 0x27
    723e:	bne.n	7212 <SPIClass::setMISO(unsigned char)+0xa>
    7240:	ldr	r2, [pc, #92]	; (72a0 <SPIClass::setMISO(unsigned char)+0x98>)
    7242:	ldrb	r3, [r2, #0]
    7244:	bic.w	r3, r3, #12
    7248:	orr.w	r3, r3, #8
    724c:	strb	r3, [r2, #0]
    724e:	b.n	7212 <SPIClass::setMISO(unsigned char)+0xa>
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    7250:	ldr	r2, [pc, #76]	; (72a0 <SPIClass::setMISO(unsigned char)+0x98>)
    7252:	ldrb	r3, [r2, #0]
    7254:	bic.w	r3, r3, #12
    7258:	orr.w	r3, r3, #4
    725c:	strb	r3, [r2, #0]
    725e:	b.n	7212 <SPIClass::setMISO(unsigned char)+0xa>
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7260:	ldmia.w	r5, {r1, r2}
    7264:	ldr	r1, [r1, #0]
    7266:	tst	r1, r2
    7268:	beq.n	7288 <SPIClass::setMISO(unsigned char)+0x80>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    726a:	ldr	r2, [pc, #56]	; (72a4 <SPIClass::setMISO(unsigned char)+0x9c>)
    726c:	add.w	r6, r2, r6, lsl #3
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7270:	adds	r1, r5, r3
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7272:	ldr	r4, [r6, #4]
					*reg = 0;
    7274:	movs	r7, #0
    7276:	str	r7, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    7278:	ldrb	r1, [r1, #24]
    727a:	add.w	r2, r2, r1, lsl #3
					*reg = hardware().miso_mux[i];
    727e:	add.w	r5, r5, r3, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7282:	ldr	r2, [r2, #4]
					*reg = hardware().miso_mux[i];
    7284:	ldr	r1, [r5, #28]
    7286:	str	r1, [r2, #0]
				}	
				miso_pin_index = i;
    7288:	strb	r3, [r0, #8]
				return;
			}
		}
	}
}
    728a:	pop	{r4, r5, r6, r7}
    728c:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    728e:	ldr	r2, [pc, #16]	; (72a0 <SPIClass::setMISO(unsigned char)+0x98>)
    7290:	ldrb	r3, [r2, #0]
    7292:	bic.w	r3, r3, #12
    7296:	strb	r3, [r2, #0]
    7298:	b.n	7212 <SPIClass::setMISO(unsigned char)+0xa>
    729a:	nop
    729c:	.word	0x20000488
    72a0:	.word	0x20005271
    72a4:	.word	0x200006ac

000072a8 <SPIClass::setSCK(unsigned char)>:

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    72a8:	ldr	r2, [pc, #160]	; (734c <SPIClass::setSCK(unsigned char)+0xa4>)
    72aa:	ldr	r3, [r0, #4]
    72ac:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    72ae:	push	{r4, r5, r6}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    72b0:	beq.n	72de <SPIClass::setSCK(unsigned char)+0x36>
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    72b2:	ldrb	r2, [r0, #10]
    72b4:	add	r2, r3
    72b6:	ldrb.w	r2, [r2, #64]	; 0x40
    72ba:	cmp	r1, r2
    72bc:	beq.n	72da <SPIClass::setSCK(unsigned char)+0x32>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    72be:	ldrb.w	r4, [r3, #64]	; 0x40
    72c2:	cmp	r4, r1
    72c4:	beq.n	7346 <SPIClass::setSCK(unsigned char)+0x9e>
    72c6:	ldrb.w	r4, [r3, #65]	; 0x41
    72ca:	cmp	r4, r1
    72cc:	beq.n	730a <SPIClass::setSCK(unsigned char)+0x62>
    72ce:	ldrb.w	r4, [r3, #66]	; 0x42
    72d2:	cmp	r4, r1
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    72d4:	it	eq
    72d6:	moveq	r1, #2
			if  (pin == hardware().sck_pin[i]) {
    72d8:	beq.n	730c <SPIClass::setSCK(unsigned char)+0x64>
				sck_pin_index = i;
				return;
			}
		}
	}
}
    72da:	pop	{r4, r5, r6}
    72dc:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    72de:	cmp	r1, #13
    72e0:	beq.n	733a <SPIClass::setSCK(unsigned char)+0x92>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    72e2:	cmp	r1, #14
    72e4:	beq.n	72fa <SPIClass::setSCK(unsigned char)+0x52>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    72e6:	cmp	r1, #27
    72e8:	bne.n	72b2 <SPIClass::setSCK(unsigned char)+0xa>
    72ea:	ldr	r4, [pc, #100]	; (7350 <SPIClass::setSCK(unsigned char)+0xa8>)
    72ec:	ldrb	r2, [r4, #0]
    72ee:	bic.w	r2, r2, #48	; 0x30
    72f2:	orr.w	r2, r2, #32
    72f6:	strb	r2, [r4, #0]
    72f8:	b.n	72b2 <SPIClass::setSCK(unsigned char)+0xa>
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    72fa:	ldr	r4, [pc, #84]	; (7350 <SPIClass::setSCK(unsigned char)+0xa8>)
    72fc:	ldrb	r2, [r4, #0]
    72fe:	bic.w	r2, r2, #48	; 0x30
    7302:	orr.w	r2, r2, #16
    7306:	strb	r2, [r4, #0]
    7308:	b.n	72b2 <SPIClass::setSCK(unsigned char)+0xa>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    730a:	movs	r1, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    730c:	ldr	r5, [r3, #0]
    730e:	ldr	r4, [r3, #4]
    7310:	ldr	r5, [r5, #0]
    7312:	tst	r5, r4
    7314:	beq.n	7336 <SPIClass::setSCK(unsigned char)+0x8e>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7316:	ldr	r4, [pc, #60]	; (7354 <SPIClass::setSCK(unsigned char)+0xac>)
    7318:	add.w	r2, r4, r2, lsl #3
					*reg = 0;
    731c:	movs	r6, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    731e:	ldr	r5, [r2, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7320:	adds	r2, r3, r1
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
    7322:	str	r6, [r5, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    7324:	ldrb.w	r2, [r2, #64]	; 0x40
    7328:	add.w	r4, r4, r2, lsl #3
					*reg = hardware().sck_mux[i];
    732c:	add.w	r3, r3, r1, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7330:	ldr	r2, [r4, #4]
					*reg = hardware().sck_mux[i];
    7332:	ldr	r3, [r3, #68]	; 0x44
    7334:	str	r3, [r2, #0]
				}	
				sck_pin_index = i;
    7336:	strb	r1, [r0, #10]
				return;
    7338:	b.n	72da <SPIClass::setSCK(unsigned char)+0x32>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    733a:	ldr	r4, [pc, #20]	; (7350 <SPIClass::setSCK(unsigned char)+0xa8>)
    733c:	ldrb	r2, [r4, #0]
    733e:	bic.w	r2, r2, #48	; 0x30
    7342:	strb	r2, [r4, #0]
    7344:	b.n	72b2 <SPIClass::setSCK(unsigned char)+0xa>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7346:	movs	r1, #0
    7348:	b.n	730c <SPIClass::setSCK(unsigned char)+0x64>
    734a:	nop
    734c:	.word	0x20000488
    7350:	.word	0x20005271
    7354:	.word	0x200006ac

00007358 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    7358:	cbz	r3, 735e <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    735a:	b.w	6c88 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    735e:	bx	lr

00007360 <breakTime(long, tmElements_t&)>:
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7360:	ldr	r2, [pc, #400]	; (74f4 <breakTime(long, tmElements_t&)+0x194>)
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7362:	ldr	r3, [pc, #404]	; (74f8 <breakTime(long, tmElements_t&)+0x198>)
// leap year calculator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    7364:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7368:	ldr	r6, [pc, #400]	; (74fc <breakTime(long, tmElements_t&)+0x19c>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    736a:	ldr.w	sl, [pc, #416]	; 750c <breakTime(long, tmElements_t&)+0x1ac>
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    736e:	ldr	r4, [pc, #400]	; (7500 <breakTime(long, tmElements_t&)+0x1a0>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7370:	ldr.w	r9, [pc, #400]	; 7504 <breakTime(long, tmElements_t&)+0x1a4>
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7374:	umull	r5, r2, r2, r0
    7378:	mov.w	ip, r2, lsr #16
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    737c:	add.w	r7, ip, #4
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7380:	umull	r2, r5, r3, r0
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7384:	umull	r6, r2, r6, r0
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7388:	umull	sl, fp, r7, sl
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    738c:	lsrs	r5, r5, #5
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    738e:	lsrs	r2, r2, #11
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7390:	umull	r6, r3, r3, r5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7394:	umull	r6, r4, r4, r2
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7398:	rsb	r6, fp, r7
    739c:	add.w	r6, fp, r6, lsr #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    73a0:	lsrs	r3, r3, #5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    73a2:	lsrs	r6, r6, #2
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    73a4:	lsrs	r4, r4, #4
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    73a6:	rsb	r6, r6, r6, lsl #3
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    73aa:	rsb	r3, r3, r3, lsl #4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    73ae:	add.w	r4, r4, r4, lsl #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    73b2:	sub.w	r3, r5, r3, lsl #2
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    73b6:	subs	r6, r7, r6
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    73b8:	rsb	r5, r5, r5, lsl #4
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    73bc:	sub.w	r2, r2, r4, lsl #3
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    73c0:	sub.w	r0, r0, r5, lsl #2
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    73c4:	adds	r6, #1
    73c6:	movs	r4, #0
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    73c8:	strb	r2, [r1, #2]
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    73ca:	strb	r0, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    73cc:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    73ce:	strb	r6, [r1, #3]
  
  year = 0;  
  days = 0;
    73d0:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    73d2:	movw	fp, #365	; 0x16d
    73d6:	mov.w	r8, #100	; 0x64
    73da:	mov.w	sl, #400	; 0x190
    73de:	b.n	73fe <breakTime(long, tmElements_t&)+0x9e>
    73e0:	rsb	r5, r6, r5, asr #7
    73e4:	mls	r5, sl, r5, r3
    73e8:	cbnz	r0, 7448 <breakTime(long, tmElements_t&)+0xe8>
    73ea:	cmp	r5, #0
    73ec:	ite	ne
    73ee:	movne	r0, fp
    73f0:	moveq.w	r0, #366	; 0x16e
    73f4:	add	r2, r0
    73f6:	cmp	ip, r2
    73f8:	add.w	r4, r4, #1
    73fc:	bcc.n	7426 <breakTime(long, tmElements_t&)+0xc6>
    73fe:	uxtb	r7, r4
    7400:	addw	r3, r7, #1970	; 0x7b2
    7404:	smull	r0, r5, r9, r3
    7408:	asrs	r6, r3, #31
    740a:	rsb	r0, r6, r5, asr #5
    740e:	ands.w	lr, r3, #3
    7412:	mls	r0, r8, r0, r3
    7416:	beq.n	73e0 <breakTime(long, tmElements_t&)+0x80>
    7418:	movw	r0, #365	; 0x16d
    741c:	add	r2, r0
    741e:	cmp	ip, r2
    7420:	add.w	r4, r4, #1
    7424:	bcs.n	73fe <breakTime(long, tmElements_t&)+0x9e>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    7426:	strb	r7, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7428:	cmp.w	lr, #0
    742c:	bne.n	744e <breakTime(long, tmElements_t&)+0xee>
    742e:	ldr	r0, [pc, #212]	; (7504 <breakTime(long, tmElements_t&)+0x1a4>)
    7430:	asrs	r6, r3, #31
    7432:	smull	r4, r0, r0, r3
    7436:	rsb	r4, r6, r0, asr #5
    743a:	movs	r5, #100	; 0x64
    743c:	mls	r4, r5, r4, r3
    7440:	cbz	r4, 74b2 <breakTime(long, tmElements_t&)+0x152>
    7442:	mov.w	r4, #366	; 0x16e
    7446:	b.n	7454 <breakTime(long, tmElements_t&)+0xf4>
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7448:	mov.w	r0, #366	; 0x16e
    744c:	b.n	73f4 <breakTime(long, tmElements_t&)+0x94>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    744e:	movw	r4, #365	; 0x16d
    7452:	asrs	r6, r3, #31
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7454:	ldr	r0, [pc, #172]	; (7504 <breakTime(long, tmElements_t&)+0x1a4>)
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    7456:	ldr	r5, [pc, #176]	; (7508 <breakTime(long, tmElements_t&)+0x1a8>)
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7458:	smull	r7, r0, r0, r3
    745c:	rsb	r8, r6, r0, asr #5
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7460:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7462:	rsb	r6, r6, r0, asr #7
    7466:	movs	r4, #100	; 0x64
    7468:	mov.w	r0, #400	; 0x190
    746c:	mls	r6, r0, r6, r3
    7470:	mls	r8, r4, r8, r3
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7474:	rsb	r2, r2, ip
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7478:	movs	r0, #1
    747a:	movs	r3, #0
    747c:	b.n	7484 <breakTime(long, tmElements_t&)+0x124>
    747e:	adds	r0, #1
    7480:	uxtb	r0, r0
    7482:	adds	r3, #1
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    7484:	cmp	r3, #1
    7486:	uxtb	r7, r3
    7488:	beq.n	74cc <breakTime(long, tmElements_t&)+0x16c>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    748a:	ldrb	r4, [r3, r5]
    748c:	cmp	r4, r2
    748e:	bhi.n	74a4 <breakTime(long, tmElements_t&)+0x144>
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7490:	cmp	r0, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    7492:	sub.w	r2, r2, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7496:	bne.n	747e <breakTime(long, tmElements_t&)+0x11e>
    7498:	movs	r7, #13
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    749a:	adds	r2, #1
    749c:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    749e:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    74a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    74a4:	adds	r7, #1
    74a6:	uxtb	r7, r7
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    74a8:	adds	r2, #1
    74aa:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    74ac:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    74ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    74b2:	mov.w	r4, #400	; 0x190
    74b6:	rsb	r0, r6, r0, asr #7
    74ba:	mls	r0, r4, r0, r3
    74be:	cmp	r0, #0
    74c0:	movw	r4, #365	; 0x16d
    74c4:	it	eq
    74c6:	moveq.w	r4, #366	; 0x16e
    74ca:	b.n	7454 <breakTime(long, tmElements_t&)+0xf4>
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    74cc:	cmp.w	lr, #0
    74d0:	bne.n	74e8 <breakTime(long, tmElements_t&)+0x188>
    74d2:	cmp.w	r8, #0
    74d6:	bne.n	74f0 <breakTime(long, tmElements_t&)+0x190>
    74d8:	cmp	r6, #0
    74da:	ite	ne
    74dc:	movne	r4, #28
    74de:	moveq	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    74e0:	cmp	r2, r4
    74e2:	bcc.n	74ec <breakTime(long, tmElements_t&)+0x18c>
      time -= monthLength;
    74e4:	subs	r2, r2, r4
    74e6:	b.n	747e <breakTime(long, tmElements_t&)+0x11e>
    74e8:	movs	r4, #28
    74ea:	b.n	74e0 <breakTime(long, tmElements_t&)+0x180>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    74ec:	movs	r7, #2
    74ee:	b.n	749a <breakTime(long, tmElements_t&)+0x13a>
    74f0:	movs	r4, #29
    74f2:	b.n	74e0 <breakTime(long, tmElements_t&)+0x180>
    74f4:	.word	0xc22e4507
    74f8:	.word	0x88888889
    74fc:	.word	0x91a2b3c5
    7500:	.word	0xaaaaaaab
    7504:	.word	0x51eb851f
    7508:	.word	0x20000578
    750c:	.word	0x24924925

00007510 <refreshCache(long) [clone .part.0]>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    7510:	push	{r4, lr}
  if (t != cacheTime) {
    breakTime(t, tm); 
    7512:	ldr	r1, [pc, #12]	; (7520 <refreshCache(long) [clone .part.0]+0x10>)

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    7514:	mov	r4, r0
  if (t != cacheTime) {
    breakTime(t, tm); 
    7516:	bl	7360 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    751a:	ldr	r3, [pc, #8]	; (7524 <refreshCache(long) [clone .part.0]+0x14>)
    751c:	str	r4, [r3, #0]
    751e:	pop	{r4, pc}
    7520:	.word	0x20004c0c
    7524:	.word	0x20004c08

00007528 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    7528:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    752a:	ldr	r4, [pc, #128]	; (75ac <now()+0x84>)
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    752c:	ldr	r6, [pc, #128]	; (75b0 <now()+0x88>)
    752e:	ldr	r3, [r4, #0]
    7530:	ldr	r2, [r6, #0]
    7532:	ldr	r5, [pc, #128]	; (75b4 <now()+0x8c>)
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    7534:	sub	sp, #12
    7536:	ldr	r0, [r5, #0]
    7538:	str	r3, [sp, #0]
	return ret;
    753a:	ldr	r3, [sp, #0]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    753c:	subs	r3, r3, r2
    753e:	cmp.w	r3, #1000	; 0x3e8
    7542:	bcc.n	7564 <now()+0x3c>
    7544:	adds	r0, #1
    7546:	b.n	754a <now()+0x22>
    7548:	mov	r0, r1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    754a:	ldr	r3, [r4, #0]
    754c:	str	r3, [sp, #0]
	return ret;
    754e:	ldr	r3, [sp, #0]
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    7550:	add.w	r2, r2, #1000	; 0x3e8
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    7554:	subs	r3, r3, r2
    7556:	cmp.w	r3, #1000	; 0x3e8
    755a:	add.w	r1, r0, #1
    755e:	bcs.n	7548 <now()+0x20>
    7560:	str	r0, [r5, #0]
    7562:	str	r2, [r6, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    7564:	ldr	r7, [pc, #80]	; (75b8 <now()+0x90>)
    7566:	ldr	r3, [r7, #0]
    7568:	cmp	r0, r3
    756a:	bcc.n	758c <now()+0x64>
    if (getTimePtr != 0) {
    756c:	ldr	r3, [pc, #76]	; (75bc <now()+0x94>)
    756e:	ldr	r3, [r3, #0]
    7570:	cbz	r3, 758c <now()+0x64>
      time_t t = getTimePtr();
    7572:	blx	r3
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    7574:	ldr	r3, [pc, #72]	; (75c0 <now()+0x98>)
#endif
  }
  if (nextSyncTime <= sysTime) {
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
    7576:	cbnz	r0, 7590 <now()+0x68>
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7578:	ldr	r1, [pc, #72]	; (75c4 <now()+0x9c>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    757a:	ldr	r2, [r3, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    757c:	ldrb	r3, [r1, #0]
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    757e:	ldr	r0, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7580:	adds	r3, #0
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7582:	add	r2, r0
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    7584:	it	ne
    7586:	movne	r3, #1
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    7588:	str	r2, [r7, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    758a:	strb	r3, [r1, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    758c:	add	sp, #12
    758e:	pop	{r4, r5, r6, r7, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7590:	ldr	r2, [r4, #0]
    7592:	str	r2, [sp, #4]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    7594:	ldr	r3, [r3, #0]
  Status = timeSet;
    7596:	ldr	r2, [pc, #44]	; (75c4 <now()+0x9c>)
	return ret;
    7598:	ldr	r4, [sp, #4]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    759a:	str	r0, [r5, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    759c:	add	r3, r0
  Status = timeSet;
    759e:	movs	r1, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    75a0:	str	r4, [r6, #0]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    75a2:	str	r3, [r7, #0]
  Status = timeSet;
    75a4:	strb	r1, [r2, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
      }
    }
  }  
  return (time_t)sysTime;
}
    75a6:	add	sp, #12
    75a8:	pop	{r4, r5, r6, r7, pc}
    75aa:	nop
    75ac:	.word	0x20005150
    75b0:	.word	0x20004c20
    75b4:	.word	0x20004c14
    75b8:	.word	0x20004c24
    75bc:	.word	0x20004c1c
    75c0:	.word	0x20000bdc
    75c4:	.word	0x20004c18

000075c8 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    75c8:	push	{r3, lr}
  return hour(now()); 
    75ca:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    75ce:	ldr	r3, [pc, #16]	; (75e0 <hour()+0x18>)
    75d0:	ldr	r3, [r3, #0]
    75d2:	cmp	r0, r3
    75d4:	beq.n	75da <hour()+0x12>
    75d6:	bl	7510 <refreshCache(long) [clone .part.0]>
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
    75da:	ldr	r3, [pc, #8]	; (75e4 <hour()+0x1c>)
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    75dc:	ldrb	r0, [r3, #2]
    75de:	pop	{r3, pc}
    75e0:	.word	0x20004c08
    75e4:	.word	0x20004c0c

000075e8 <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    75e8:	push	{r3, lr}
  return minute(now()); 
    75ea:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    75ee:	ldr	r3, [pc, #16]	; (7600 <minute()+0x18>)
    75f0:	ldr	r3, [r3, #0]
    75f2:	cmp	r0, r3
    75f4:	beq.n	75fa <minute()+0x12>
    75f6:	bl	7510 <refreshCache(long) [clone .part.0]>
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
    75fa:	ldr	r3, [pc, #8]	; (7604 <minute()+0x1c>)
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    75fc:	ldrb	r0, [r3, #1]
    75fe:	pop	{r3, pc}
    7600:	.word	0x20004c08
    7604:	.word	0x20004c0c

00007608 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    7608:	push	{r3, lr}
  return second(now()); 
    760a:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    760e:	ldr	r3, [pc, #16]	; (7620 <second()+0x18>)
    7610:	ldr	r3, [r3, #0]
    7612:	cmp	r0, r3
    7614:	beq.n	761a <second()+0x12>
    7616:	bl	7510 <refreshCache(long) [clone .part.0]>
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
    761a:	ldr	r3, [pc, #8]	; (7624 <second()+0x1c>)
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    761c:	ldrb	r0, [r3, #0]
    761e:	pop	{r3, pc}
    7620:	.word	0x20004c08
    7624:	.word	0x20004c0c

00007628 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    7628:	push	{r3, lr}
  return(day(now())); 
    762a:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    762e:	ldr	r3, [pc, #16]	; (7640 <day()+0x18>)
    7630:	ldr	r3, [r3, #0]
    7632:	cmp	r0, r3
    7634:	beq.n	763a <day()+0x12>
    7636:	bl	7510 <refreshCache(long) [clone .part.0]>
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
    763a:	ldr	r3, [pc, #8]	; (7644 <day()+0x1c>)
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    763c:	ldrb	r0, [r3, #4]
    763e:	pop	{r3, pc}
    7640:	.word	0x20004c08
    7644:	.word	0x20004c0c

00007648 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    7648:	push	{r3, lr}
  return month(now()); 
    764a:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    764e:	ldr	r3, [pc, #16]	; (7660 <month()+0x18>)
    7650:	ldr	r3, [r3, #0]
    7652:	cmp	r0, r3
    7654:	beq.n	765a <month()+0x12>
    7656:	bl	7510 <refreshCache(long) [clone .part.0]>
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
    765a:	ldr	r3, [pc, #8]	; (7664 <month()+0x1c>)
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    765c:	ldrb	r0, [r3, #5]
    765e:	pop	{r3, pc}
    7660:	.word	0x20004c08
    7664:	.word	0x20004c0c

00007668 <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    7668:	push	{r3, lr}
  return year(now()); 
    766a:	bl	7528 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    766e:	ldr	r3, [pc, #20]	; (7684 <year()+0x1c>)
    7670:	ldr	r3, [r3, #0]
    7672:	cmp	r0, r3
    7674:	beq.n	767a <year()+0x12>
    7676:	bl	7510 <refreshCache(long) [clone .part.0]>
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
    767a:	ldr	r3, [pc, #12]	; (7688 <year()+0x20>)
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    767c:	ldrb	r0, [r3, #6]
}
    767e:	addw	r0, r0, #1970	; 0x7b2
    7682:	pop	{r3, pc}
    7684:	.word	0x20004c08
    7688:	.word	0x20004c0c

0000768c <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    768c:	bx	lr
    768e:	nop

00007690 <_GLOBAL__sub_I_SD>:
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    7690:	push	{r4, r5, r6, r7}
{
public:
	SDClass() { }
    7692:	ldr	r3, [pc, #68]	; (76d8 <_GLOBAL__sub_I_SD+0x48>)
    7694:	ldr	r5, [pc, #68]	; (76dc <_GLOBAL__sub_I_SD+0x4c>)
    7696:	ldr	r4, [pc, #72]	; (76e0 <_GLOBAL__sub_I_SD+0x50>)
    7698:	str	r5, [r3, #0]
    769a:	str.w	r4, [r3, #1184]	; 0x4a0
    769e:	movs	r5, #41	; 0x29
    76a0:	movs	r4, #0
    76a2:	ldr	r0, [pc, #64]	; (76e4 <_GLOBAL__sub_I_SD+0x54>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    76a4:	ldr	r7, [pc, #64]	; (76e8 <_GLOBAL__sub_I_SD+0x58>)
    76a6:	strb.w	r5, [r3, #1203]	; 0x4b3
    76aa:	movs	r6, #1
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    76ac:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    76b0:	strb.w	r4, [r3, #1181]	; 0x49d
    76b4:	strb.w	r4, [r3, #1206]	; 0x4b6
    76b8:	str.w	r0, [r3, #1172]	; 0x494
    76bc:	str.w	r7, [r3, #1192]	; 0x4a8
    76c0:	strb.w	r6, [r3, #1201]	; 0x4b1
    76c4:	str.w	r4, [r3, #1156]	; 0x484
    76c8:	str.w	r4, [r3, #1160]	; 0x488
    76cc:	ldr	r2, [pc, #28]	; (76ec <_GLOBAL__sub_I_SD+0x5c>)
    76ce:	ldr	r1, [pc, #32]	; (76f0 <_GLOBAL__sub_I_SD+0x60>)
    76d0:	mov	r0, r3
    76d2:	pop	{r4, r5, r6, r7}
    76d4:	b.w	eb64 <__aeabi_atexit>
    76d8:	.word	0x20004c28
    76dc:	.word	0x20000134
    76e0:	.word	0x20000594
    76e4:	.word	0x200005ec
    76e8:	.word	0x38011001
    76ec:	.word	0x20000b5c
    76f0:	.word	0x0000768d

000076f4 <FsCache::sync() [clone .part.0]>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    76f4:	push	{r3, r4, r5, r6, r7, lr}
    76f6:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    76f8:	add.w	r6, r0, #16
    76fc:	ldr	r0, [r0, #4]
    76fe:	ldr	r1, [r4, #12]
    7700:	ldr	r3, [r0, #0]
    7702:	mov	r2, r6
    7704:	ldr	r3, [r3, #28]
    7706:	blx	r3
    7708:	cbz	r0, 771c <FsCache::sync() [clone .part.0]+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    770a:	ldrb	r3, [r4, #0]
    770c:	lsls	r2, r3, #30
    770e:	mov	r5, r0
    7710:	bmi.n	7722 <FsCache::sync() [clone .part.0]+0x2e>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    7712:	bic.w	r3, r3, #1
    7716:	strb	r3, [r4, #0]
  }
  return true;

 fail:
  return false;
}
    7718:	mov	r0, r5
    771a:	pop	{r3, r4, r5, r6, r7, pc}
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    771c:	movs	r5, #0
}
    771e:	mov	r0, r5
    7720:	pop	{r3, r4, r5, r6, r7, pc}
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    7722:	ldr	r0, [r4, #4]
    7724:	ldr	r1, [r4, #12]
    7726:	ldr	r2, [r0, #0]
    7728:	ldr	r3, [r4, #8]
    772a:	ldr	r7, [r2, #28]
    772c:	add	r1, r3
    772e:	mov	r2, r6
    7730:	blx	r7
    7732:	cmp	r0, #0
    7734:	beq.n	771c <FsCache::sync() [clone .part.0]+0x28>
    7736:	ldrb	r3, [r4, #0]
    7738:	b.n	7712 <FsCache::sync() [clone .part.0]+0x1e>
    773a:	nop

0000773c <FsCache::get(unsigned long, unsigned char)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    773c:	push	{r3, r4, r5, r6, r7, lr}
  if (!m_blockDev) {
    773e:	ldr	r5, [r0, #4]
    7740:	cbz	r5, 7782 <FsCache::get(unsigned long, unsigned char)+0x46>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    7742:	ldr	r3, [r0, #12]
    7744:	cmp	r3, r1
    7746:	mov	r4, r0
    7748:	mov	r7, r2
    774a:	mov	r6, r1
    774c:	beq.n	776c <FsCache::get(unsigned long, unsigned char)+0x30>
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    774e:	ldrb	r3, [r0, #0]
    7750:	lsls	r2, r3, #31
    7752:	bmi.n	777a <FsCache::get(unsigned long, unsigned char)+0x3e>
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    7754:	lsls	r3, r7, #29
    7756:	bpl.n	7786 <FsCache::get(unsigned long, unsigned char)+0x4a>
    7758:	add.w	r5, r4, #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    775c:	and.w	r2, r7, #3
    7760:	movs	r3, #0
    7762:	orrs	r3, r2
    7764:	strb	r3, [r4, #0]
    7766:	mov	r0, r5
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_sector = sector;
    7768:	str	r6, [r4, #12]
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
}
    776a:	pop	{r3, r4, r5, r6, r7, pc}
    776c:	ldrsb.w	r3, [r0], #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    7770:	and.w	r2, r7, #3
    7774:	orrs	r3, r2
    7776:	strb	r3, [r4, #0]
  return m_buffer;

 fail:
  return nullptr;
}
    7778:	pop	{r3, r4, r5, r6, r7, pc}
    777a:	bl	76f4 <FsCache::sync() [clone .part.0]>
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
    777e:	cmp	r0, #0
    7780:	bne.n	7754 <FsCache::get(unsigned long, unsigned char)+0x18>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    7782:	movs	r0, #0
    7784:	pop	{r3, r4, r5, r6, r7, pc}
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    7786:	ldr	r0, [r4, #4]
    7788:	ldr	r3, [r0, #0]
    778a:	add.w	r5, r4, #16
    778e:	ldr	r3, [r3, #12]
    7790:	mov	r2, r5
    7792:	mov	r1, r6
    7794:	blx	r3
    7796:	cmp	r0, #0
    7798:	bne.n	775c <FsCache::get(unsigned long, unsigned char)+0x20>
    779a:	b.n	7782 <FsCache::get(unsigned long, unsigned char)+0x46>

0000779c <FsCache::sync()>:
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    779c:	ldrb	r3, [r0, #0]
    779e:	lsls	r3, r3, #31
    77a0:	bmi.n	77a6 <FsCache::sync()+0xa>
  }
  return true;

 fail:
  return false;
}
    77a2:	movs	r0, #1
    77a4:	bx	lr
    77a6:	b.w	76f4 <FsCache::sync() [clone .part.0]>
    77aa:	nop

000077ac <fmtBase10(char*, unsigned short)>:
}
*/
//------------------------------------------------------------------------------
// Format 16-bit unsigned
char* fmtBase10(char* str, uint16_t n) {
  while (n > 9) {
    77ac:	cmp	r1, #9
    77ae:	bls.n	77f8 <fmtBase10(char*, unsigned short)+0x4c>
// return q + (r > 9);
}
*/
//------------------------------------------------------------------------------
// Format 16-bit unsigned
char* fmtBase10(char* str, uint16_t n) {
    77b0:	push	{r4}
#ifdef USE_STIMMER
    uint8_t tmp8, r;
    divmod10_asm16(n, r, tmp8);
#else  // USE_STIMMER
    uint16_t t = n;
    n = (n >> 1) + (n >> 2);
    77b2:	asrs	r2, r1, #2
    77b4:	add.w	r2, r2, r1, lsr #1
    n = n + (n >> 4);
    77b8:	ubfx	r4, r2, #4, #16
    77bc:	add	r2, r4
    77be:	uxth	r2, r2
    n = n + (n >> 8);
    // n = n + (n >> 16);  // no code for 16-bit n
    n = n >> 3;
    77c0:	add.w	r2, r2, r2, lsr #8
    77c4:	ubfx	r3, r2, #3, #13
    uint8_t r = t - (((n << 2) + n) << 1);
    77c8:	uxtb	r4, r3
    77ca:	add.w	r4, r4, r4, lsl #2
    77ce:	sub.w	r2, r1, r4, lsl #1
    77d2:	uxtb	r2, r2
    if (r > 9) {
    77d4:	cmp	r2, #9
    uint16_t t = n;
    n = (n >> 1) + (n >> 2);
    n = n + (n >> 4);
    n = n + (n >> 8);
    // n = n + (n >> 16);  // no code for 16-bit n
    n = n >> 3;
    77d6:	uxth	r1, r3
    uint8_t r = t - (((n << 2) + n) << 1);
    if (r > 9) {
      n++;
      r -= 10;
    77d8:	sub.w	r3, r2, #10
    77dc:	itt	hi
    77de:	uxtbhi	r2, r3
    n = n + (n >> 8);
    // n = n + (n >> 16);  // no code for 16-bit n
    n = n >> 3;
    uint8_t r = t - (((n << 2) + n) << 1);
    if (r > 9) {
      n++;
    77e0:	addhi	r1, #1
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
    77e2:	adds	r2, #48	; 0x30
}
*/
//------------------------------------------------------------------------------
// Format 16-bit unsigned
char* fmtBase10(char* str, uint16_t n) {
  while (n > 9) {
    77e4:	cmp	r1, #9
    if (r > 9) {
      n++;
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
    77e6:	strb.w	r2, [r0, #-1]!
}
*/
//------------------------------------------------------------------------------
// Format 16-bit unsigned
char* fmtBase10(char* str, uint16_t n) {
  while (n > 9) {
    77ea:	bhi.n	77b2 <fmtBase10(char*, unsigned short)+0x6>
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
  }
  *--str = n + '0';
    77ec:	adds	r1, #48	; 0x30
    77ee:	strb.w	r1, [r0, #-1]!
  return str;
}
    77f2:	ldr.w	r4, [sp], #4
    77f6:	bx	lr
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
  }
  *--str = n + '0';
    77f8:	adds	r1, #48	; 0x30
    77fa:	strb.w	r1, [r0, #-1]!
  return str;
}
    77fe:	bx	lr

00007800 <fmtBase10(char*, unsigned long)>:
//------------------------------------------------------------------------------
// format 32-bit unsigned
char* fmtBase10(char* str, uint32_t n) {
  while (n > 0XFFFF) {
    7800:	cmp.w	r1, #65536	; 0x10000
    7804:	bcc.n	784c <fmtBase10(char*, unsigned long)+0x4c>
  *--str = n + '0';
  return str;
}
//------------------------------------------------------------------------------
// format 32-bit unsigned
char* fmtBase10(char* str, uint32_t n) {
    7806:	push	{r4}
#ifdef USE_STIMMER
    uint8_t tmp8, r;
    divmod10_asm32(n, r, tmp8);
#else  //  USE_STIMMER
    uint32_t t = n;
    n = (n >> 1) + (n >> 2);
    7808:	lsrs	r3, r1, #2
    780a:	add.w	r3, r3, r1, lsr #1
    n = n + (n >> 4);
    780e:	add.w	r3, r3, r3, lsr #4
    n = n + (n >> 8);
    7812:	add.w	r3, r3, r3, lsr #8
    n = n + (n >> 16);
    7816:	add.w	r3, r3, r3, lsr #16
    n = n >> 3;
    781a:	lsrs	r3, r3, #3
    uint8_t r = t - (((n << 2) + n) << 1);
    781c:	uxtb	r2, r3
    781e:	add.w	r2, r2, r2, lsl #2
    7822:	sub.w	r1, r1, r2, lsl #1
    7826:	uxtb	r2, r1
    if (r > 9) {
    7828:	cmp	r2, #9
      n++;
      r -= 10;
    782a:	sub.w	r4, r2, #10
    782e:	itte	hi
    7830:	uxtbhi	r2, r4
    n = n + (n >> 8);
    n = n + (n >> 16);
    n = n >> 3;
    uint8_t r = t - (((n << 2) + n) << 1);
    if (r > 9) {
      n++;
    7832:	addhi	r1, r3, #1
    uint32_t t = n;
    n = (n >> 1) + (n >> 2);
    n = n + (n >> 4);
    n = n + (n >> 8);
    n = n + (n >> 16);
    n = n >> 3;
    7834:	movls	r1, r3
    if (r > 9) {
      n++;
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
    7836:	adds	r2, #48	; 0x30
  return str;
}
//------------------------------------------------------------------------------
// format 32-bit unsigned
char* fmtBase10(char* str, uint32_t n) {
  while (n > 0XFFFF) {
    7838:	cmp.w	r1, #65536	; 0x10000
    if (r > 9) {
      n++;
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
    783c:	strb.w	r2, [r0, #-1]!
  return str;
}
//------------------------------------------------------------------------------
// format 32-bit unsigned
char* fmtBase10(char* str, uint32_t n) {
  while (n > 0XFFFF) {
    7840:	bcs.n	7808 <fmtBase10(char*, unsigned long)+0x8>
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
  }
  return fmtBase10(str, (uint16_t)n);
    7842:	uxth	r1, r1
}
    7844:	ldr.w	r4, [sp], #4
      r -= 10;
    }
#endif  // USE_STIMMER
    *--str = r + '0';
  }
  return fmtBase10(str, (uint16_t)n);
    7848:	b.w	77ac <fmtBase10(char*, unsigned short)>
    784c:	uxth	r1, r1
    784e:	b.w	77ac <fmtBase10(char*, unsigned short)>
    7852:	nop

00007854 <fsFmtDate(char*, unsigned short)>:
    *--str = '0';
  }
  return str;
}
//------------------------------------------------------------------------------
char* fsFmtDate(char* str, uint16_t date) {
    7854:	push	{r3, r4, r5, lr}
  str = fsFmtField(str, date & 31, 0);
    7856:	and.w	r5, r1, #31
    *--str = '0';
  }
  return str;
}
//------------------------------------------------------------------------------
char* fsFmtDate(char* str, uint16_t date) {
    785a:	mov	r4, r1
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
    785c:	mov	r1, r5
    785e:	bl	77ac <fmtBase10(char*, unsigned short)>
  if (n < 10) {
    7862:	cmp	r5, #9
    7864:	bhi.n	786e <fsFmtDate(char*, unsigned short)+0x1a>
    *--str = '0';
    7866:	movs	r3, #48	; 0x30
    7868:	strb.w	r3, [r0, #-1]
    786c:	subs	r0, #1
  return str;
}
//------------------------------------------------------------------------------
char* fsFmtDate(char* str, uint16_t date) {
  str = fsFmtField(str, date & 31, 0);
  date >>= 5;
    786e:	asrs	r4, r4, #5
  str = fsFmtField(str, date & 15, '-');
    7870:	and.w	r5, r4, #15
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
    7874:	movs	r3, #45	; 0x2d
    7876:	strb.w	r3, [r0, #-1]
  }
  str = fmtBase10(str, n);
    787a:	mov	r1, r5
    787c:	subs	r0, #1
    787e:	bl	77ac <fmtBase10(char*, unsigned short)>
  if (n < 10) {
    7882:	cmp	r5, #9
    7884:	bhi.n	788e <fsFmtDate(char*, unsigned short)+0x3a>
    *--str = '0';
    7886:	movs	r3, #48	; 0x30
    7888:	strb.w	r3, [r0, #-1]
    788c:	subs	r0, #1
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
    788e:	movs	r3, #45	; 0x2d
  }
  str = fmtBase10(str, n);
    7890:	asrs	r1, r4, #4
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
    7892:	strb.w	r3, [r0, #-1]
  }
  str = fmtBase10(str, n);
    7896:	addw	r1, r1, #1980	; 0x7bc
    789a:	subs	r0, #1
  str = fsFmtField(str, date & 31, 0);
  date >>= 5;
  str = fsFmtField(str, date & 15, '-');
  date >>= 4;
  return fsFmtField(str, 1980 + date, '-');
}
    789c:	ldmia.w	sp!, {r3, r4, r5, lr}
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
    78a0:	b.w	77ac <fmtBase10(char*, unsigned short)>

000078a4 <fsFmtTime(char*, unsigned short)>:
  str = fsFmtField(str, date & 15, '-');
  date >>= 4;
  return fsFmtField(str, 1980 + date, '-');
}
//------------------------------------------------------------------------------
char* fsFmtTime(char* str, uint16_t time) {
    78a4:	push	{r3, r4, r5, lr}
  time >>= 5;
    78a6:	lsrs	r4, r1, #5
  str = fsFmtField(str, time & 63, 0);
    78a8:	and.w	r5, r4, #63	; 0x3f
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
    78ac:	mov	r1, r5
    78ae:	bl	77ac <fmtBase10(char*, unsigned short)>
  if (n < 10) {
    78b2:	cmp	r5, #9
    78b4:	bhi.n	78be <fsFmtTime(char*, unsigned short)+0x1a>
    *--str = '0';
    78b6:	movs	r3, #48	; 0x30
    78b8:	strb.w	r3, [r0, #-1]
    78bc:	subs	r0, #1
    78be:	asrs	r4, r4, #6
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
    78c0:	movs	r3, #58	; 0x3a
    78c2:	strb.w	r3, [r0, #-1]
  }
  str = fmtBase10(str, n);
    78c6:	mov	r1, r4
    78c8:	subs	r0, #1
    78ca:	bl	77ac <fmtBase10(char*, unsigned short)>
  if (n < 10) {
    78ce:	cmp	r4, #9
    78d0:	bgt.n	78da <fsFmtTime(char*, unsigned short)+0x36>
    *--str = '0';
    78d2:	movs	r3, #48	; 0x30
    78d4:	strb.w	r3, [r0, #-1]
    78d8:	subs	r0, #1
//------------------------------------------------------------------------------
char* fsFmtTime(char* str, uint16_t time) {
  time >>= 5;
  str = fsFmtField(str, time & 63, 0);
  return fsFmtField(str, time >> 6, ':');
}
    78da:	pop	{r3, r4, r5, pc}

000078dc <fsPrintDateTime(Print*, unsigned short, unsigned short)>:
    } while (str > buf);
  }
  return pr->write(reinterpret_cast<uint8_t*>(str), buf + sizeof(buf) - str);
}
//------------------------------------------------------------------------------
size_t fsPrintDateTime(print_t* pr, uint16_t date, uint16_t time) {
    78dc:	push	{r4, r5, lr}
    78de:	mov	r4, r0
    78e0:	sub	sp, #20
  // Allow YYYY-MM-DD hh:mm
  char buf[sizeof("YYYY-MM-DD hh:mm") -1];
  char* str = buf + sizeof(buf);
  if (date) {
    78e2:	cbnz	r1, 7902 <fsPrintDateTime(Print*, unsigned short, unsigned short)+0x26>
    78e4:	add	r1, sp, #16
    78e6:	mov	r2, sp
    str = fsFmtTime(str, time);
    *--str = ' ';
    str = fsFmtDate(str, date);
  } else {
    do {
      *--str = ' ';
    78e8:	movs	r3, #32
    78ea:	strb.w	r3, [r1, #-1]!
    } while (str > buf);
    78ee:	cmp	r1, r2
    78f0:	bne.n	78ea <fsPrintDateTime(Print*, unsigned short, unsigned short)+0xe>
  }
  return pr->write(reinterpret_cast<uint8_t*>(str), buf + sizeof(buf) - str);
    78f2:	ldr	r3, [r4, #0]
    78f4:	add	r2, sp, #16
    78f6:	mov	r0, r4
    78f8:	ldr	r3, [r3, #4]
    78fa:	subs	r2, r2, r1
    78fc:	blx	r3
}
    78fe:	add	sp, #20
    7900:	pop	{r4, r5, pc}
    7902:	mov	r5, r1
size_t fsPrintDateTime(print_t* pr, uint16_t date, uint16_t time) {
  // Allow YYYY-MM-DD hh:mm
  char buf[sizeof("YYYY-MM-DD hh:mm") -1];
  char* str = buf + sizeof(buf);
  if (date) {
    str = fsFmtTime(str, time);
    7904:	add	r0, sp, #16
    7906:	mov	r1, r2
    7908:	bl	78a4 <fsFmtTime(char*, unsigned short)>
    *--str = ' ';
    790c:	movs	r3, #32
    str = fsFmtDate(str, date);
    790e:	mov	r1, r5
  // Allow YYYY-MM-DD hh:mm
  char buf[sizeof("YYYY-MM-DD hh:mm") -1];
  char* str = buf + sizeof(buf);
  if (date) {
    str = fsFmtTime(str, time);
    *--str = ' ';
    7910:	strb.w	r3, [r0, #-1]
    str = fsFmtDate(str, date);
    7914:	subs	r0, #1
    7916:	bl	7854 <fsFmtDate(char*, unsigned short)>
    791a:	mov	r1, r0
    791c:	b.n	78f2 <fsPrintDateTime(Print*, unsigned short, unsigned short)+0x16>
    791e:	nop

00007920 <ExFatFile::close()>:
#include "../common/DebugMacros.h"
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    7920:	push	{r4, lr}
    7922:	mov	r4, r0
  bool rtn = sync();
    7924:	bl	8d88 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    7928:	movs	r3, #0
    792a:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    792e:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    7932:	pop	{r4, pc}

00007934 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    7934:	push	{r3, r4, r5, lr}
    7936:	mov	r5, r1
    7938:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    793a:	add.w	r1, r0, #36	; 0x24
    793e:	movs	r2, #0
    7940:	ldr	r0, [r0, #32]
    7942:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    7946:	cbz	r0, 7952 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    7948:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    794a:	strh	r3, [r5, #0]
    794c:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    794e:	strh	r3, [r4, #0]
  return true;
    7950:	movs	r0, #1

 fail:
  return false;
}
    7952:	pop	{r3, r4, r5, pc}

00007954 <ExFatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    7954:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    7958:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    795c:	mov	r9, r0
    795e:	mov	r7, r1
    7960:	mov	r5, r2
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    7962:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    7966:	sub	sp, #20
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
    7968:	ldrb.w	r3, [r9, #49]	; 0x31
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    796c:	add	r6, sp, #4
    796e:	stmia.w	r6, {r0, r1, r2}
  size_t n = 0;
  if (!isOpen()) {
    7972:	cmp	r3, #0
    7974:	beq.n	79f4 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    7976:	ldrb.w	r3, [r9, #48]	; 0x30
    797a:	cmp	r3, #1
    797c:	bls.n	79fe <ExFatFile::getName(char*, unsigned int)+0xaa>
    797e:	mov.w	r8, #1
    7982:	movs	r4, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
    7984:	cmp.w	r8, #1
    7988:	ite	ne
    798a:	movne	r2, #32
    798c:	moveq	r2, #64	; 0x40
    798e:	mov	r1, r6
    7990:	ldr.w	r0, [r9, #32]
    7994:	bl	8774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    7998:	cmp	r0, #1
    799a:	bne.n	79f4 <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    799c:	movs	r2, #0
    799e:	mov	r1, r6
    79a0:	ldr.w	r0, [r9, #32]
    79a4:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    79a8:	cbz	r0, 79f4 <ExFatFile::getName(char*, unsigned int)+0xa0>
    79aa:	ldrb	r3, [r0, #0]
    79ac:	cmp	r3, #193	; 0xc1
    79ae:	bne.n	79f4 <ExFatFile::getName(char*, unsigned int)+0xa0>
    79b0:	adds	r1, r7, r4
    79b2:	add.w	lr, r4, #15
    79b6:	b.n	79ba <ExFatFile::getName(char*, unsigned int)+0x66>
    79b8:	mov	r4, r2
    79ba:	ldrh.w	r3, [r0, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
    79be:	adds	r2, r4, #1
    79c0:	cbz	r3, 79e8 <ExFatFile::getName(char*, unsigned int)+0x94>
    79c2:	cmp	r2, r5
    79c4:	bcs.n	79e8 <ExFatFile::getName(char*, unsigned int)+0x94>
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    79c6:	cmp	r3, #126	; 0x7e
    79c8:	ite	ls
    79ca:	uxtbls	r3, r3
    79cc:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    79ce:	cmp	r2, lr
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    79d0:	strb.w	r3, [r1], #1
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    79d4:	bne.n	79b8 <ExFatFile::getName(char*, unsigned int)+0x64>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    79d6:	add.w	r8, r8, #1
    79da:	ldrb.w	r3, [r9, #48]	; 0x30
    79de:	uxtb.w	r8, r8
    79e2:	cmp	r3, r8
    79e4:	mov	r4, r2
    79e6:	bhi.n	7984 <ExFatFile::getName(char*, unsigned int)+0x30>
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    79e8:	movs	r3, #0
  return n;
    79ea:	mov	r0, r4
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    79ec:	strb	r3, [r7, r4]
  return n;

 fail:
  *name = 0;
  return 0;
}
    79ee:	add	sp, #20
    79f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 done:
  name[n] = 0;
  return n;

 fail:
  *name = 0;
    79f4:	movs	r0, #0
    79f6:	strb	r0, [r7, #0]
  return 0;
}
    79f8:	add	sp, #20
    79fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    79fe:	movs	r4, #0
    7a00:	b.n	79e8 <ExFatFile::getName(char*, unsigned int)+0x94>
    7a02:	nop

00007a04 <ExFatFile::openRoot(ExFatVolume*)>:
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    7a04:	ldrb.w	r2, [r0, #49]	; 0x31
    7a08:	cbz	r2, 7a0e <ExFatFile::openRoot(ExFatVolume*)+0xa>
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    7a0a:	movs	r0, #0
    7a0c:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    7a0e:	push	{r3, r4, r5, lr}
    7a10:	mov	r4, r0
    7a12:	mov	r5, r1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    7a14:	mov	r1, r2
    7a16:	movs	r2, #56	; 0x38
    7a18:	bl	1001c <memset>
  m_attributes = FILE_ATTR_ROOT;
    7a1c:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    7a1e:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    7a20:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    7a24:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    7a28:	str	r5, [r4, #32]
    7a2a:	pop	{r3, r4, r5, pc}

00007a2c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const ExChar_t* path,
                            ExName_t* fname, const ExChar_t** ptr) {
    7a2c:	push	{r4, r5, r6, r7, lr}
  ExChar_t c;
  int end;
  int len = 0;

  // Skip leading spaces.
  while (*path == ' ') {
    7a2e:	ldrb	r0, [r1, #0]
    7a30:	cmp	r0, #32
    7a32:	bne.n	7a3c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    7a34:	ldrb.w	r0, [r1, #1]!
    7a38:	cmp	r0, #32
    7a3a:	beq.n	7a34 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x8>
    path++;
  }
  fname->lfn = path;
    7a3c:	str	r1, [r2, #4]

  for (len = 0; ; len++) {
    c = path[len];
    7a3e:	ldrb	r0, [r1, #0]
    if (c == 0 || isDirSeparator(c)) {
    7a40:	cmp	r0, #0
    7a42:	beq.n	7ae8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xbc>
    7a44:	cmp	r0, #47	; 0x2f
    7a46:	beq.n	7aa0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x74>
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    7a48:	cmp	r0, #92	; 0x5c
    7a4a:	beq.n	7a8e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    7a4c:	sub.w	r4, r0, #34	; 0x22
    7a50:	uxtb	r4, r4
    7a52:	cmp	r4, #29
    7a54:	bls.n	7a92 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
    7a56:	ldr.w	lr, [pc, #148]	; 7aec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>
    7a5a:	adds	r6, r1, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    7a5c:	movs	r4, #0
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    7a5e:	cmp	r0, #124	; 0x7c
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    7a60:	sub.w	r5, r0, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    7a64:	mov	r7, r6
    7a66:	beq.n	7a8e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    7a68:	cmp	r5, #94	; 0x5e
    7a6a:	bhi.n	7a8e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    7a6c:	ldrb.w	r0, [r6], #1
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    7a70:	sub.w	r5, r0, #34	; 0x22
    7a74:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    7a76:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    7a78:	cbz	r0, 7ada <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xae>
    7a7a:	cmp	r0, #47	; 0x2f
    7a7c:	beq.n	7aa2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x76>
    7a7e:	cmp	r0, #92	; 0x5c
    7a80:	lsr.w	r7, lr, r5
    7a84:	beq.n	7a8e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    7a86:	cmp	r5, #29
    7a88:	bhi.n	7a5e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
    7a8a:	lsls	r5, r7, #31
    7a8c:	bpl.n	7a5e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    7a8e:	movs	r0, #0
    7a90:	pop	{r4, r5, r6, r7, pc}
    7a92:	ldr	r5, [pc, #88]	; (7aec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>)
    7a94:	lsr.w	r4, r5, r4
    7a98:	lsls	r6, r4, #31
    7a9a:	bpl.n	7a56 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2a>
    7a9c:	movs	r0, #0
    7a9e:	pop	{r4, r5, r6, r7, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    7aa0:	movs	r4, #0
    7aa2:	adds	r7, r1, r4
    7aa4:	mov	r6, r7
    7aa6:	mov	r5, r4
    7aa8:	movs	r0, #47	; 0x2f
    7aaa:	b.n	7ab2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x86>
    7aac:	ldrb.w	r0, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    7ab0:	adds	r5, #1
    7ab2:	cmp	r0, #32
    7ab4:	beq.n	7aac <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
    7ab6:	cmp	r0, #47	; 0x2f
    7ab8:	beq.n	7aac <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
  *ptr = &path[end];
    7aba:	add	r1, r5
    7abc:	str	r1, [r3, #0]

  // Back over spaces and dots.
  while (len) {
    7abe:	cbz	r4, 7ad2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    7ac0:	mov	r1, r7
    c = path[len - 1];
    7ac2:	ldrb.w	r3, [r1, #-1]!
    if (c != '.' && c != ' ') {
    7ac6:	cmp	r3, #46	; 0x2e
    7ac8:	beq.n	7ace <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa2>
    7aca:	cmp	r3, #32
    7acc:	bne.n	7ae0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xb4>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    7ace:	subs	r4, #1
    7ad0:	bne.n	7ac2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x96>
    7ad2:	mov	r0, r4
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    return false;
  }
  fname->len = len;
    7ad4:	str	r0, [r2, #0]
  return true;
    7ad6:	movs	r0, #1
    7ad8:	pop	{r4, r5, r6, r7, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    7ada:	str	r7, [r3, #0]
    7adc:	adds	r7, r1, r4
    7ade:	b.n	7ac0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x94>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    7ae0:	cmp	r4, #255	; 0xff
    7ae2:	ble.n	7ad2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    7ae4:	movs	r0, #0
    7ae6:	pop	{r4, r5, r6, r7, pc}
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    7ae8:	str	r1, [r3, #0]
    7aea:	b.n	7ad4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa8>
    7aec:	.word	0x35000101

00007af0 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    7af0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7af4:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    7af8:	lsls	r6, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    7afa:	sub	sp, #12
    7afc:	mov	r4, r0
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    7afe:	bpl.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    7b00:	lsls	r5, r3, #25
    7b02:	mov	r6, r1
    7b04:	mov	fp, r2
    7b06:	bpl.w	7c7a <ExFatFile::read(void*, unsigned int)+0x18a>
    if ((m_curPosition + count) > m_validLength) {
    7b0a:	ldrd	r0, r1, [r4]
    7b0e:	ldrd	r2, r3, [r4, #16]
    7b12:	adds.w	r8, r0, fp
    7b16:	adc.w	r9, r1, #0
    7b1a:	cmp	r3, r9
    7b1c:	it	eq
    7b1e:	cmpeq	r2, r8
    7b20:	bcc.w	7c86 <ExFatFile::read(void*, unsigned int)+0x196>
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    7b24:	cmp.w	fp, #0
    7b28:	beq.n	7c08 <ExFatFile::read(void*, unsigned int)+0x118>
    7b2a:	mov	r9, r4
    7b2c:	ldrd	r0, r1, [r9], #24
    7b30:	mov	r5, fp
    clusterOffset = m_curPosition & m_vol->clusterMask();
    7b32:	ldr	r7, [r4, #32]
    7b34:	ldr.w	r3, [r7, #1080]	; 0x438
    7b38:	ands	r3, r0
    sectorOffset = clusterOffset & m_vol->sectorMask();
    7b3a:	ubfx	sl, r3, #0, #9
    if (clusterOffset == 0) {
    7b3e:	cmp	r3, #0
    7b40:	bne.n	7c14 <ExFatFile::read(void*, unsigned int)+0x124>
      if (m_curPosition == 0) {
    7b42:	orrs.w	r2, r0, r1
    7b46:	bne.n	7c34 <ExFatFile::read(void*, unsigned int)+0x144>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    7b48:	ldrb.w	r2, [r4, #49]	; 0x31
    7b4c:	lsls	r1, r2, #25
    7b4e:	ite	mi
    7b50:	ldrmi.w	r2, [r7, #1076]	; 0x434
    7b54:	ldrpl	r2, [r4, #28]
      } else if (isContiguous()) {
        m_curCluster++;
    7b56:	str	r2, [r4, #24]
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    7b58:	ldr.w	r0, [r7, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    7b5c:	ldrb.w	lr, [r7, #1093]	; 0x445
    7b60:	lsrs	r3, r3, #9
    7b62:	subs	r2, #2
    7b64:	adds	r1, r3, r0
    7b66:	lsl.w	r2, r2, lr
    7b6a:	add	r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    7b6c:	cmp.w	sl, #0
    7b70:	bne.n	7bcc <ExFatFile::read(void*, unsigned int)+0xdc>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    7b72:	cmp.w	r5, #512	; 0x200
    7b76:	bcc.n	7bcc <ExFatFile::read(void*, unsigned int)+0xdc>
    7b78:	ldr.w	r2, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    7b7c:	cmp	r1, r2
    7b7e:	beq.n	7bcc <ExFatFile::read(void*, unsigned int)+0xdc>
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    7b80:	cmp.w	r5, #1024	; 0x400
    7b84:	bcc.n	7c42 <ExFatFile::read(void*, unsigned int)+0x152>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    7b86:	mov.w	r8, #1
    7b8a:	lsl.w	r8, r8, lr
    7b8e:	rsb	r3, r3, r8
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    7b92:	mov.w	r8, r5, lsr #9
    7b96:	cmp	r8, r3
    7b98:	it	cs
    7b9a:	movcs	r8, r3
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    7b9c:	cmp	r1, r2
    7b9e:	bhi.n	7c18 <ExFatFile::read(void*, unsigned int)+0x128>
    7ba0:	add.w	r3, r8, r1
    7ba4:	cmp	r2, r3
    7ba6:	bcs.n	7c18 <ExFatFile::read(void*, unsigned int)+0x128>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    7ba8:	add.w	r0, r7, #528	; 0x210
    7bac:	str	r1, [sp, #4]
    7bae:	bl	779c <FsCache::sync()>
    7bb2:	ldr	r1, [sp, #4]
    7bb4:	cbnz	r0, 7c18 <ExFatFile::read(void*, unsigned int)+0x128>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    7bb6:	ldrb.w	r3, [r4, #50]	; 0x32
  return -1;
    7bba:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    7bbe:	orr.w	r3, r3, #2
    7bc2:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
}
    7bc6:	add	sp, #12
    7bc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    7bcc:	add.w	r0, r7, #528	; 0x210
    7bd0:	movs	r2, #0
    7bd2:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    7bd6:	cmp	r0, #0
    7bd8:	beq.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    7bda:	rsb	r8, sl, #512	; 0x200
    7bde:	cmp	r8, r5
    7be0:	it	cs
    7be2:	movcs	r8, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    7be4:	add.w	r1, r0, sl
    7be8:	mov	r2, r8
    7bea:	mov	r0, r6
    7bec:	bl	cfd4 <memcpy>
    7bf0:	mov	r2, r8
    7bf2:	movs	r3, #0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    7bf4:	ldrd	r0, r1, [r4]
    7bf8:	adds	r0, r0, r2
    7bfa:	adcs	r1, r3
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    7bfc:	subs.w	r5, r5, r8
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    7c00:	add	r6, r8
    m_curPosition += n;
    7c02:	strd	r0, r1, [r4]
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    7c06:	bne.n	7b32 <ExFatFile::read(void*, unsigned int)+0x42>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    7c08:	movs	r5, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    7c0a:	rsb	r0, r5, fp

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    7c0e:	add	sp, #12
    7c10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7c14:	ldr	r2, [r4, #24]
    7c16:	b.n	7b58 <ExFatFile::read(void*, unsigned int)+0x68>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    7c18:	ldr.w	r0, [r7, #532]	; 0x214
    7c1c:	ldr	r3, [r0, #0]
    7c1e:	mov	r2, r6
    7c20:	ldr	r7, [r3, #16]
    7c22:	mov	r3, r8
    7c24:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    7c26:	cmp	r0, #0
    7c28:	beq.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    7c2a:	mov.w	r8, r8, lsl #9
    7c2e:	mov	r2, r8
    7c30:	movs	r3, #0
    7c32:	b.n	7bf4 <ExFatFile::read(void*, unsigned int)+0x104>
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
    7c34:	ldrb.w	r2, [r4, #51]	; 0x33
    7c38:	lsls	r2, r2, #25
    7c3a:	bpl.n	7c5e <ExFatFile::read(void*, unsigned int)+0x16e>
        m_curCluster++;
    7c3c:	ldr	r2, [r4, #24]
    7c3e:	adds	r2, #1
    7c40:	b.n	7b56 <ExFatFile::read(void*, unsigned int)+0x66>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    7c42:	ldr.w	r0, [r7, #532]	; 0x214
    7c46:	ldr	r3, [r0, #0]
    7c48:	mov	r2, r6
    7c4a:	ldr	r3, [r3, #12]
    7c4c:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    7c4e:	cmp	r0, #0
    7c50:	beq.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>
    7c52:	mov.w	r2, #512	; 0x200
    7c56:	movs	r3, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    7c58:	mov.w	r8, #512	; 0x200
    7c5c:	b.n	7bf4 <ExFatFile::read(void*, unsigned int)+0x104>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    7c5e:	mov	r0, r7
    7c60:	mov	r2, r9
    7c62:	ldr	r1, [r4, #24]
    7c64:	str	r3, [sp, #4]
    7c66:	bl	87cc <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    7c6a:	sxtb	r0, r0
        if (fg < 0) {
    7c6c:	cmp	r0, #0
    7c6e:	blt.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    7c70:	beq.n	7c8c <ExFatFile::read(void*, unsigned int)+0x19c>
    7c72:	ldr	r7, [r4, #32]
    7c74:	ldr	r2, [r4, #24]
    7c76:	ldr	r3, [sp, #4]
    7c78:	b.n	7b58 <ExFatFile::read(void*, unsigned int)+0x68>

  if (!isReadable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    7c7a:	ldrb.w	r3, [r0, #49]	; 0x31
    7c7e:	lsls	r0, r3, #28
    7c80:	bmi.w	7b0a <ExFatFile::read(void*, unsigned int)+0x1a>
    7c84:	b.n	7b24 <ExFatFile::read(void*, unsigned int)+0x34>
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    7c86:	rsb	fp, r0, r2
    7c8a:	b.n	7b24 <ExFatFile::read(void*, unsigned int)+0x34>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
          // EOF if directory.
          if (isDir()) {
    7c8c:	ldrb.w	r3, [r4, #49]	; 0x31
    7c90:	tst.w	r3, #80	; 0x50
    7c94:	bne.n	7c0a <ExFatFile::read(void*, unsigned int)+0x11a>
    7c96:	b.n	7bb6 <ExFatFile::read(void*, unsigned int)+0xc6>

00007c98 <ExFatFile::peek()>:
  }
  fname->len = len;
  return true;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    7c98:	push	{r4, r5, r6, r7, lr}
    7c9a:	sub	sp, #12
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    7c9c:	movs	r2, #1
    7c9e:	add.w	r1, sp, #7
    7ca2:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    7ca4:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    7ca8:	ldr	r5, [r0, #24]
    7caa:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
    7cae:	cmp	r0, #1
    7cb0:	it	eq
    7cb2:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    7cb6:	str	r5, [r4, #24]
    7cb8:	it	ne
    7cba:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    7cbe:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    7cc2:	add	sp, #12
    7cc4:	pop	{r4, r5, r6, r7, pc}
    7cc6:	nop

00007cc8 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    7cc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7ccc:	ldrb.w	lr, [r0, #49]	; 0x31
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    7cd0:	ldr	r5, [r0, #24]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    7cd2:	sub	sp, #12
    7cd4:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    7cd6:	cmp.w	lr, #0
    7cda:	beq.n	7d14 <ExFatFile::seekSet(unsigned long long)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    7cdc:	ldrd	r0, r1, [r0]
    7ce0:	cmp	r1, r3
    7ce2:	it	eq
    7ce4:	cmpeq	r0, r2
    7ce6:	mov	r6, r2
    7ce8:	mov	r7, r3
    7cea:	beq.n	7d64 <ExFatFile::seekSet(unsigned long long)+0x9c>
    return true;
  }
  if (pos == 0) {
    7cec:	orrs.w	r3, r6, r7
    7cf0:	bne.n	7d02 <ExFatFile::seekSet(unsigned long long)+0x3a>
    // set position to start of file
    m_curCluster = 0;
    7cf2:	movs	r3, #0
    7cf4:	str	r3, [r4, #24]
    }
  }

 done:
  m_curPosition = pos;
  return true;
    7cf6:	movs	r0, #1
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    7cf8:	strd	r6, r7, [r4]
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    7cfc:	add	sp, #12
    7cfe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    7d02:	tst.w	lr, #8
    7d06:	beq.n	7d1e <ExFatFile::seekSet(unsigned long long)+0x56>
    if (pos > m_validLength) {
    7d08:	ldrd	r2, r3, [r4, #16]
    7d0c:	cmp	r3, r7
    7d0e:	it	eq
    7d10:	cmpeq	r2, r6
    7d12:	bcs.n	7d1e <ExFatFile::seekSet(unsigned long long)+0x56>
 done:
  m_curPosition = pos;
  return true;

 fail:
  m_curCluster = tmp;
    7d14:	str	r5, [r4, #24]
  return false;
    7d16:	movs	r0, #0
}
    7d18:	add	sp, #12
    7d1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    7d1e:	ldr	r3, [r4, #32]
    7d20:	str	r3, [sp, #4]
    7d22:	ldrb.w	ip, [r3, #1093]	; 0x445
  if (isContiguous()) {
    7d26:	ldrb.w	sl, [r4, #51]	; 0x33
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    7d2a:	add.w	ip, ip, #9
    7d2e:	uxtb.w	ip, ip
    7d32:	adds.w	r2, r6, #4294967295
    7d36:	adc.w	r3, r7, #4294967295
    7d3a:	rsb	r8, ip, #32
    7d3e:	lsl.w	fp, r3, r8
    7d42:	lsr.w	r2, r2, ip
    7d46:	orr.w	r2, r2, fp
    7d4a:	sub.w	fp, ip, #32
    7d4e:	lsr.w	r3, r3, fp
  if (isContiguous()) {
    7d52:	tst.w	sl, #64	; 0x40
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    7d56:	orr.w	r2, r2, r3
  if (isContiguous()) {
    7d5a:	beq.n	7d68 <ExFatFile::seekSet(unsigned long long)+0xa0>
    m_curCluster = m_firstCluster + nNew;
    7d5c:	ldr	r3, [r4, #28]
    7d5e:	add	r2, r3
    7d60:	str	r2, [r4, #24]
    goto done;
    7d62:	b.n	7cf6 <ExFatFile::seekSet(unsigned long long)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    7d64:	movs	r0, #1
    7d66:	b.n	7d18 <ExFatFile::seekSet(unsigned long long)+0x50>
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    7d68:	adds.w	r9, r0, #4294967295
    7d6c:	adc.w	sl, r1, #4294967295
    7d70:	lsr.w	ip, r9, ip
    7d74:	lsl.w	r8, sl, r8
    7d78:	orr.w	ip, ip, r8
    7d7c:	lsr.w	fp, sl, fp
    7d80:	orr.w	ip, ip, fp
  if (nNew < nCur || m_curPosition == 0) {
    7d84:	cmp	r2, ip
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    7d86:	mov	r3, sl
  if (nNew < nCur || m_curPosition == 0) {
    7d88:	bcs.n	7dba <ExFatFile::seekSet(unsigned long long)+0xf2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    7d8a:	tst.w	lr, #64	; 0x40
    7d8e:	itet	ne
    7d90:	ldrne	r3, [sp, #4]
    7d92:	ldreq	r3, [r4, #28]
    7d94:	ldrne.w	r3, [r3, #1076]	; 0x434
    7d98:	str	r3, [r4, #24]
    7d9a:	mov	r8, r2
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    7d9c:	add.w	r9, r4, #24
    7da0:	mov	r2, r9
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    7da2:	cmp.w	r8, #0
    7da6:	beq.n	7cf6 <ExFatFile::seekSet(unsigned long long)+0x2e>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    7da8:	ldr	r1, [r4, #24]
    7daa:	ldr	r0, [r4, #32]
    7dac:	bl	87cc <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    7db0:	add.w	r8, r8, #4294967295
    7db4:	cmp	r0, #0
    7db6:	bne.n	7da0 <ExFatFile::seekSet(unsigned long long)+0xd8>
    7db8:	b.n	7d14 <ExFatFile::seekSet(unsigned long long)+0x4c>
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
  if (nNew < nCur || m_curPosition == 0) {
    7dba:	orrs.w	r3, r0, r1
    7dbe:	beq.n	7d8a <ExFatFile::seekSet(unsigned long long)+0xc2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    7dc0:	rsb	r2, ip, r2
    7dc4:	b.n	7d9a <ExFatFile::seekSet(unsigned long long)+0xd2>
    7dc6:	nop

00007dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    7dc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7dcc:	mov	r6, r1
    7dce:	sub	sp, #76	; 0x4c
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    7dd0:	ldrb.w	r1, [r0, #49]	; 0x31
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    7dd4:	str	r2, [sp, #0]
    7dd6:	mov	r5, r0
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    7dd8:	cbnz	r1, 7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    7dda:	mov	sl, r3
    7ddc:	ldrb.w	r3, [r6, #49]	; 0x31
    7de0:	tst.w	r3, #80	; 0x50
    7de4:	bne.n	7df6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
  return sync();
#endif  // READ_ONLY
 fail:

  // close file
  m_attributes = FILE_ATTR_CLOSED;
    7de6:	movs	r0, #0
    7de8:	strb.w	r0, [r5, #49]	; 0x31
  m_flags = 0;
    7dec:	strb.w	r0, [r5, #51]	; 0x33
  return false;
}
    7df0:	add	sp, #76	; 0x4c
    7df2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    7df6:	ldr	r3, [sp, #112]	; 0x70
    7df8:	and.w	r3, r3, #3
    7dfc:	cmp	r3, #1
    7dfe:	beq.n	7e0e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x46>
    7e00:	cmp	r3, #2
    7e02:	beq.w	8018 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x250>
    7e06:	cmp	r3, #0
    7e08:	bne.n	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    7e0a:	movs	r3, #1
    7e0c:	b.n	7e10 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
    7e0e:	movs	r3, #2
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    7e10:	ldr	r2, [sp, #112]	; 0x70
    7e12:	and.w	r2, r2, #8
    7e16:	orrs	r3, r2
    7e18:	str	r3, [sp, #4]
  if (name) {
    7e1a:	ldr	r3, [sp, #0]
    7e1c:	cmp	r3, #0
    7e1e:	beq.w	801c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x254>
    nameHash = exFatHashName(name, nameLength, 0);
    7e22:	mov	r0, r3
    7e24:	movs	r2, #0
    7e26:	mov	r1, sl
    7e28:	bl	8a48 <exFatHashName(char const*, unsigned int, unsigned short)>
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    7e2c:	ldrb.w	r3, [r6, #49]	; 0x31
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    7e30:	str	r0, [sp, #8]
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    7e32:	cbz	r3, 7e48 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    7e34:	ldrd	r2, r3, [r6]
    7e38:	orrs	r3, r2
    7e3a:	beq.n	7e48 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    7e3c:	movs	r2, #0
    7e3e:	movs	r3, #0
    7e40:	strd	r2, r3, [r6]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    7e44:	movs	r1, #0
    7e46:	str	r1, [r6, #24]
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    7e48:	ldr	r2, [pc, #736]	; (812c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x364>)
    7e4a:	add.w	r3, sl, #14
    7e4e:	smull	r1, r2, r2, r3
    7e52:	add	r2, r3
    7e54:	asrs	r3, r3, #31
    7e56:	rsb	r3, r3, r2, asr #3
    7e5a:	uxtb	r3, r3
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;
    7e5c:	mov.w	r9, #0
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    7e60:	str	r3, [sp, #12]
    7e62:	adds	r3, #2
    7e64:	uxtb.w	fp, r3

  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
    7e68:	mov	r4, r9
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
    7e6a:	mov	r7, r9
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    7e6c:	movs	r2, #32
    7e6e:	add	r1, sp, #40	; 0x28
    7e70:	mov	r0, r6
    7e72:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    7e76:	cmp	r0, #0
    7e78:	beq.n	7ef6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      goto create;
    }
    if (n != 32) {
    7e7a:	cmp	r0, #32
    7e7c:	bne.n	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    7e7e:	ldrb.w	r3, [sp, #40]	; 0x28
    7e82:	lsls	r2, r3, #24
    7e84:	bmi.n	7f54 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x18c>
      if (freeCount == 0) {
    7e86:	cmp	r4, #0
    7e88:	bne.n	7f4e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x186>
        freePos.position = dir->curPosition() - 32;
    7e8a:	ldr	r2, [r6, #0]
        freePos.cluster = dir->curCluster();
    7e8c:	ldr	r1, [r6, #24]
    7e8e:	str	r1, [sp, #28]
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
    7e90:	subs	r2, #32
    7e92:	str	r2, [sp, #32]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
        freeCount++;
    7e94:	adds	r4, #1
    7e96:	uxtb	r4, r4
      }
      if (!buf[0]) {
    7e98:	cbz	r3, 7ef6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    }
    switch (buf[0]) {
    7e9a:	cmp	r3, #192	; 0xc0
    7e9c:	beq.w	7fc6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fe>
    7ea0:	cmp	r3, #193	; 0xc1
    7ea2:	beq.n	7f6a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1a2>
    7ea4:	cmp	r3, #133	; 0x85
    7ea6:	bne.n	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
    7ea8:	movs	r2, #56	; 0x38
    7eaa:	movs	r1, #0
    7eac:	mov	r0, r5
    7eae:	bl	1001c <memset>
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    7eb2:	ldrb.w	r3, [sp, #44]	; 0x2c
    }
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
    7eb6:	ldrb.w	r2, [sp, #41]	; 0x29
    7eba:	strb.w	r2, [r5, #48]	; 0x30
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    7ebe:	lsls	r0, r3, #27
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    7ec0:	and.w	r2, r3, #55	; 0x37
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
    7ec4:	it	pl
    7ec6:	orrpl.w	r2, r2, #8
    7eca:	strb.w	r2, [r5, #49]	; 0x31
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    7ece:	ldr	r3, [r6, #0]
    7ed0:	ldr	r1, [r6, #32]
    7ed2:	ldr	r2, [r6, #24]
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
    7ed4:	str	r2, [r5, #36]	; 0x24
        m_dirPos.position = dir->curPosition() - 32;
    7ed6:	subs	r3, #32
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();
    7ed8:	str	r1, [r5, #32]

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    7eda:	str	r3, [r5, #40]	; 0x28
        m_dirPos.isContiguous = dir->isContiguous();
    7edc:	ldrb.w	r3, [r6, #51]	; 0x33
    7ee0:	ubfx	r3, r3, #6, #1
    7ee4:	strb.w	r3, [r5, #44]	; 0x2c
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    7ee8:	movs	r2, #32
    7eea:	add	r1, sp, #40	; 0x28
    7eec:	mov	r0, r6
    7eee:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    7ef2:	cmp	r0, #0
    7ef4:	bne.n	7e7a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xb2>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    7ef6:	ldr	r3, [sp, #112]	; 0x70
    7ef8:	lsls	r1, r3, #22
    7efa:	bpl.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    7efe:	ldr	r3, [sp, #4]
    7f00:	lsls	r2, r3, #30
    7f02:	bpl.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    7f06:	ldr	r3, [sp, #0]
    7f08:	cmp	r3, #0
    7f0a:	beq.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    7f0e:	cmp	r4, fp
    7f10:	bcc.n	7f2c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x164>
    7f12:	b.n	8022 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
        goto fail;
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
    7f14:	cmp	r0, #32
    7f16:	bne.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    7f1a:	cbnz	r4, 7f26 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x15e>
      freePos.position = dir->curPosition() - 32;
    7f1c:	ldr	r2, [r6, #0]
      freePos.cluster = dir->curCluster();
    7f1e:	ldr	r1, [r6, #24]
    7f20:	str	r1, [sp, #28]
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
    7f22:	subs	r2, #32
    7f24:	str	r2, [sp, #32]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    7f26:	uxtb	r4, r3
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    7f28:	cmp	fp, r4
    7f2a:	bls.n	8022 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
    n = dir->read(buf, 32);
    7f2c:	movs	r2, #32
    7f2e:	add	r1, sp, #40	; 0x28
    7f30:	mov	r0, r6
    7f32:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    7f36:	adds	r3, r4, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
    7f38:	cmp	r0, #0
    7f3a:	bne.n	7f14 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x14c>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    7f3c:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    7f3e:	ldr	r7, [r6, #24]
      if (!dir->addDirCluster()) {
    7f40:	bl	8de8 <ExFatFile::addDirCluster()>
    7f44:	cmp	r0, #0
    7f46:	beq.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    7f4a:	str	r7, [r6, #24]
      continue;
    7f4c:	b.n	7f28 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x160>
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    7f4e:	cmp	r4, fp
    7f50:	bcs.n	7e98 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd0>
    7f52:	b.n	7e94 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xcc>
        freeCount++;
      }
      if (!buf[0]) {
        goto create;
      }
    } else if (!inSet) {
    7f54:	cmp.w	r9, #0
    7f58:	bne.n	7e9a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd2>
      if (freeCount < freeNeed) {
        freeCount = 0;
    7f5a:	cmp	r4, fp
    7f5c:	it	cc
    7f5e:	movcc	r4, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    7f60:	cmp	r3, #133	; 0x85
    7f62:	bne.n	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        continue;
      }
      inSet = true;
    7f64:	mov.w	r9, #1
    7f68:	b.n	7ea8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xe0>
        }
        break;

      case EXFAT_TYPE_NAME:
        dirName = reinterpret_cast<DirName_t*>(buf);
        nCmp = nameLength - nameOffset;
    7f6a:	rsb	r8, r7, sl
    7f6e:	uxtb.w	r8, r8
    7f72:	cmp.w	r8, #15
    7f76:	it	cs
    7f78:	movcs.w	r8, #15
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
    7f7c:	mov	r3, r8
    7f7e:	mov	r2, r7
    7f80:	ldr	r1, [sp, #0]
    7f82:	add	r0, sp, #40	; 0x28
    7f84:	bl	89f0 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>
    7f88:	cmp	r0, #0
    7f8a:	beq.n	8006 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x23e>
          inSet = false;
          break;
        }
        nameOffset += nCmp;
    7f8c:	add	r7, r8
    7f8e:	uxtb	r7, r7

        if (nameOffset == nameLength) {
    7f90:	cmp	sl, r7
    7f92:	bne.w	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    7f96:	ldr	r3, [sp, #112]	; 0x70
    7f98:	lsls	r3, r3, #20
    7f9a:	bmi.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    7f9e:	ldr	r3, [sp, #112]	; 0x70
    7fa0:	tst.w	r3, #17408	; 0x4400
    7fa4:	bne.w	80e8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
    7fa8:	ldrb.w	r3, [r5, #51]	; 0x33
    7fac:	lsls	r7, r3, #30
    7fae:	bmi.w	80e8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    7fb2:	ldr	r3, [sp, #112]	; 0x70
    7fb4:	lsls	r3, r3, #21
    7fb6:	bmi.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    7fba:	ldr	r3, [sp, #112]	; 0x70
    7fbc:	lsls	r0, r3, #17
    7fbe:	bmi.w	8130 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x368>
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // READ_ONLY
  return true;
    7fc2:	movs	r0, #1
    7fc4:	b.n	7df0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    7fc6:	ldrb.w	r3, [sp, #41]	; 0x29
        m_dirPos.isContiguous = dir->isContiguous();
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
    7fca:	ldr	r2, [sp, #4]
    7fcc:	strb.w	r2, [r5, #51]	; 0x33
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    7fd0:	lsls	r1, r3, #30
    7fd2:	bpl.n	7fdc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x214>
          m_flags |= FILE_FLAG_CONTIGUOUS;
    7fd4:	orr.w	r3, r2, #64	; 0x40
    7fd8:	strb.w	r3, [r5, #51]	; 0x33
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    7fdc:	ldrd	r2, r3, [sp, #48]	; 0x30
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    7fe0:	ldrd	r0, r1, [sp, #64]	; 0x40
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    7fe4:	strd	r2, r3, [r5, #16]
        m_firstCluster = getLe32(dirStream->firstCluster);
    7fe8:	ldr	r3, [sp, #60]	; 0x3c
    7fea:	str	r3, [r5, #28]
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
    7fec:	ldr	r3, [sp, #0]
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    7fee:	strd	r0, r1, [r5, #8]
        if (!name) {
    7ff2:	cmp	r3, #0
    7ff4:	beq.n	7f96 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1ce>
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    7ff6:	ldrb.w	r3, [sp, #43]	; 0x2b
    7ffa:	cmp	r3, sl
    7ffc:	beq.n	800a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x242>
            nameHash != getLe16(dirStream->nameHash)) {
          inSet = false;
    7ffe:	mov.w	r9, #0
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    8002:	mov	r7, r9
    8004:	b.n	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        nCmp = nameLength - nameOffset;
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
          inSet = false;
    8006:	mov	r9, r0
    8008:	b.n	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    800a:	ldrh.w	r3, [sp, #44]	; 0x2c
    800e:	ldr	r2, [sp, #8]
    8010:	cmp	r3, r2
    8012:	bne.n	7ffe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x236>
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    8014:	movs	r7, #0
    8016:	b.n	7e6c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    8018:	movs	r3, #3
    801a:	b.n	7e10 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
  uint8_t nCmp;
  uint8_t modeFlags;
  uint16_t nameHash = 0;
    801c:	ldr	r3, [sp, #0]
    801e:	str	r3, [sp, #8]
    8020:	b.n	7e48 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    8022:	ldrb.w	r3, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    8026:	movs	r2, #56	; 0x38
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    8028:	ubfx	r3, r3, #6, #1
  memset(this, 0, sizeof(ExFatFile));
    802c:	movs	r1, #0
    802e:	mov	r0, r5
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    8030:	add.w	r8, sp, #28
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    8034:	strb.w	r3, [sp, #36]	; 0x24
  memset(this, 0, sizeof(ExFatFile));
    8038:	bl	1001c <memset>
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    803c:	ldr	r4, [sp, #12]
    803e:	ldr	r3, [r6, #32]
    8040:	str.w	sl, [sp, #12]

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    8044:	ldmia.w	r8, {r0, r1, r2}
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8048:	add.w	r9, r4, #1
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
    804c:	movs	r4, #8
    804e:	strb.w	r4, [r5, #49]	; 0x31
    8052:	add.w	r7, sl, #30
  m_dirPos = freePos;
    8056:	add.w	r4, r5, #36	; 0x24
    805a:	ldr.w	sl, [sp]
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
    805e:	str	r3, [r5, #32]
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8060:	uxtb.w	r9, r9

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    8064:	stmia.w	r4, {r0, r1, r2}
    8068:	uxtb	r7, r7
  for (uint8_t i = 0; i < freeNeed; i++) {
    806a:	movs	r6, #0
    806c:	mov	r0, r3
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
    806e:	movs	r2, #1
    8070:	mov	r1, r8
    8072:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    8076:	mov	r4, r0
    8078:	cmp	r0, #0
    807a:	beq.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    807e:	ldrsb.w	r3, [r0]
    8082:	cmp	r3, #0
    8084:	blt.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    8088:	movs	r2, #32
    808a:	movs	r1, #0
    808c:	bl	1001c <memset>
    if (i == 0) {
    8090:	cmp	r6, #0
    8092:	beq.n	8162 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x39a>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    8094:	cmp	r6, #1
    8096:	beq.n	8142 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x37a>
    8098:	rsb	r3, r6, r6, lsl #4
    809c:	cmp	r7, #15
    809e:	sub.w	r3, r3, #30

      dirStream->nameLength = nameLength;
      setLe16(dirStream->nameHash, nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    80a2:	mov.w	r2, #193	; 0xc1
    80a6:	mov	r1, r7
    80a8:	it	cs
    80aa:	movcs	r1, #15
    80ac:	uxtb	r3, r3
    80ae:	strb	r2, [r4, #0]
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    80b0:	cbz	r1, 80c8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    80b2:	adds	r4, #2
    80b4:	sxth	r1, r1
    80b6:	add.w	r1, r4, r1, lsl #1
    80ba:	add	r3, sl
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
    80bc:	ldrb.w	r2, [r3], #1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    80c0:	strh.w	r2, [r4], #2
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    80c4:	cmp	r1, r4
    80c6:	bne.n	80bc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2f4>
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
    80c8:	adds	r6, #1
    80ca:	uxtb	r6, r6
    80cc:	cmp	fp, r6
    80ce:	bls.n	8124 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x35c>
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
    80d0:	movs	r2, #32
    80d2:	mov	r1, r8
    80d4:	ldr	r0, [r5, #32]
    80d6:	bl	8774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    80da:	cmp	r0, #1
    80dc:	bne.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    80e0:	subs	r7, #15
    80e2:	uxtb	r7, r7
    80e4:	ldr	r0, [r5, #32]
    80e6:	b.n	806e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2a6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    80e8:	ldrb.w	r3, [r5, #49]	; 0x31
    80ec:	tst.w	r3, #17
    80f0:	bne.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    80f4:	ldr	r3, [sp, #112]	; 0x70
    80f6:	lsls	r6, r3, #21
    80f8:	bpl.w	7fba <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1f2>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    80fc:	ldrb.w	r3, [r5, #51]	; 0x33
    8100:	lsls	r4, r3, #30
    8102:	bpl.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    8106:	movs	r2, #0
    8108:	movs	r3, #0
    810a:	mov	r0, r5
    810c:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
    8110:	cmp	r0, #0
    8112:	beq.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8116:	mov	r0, r5
    8118:	bl	90b0 <ExFatFile::truncate()>
    811c:	cmp	r0, #0
    811e:	beq.w	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8122:	b.n	7fc2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
      for (size_t k = 0; k < nCmp; k++) {
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
      }
    }
  }
  return sync();
    8124:	mov	r0, r5
    8126:	bl	8d88 <ExFatFile::sync()>
    812a:	b.n	7df0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
    812c:	.word	0x88888889
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    8130:	ldrd	r2, r3, [r5, #16]
    8134:	mov	r0, r5
    8136:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
    813a:	cmp	r0, #0
    813c:	bne.w	7fc2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
    8140:	b.n	7de6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    8142:	movs	r3, #192	; 0xc0
    8144:	strb	r3, [r4, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8146:	ldr	r3, [sp, #4]
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    8148:	movs	r2, #3
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    814a:	orn	r3, r3, #63	; 0x3f
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    814e:	strb	r2, [r4, #1]
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8150:	strb.w	r3, [r5, #51]	; 0x33

      dirStream->nameLength = nameLength;
    8154:	ldrb.w	r3, [sp, #12]
    8158:	strb	r3, [r4, #3]
    815a:	ldrh.w	r3, [sp, #8]
    815e:	strh	r3, [r4, #4]
    8160:	b.n	80c8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
      goto fail;
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    8162:	movs	r3, #133	; 0x85
    8164:	strb	r3, [r4, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    8166:	ldr	r3, [pc, #56]	; (81a0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3d8>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8168:	strb.w	r9, [r5, #48]	; 0x30
      dirFile->setCount = m_setCount;
    816c:	strb.w	r9, [r4, #1]

      if (FsDateTime::callback) {
    8170:	ldr	r3, [r3, #0]
    8172:	cbz	r3, 8194 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3cc>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    8174:	add.w	r2, sp, #23
    8178:	add.w	r1, sp, #26
    817c:	add	r0, sp, #24
    817e:	blx	r3
    8180:	ldrh.w	r1, [sp, #24]
    8184:	ldrh.w	r2, [sp, #26]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    8188:	ldrb.w	r3, [sp, #23]
    818c:	strh	r1, [r4, #10]
    818e:	strh	r2, [r4, #8]
    8190:	strb	r3, [r4, #20]
    8192:	b.n	80c8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    8194:	movw	r3, #21025	; 0x5221
    8198:	strh	r3, [r4, #10]
    819a:	strh	r3, [r4, #14]
    819c:	strh	r3, [r4, #18]
    819e:	b.n	80c8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    81a0:	.word	0x200050e0

000081a4 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    81a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    81a8:	mov	r6, r0
    81aa:	sub	sp, #84	; 0x54
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    81ac:	ldrb.w	r4, [r6, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    81b0:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    81b2:	movs	r0, #0
    81b4:	strb.w	r0, [sp, #73]	; 0x49
    81b8:	strb.w	r0, [sp, #74]	; 0x4a
    81bc:	strb.w	r0, [sp, #75]	; 0x4b
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    81c0:	cbnz	r4, 81d0 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
    81c2:	mov	r9, r3
    81c4:	ldrb.w	r3, [r1, #49]	; 0x31
    81c8:	tst.w	r3, #80	; 0x50
    81cc:	mov	r5, r1
    81ce:	bne.n	81d8 <ExFatFile::open(ExFatFile*, char const*, int)+0x34>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    81d0:	movs	r0, #0
}
    81d2:	add	sp, #84	; 0x54
    81d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    81d8:	ldrb	r3, [r2, #0]
    81da:	cmp	r3, #47	; 0x2f
    81dc:	mov	r4, r2
    81de:	beq.n	8246 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    81e0:	mov.w	r8, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    81e4:	mov	r1, r4
    81e6:	add	r3, sp, #12
    81e8:	add	r2, sp, #16
    81ea:	mov	r0, r6
    81ec:	bl	7a2c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    81f0:	cmp	r0, #0
    81f2:	beq.n	81d0 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    81f4:	ldr	r3, [sp, #12]
    81f6:	ldrb	r3, [r3, #0]
    81f8:	cmp	r3, #0
    81fa:	beq.n	8270 <ExFatFile::open(ExFatFile*, char const*, int)+0xcc>
    81fc:	ldrb.w	r3, [sp, #16]
    8200:	ldr	r2, [sp, #20]
    8202:	str.w	r8, [sp]
    8206:	mov	r1, r5
    8208:	mov	r0, r6
    820a:	bl	7dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    820e:	cmp	r0, #0
    8210:	beq.n	81d0 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    8212:	mov	r4, r6
    8214:	add	r7, sp, #24
    8216:	add.w	lr, r6, #48	; 0x30
    821a:	ldr	r0, [r4, #0]
    821c:	ldr	r1, [r4, #4]
    821e:	ldr	r2, [r4, #8]
    8220:	ldr	r3, [r4, #12]
    8222:	mov	r5, r7
    8224:	stmia	r5!, {r0, r1, r2, r3}
    8226:	adds	r4, #16
    8228:	cmp	r4, lr
    822a:	mov	r7, r5
    822c:	bne.n	821a <ExFatFile::open(ExFatFile*, char const*, int)+0x76>
    822e:	ldr	r0, [r4, #0]
    8230:	str	r0, [r5, #0]
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
    8232:	mov	r0, r6
    8234:	bl	8d88 <ExFatFile::sync()>
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    8238:	add	r5, sp, #24
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    823a:	strb.w	r8, [r6, #49]	; 0x31
  m_flags = 0;
    823e:	strb.w	r8, [r6, #51]	; 0x33
    8242:	ldr	r4, [sp, #12]
    8244:	b.n	81e4 <ExFatFile::open(ExFatFile*, char const*, int)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    8246:	adds	r4, #1
    8248:	str	r4, [sp, #12]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    824a:	ldrb	r1, [r4, #0]
    824c:	cmp	r1, #47	; 0x2f
    824e:	beq.n	8246 <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
      path++;
    }
    if (*path == 0) {
    8250:	cbz	r1, 8288 <ExFatFile::open(ExFatFile*, char const*, int)+0xe4>
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8252:	movs	r2, #56	; 0x38
    8254:	add	r0, sp, #24
    8256:	movs	r1, #0
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    8258:	ldr	r7, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    825a:	bl	1001c <memset>
  m_attributes = FILE_ATTR_ROOT;
    825e:	movs	r2, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8260:	movs	r3, #1
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    8262:	add	r5, sp, #24
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8264:	str	r7, [sp, #56]	; 0x38
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8266:	strb.w	r2, [sp, #73]	; 0x49
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    826a:	strb.w	r3, [sp, #75]	; 0x4b
    826e:	b.n	81e0 <ExFatFile::open(ExFatFile*, char const*, int)+0x3c>
    8270:	ldrb.w	r3, [sp, #16]
    8274:	ldr	r2, [sp, #20]
    8276:	str.w	r9, [sp]
    827a:	mov	r1, r5
    827c:	mov	r0, r6
    827e:	bl	7dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
}
    8282:	add	sp, #84	; 0x54
    8284:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8288:	movs	r2, #56	; 0x38
    828a:	mov	r0, r6
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    828c:	ldr	r4, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    828e:	bl	1001c <memset>
  m_attributes = FILE_ATTR_ROOT;
    8292:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8294:	movs	r0, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8296:	str	r4, [r6, #32]
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8298:	strb.w	r3, [r6, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    829c:	strb.w	r0, [r6, #51]	; 0x33
    82a0:	b.n	81d2 <ExFatFile::open(ExFatFile*, char const*, int)+0x2e>
    82a2:	nop

000082a4 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const ExChar_t* path, int oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
    82a4:	cbz	r1, 82ae <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    82a6:	add.w	r1, r1, #1096	; 0x448
    82aa:	b.w	81a4 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    82ae:	mov	r0, r1
    82b0:	bx	lr
    82b2:	nop

000082b4 <ExFatFile::openNext(ExFatFile*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    82b4:	ldrb.w	r3, [r0, #49]	; 0x31
    82b8:	cbnz	r3, 82d0 <ExFatFile::openNext(ExFatFile*, int)+0x1c>
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    82ba:	push	{r4, r5, lr}
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    82bc:	ldrb.w	r4, [r1, #49]	; 0x31
    82c0:	ands.w	r4, r4, #80	; 0x50
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    82c4:	sub	sp, #12
    82c6:	mov	r5, r1
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    82c8:	bne.n	82d4 <ExFatFile::openNext(ExFatFile*, int)+0x20>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    82ca:	mov	r0, r4
}
    82cc:	add	sp, #12
    82ce:	pop	{r4, r5, pc}
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    82d0:	movs	r0, #0
}
    82d2:	bx	lr
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    82d4:	ldrd	r4, r5, [r5]
    82d8:	movs	r5, #0
    82da:	and.w	r4, r4, #31
    82de:	orrs	r4, r5
    82e0:	beq.n	82e8 <ExFatFile::openNext(ExFatFile*, int)+0x34>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    82e2:	mov	r0, r3
}
    82e4:	add	sp, #12
    82e6:	pop	{r4, r5, pc}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);
    82e8:	str	r2, [sp, #0]
    82ea:	mov	r2, r3
    82ec:	bl	7dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>

 fail:
  return false;
}
    82f0:	add	sp, #12
    82f2:	pop	{r4, r5, pc}

000082f4 <ExFatFile::printFileSize(Print*)>:
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printFileSize(print_t* pr) {
    82f4:	push	{r4, r5, r6, lr}
    82f6:	sub	sp, #24
  uint64_t n = m_validLength;
  char buf[21];
  char *str = &buf[sizeof(buf) - 1];
  char *bgn = str - 12;
  *str = '\0';
    82f8:	add	r5, sp, #24
    82fa:	movs	r2, #0
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printFileSize(print_t* pr) {
  uint64_t n = m_validLength;
    82fc:	ldr	r4, [r0, #16]
    82fe:	ldr	r3, [r0, #20]
  char buf[21];
  char *str = &buf[sizeof(buf) - 1];
  char *bgn = str - 12;
  *str = '\0';
    8300:	strb.w	r2, [r5, #-4]!
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printFileSize(print_t* pr) {
    8304:	mov	r6, r1
  char *str = &buf[sizeof(buf) - 1];
  char *bgn = str - 12;
  *str = '\0';
  do {
    uint64_t m = n;
    n /= 10;
    8306:	mov	r1, r3
    8308:	movs	r2, #10
    830a:	movs	r3, #0
    830c:	mov	r0, r4
    830e:	bl	f490 <__aeabi_uldivmod>
    *--str = m - 10*n + '0';
    8312:	adds	r4, #48	; 0x30
    8314:	add.w	r3, r0, r0, lsl #2
    8318:	sub.w	r4, r4, r3, lsl #1
  uint64_t n = m_validLength;
  char buf[21];
  char *str = &buf[sizeof(buf) - 1];
  char *bgn = str - 12;
  *str = '\0';
  do {
    831c:	orrs.w	r2, r0, r1
    uint64_t m = n;
    n /= 10;
    *--str = m - 10*n + '0';
    8320:	strb.w	r4, [r5, #-1]!
    8324:	mov	r3, r1
    8326:	mov	r4, r0
  uint64_t n = m_validLength;
  char buf[21];
  char *str = &buf[sizeof(buf) - 1];
  char *bgn = str - 12;
  *str = '\0';
  do {
    8328:	bne.n	8306 <ExFatFile::printFileSize(Print*)+0x12>
    uint64_t m = n;
    n /= 10;
    *--str = m - 10*n + '0';
  } while (n);
  while (str > bgn) {
    832a:	add	r3, sp, #8
    832c:	cmp	r5, r3
    832e:	bls.n	833e <ExFatFile::printFileSize(Print*)+0x4a>
    8330:	mov	r1, r5
    *--str = ' ';
    8332:	movs	r2, #32
    8334:	strb.w	r2, [r1, #-1]!
  do {
    uint64_t m = n;
    n /= 10;
    *--str = m - 10*n + '0';
  } while (n);
  while (str > bgn) {
    8338:	cmp	r1, r3
    833a:	bne.n	8334 <ExFatFile::printFileSize(Print*)+0x40>
    833c:	add	r5, sp, #8
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    833e:	mov	r0, r5
    8340:	bl	10680 <strlen>
    8344:	ldr	r3, [r6, #0]
    8346:	mov	r2, r0
    8348:	mov	r1, r5
    834a:	ldr	r3, [r3, #4]
    834c:	mov	r0, r6
    834e:	blx	r3
    *--str = ' ';
  }
  return pr->write(str);
}
    8350:	add	sp, #24
    8352:	pop	{r4, r5, r6, pc}

00008354 <ExFatFile::printModifyDateTime(Print*)>:
//------------------------------------------------------------------------------
size_t ExFatFile::printModifyDateTime(print_t* pr) {
    8354:	push	{r4, lr}
    8356:	sub	sp, #8
    8358:	mov	r4, r1
  uint16_t date;
  uint16_t time;
  if (getModifyDateTime(&date, &time)) {
    835a:	add.w	r2, sp, #6
    835e:	add	r1, sp, #4
    8360:	bl	7934 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
    8364:	cbz	r0, 8374 <ExFatFile::printModifyDateTime(Print*)+0x20>
    return fsPrintDateTime(pr, date, time);
    8366:	mov	r0, r4
    8368:	ldrh.w	r2, [sp, #6]
    836c:	ldrh.w	r1, [sp, #4]
    8370:	bl	78dc <fsPrintDateTime(Print*, unsigned short, unsigned short)>
  }
  return 0;
}
    8374:	add	sp, #8
    8376:	pop	{r4, pc}

00008378 <ExFatFile::printName(Print*)>:
//------------------------------------------------------------------------------
size_t ExFatFile::printName(print_t* pr) {
    8378:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    837c:	add.w	r3, r0, #36	; 0x24
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printName(print_t* pr) {
    8380:	mov	r6, r0
    8382:	mov	r8, r1
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8384:	ldmia.w	r3, {r0, r1, r2}
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printName(print_t* pr) {
    8388:	sub	sp, #36	; 0x24
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  uint8_t in;
  uint8_t buf[15];
  if (!isOpen()) {
    838a:	ldrb.w	r3, [r6, #49]	; 0x31
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::printName(print_t* pr) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    838e:	add	r7, sp, #4
    8390:	stmia.w	r7, {r0, r1, r2}
  size_t n = 0;
  uint8_t in;
  uint8_t buf[15];
  if (!isOpen()) {
    8394:	cmp	r3, #0
    8396:	beq.n	841e <ExFatFile::printName(Print*)+0xa6>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8398:	ldrb.w	r3, [r6, #48]	; 0x30
    839c:	cmp	r3, #1
    839e:	bls.n	841e <ExFatFile::printName(Print*)+0xa6>
    83a0:	movs	r5, #1
    83a2:	mov.w	r9, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
    83a6:	cmp	r5, #1
    83a8:	ite	ne
    83aa:	movne	r2, #32
    83ac:	moveq	r2, #64	; 0x40
    83ae:	mov	r1, r7
    83b0:	ldr	r0, [r6, #32]
    83b2:	bl	8774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    83b6:	cmp	r0, #1
    83b8:	bne.n	841e <ExFatFile::printName(Print*)+0xa6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    83ba:	movs	r2, #0
    83bc:	mov	r1, r7
    83be:	ldr	r0, [r6, #32]
    83c0:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    83c4:	cbz	r0, 841e <ExFatFile::printName(Print*)+0xa6>
    83c6:	ldrb	r3, [r0, #0]
    83c8:	cmp	r3, #193	; 0xc1
    83ca:	bne.n	841e <ExFatFile::printName(Print*)+0xa6>
    83cc:	add.w	r1, sp, #15
    83d0:	add.w	lr, r9, #15
    83d4:	mov	r4, r9
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    83d6:	ldrh.w	r3, [r0, #2]!
    83da:	rsb	r2, r9, r4
    83de:	uxtb	r2, r2
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (!c) {
    83e0:	cbz	r3, 841a <ExFatFile::printName(Print*)+0xa2>
        break;;
      }
      buf[in] = c < 0X7f ? c : '?';
    83e2:	cmp	r3, #126	; 0x7e
      n++;
    83e4:	add.w	r4, r4, #1
    for (in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (!c) {
        break;;
      }
      buf[in] = c < 0X7f ? c : '?';
    83e8:	ite	ls
    83ea:	uxtbls	r3, r3
    83ec:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (in = 0; in < 15; in++) {
    83ee:	cmp	r4, lr
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (!c) {
        break;;
      }
      buf[in] = c < 0X7f ? c : '?';
    83f0:	strb.w	r3, [r1, #1]!
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (in = 0; in < 15; in++) {
    83f4:	bne.n	83d6 <ExFatFile::printName(Print*)+0x5e>
    83f6:	mov	r9, r4
    83f8:	movs	r2, #15
        break;;
      }
      buf[in] = c < 0X7f ? c : '?';
      n++;
    }
    pr->write(buf, in);
    83fa:	ldr.w	r3, [r8]
    83fe:	add	r1, sp, #16
    8400:	ldr	r3, [r3, #4]
    8402:	mov	r0, r8
    8404:	blx	r3
  uint8_t buf[15];
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8406:	adds	r5, #1
    8408:	ldrb.w	r3, [r6, #48]	; 0x30
    840c:	uxtb	r5, r5
    840e:	cmp	r3, r5
    8410:	bhi.n	83a6 <ExFatFile::printName(Print*)+0x2e>
    8412:	mov	r0, r4
  }
  return n;

 fail:
  return 0;
}
    8414:	add	sp, #36	; 0x24
    8416:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (!c) {
    841a:	mov	r9, r4
    841c:	b.n	83fa <ExFatFile::printName(Print*)+0x82>
    pr->write(buf, in);
  }
  return n;

 fail:
  return 0;
    841e:	movs	r0, #0
}
    8420:	add	sp, #36	; 0x24
    8422:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8426:	nop

00008428 <ExFatFile::ls(Print*, unsigned char, unsigned char)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
    8428:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ExFatFile file;
  if (!isDir()) {
    842c:	ldrb.w	r6, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
    8430:	sub	sp, #56	; 0x38
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    8432:	movs	r4, #0
  ExFatFile file;
  if (!isDir()) {
    8434:	tst.w	r6, #80	; 0x50
    8438:	strb.w	r4, [sp, #49]	; 0x31
    843c:	strb.w	r4, [sp, #50]	; 0x32
    8440:	strb.w	r4, [sp, #51]	; 0x33
    8444:	bne.n	844e <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x26>
    goto fail;
  }
  return true;

 fail:
  return false;
    8446:	movs	r0, #0
}
    8448:	add	sp, #56	; 0x38
    844a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    844e:	mov	r9, r0
    8450:	mov	r8, r2
    8452:	mov	r7, r3
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    8454:	movs	r2, #0
    8456:	movs	r3, #0
    8458:	mov	r5, r1
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    845a:	and.w	sl, r8, #2
    845e:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    8462:	movs	r2, #0
    8464:	mov	r1, r9
    8466:	mov	r0, sp
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    8468:	uxtb.w	sl, sl
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    846c:	bl	82b4 <ExFatFile::openNext(ExFatFile*, int)>
    8470:	cmp	r0, #0
    8472:	beq.n	84fc <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xd4>
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
    8474:	ldrb.w	r3, [sp, #49]	; 0x31
    8478:	lsls	r3, r3, #30
    847a:	bpl.n	8482 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x5a>
    847c:	tst.w	r8, #1
    8480:	beq.n	84e8 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xc0>
      for (uint8_t i = 0; i < indent; i++) {
    8482:	movs	r4, #0
    8484:	cbz	r7, 8498 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x70>
        pr->write(' ');
    8486:	ldr	r3, [r5, #0]
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    8488:	adds	r4, #1
        pr->write(' ');
    848a:	movs	r1, #32
    848c:	ldr	r6, [r3, #0]
    848e:	mov	r0, r5
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    8490:	uxtb	r4, r4
        pr->write(' ');
    8492:	blx	r6
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    8494:	cmp	r7, r4
    8496:	bne.n	8486 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x5e>
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    8498:	cmp.w	sl, #0
    849c:	bne.n	8534 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x10c>
        file.printModifyDateTime(pr);
        pr->write(' ');
      }
      if (flags & LS_SIZE) {
    849e:	tst.w	r8, #4
    84a2:	bne.n	8520 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xf8>
        file.printFileSize(pr);
        pr->write(' ');
      }
      file.printName(pr);
    84a4:	mov	r1, r5
    84a6:	mov	r0, sp
    84a8:	bl	8378 <ExFatFile::printName(Print*)>
      if (file.isDir()) {
    84ac:	ldrb.w	r3, [sp, #49]	; 0x31
    84b0:	tst.w	r3, #80	; 0x50
    84b4:	bne.n	8514 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xec>
        pr->write('/');
      }
      pr->write('\r');
    84b6:	ldr	r3, [r5, #0]
    84b8:	movs	r1, #13
    84ba:	ldr	r3, [r3, #0]
    84bc:	mov	r0, r5
    84be:	blx	r3
      pr->write('\n');
    84c0:	ldr	r3, [r5, #0]
    84c2:	movs	r1, #10
    84c4:	ldr	r3, [r3, #0]
    84c6:	mov	r0, r5
    84c8:	blx	r3
      if ((flags & LS_R) && file.isDir()) {
    84ca:	tst.w	r8, #8
    84ce:	beq.n	84e8 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xc0>
    84d0:	ldrb.w	r3, [sp, #49]	; 0x31
    84d4:	tst.w	r3, #80	; 0x50
    84d8:	beq.n	84e8 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0xc0>
        file.ls(pr, flags, indent + 2);
    84da:	adds	r3, r7, #2
    84dc:	uxtb	r3, r3
    84de:	mov	r2, r8
    84e0:	mov	r1, r5
    84e2:	mov	r0, sp
    84e4:	bl	8428 <ExFatFile::ls(Print*, unsigned char, unsigned char)>
      }
    }
    file.close();
    84e8:	mov	r0, sp
    84ea:	bl	7920 <ExFatFile::close()>
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    84ee:	movs	r2, #0
    84f0:	mov	r1, r9
    84f2:	mov	r0, sp
    84f4:	bl	82b4 <ExFatFile::openNext(ExFatFile*, int)>
    84f8:	cmp	r0, #0
    84fa:	bne.n	8474 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x4c>
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime);
  /** \return All error bits. */
  uint8_t getError() const {
    return isOpen() ? m_error : 0XFF;
    84fc:	ldrb.w	r3, [r9, #49]	; 0x31
    8500:	cmp	r3, #0
    8502:	beq.n	8446 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x1e>
        file.ls(pr, flags, indent + 2);
      }
    }
    file.close();
  }
  if (getError()) {
    8504:	ldrb.w	r0, [r9, #50]	; 0x32
    8508:	clz	r0, r0
    850c:	lsrs	r0, r0, #5
  }
  return true;

 fail:
  return false;
}
    850e:	add	sp, #56	; 0x38
    8510:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        file.printFileSize(pr);
        pr->write(' ');
      }
      file.printName(pr);
      if (file.isDir()) {
        pr->write('/');
    8514:	ldr	r3, [r5, #0]
    8516:	movs	r1, #47	; 0x2f
    8518:	ldr	r3, [r3, #0]
    851a:	mov	r0, r5
    851c:	blx	r3
    851e:	b.n	84b6 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x8e>
      if (flags & LS_DATE) {
        file.printModifyDateTime(pr);
        pr->write(' ');
      }
      if (flags & LS_SIZE) {
        file.printFileSize(pr);
    8520:	mov	r1, r5
    8522:	mov	r0, sp
    8524:	bl	82f4 <ExFatFile::printFileSize(Print*)>
        pr->write(' ');
    8528:	ldr	r3, [r5, #0]
    852a:	movs	r1, #32
    852c:	ldr	r3, [r3, #0]
    852e:	mov	r0, r5
    8530:	blx	r3
    8532:	b.n	84a4 <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x7c>
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
        file.printModifyDateTime(pr);
    8534:	mov	r1, r5
    8536:	mov	r0, sp
    8538:	bl	8354 <ExFatFile::printModifyDateTime(Print*)>
        pr->write(' ');
    853c:	ldr	r3, [r5, #0]
    853e:	movs	r1, #32
    8540:	ldr	r3, [r3, #0]
    8542:	mov	r0, r5
    8544:	blx	r3
    8546:	b.n	849e <ExFatFile::ls(Print*, unsigned char, unsigned char)+0x76>

00008548 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>:
    }
  }
  return 1;
}
//------------------------------------------------------------------------------
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    8548:	push	{r3, r4, r5, lr}
    854a:	mov	r4, r1
    854c:	ldr.w	r1, [r0, #1060]	; 0x424
    8550:	mov	r5, r2
    8552:	add.w	r1, r1, r4, lsr #7
    8556:	add.w	r0, r0, #528	; 0x210
    855a:	movs	r2, #0
    855c:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    return -1;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    8560:	cbz	r0, 8574 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x2c>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    8562:	lsls	r4, r4, #2
    8564:	ubfx	r4, r4, #0, #9
    8568:	ldr	r3, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    856a:	adds	r2, r3, #1
    856c:	beq.n	8578 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x30>
    return 0;
  }
  *value = next;
    856e:	str	r3, [r5, #0]
  return 1;
    8570:	movs	r0, #1
    8572:	pop	{r3, r4, r5, pc}
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    return -1;
    8574:	movs	r0, #255	; 0xff
    8576:	pop	{r3, r4, r5, pc}
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    return 0;
    8578:	movs	r0, #0
  }
  *value = next;
  return 1;
}
    857a:	pop	{r3, r4, r5, pc}

0000857c <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    857c:	push	{r3, r4, r5, lr}
    857e:	mov	r4, r1
    8580:	ldr.w	r1, [r0, #1060]	; 0x424
    8584:	mov	r5, r2
    8586:	add.w	r1, r1, r4, lsr #7
    858a:	add.w	r0, r0, #528	; 0x210
    858e:	movs	r2, #1
    8590:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    8594:	mov	r3, r0
    8596:	cbz	r0, 85a4 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]+0x28>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    8598:	lsls	r4, r4, #2
    859a:	ubfx	r4, r4, #0, #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    859e:	movs	r0, #1
    85a0:	str	r5, [r3, r4]
    85a2:	pop	{r3, r4, r5, pc}

 fail:
  return false;
}
    85a4:	pop	{r3, r4, r5, pc}
    85a6:	nop

000085a8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    85a8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    85ac:	mov	r8, r0
    85ae:	mov	r9, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    85b0:	mov	fp, r1
    85b2:	cmp	r1, #0
    85b4:	beq.n	8640 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x98>
    85b6:	subs	r7, r1, #2
  if (start >= m_clusterCount) {
    85b8:	ldr.w	r3, [r8, #1072]	; 0x430
    85bc:	cmp	r7, r3
    85be:	bcs.n	8638 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x90>
    85c0:	and.w	r5, r7, #7
    85c4:	movs	r3, #1
    85c6:	lsl.w	r5, r3, r5
    85ca:	uxtb	r5, r5
    85cc:	ubfx	sl, r7, #3, #9
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    85d0:	mov	r6, r7
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    85d2:	mov	r4, r7
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    85d4:	ldr.w	r1, [r8, #1068]	; 0x42c
    85d8:	movs	r2, #0
    85da:	add.w	r1, r1, r4, lsr #12
    85de:	mov	r0, r8
    85e0:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    85e4:	cbz	r0, 8618 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
    85e6:	ldrb.w	r1, [r0, sl]
    85ea:	b.n	8602 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x5a>
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    85ec:	cmp	r2, r9
    85ee:	beq.n	8646 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x9e>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    85f0:	cmp	r7, r4
    85f2:	beq.n	8616 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    85f4:	ldr.w	r2, [r8, #1072]	; 0x430
    85f8:	cmp	r4, r2
    85fa:	bcs.n	862c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x84>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    85fc:	ands.w	r5, r3, #255	; 0xff
    8600:	beq.n	861c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x74>
        endAlloc++;
    8602:	adds	r4, #1
        if (!(mask & cache[i])) {
    8604:	tst	r5, r1
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    8606:	mov.w	r3, r5, lsl #1
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    860a:	sub.w	r2, r4, r6
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    860e:	beq.n	85ec <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x44>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    8610:	cmp	r7, r4
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    8612:	mov	r6, r4
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    8614:	bne.n	85f4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4c>
          return 1;
    8616:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    8618:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    861c:	add.w	sl, sl, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    8620:	cmp.w	sl, #512	; 0x200
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    8624:	mov.w	r5, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    8628:	bne.n	85e6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x3e>
    862a:	b.n	8630 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x88>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    862c:	movs	r6, #0
    862e:	mov	r4, r6
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    8630:	mov.w	sl, #0
    8634:	movs	r5, #1
    8636:	b.n	85d4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x2c>
    8638:	movs	r7, #0
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
    863a:	mov	sl, r7
    863c:	movs	r5, #1
    863e:	b.n	85d0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x28>
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    8640:	ldr.w	r7, [r0, #1056]	; 0x420
    8644:	b.n	85b8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
            if (cluster == 0 && count == 1) {
    8646:	cmp.w	fp, #0
    864a:	bne.n	8656 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xae>
    864c:	cmp.w	r9, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    8650:	it	eq
    8652:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    8656:	adds	r0, r6, #2
    8658:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    865c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector;
  uint32_t start = cluster - 2;
    8660:	subs	r1, #2
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    8662:	mov	r8, r0
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    8664:	ldr.w	r0, [r0, #1072]	; 0x430
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    8668:	mov	r5, r2
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    866a:	adds	r2, r1, r2
    866c:	cmp	r2, r0
    866e:	bhi.n	86e2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    8670:	mov	sl, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    8672:	ldr.w	r3, [r8, #1056]	; 0x420
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    8676:	cmp.w	sl, #0
    867a:	bne.n	86e8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x8c>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    }
  } else {
    if (start < m_bitmapStart) {
    867c:	cmp	r1, r3
      m_bitmapStart = start;
    867e:	it	cc
    8680:	strcc.w	r1, [r8, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    8684:	and.w	r4, r1, #7
    8688:	movs	r2, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    868a:	ldr.w	r3, [r8, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    868e:	lsl.w	r4, r2, r4
    8692:	uxtb	r4, r4
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    8694:	add.w	r9, r3, r1, lsr #12
  i = (start >> 3) & m_sectorMask;
    8698:	ubfx	r6, r1, #3, #9
    869c:	movs	r2, #1
    869e:	mov	r1, r9
    86a0:	mov	r0, r8
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    86a2:	add	r9, r2
    86a4:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    86a8:	cbz	r0, 86e2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    86aa:	adds	r7, r0, r6
    86ac:	add.w	r0, r0, #512	; 0x200
    86b0:	ldrb.w	r2, [r7], #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    86b4:	tst	r2, r4
    86b6:	ite	ne
    86b8:	movne	r6, #1
    86ba:	moveq	r6, #0
    86bc:	cmp	r6, sl
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    86be:	eor.w	r2, r2, r4
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    86c2:	mov.w	r4, r4, lsl #1
        if (value == static_cast<bool>(cache[i] & mask)) {
    86c6:	beq.n	86e2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
    86c8:	subs	r5, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    86ca:	strb.w	r2, [r7, #-1]
        if (--count == 0) {
    86ce:	beq.n	86fc <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    86d0:	ands.w	r4, r4, #255	; 0xff
    86d4:	bne.n	86b4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x58>
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    86d6:	cmp	r0, r7
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    86d8:	mov	r6, r4
    86da:	mov.w	r4, #1
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    86de:	bne.n	86b0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    86e0:	b.n	869c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x40>
    }
    i = 0;
  }

 fail:
  return false;
    86e2:	movs	r0, #0
    86e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    86e8:	cmp	r1, r3
    86ea:	bhi.n	8684 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
    86ec:	cmp	r2, r3
    86ee:	bls.n	8684 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    86f0:	cmp	r2, r0
    86f2:	it	cs
    86f4:	movcs	r2, #0
    86f6:	str.w	r2, [r8, #1056]	; 0x420
    86fa:	b.n	8684 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    86fc:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    86fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8702:	nop

00008704 <ExFatPartition::chainSize(unsigned long)>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    8704:	push	{r4, r5, r6, lr}
    8706:	sub	sp, #8
    8708:	add	r6, sp, #8
    870a:	mov	r5, r0
    870c:	str.w	r1, [r6, #-4]!
  uint32_t n = 0;
    8710:	movs	r4, #0
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8712:	ldr.w	r3, [r5, #1072]	; 0x430
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    8716:	ldr	r1, [sp, #4]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8718:	adds	r3, #1
    871a:	cmp	r1, r3
    871c:	bls.n	8724 <ExFatPartition::chainSize(unsigned long)+0x20>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    871e:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    8720:	add	sp, #8
    8722:	pop	{r4, r5, r6, pc}
    8724:	mov	r2, r6
    8726:	mov	r0, r5
    8728:	bl	8548 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    872c:	sxtb	r0, r0
    if (status < 0) return 0;
    872e:	cmp	r0, #0
    8730:	blt.n	871e <ExFatPartition::chainSize(unsigned long)+0x1a>
    n++;
    8732:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    8736:	bne.n	8712 <ExFatPartition::chainSize(unsigned long)+0xe>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    8738:	mov	r0, r4
  } while (status);
  return n;
}
    873a:	add	sp, #8
    873c:	pop	{r4, r5, r6, pc}
    873e:	nop

00008740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    8740:	push	{r3, r4, r5, r6, r7, lr}
    8742:	mov	r6, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    8744:	ldmia.w	r6, {r3, r5}
    8748:	ldr.w	r1, [r0, #1080]	; 0x438
    874c:	ldr.w	r4, [r0, #1068]	; 0x42c
    8750:	ldrb.w	r7, [r0, #1093]	; 0x445
    8754:	ands	r1, r5
    8756:	subs	r3, #2
    8758:	add.w	r1, r4, r1, lsr #9
    875c:	lsls	r3, r7
    875e:	add	r1, r3
    8760:	add.w	r0, r0, #528	; 0x210
    8764:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    8768:	cbz	r0, 8772 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x32>
    876a:	ldr	r3, [r6, #4]
    876c:	ubfx	r3, r3, #0, #9
    8770:	add	r0, r3
}
    8772:	pop	{r3, r4, r5, r6, r7, pc}

00008774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8774:	push	{r4, r5, r6, lr}
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8776:	ldr	r4, [r1, #4]
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8778:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
    877a:	adds	r3, r4, r2
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    877c:	ldr.w	r1, [r0, #1080]	; 0x438
  pos->position += offset;
    8780:	str	r3, [r5, #4]
  tmp >>= bytesPerClusterShift();
    8782:	ldrb.w	r3, [r0, #1093]	; 0x445
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8786:	ands	r4, r1
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    8788:	adds	r3, #9
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    878a:	add	r2, r4
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    878c:	uxtb	r3, r3
    878e:	lsr.w	r4, r2, r3
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8792:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    8794:	cbz	r4, 87a6 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x32>
    if (pos->isContiguous) {
    8796:	ldrb	r3, [r5, #8]
    8798:	cbz	r3, 87aa <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x36>
      pos->cluster++;
    879a:	ldr	r3, [r5, #0]
    879c:	adds	r3, #1
    879e:	str	r3, [r5, #0]
    87a0:	subs	r4, #1
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    87a2:	cmp	r4, #0
    87a4:	bne.n	8796 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x22>
      if (status != 1) {
        return status;
      }
    }
  }
  return 1;
    87a6:	movs	r0, #1
    87a8:	pop	{r4, r5, r6, pc}
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    87aa:	ldr.w	r3, [r6, #1072]	; 0x430
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    87ae:	ldr	r1, [r5, #0]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    87b0:	adds	r3, #1
    87b2:	cmp	r1, r3
    87b4:	bls.n	87bc <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x48>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    87b6:	mov.w	r0, #4294967295
        return status;
      }
    }
  }
  return 1;
}
    87ba:	pop	{r4, r5, r6, pc}
    87bc:	mov	r2, r5
    87be:	mov	r0, r6
    87c0:	bl	8548 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    87c4:	sxtb	r0, r0
      if (status != 1) {
    87c6:	cmp	r0, #1
    87c8:	beq.n	87a0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    87ca:	pop	{r4, r5, r6, pc}

000087cc <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    87cc:	ldr.w	r3, [r0, #1072]	; 0x430
    87d0:	adds	r3, #1
    87d2:	cmp	r3, r1
    87d4:	bcs.n	87da <ExFatPartition::fatGet(unsigned long, unsigned long*)+0xe>
  if (next == EXFAT_EOC) {
    return 0;
  }
  *value = next;
  return 1;
}
    87d6:	movs	r0, #255	; 0xff
    87d8:	bx	lr
    87da:	b.w	8548 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
    87de:	nop

000087e0 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    87e0:	cmp	r1, #1
    87e2:	bls.n	8800 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x20>
    87e4:	ldr.w	r3, [r0, #1072]	; 0x430
    87e8:	adds	r3, #1
    87ea:	cmp	r1, r3
  }
  *value = next;
  return 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    87ec:	push	{r4}
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    87ee:	bls.n	87f8 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x18>
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
}
    87f0:	movs	r0, #0
    87f2:	ldr.w	r4, [sp], #4
    87f6:	bx	lr
    87f8:	ldr.w	r4, [sp], #4
    87fc:	b.w	857c <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    8800:	movs	r0, #0
    8802:	bx	lr

00008804 <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    8804:	push	{r4, r5, r6, r7, lr}
    8806:	mov	r4, r1
    8808:	sub	sp, #12
    880a:	mov	r5, r0
  uint32_t next;
  uint32_t start = cluster;
    880c:	mov	r6, r1
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    880e:	ldr.w	r3, [r5, #1072]	; 0x430
    8812:	adds	r3, #1
    8814:	cmp	r4, r3
    8816:	bls.n	881e <ExFatPartition::freeChain(unsigned long)+0x1a>
  } while (status);

  return true;

 fail:
  return false;
    8818:	movs	r0, #0
}
    881a:	add	sp, #12
    881c:	pop	{r4, r5, r6, r7, pc}
    881e:	add	r2, sp, #4
    8820:	mov	r1, r4
    8822:	mov	r0, r5
    8824:	bl	8548 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    8828:	sxtb	r7, r0
    if (status < 0) {
    882a:	cmp	r7, #0
    882c:	blt.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    882e:	cmp	r4, #1
    8830:	bls.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>
    8832:	ldr.w	r3, [r5, #1072]	; 0x430
    8836:	adds	r3, #1
    8838:	cmp	r4, r3
    883a:	bhi.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>
    883c:	movs	r2, #0
    883e:	mov	r1, r4
    8840:	mov	r0, r5
    8842:	bl	857c <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    8846:	cmp	r0, #0
    8848:	beq.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    884a:	ldr	r3, [sp, #4]
    884c:	adds	r4, #1
    884e:	cmp	r4, r3
    8850:	bne.n	886a <ExFatPartition::freeChain(unsigned long)+0x66>
    8852:	cmp	r7, #0
    8854:	bne.n	880e <ExFatPartition::freeChain(unsigned long)+0xa>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    8856:	mov	r3, r7
    8858:	subs	r2, r4, r6
    885a:	mov	r1, r6
    885c:	mov	r0, r5
    885e:	bl	865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8862:	cmp	r0, #0
    8864:	beq.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>

  return true;

 fail:
  return false;
}
    8866:	add	sp, #12
    8868:	pop	{r4, r5, r6, r7, pc}
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    886a:	subs	r2, r4, r6
    886c:	mov	r1, r6
    886e:	movs	r3, #0
    8870:	mov	r0, r5
    8872:	bl	865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8876:	cmp	r0, #0
    8878:	beq.n	8818 <ExFatPartition::freeChain(unsigned long)+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    887a:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    887c:	cmp	r7, #0
    887e:	beq.n	881a <ExFatPartition::freeChain(unsigned long)+0x16>
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    8880:	mov	r6, r4
    8882:	b.n	880e <ExFatPartition::freeChain(unsigned long)+0xa>

00008884 <ExFatPartition::freeClusterCount()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    8884:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
    8888:	movs	r4, #0
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    888a:	ldr.w	r6, [r0, #1068]	; 0x42c

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    888e:	mov	r8, r0
    8890:	add.w	r7, r0, #528	; 0x210
  uint32_t nc = 0;
    8894:	mov	r5, r4
    8896:	mov	r1, r6
    8898:	movs	r2, #0
    889a:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    889c:	adds	r6, #1
    889e:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    88a2:	cbz	r0, 88f2 <ExFatPartition::freeClusterCount()+0x6e>
    88a4:	add.w	lr, r0, #4294967295
    88a8:	ldr.w	ip, [r8, #1072]	; 0x430
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    88ac:	ldrb.w	r0, [lr, #1]!
    88b0:	cmp	r0, #255	; 0xff
    88b2:	add.w	r9, r5, #4096	; 0x1000
    88b6:	beq.n	88e0 <ExFatPartition::freeClusterCount()+0x5c>
        usedCount+= 8;
      } else if (cache[i]) {
    88b8:	cbz	r0, 88ce <ExFatPartition::freeClusterCount()+0x4a>
    88ba:	movs	r2, #8
    88bc:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    88be:	tst	r0, r3
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    88c0:	mov.w	r1, r3, lsl #1
          if ((mask & cache[i])) {
            usedCount++;
    88c4:	it	ne
    88c6:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    88c8:	subs	r2, #1
    88ca:	uxtb	r3, r1
    88cc:	bne.n	88be <ExFatPartition::freeClusterCount()+0x3a>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    88ce:	adds	r5, #8
      if (nc >= m_clusterCount) {
    88d0:	cmp	ip, r5
    88d2:	bls.n	88ea <ExFatPartition::freeClusterCount()+0x66>
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    88d4:	cmp	r5, r9
    88d6:	beq.n	8896 <ExFatPartition::freeClusterCount()+0x12>
      if (cache[i] == 0XFF) {
    88d8:	ldrb.w	r0, [lr, #1]!
    88dc:	cmp	r0, #255	; 0xff
    88de:	bne.n	88b8 <ExFatPartition::freeClusterCount()+0x34>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    88e0:	adds	r5, #8
      if (nc >= m_clusterCount) {
    88e2:	cmp	ip, r5
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
    88e4:	add.w	r4, r4, #8
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    88e8:	bhi.n	88d4 <ExFatPartition::freeClusterCount()+0x50>
        return m_clusterCount - usedCount;
    88ea:	rsb	r0, r4, ip
    88ee:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }
}
    88f2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    88f6:	nop

000088f8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    88f8:	push	{r3, r4, r5, r6, r7, lr}
    88fa:	mov	r4, r0
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    88fc:	movs	r3, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    88fe:	mov.w	r6, #4294967295
    8902:	add.w	r7, r0, #528	; 0x210
  m_blockDev = dev;
    8906:	str.w	r1, [r0, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    890a:	str	r1, [r0, #4]
    890c:	str.w	r1, [r0, #532]	; 0x214
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    8910:	mov	r5, r2
    8912:	mov	r0, r7
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    8914:	strb.w	r3, [r4, #1092]	; 0x444
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    8918:	strb	r3, [r4, #0]
    891a:	strb.w	r3, [r4, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    891e:	str	r6, [r4, #12]
    8920:	str.w	r6, [r4, #540]	; 0x21c
    8924:	mov	r2, r3
    8926:	mov	r1, r3
    8928:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    892c:	cmp	r5, #4
    892e:	bhi.n	894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    8930:	mov	r6, r0
    8932:	cbz	r0, 894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    8934:	cbnz	r5, 894e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    8936:	movs	r2, #5
    8938:	ldr	r1, [pc, #152]	; (89d4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xdc>)
    893a:	adds	r0, r6, #3
    893c:	bl	1075c <strncmp>
    8940:	cbnz	r0, 894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    8942:	ldrb.w	r3, [r6, #108]	; 0x6c
    8946:	cmp	r3, #9
    8948:	beq.n	897e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x86>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    894a:	movs	r0, #0
    894c:	pop	{r3, r4, r5, r6, r7, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    894e:	subs	r3, r5, #1
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    8950:	add.w	r3, r0, r3, lsl #4
    8954:	ldrb.w	r2, [r3, #446]	; 0x1be
    8958:	ands.w	r2, r2, #127	; 0x7f
    895c:	bne.n	894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    895e:	ldrb.w	r3, [r3, #450]	; 0x1c2
    8962:	cmp	r3, #0
    8964:	beq.n	894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    8966:	add.w	r5, r0, r5, lsl #4
    896a:	mov	r0, r7
    896c:	ldr.w	r5, [r5, #438]	; 0x1b6
    8970:	mov	r1, r5
    8972:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
    8976:	mov	r6, r0
    8978:	cmp	r0, #0
    897a:	bne.n	8936 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x3e>
    897c:	b.n	894a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    897e:	ldr	r3, [r6, #80]	; 0x50
    8980:	add	r3, r5
    8982:	str.w	r3, [r4, #1060]	; 0x424
    8986:	ldr	r3, [r6, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    8988:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    898c:	ldr	r3, [r6, #88]	; 0x58
    898e:	add	r5, r3
    8990:	str.w	r5, [r4, #1068]	; 0x42c
    8994:	ldr	r3, [r6, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    8996:	str.w	r3, [r4, #1072]	; 0x430
    899a:	ldr	r3, [r6, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    899c:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    89a0:	ldrb.w	r3, [r6, #109]	; 0x6d
    89a4:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    89a8:	movs	r5, #1
    89aa:	adds	r3, #9
    89ac:	lsl.w	r3, r5, r3
  m_clusterMask = m_bytesPerCluster - 1;
    89b0:	subs	r2, r3, #1
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    89b2:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    89b6:	mov	r1, r0
  m_fatLength = getLe32(bpb->fatLength);
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
  m_clusterCount = getLe32(bpb->clusterCount);
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    89b8:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    89bc:	str.w	r2, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
  bitmapFind(0, 1);
    89c0:	mov	r0, r4
    89c2:	mov	r2, r5
    89c4:	bl	85a8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    89c8:	movs	r3, #64	; 0x40
    89ca:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    89ce:	mov	r0, r5

 fail:
  return false;
}
    89d0:	pop	{r3, r4, r5, r6, r7, pc}
    89d2:	nop
    89d4:	.word	0x20000584

000089d8 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    89d8:	push	{r4, lr}
    89da:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    89dc:	ldr.w	r1, [r0, #1076]	; 0x434
    89e0:	bl	8704 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    89e4:	ldrb.w	r3, [r4, #1093]	; 0x445
    89e8:	adds	r3, #9
    89ea:	uxtb	r3, r3
}
    89ec:	lsls	r0, r3
    89ee:	pop	{r4, pc}

000089f0 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>:
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    89f0:	cbz	r3, 8a44 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x54>
  }
  return true;
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
    89f2:	push	{r4, r5, r6}
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    89f4:	ldrh	r4, [r0, #2]
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    89f6:	cmp	r4, #126	; 0x7e
    89f8:	bhi.n	8a38 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
    89fa:	add	r3, r2
    89fc:	adds	r5, r1, r3
    89fe:	add	r2, r1
    8a00:	adds	r0, #2
    8a02:	ldrb.w	r3, [r2], #1
    8a06:	uxtb	r4, r4
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    8a08:	sub.w	r1, r3, #97	; 0x61
    8a0c:	cmp	r1, #25
    8a0e:	sub.w	r1, r4, #97	; 0x61
    8a12:	ite	ls
    8a14:	movls	r6, #32
    8a16:	movhi	r6, #0
    8a18:	cmp	r1, #25
    8a1a:	ite	ls
    8a1c:	movls	r1, #32
    8a1e:	movhi	r1, #0
    8a20:	subs	r3, r3, r6
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    8a22:	subs	r4, r4, r1
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    8a24:	uxtb	r3, r3
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    8a26:	uxtb	r4, r4
    8a28:	cmp	r4, r3
    8a2a:	bne.n	8a38 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    8a2c:	cmp	r2, r5
    8a2e:	beq.n	8a3e <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x4e>
    8a30:	ldrh.w	r4, [r0, #2]!
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    8a34:	cmp	r4, #126	; 0x7e
    8a36:	bls.n	8a02 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x12>
      return false;
    8a38:	movs	r0, #0
    }
  }
  return true;
}
    8a3a:	pop	{r4, r5, r6}
    8a3c:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    8a3e:	movs	r0, #1
}
    8a40:	pop	{r4, r5, r6}
    8a42:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    8a44:	movs	r0, #1
}
    8a46:	bx	lr

00008a48 <exFatHashName(char const*, unsigned int, unsigned short)>:
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    8a48:	cbz	r1, 8a7e <exFatHashName(char const*, unsigned int, unsigned short)+0x36>
    hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
    8a4a:	push	{r4}
    8a4c:	add	r1, r0
    8a4e:	lsls	r3, r2, #15
    8a50:	orr.w	r3, r3, r2, lsr #1
  for (size_t i = 0; i < n; i++) {
    uint8_t c = name[i];
    8a54:	ldrb.w	r2, [r0], #1
    if ('a' <= c && c <= 'z') {
    8a58:	sub.w	r4, r2, #97	; 0x61
    8a5c:	cmp	r4, #25
      c -= 'a' - 'A';
    8a5e:	itt	ls
    8a60:	subls	r2, #32
    8a62:	uxtbls	r2, r2
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    8a64:	uxtah	r2, r2, r3
    8a68:	uxth	r2, r2
    8a6a:	lsls	r3, r2, #15
    8a6c:	orr.w	r2, r3, r2, lsr #1
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    8a70:	cmp	r1, r0
    8a72:	uxth	r2, r2
    8a74:	bne.n	8a4e <exFatHashName(char const*, unsigned int, unsigned short)+0x6>
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    hash = ((hash << 15) | (hash >> 1));
  }
  return hash;
}
    8a76:	mov	r0, r2
    8a78:	ldr.w	r4, [sp], #4
    8a7c:	bx	lr
    8a7e:	mov	r0, r2
    8a80:	bx	lr
    8a82:	nop

00008a84 <ExFatFile::addCluster()>:
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    8a84:	ldr	r1, [r0, #24]
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    8a86:	push	{r3, r4, r5, r6, r7, lr}
    8a88:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    8a8a:	ldr	r0, [r0, #32]
    8a8c:	cbz	r1, 8a90 <ExFatFile::addCluster()+0xc>
    8a8e:	adds	r1, #1
    8a90:	movs	r2, #1
    8a92:	bl	85a8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    8a96:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    8a98:	mov	r6, r0
  if (find < 2) {
    8a9a:	bls.n	8afc <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    8a9c:	movs	r3, #1
    8a9e:	mov	r1, r0
    8aa0:	mov	r2, r3
    8aa2:	ldr	r0, [r4, #32]
    8aa4:	bl	865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8aa8:	mov	r7, r0
    8aaa:	cbz	r0, 8afc <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    8aac:	ldr	r0, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    8aae:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    8ab2:	cbz	r0, 8b02 <ExFatFile::addCluster()+0x7e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    goto done;
  }
  if (isContiguous()) {
    8ab4:	lsls	r2, r3, #25
    8ab6:	bpl.n	8ae0 <ExFatFile::addCluster()+0x5c>
    if (find == (m_curCluster + 1)) {
    8ab8:	adds	r2, r0, #1
    8aba:	cmp	r6, r2
    8abc:	beq.n	8b0a <ExFatFile::addCluster()+0x86>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    8abe:	bic.w	r2, r3, #64	; 0x40
    8ac2:	strb.w	r2, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    8ac6:	ldr	r3, [r4, #28]
    8ac8:	b.n	8ad6 <ExFatFile::addCluster()+0x52>
      if (!m_vol->fatPut(c, c + 1)) {
    8aca:	ldr	r0, [r4, #32]
    8acc:	bl	87e0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    8ad0:	cbz	r0, 8afc <ExFatFile::addCluster()+0x78>
    8ad2:	ldr	r0, [r4, #24]
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    8ad4:	mov	r3, r5
      if (!m_vol->fatPut(c, c + 1)) {
    8ad6:	adds	r5, r3, #1
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    8ad8:	cmp	r3, r0
      if (!m_vol->fatPut(c, c + 1)) {
    8ada:	mov	r1, r3
    8adc:	mov	r2, r5
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    8ade:	bcc.n	8aca <ExFatFile::addCluster()+0x46>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    8ae0:	mov.w	r2, #4294967295
    8ae4:	mov	r1, r6
    8ae6:	ldr	r0, [r4, #32]
    8ae8:	bl	87e0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    8aec:	cbz	r0, 8afc <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    8aee:	ldr	r1, [r4, #24]
    8af0:	cbz	r1, 8b0a <ExFatFile::addCluster()+0x86>
    if (!m_vol->fatPut(m_curCluster, find)) {
    8af2:	mov	r2, r6
    8af4:	ldr	r0, [r4, #32]
    8af6:	bl	87e0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    8afa:	cbnz	r0, 8b0a <ExFatFile::addCluster()+0x86>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    8afc:	movs	r7, #0
}
    8afe:	mov	r0, r7
    8b00:	pop	{r3, r4, r5, r6, r7, pc}
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    8b02:	orr.w	r3, r3, #64	; 0x40
    8b06:	strb.w	r3, [r4, #51]	; 0x33
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    8b0a:	str	r6, [r4, #24]
  return true;

 fail:
  return false;
}
    8b0c:	mov	r0, r7
    8b0e:	pop	{r3, r4, r5, r6, r7, pc}

00008b10 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    8b10:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirPos_t pos = m_dirPos;
    8b14:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    8b18:	mov	r5, r0
  DirPos_t pos = m_dirPos;
    8b1a:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    8b1e:	sub	sp, #20
    8b20:	ldrb.w	r3, [r5, #51]	; 0x33
  DirPos_t pos = m_dirPos;
    8b24:	add	r6, sp, #4
    8b26:	stmia.w	r6, {r0, r1, r2}
  uint8_t* cache;
  if (!isWritable()) {
    8b2a:	lsls	r2, r3, #30
    8b2c:	bpl.n	8b66 <ExFatFile::remove()+0x56>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    8b2e:	ldr	r1, [r5, #28]
    8b30:	cbnz	r1, 8b6e <ExFatFile::remove()+0x5e>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    8b32:	movs	r4, #0
  for (uint8_t i = 0; i <= m_setCount; i++) {
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    8b34:	movs	r2, #1
    8b36:	mov	r1, r6
    8b38:	ldr	r0, [r5, #32]
    8b3a:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    8b3e:	adds	r4, #1
    8b40:	uxtb	r4, r4
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    8b42:	cbz	r0, 8b66 <ExFatFile::remove()+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    8b44:	ldrb	r3, [r0, #0]
    8b46:	and.w	r3, r3, #127	; 0x7f
    8b4a:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    8b4c:	ldrb.w	r3, [r5, #48]	; 0x30
    8b50:	cmp	r3, r4
    8b52:	bcc.n	8bb8 <ExFatFile::remove()+0xa8>
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
    8b54:	cmp	r4, #0
    8b56:	beq.n	8b34 <ExFatFile::remove()+0x24>
    8b58:	movs	r2, #32
    8b5a:	mov	r1, r6
    8b5c:	ldr	r0, [r5, #32]
    8b5e:	bl	8774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    8b62:	cmp	r0, #1
    8b64:	beq.n	8b34 <ExFatFile::remove()+0x24>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    8b66:	movs	r0, #0
}
    8b68:	add	sp, #20
    8b6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    8b6e:	lsls	r3, r3, #25
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    8b70:	ldr	r0, [r5, #32]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    8b72:	bpl.n	8bae <ExFatFile::remove()+0x9e>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    8b74:	ldrd	r2, r3, [r5, #8]
    8b78:	ldrb.w	r4, [r0, #1093]	; 0x445
    8b7c:	adds	r4, #9
    8b7e:	uxtb	r4, r4
    8b80:	adds.w	r8, r2, #4294967295
    8b84:	adc.w	r9, r3, #4294967295
    8b88:	rsb	r7, r4, #32
    8b8c:	lsl.w	r7, r9, r7
    8b90:	lsr.w	r2, r8, r4
    8b94:	sub.w	r3, r4, #32
    8b98:	lsr.w	r3, r9, r3
    8b9c:	orrs	r2, r7
    8b9e:	orrs	r2, r3
    8ba0:	adds	r2, #1
    8ba2:	movs	r3, #0
    8ba4:	bl	865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8ba8:	cmp	r0, #0
    8baa:	bne.n	8b32 <ExFatFile::remove()+0x22>
    8bac:	b.n	8b66 <ExFatFile::remove()+0x56>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    8bae:	bl	8804 <ExFatPartition::freeChain(unsigned long)>
    8bb2:	cmp	r0, #0
    8bb4:	bne.n	8b32 <ExFatFile::remove()+0x22>
    8bb6:	b.n	8b66 <ExFatFile::remove()+0x56>
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  return m_vol->cacheSync();
    8bb8:	ldr	r4, [r5, #32]
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    8bba:	movs	r3, #0
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    8bbc:	mov	r0, r4
    8bbe:	strb.w	r3, [r5, #49]	; 0x31
  m_flags = 0;
    8bc2:	strb.w	r3, [r5, #51]	; 0x33
    8bc6:	bl	779c <FsCache::sync()>
    8bca:	cmp	r0, #0
    8bcc:	beq.n	8b66 <ExFatFile::remove()+0x56>
    8bce:	add.w	r0, r4, #528	; 0x210
    8bd2:	bl	779c <FsCache::sync()>
    8bd6:	cmp	r0, #0
    8bd8:	beq.n	8b66 <ExFatFile::remove()+0x56>
    8bda:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    8bde:	ldr	r3, [r0, #0]
    8be0:	ldr	r3, [r3, #24]
    8be2:	blx	r3
    8be4:	b.n	8b68 <ExFatFile::remove()+0x58>
    8be6:	nop

00008be8 <ExFatFile::rmdir()>:
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    8be8:	ldrb.w	r3, [r0, #49]	; 0x31
    8bec:	lsls	r1, r3, #27
    8bee:	bmi.n	8bf4 <ExFatFile::rmdir()+0xc>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    8bf0:	movs	r0, #0
}
    8bf2:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    8bf4:	push	{r4, lr}
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    8bf6:	movs	r2, #0
    8bf8:	sub	sp, #32
    8bfa:	movs	r3, #0
    8bfc:	mov	r4, r0
    8bfe:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
    8c02:	b.n	8c12 <ExFatFile::rmdir()+0x2a>
  while (1) {
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    8c04:	cmp	r0, #32
    8c06:	bne.n	8c3c <ExFatFile::rmdir()+0x54>
    8c08:	ldrb.w	r3, [sp]
    8c0c:	lsls	r2, r3, #24
    8c0e:	bmi.n	8c3c <ExFatFile::rmdir()+0x54>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    8c10:	cbz	r3, 8c20 <ExFatFile::rmdir()+0x38>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    8c12:	movs	r2, #32
    8c14:	mov	r1, sp
    8c16:	mov	r0, r4
    8c18:	bl	7af0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    8c1c:	cmp	r0, #0
    8c1e:	bne.n	8c04 <ExFatFile::rmdir()+0x1c>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    8c20:	ldrb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    8c24:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    8c26:	orr.w	r3, r3, #2
    8c2a:	strb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    8c2e:	strb.w	r2, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    8c32:	mov	r0, r4
    8c34:	bl	8b10 <ExFatFile::remove()>

 fail:
  return false;
}
    8c38:	add	sp, #32
    8c3a:	pop	{r4, pc}
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    8c3c:	movs	r0, #0
}
    8c3e:	add	sp, #32
    8c40:	pop	{r4, pc}
    8c42:	nop

00008c44 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    8c44:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    8c48:	add.w	fp, r0, #36	; 0x24
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    8c4c:	mov	r6, r0
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    8c4e:	ldmia.w	fp, {r0, r1, r2}
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    8c52:	sub	sp, #28
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    8c54:	add.w	r8, sp, #12
    8c58:	stmia.w	r8, {r0, r1, r2}
    8c5c:	movs	r7, #0
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;
    8c5e:	mov	sl, r7
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    8c60:	mov	r4, r7
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    8c62:	movs	r2, #0
    8c64:	mov	r1, r8
    8c66:	ldr	r0, [r6, #32]
    8c68:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    8c6c:	uxtb.w	r9, r7
    if (!cache) {
    8c70:	mov	r5, r0
    8c72:	cbz	r0, 8c82 <ExFatFile::syncDir()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    8c74:	ldrb	r3, [r0, #0]
    8c76:	cmp	r3, #192	; 0xc0
    8c78:	beq.n	8d1e <ExFatFile::syncDir()+0xda>
    8c7a:	cmp	r3, #193	; 0xc1
    8c7c:	beq.n	8d1a <ExFatFile::syncDir()+0xd6>
    8c7e:	cmp	r3, #133	; 0x85
    8c80:	beq.n	8c96 <ExFatFile::syncDir()+0x52>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    8c82:	ldrb.w	r3, [r6, #50]	; 0x32
    8c86:	orr.w	r3, r3, #1
    8c8a:	strb.w	r3, [r6, #50]	; 0x32
  return false;
    8c8e:	movs	r0, #0
}
    8c90:	add	sp, #28
    8c92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    8c96:	ldr	r3, [pc, #236]	; (8d84 <ExFatFile::syncDir()+0x140>)
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    8c98:	ldrb.w	r2, [r6, #49]	; 0x31
    8c9c:	ldr	r3, [r3, #0]
      goto fail;
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
    8c9e:	ldrb.w	sl, [r0, #1]
    8ca2:	and.w	r2, r2, #55	; 0x37
    8ca6:	strh	r2, [r0, #4]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    8ca8:	cbz	r3, 8ccc <ExFatFile::syncDir()+0x88>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    8caa:	add.w	r2, sp, #7
    8cae:	add.w	r1, sp, #10
    8cb2:	add	r0, sp, #8
    8cb4:	blx	r3
          df->modifyTimeMs = ms10;
          setLe16(df->modifyTime, time);
    8cb6:	ldrh.w	r2, [sp, #10]
          setLe16(df->modifyDate, date);
    8cba:	ldrh.w	r3, [sp, #8]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    8cbe:	ldrb.w	r1, [sp, #7]
    8cc2:	strb	r1, [r5, #21]
    8cc4:	strh	r2, [r5, #12]
    8cc6:	strh	r2, [r5, #16]
    8cc8:	strh	r3, [r5, #14]
    8cca:	strh	r3, [r5, #18]
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
        m_vol->dataCacheDirty();
    8ccc:	ldr	r2, [r6, #32]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    8cce:	ldrb.w	r3, [r2, #528]	; 0x210
    8cd2:	orr.w	r3, r3, #1
    8cd6:	strb.w	r3, [r2, #528]	; 0x210
    8cda:	ldrb	r0, [r5, #0]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    8cdc:	movs	r1, #0
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    8cde:	ldrb	r2, [r5, r1]
    8ce0:	lsls	r3, r4, #15
    8ce2:	orr.w	r4, r3, r4, lsr #1
    8ce6:	uxtah	r4, r2, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    8cea:	cmp	r1, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    8cec:	uxth	r4, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    8cee:	add.w	r1, r1, #1
    8cf2:	beq.n	8d10 <ExFatFile::syncDir()+0xcc>
    8cf4:	cmp	r1, #31
    8cf6:	bls.n	8cde <ExFatFile::syncDir()+0x9a>
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    if (i == setCount) break;
    8cf8:	cmp	sl, r9
    8cfa:	beq.n	8d4a <ExFatFile::syncDir()+0x106>
    if (m_vol->dirSeek(&pos, 32) != 1) {
    8cfc:	movs	r2, #32
    8cfe:	mov	r1, r8
    8d00:	ldr	r0, [r6, #32]
    8d02:	bl	8774 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    8d06:	cmp	r0, #1
    8d08:	add.w	r7, r7, #1
    8d0c:	beq.n	8c62 <ExFatFile::syncDir()+0x1e>
    8d0e:	b.n	8c82 <ExFatFile::syncDir()+0x3e>
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    8d10:	cmp	r0, #133	; 0x85
    8d12:	ite	eq
    8d14:	moveq	r1, #4
    8d16:	movne	r1, #2
    8d18:	b.n	8cde <ExFatFile::syncDir()+0x9a>
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    8d1a:	mov	r0, r3
    8d1c:	b.n	8cdc <ExFatFile::syncDir()+0x98>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    8d1e:	ldrb.w	r3, [r6, #51]	; 0x33
    8d22:	tst.w	r3, #64	; 0x40
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    8d26:	ldrb	r3, [r0, #1]
    8d28:	ite	ne
    8d2a:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    8d2e:	biceq.w	r3, r3, #2
    8d32:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    8d34:	ldrd	r2, r3, [r6, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    8d38:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
    8d3c:	ldrd	r2, r3, [r6, #8]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
    8d40:	ldr	r1, [r6, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    8d42:	str	r1, [r0, #20]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    8d44:	strd	r2, r3, [r0, #24]
    8d48:	b.n	8ccc <ExFatFile::syncDir()+0x88>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    8d4a:	mov	r1, fp
    8d4c:	movs	r2, #1
    8d4e:	ldr	r0, [r6, #32]
    8d50:	bl	8740 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    8d54:	cmp	r0, #0
    8d56:	beq.n	8c82 <ExFatFile::syncDir()+0x3e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    8d58:	ldr	r5, [r6, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    8d5a:	strh	r4, [r0, #2]
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    8d5c:	mov	r0, r5
    8d5e:	bl	779c <FsCache::sync()>
    8d62:	cmp	r0, #0
    8d64:	beq.n	8c82 <ExFatFile::syncDir()+0x3e>
    8d66:	add.w	r0, r5, #528	; 0x210
    8d6a:	bl	779c <FsCache::sync()>
    8d6e:	cmp	r0, #0
    8d70:	beq.n	8c82 <ExFatFile::syncDir()+0x3e>
    8d72:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    8d76:	ldr	r3, [r0, #0]
    8d78:	ldr	r3, [r3, #24]
    8d7a:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    8d7c:	cmp	r0, #0
    8d7e:	beq.n	8c82 <ExFatFile::syncDir()+0x3e>
    8d80:	b.n	8c90 <ExFatFile::syncDir()+0x4c>
    8d82:	nop
    8d84:	.word	0x200050e0

00008d88 <ExFatFile::sync()>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    8d88:	ldrb.w	r2, [r0, #49]	; 0x31
    8d8c:	cbz	r2, 8db4 <ExFatFile::sync()+0x2c>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    8d8e:	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    8d90:	ldrb.w	r2, [r0, #51]	; 0x33
    8d94:	lsls	r1, r2, #24
    8d96:	bmi.n	8db8 <ExFatFile::sync()+0x30>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
  }
  if (!m_vol->cacheSync()) {
    8d98:	ldr	r5, [r0, #32]
    8d9a:	mov	r4, r0
    8d9c:	mov	r0, r5
    8d9e:	bl	779c <FsCache::sync()>
    8da2:	cbnz	r0, 8dc8 <ExFatFile::sync()+0x40>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    8da4:	ldrb.w	r3, [r4, #50]	; 0x32
    8da8:	orr.w	r3, r3, #1
    8dac:	strb.w	r3, [r4, #50]	; 0x32
  return false;
    8db0:	movs	r0, #0
}
    8db2:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    8db4:	movs	r0, #1
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    8db6:	bx	lr
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    8db8:	and.w	r2, r2, #127	; 0x7f
    8dbc:	strb.w	r2, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    8dc0:	ldmia.w	sp!, {r3, r4, r5, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    8dc4:	b.w	8c44 <ExFatFile::syncDir()>
    8dc8:	add.w	r0, r5, #528	; 0x210
    8dcc:	bl	779c <FsCache::sync()>
    8dd0:	cmp	r0, #0
    8dd2:	beq.n	8da4 <ExFatFile::sync()+0x1c>
    8dd4:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    8dd8:	ldr	r3, [r0, #0]
    8dda:	ldr	r3, [r3, #24]
    8ddc:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    8dde:	cmp	r0, #0
    8de0:	beq.n	8da4 <ExFatFile::sync()+0x1c>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    8de2:	movs	r0, #1
    8de4:	pop	{r3, r4, r5, pc}
    8de6:	nop

00008de8 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    8de8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    8dec:	ldrb.w	r3, [r0, #49]	; 0x31
    8df0:	lsls	r1, r3, #25

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    8df2:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    8df4:	bmi.n	8eb8 <ExFatFile::addDirCluster()+0xd0>
    8df6:	ldr	r0, [r0, #8]
    8df8:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    8dfa:	ldr.w	r3, [r3, #1084]	; 0x43c
    8dfe:	add	r0, r3
    8e00:	cmp.w	r0, #67108864	; 0x4000000
    8e04:	bcc.n	8e0c <ExFatFile::addDirCluster()+0x24>
  }
  return sync();

 fail:
  return false;
}
    8e06:	movs	r0, #0
    8e08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    8e0c:	mov	r0, r4
    8e0e:	bl	8a84 <ExFatFile::addCluster()>
    8e12:	cmp	r0, #0
    8e14:	beq.n	8e06 <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    8e16:	ldr	r6, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    8e18:	ldrb.w	r3, [r6, #528]	; 0x210
    8e1c:	lsls	r2, r3, #31
    8e1e:	bmi.n	8ec0 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    8e20:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    8e24:	movs	r5, #0
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    8e26:	add.w	r8, r6, #544	; 0x220
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    8e2a:	str.w	r3, [r6, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    8e2e:	strb.w	r5, [r6, #528]	; 0x210
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    8e32:	mov	r1, r5
    8e34:	mov.w	r2, #512	; 0x200
    8e38:	mov	r0, r8
    8e3a:	bl	1001c <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    8e3e:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    8e40:	ldr	r3, [r4, #24]
    8e42:	ldrb.w	r0, [r2, #1093]	; 0x445
    8e46:	ldr.w	r1, [r2, #1068]	; 0x42c
    8e4a:	subs	r3, #2
    8e4c:	lsls	r3, r0
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    8e4e:	movs	r6, #1
    8e50:	adds	r7, r3, r1
    8e52:	lsls.w	r3, r6, r0
    8e56:	beq.n	8e7a <ExFatFile::addDirCluster()+0x92>
    8e58:	ldr.w	r0, [r2, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    8e5c:	ldr	r3, [r0, #0]
    8e5e:	adds	r1, r7, r5
    8e60:	ldr	r3, [r3, #28]
    8e62:	mov	r2, r8
    8e64:	blx	r3
    8e66:	adds	r5, #1
    if (!m_vol->writeSector(sector + i, cache)) {
    8e68:	cmp	r0, #0
    8e6a:	beq.n	8e06 <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    8e6c:	ldr	r2, [r4, #32]
    8e6e:	ldrb.w	r3, [r2, #1093]	; 0x445
    8e72:	lsl.w	r3, r6, r3
    8e76:	cmp	r3, r5
    8e78:	bhi.n	8e58 <ExFatFile::addDirCluster()+0x70>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    8e7a:	ldrb.w	r3, [r4, #49]	; 0x31
    8e7e:	lsls	r3, r3, #25
    8e80:	bmi.n	8eae <ExFatFile::addDirCluster()+0xc6>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    8e82:	ldrb.w	r3, [r4, #51]	; 0x33
    8e86:	orn	r3, r3, #127	; 0x7f
    8e8a:	strb.w	r3, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    8e8e:	ldr.w	r6, [r2, #1084]	; 0x43c
    8e92:	ldrd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    8e96:	ldrd	r0, r1, [r4, #16]
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    8e9a:	adds	r2, r2, r6
    8e9c:	mov.w	r7, #0
    8ea0:	adcs	r3, r7
    m_validLength += m_vol->bytesPerCluster();
    8ea2:	adds	r0, r0, r6
    8ea4:	adcs	r1, r7
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    8ea6:	strd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    8eaa:	strd	r0, r1, [r4, #16]
  }
  return sync();
    8eae:	mov	r0, r4

 fail:
  return false;
}
    8eb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    8eb4:	b.w	8d88 <ExFatFile::sync()>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    8eb8:	ldr	r0, [r0, #32]
    8eba:	bl	89d8 <ExFatPartition::rootLength()>
    8ebe:	b.n	8df8 <ExFatFile::addDirCluster()+0x10>
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    8ec0:	add.w	r0, r6, #528	; 0x210
    8ec4:	bl	779c <FsCache::sync()>
    8ec8:	cmp	r0, #0
    8eca:	bne.n	8e20 <ExFatFile::addDirCluster()+0x38>
    8ecc:	b.n	8e06 <ExFatFile::addDirCluster()+0x1e>
    8ece:	nop

00008ed0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
  if (!parent->isDir()) {
    8ed0:	ldrb.w	r3, [r1, #49]	; 0x31
    8ed4:	tst.w	r3, #80	; 0x50
    8ed8:	bne.n	8ede <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0xe>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    8eda:	movs	r0, #0
    8edc:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    8ede:	push	{r4, r5, lr}
    8ee0:	sub	sp, #12
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    8ee2:	movw	r5, #2562	; 0xa02
    8ee6:	ldrb	r3, [r2, #0]
    8ee8:	ldr	r2, [r2, #4]
    8eea:	str	r5, [sp, #0]
    8eec:	mov	r4, r0
    8eee:	bl	7dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    8ef2:	cbnz	r0, 8efa <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x2a>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    8ef4:	movs	r0, #0
    8ef6:	add	sp, #12
    8ef8:	pop	{r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory

  m_attributes = FILE_ATTR_SUBDIR;
    8efa:	movs	r3, #16
    8efc:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    8f00:	mov	r0, r4
    8f02:	bl	8de8 <ExFatFile::addDirCluster()>
    8f06:	cmp	r0, #0
    8f08:	beq.n	8ef4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    8f0a:	ldr	r3, [r4, #24]
    8f0c:	str	r3, [r4, #28]
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    8f0e:	movs	r2, #0
    8f10:	movs	r3, #0
    8f12:	mov	r0, r4
    8f14:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8f18:	movs	r3, #193	; 0xc1
  return sync();
    8f1a:	mov	r0, r4
  }
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8f1c:	strb.w	r3, [r4, #51]	; 0x33
  return sync();

 fail:
  return false;
}
    8f20:	add	sp, #12
    8f22:	ldmia.w	sp!, {r4, r5, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    8f26:	b.w	8d88 <ExFatFile::sync()>
    8f2a:	nop

00008f2c <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    8f2c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8f30:	mov	r6, r0
    8f32:	sub	sp, #84	; 0x54
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    8f34:	ldrb.w	r5, [r6, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    8f38:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    8f3a:	movs	r0, #0
    8f3c:	strb.w	r0, [sp, #73]	; 0x49
    8f40:	strb.w	r0, [sp, #74]	; 0x4a
    8f44:	strb.w	r0, [sp, #75]	; 0x4b
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    8f48:	cbnz	r5, 8f58 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    8f4a:	mov	r9, r3
    8f4c:	ldrb.w	r3, [r1, #49]	; 0x31
    8f50:	tst.w	r3, #80	; 0x50
    8f54:	mov	r4, r1
    8f56:	bne.n	8f60 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x34>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    8f58:	movs	r0, #0
}
    8f5a:	add	sp, #84	; 0x54
    8f5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    8f60:	ldrb	r3, [r2, #0]
    8f62:	cmp	r3, #47	; 0x2f
    8f64:	mov	r1, r2
    8f66:	beq.n	8fd6 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    8f68:	mov.w	r8, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    8f6c:	add	r3, sp, #12
    8f6e:	add	r2, sp, #16
    8f70:	mov	r0, r6
    8f72:	bl	7a2c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    8f76:	cmp	r0, #0
    8f78:	beq.n	8f58 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    8f7a:	ldr	r3, [sp, #12]
    8f7c:	ldrb	r3, [r3, #0]
    8f7e:	cmp	r3, #0
    8f80:	beq.n	8ff2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xc6>
    8f82:	ldrb.w	r3, [sp, #16]
    8f86:	ldr	r2, [sp, #20]
    8f88:	str.w	r8, [sp]
    8f8c:	mov	r1, r4
    8f8e:	mov	r0, r6
    8f90:	bl	7dc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    8f94:	cbnz	r0, 8faa <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
      if (!pFlag || !mkdir(parent, &fname)) {
    8f96:	cmp.w	r9, #0
    8f9a:	beq.n	8f58 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    8f9c:	mov	r1, r4
    8f9e:	add	r2, sp, #16
    8fa0:	mov	r0, r6
    8fa2:	bl	8ed0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    8fa6:	cmp	r0, #0
    8fa8:	beq.n	8f58 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    8faa:	mov	r4, r6
    8fac:	add	r7, sp, #24
    8fae:	add.w	lr, r6, #48	; 0x30
    8fb2:	ldr	r0, [r4, #0]
    8fb4:	ldr	r1, [r4, #4]
    8fb6:	ldr	r2, [r4, #8]
    8fb8:	ldr	r3, [r4, #12]
    8fba:	mov	r5, r7
    8fbc:	stmia	r5!, {r0, r1, r2, r3}
    8fbe:	adds	r4, #16
    8fc0:	cmp	r4, lr
    8fc2:	mov	r7, r5
    8fc4:	bne.n	8fb2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x86>
    8fc6:	ldr	r0, [r4, #0]
    8fc8:	str	r0, [r5, #0]
    parent = &tmpDir;
    close();
    8fca:	mov	r0, r6
    8fcc:	bl	7920 <ExFatFile::close()>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    8fd0:	add	r4, sp, #24
    8fd2:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    8fd4:	b.n	8f6c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    8fd6:	adds	r1, #1
    8fd8:	str	r1, [sp, #12]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    8fda:	ldrb	r3, [r1, #0]
    8fdc:	cmp	r3, #47	; 0x2f
    8fde:	beq.n	8fd6 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    8fe0:	ldr	r1, [r4, #32]
    8fe2:	add	r0, sp, #24
    8fe4:	bl	7a04 <ExFatFile::openRoot(ExFatVolume*)>
    8fe8:	cmp	r0, #0
    8fea:	beq.n	8f58 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    8fec:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    8fee:	add	r4, sp, #24
    8ff0:	b.n	8f68 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x3c>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    8ff2:	add	r2, sp, #16
    8ff4:	mov	r1, r4
    8ff6:	mov	r0, r6
    8ff8:	bl	8ed0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>

 fail:
  return false;
}
    8ffc:	add	sp, #84	; 0x54
    8ffe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    9002:	nop

00009004 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    9004:	push	{r4, r5, r6, r7, lr}
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    9006:	ldrb.w	r4, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    900a:	sub	sp, #116	; 0x74
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    900c:	movs	r3, #0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    900e:	tst.w	r4, #24
    9012:	strb.w	r3, [sp, #49]	; 0x31
    9016:	strb.w	r3, [sp, #50]	; 0x32
    901a:	strb.w	r3, [sp, #51]	; 0x33
    901e:	strb.w	r3, [sp, #105]	; 0x69
    9022:	strb.w	r3, [sp, #106]	; 0x6a
    9026:	strb.w	r3, [sp, #107]	; 0x6b
    902a:	beq.n	9034 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    902c:	ldr	r3, [r1, #32]
    902e:	ldr	r4, [r0, #32]
    9030:	cmp	r4, r3
    9032:	beq.n	903a <ExFatFile::rename(ExFatFile*, char const*)+0x36>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    9034:	movs	r0, #0
}
    9036:	add	sp, #116	; 0x74
    9038:	pop	{r4, r5, r6, r7, pc}
    903a:	mov	r4, r0
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    903c:	movw	r3, #2561	; 0xa01
    9040:	mov	r0, sp
    9042:	bl	81a4 <ExFatFile::open(ExFatFile*, char const*, int)>
    9046:	cmp	r0, #0
    9048:	beq.n	9034 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    904a:	add	r7, sp, #56	; 0x38
    904c:	mov	r5, r4
    904e:	add.w	lr, r4, #48	; 0x30
    9052:	ldr	r0, [r5, #0]
    9054:	ldr	r1, [r5, #4]
    9056:	ldr	r2, [r5, #8]
    9058:	ldr	r3, [r5, #12]
    905a:	mov	r6, r7
    905c:	stmia	r6!, {r0, r1, r2, r3}
    905e:	adds	r5, #16
    9060:	cmp	r5, lr
    9062:	mov	r7, r6
    9064:	bne.n	9052 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    9066:	ldr	r0, [r5, #0]
    9068:	str	r0, [r6, #0]
  m_dirPos = file.m_dirPos;
    906a:	add	r3, sp, #36	; 0x24
    906c:	ldmia.w	r3, {r0, r1, r2}
    9070:	add.w	r3, r4, #36	; 0x24
    9074:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9078:	ldrb.w	r3, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
    907c:	ldrb.w	r2, [sp, #48]	; 0x30
    9080:	strb.w	r2, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9084:	orn	r3, r3, #127	; 0x7f
    9088:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    908c:	mov	r0, r4
    908e:	bl	8d88 <ExFatFile::sync()>
    9092:	cmp	r0, #0
    9094:	beq.n	9034 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    9096:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    9098:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    909a:	movs	r3, #8
  return oldFile.remove();
    909c:	add	r0, sp, #56	; 0x38
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    909e:	str	r1, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    90a0:	strb.w	r2, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
    90a4:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    90a8:	bl	8b10 <ExFatFile::remove()>
    90ac:	b.n	9036 <ExFatFile::rename(ExFatFile*, char const*)+0x32>
    90ae:	nop

000090b0 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    90b0:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    90b4:	lsls	r2, r3, #30
    90b6:	bpl.n	90ea <ExFatFile::truncate()+0x3a>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    90b8:	push	{r4, r5, r6, r7, lr}
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    90ba:	ldr	r5, [r0, #28]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    90bc:	sub	sp, #12
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    90be:	cbz	r5, 90e4 <ExFatFile::truncate()+0x34>
      return true;
  }
  if (isContiguous()) {
    90c0:	and.w	r3, r3, #64	; 0x40
    90c4:	mov	r4, r0
    90c6:	and.w	r0, r3, #255	; 0xff
    90ca:	cbnz	r3, 90ee <ExFatFile::truncate()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    90cc:	ldr	r1, [r4, #24]
    90ce:	cmp	r1, #0
    90d0:	bne.n	9156 <ExFatFile::truncate()+0xa6>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    90d2:	str	r5, [sp, #4]
      m_firstCluster = 0;
    90d4:	str	r1, [r4, #28]
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
    90d6:	mov	r1, r5
    90d8:	ldr	r0, [r4, #32]
    90da:	bl	8804 <ExFatPartition::freeChain(unsigned long)>
    90de:	cbnz	r0, 912e <ExFatFile::truncate()+0x7e>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    90e0:	movs	r0, #0
    90e2:	b.n	90e6 <ExFatFile::truncate()+0x36>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    90e4:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    90e6:	add	sp, #12
    90e8:	pop	{r4, r5, r6, r7, pc}
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    90ea:	movs	r0, #0
}
    90ec:	bx	lr
    90ee:	ldr	r0, [r4, #32]
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
    90f0:	ldr	r1, [r4, #24]
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    90f2:	ldrb.w	r3, [r0, #1093]	; 0x445
    90f6:	ldrd	r6, r7, [r4, #8]
    90fa:	adds	r3, #9
    90fc:	uxtb	r3, r3
    90fe:	adds.w	r6, r6, #4294967295
    9102:	rsb	lr, r3, #32
    9106:	adc.w	r7, r7, #4294967295
    910a:	lsr.w	r2, r6, r3
    910e:	lsl.w	lr, r7, lr
    9112:	subs	r3, #32
    9114:	orr.w	r2, r2, lr
    9118:	lsr.w	r3, r7, r3
    911c:	orrs	r2, r3
    911e:	adds	r2, #1
    if (m_curCluster) {
    9120:	cbz	r1, 9150 <ExFatFile::truncate()+0xa0>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    9122:	subs	r5, #1
    9124:	subs	r5, r5, r1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    9126:	adds	r1, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    9128:	add	r2, r5
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    912a:	str	r1, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    912c:	cbnz	r2, 9172 <ExFatFile::truncate()+0xc2>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    912e:	ldrd	r0, r1, [r4]
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9132:	ldrb.w	r3, [r4, #51]	; 0x33
    9136:	orn	r3, r3, #127	; 0x7f
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    913a:	strd	r0, r1, [r4, #8]
  m_validLength = m_curPosition;
    913e:	strd	r0, r1, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9142:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    9146:	mov	r0, r4
    9148:	bl	8d88 <ExFatFile::sync()>

 fail:
  return false;
}
    914c:	add	sp, #12
    914e:	pop	{r4, r5, r6, r7, pc}
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
    9150:	str	r5, [sp, #4]
      m_firstCluster = 0;
    9152:	str	r1, [r4, #28]
    9154:	b.n	912c <ExFatFile::truncate()+0x7c>
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    9156:	add	r2, sp, #8
    9158:	str.w	r0, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    915c:	ldr	r0, [r4, #32]
    915e:	bl	87cc <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    9162:	sxtb	r0, r0
      if (fg < 0) {
    9164:	cmp	r0, #0
    9166:	blt.n	90e0 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    9168:	bne.n	9180 <ExFatFile::truncate()+0xd0>
      }
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
    916a:	ldr	r5, [sp, #4]
    916c:	cmp	r5, #0
    916e:	beq.n	912e <ExFatFile::truncate()+0x7e>
    9170:	b.n	90d6 <ExFatFile::truncate()+0x26>
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    9172:	movs	r3, #0
    9174:	ldr	r1, [sp, #4]
    9176:	bl	865c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    917a:	cmp	r0, #0
    917c:	bne.n	912e <ExFatFile::truncate()+0x7e>
    917e:	b.n	90e0 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    9180:	mov.w	r2, #4294967295
    9184:	ldr	r1, [r4, #24]
    9186:	ldr	r0, [r4, #32]
    9188:	bl	87e0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    918c:	cmp	r0, #0
    918e:	bne.n	916a <ExFatFile::truncate()+0xba>
    9190:	b.n	90e0 <ExFatFile::truncate()+0x30>
    9192:	nop

00009194 <ExFatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    9194:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9198:	ldrb.w	r3, [r0, #51]	; 0x33
    919c:	sub	sp, #12

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    919e:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    91a0:	mov	r4, r0
    91a2:	str	r2, [sp, #0]

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    91a4:	bmi.n	91bc <ExFatFile::write(void const*, unsigned int)+0x28>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    91a6:	ldrb.w	r3, [r4, #50]	; 0x32
    91aa:	orr.w	r3, r3, #1
    91ae:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    91b2:	mov.w	r0, #4294967295
}
    91b6:	add	sp, #12
    91b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    91bc:	lsls	r2, r3, #28
    91be:	mov	r9, r1
    91c0:	bmi.w	93c6 <ExFatFile::write(void const*, unsigned int)+0x232>
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    91c4:	ldr	r3, [sp, #0]
    91c6:	cmp	r3, #0
    91c8:	beq.w	93ee <ExFatFile::write(void const*, unsigned int)+0x25a>
    91cc:	mov	r1, r4
    91ce:	ldrd	r2, r3, [r1], #24
    91d2:	ldr.w	r8, [sp]
    91d6:	str	r1, [sp, #4]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    91d8:	mov.w	fp, #1
    91dc:	mov	sl, r9
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    91de:	ldr	r0, [r4, #32]
    91e0:	ldr.w	r5, [r0, #1080]	; 0x438
    91e4:	ands	r5, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    91e6:	ubfx	r9, r5, #0, #9
    if (clusterOffset == 0) {
    91ea:	cbnz	r5, 923e <ExFatFile::write(void const*, unsigned int)+0xaa>
      // start of new cluster
      if (m_curCluster != 0) {
    91ec:	ldr	r1, [r4, #24]
    91ee:	cmp	r1, #0
    91f0:	beq.w	9350 <ExFatFile::write(void const*, unsigned int)+0x1bc>
        int fg;

        if (isContiguous()) {
    91f4:	ldrb.w	r3, [r4, #51]	; 0x33
    91f8:	lsls	r3, r3, #25
    91fa:	bpl.w	9398 <ExFatFile::write(void const*, unsigned int)+0x204>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    91fe:	ldrd	r6, r7, [r4, #8]
    9202:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    9206:	ldr	r3, [r4, #28]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    9208:	adds	r2, #9
    920a:	uxtb	r2, r2
    920c:	adds.w	r6, r6, #4294967295
    9210:	adc.w	r7, r7, #4294967295
    9214:	rsb	lr, r2, #32
    9218:	lsrs	r6, r2
    921a:	lsl.w	lr, r7, lr
    921e:	subs	r2, #32
    9220:	orr.w	r6, r6, lr
    9224:	lsr.w	r2, r7, r2
    9228:	orrs	r6, r2
    922a:	add	r3, r6
    922c:	cmp	r1, r3
    922e:	bcc.w	937e <ExFatFile::write(void const*, unsigned int)+0x1ea>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    9232:	mov	r0, r4
    9234:	bl	8a84 <ExFatFile::addCluster()>
    9238:	cmp	r0, #0
    923a:	beq.n	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
    923c:	ldr	r0, [r4, #32]
    923e:	ldr	r6, [r4, #24]
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    9240:	ldr.w	r7, [r0, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    9244:	ldrb.w	lr, [r0, #1093]	; 0x445
    9248:	lsrs	r5, r5, #9
    924a:	subs	r6, #2
    924c:	adds	r1, r5, r7
    924e:	lsl.w	r6, r6, lr
    9252:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    9254:	cmp.w	r9, #0
    9258:	bne.n	9342 <ExFatFile::write(void const*, unsigned int)+0x1ae>
    925a:	cmp.w	r8, #512	; 0x200
    925e:	bcs.n	92fc <ExFatFile::write(void const*, unsigned int)+0x168>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    9260:	ldrd	r2, r3, [r4, #16]
    9264:	ldrd	r6, r7, [r4]
    9268:	cmp.w	r8, #512	; 0x200
    926c:	mov	r5, r8
    926e:	it	cs
    9270:	movcs.w	r5, #512	; 0x200
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    9274:	cmp	r7, r3
    9276:	it	eq
    9278:	cmpeq	r6, r2
    927a:	ite	cc
    927c:	movcc	r2, #1
    927e:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    9280:	add.w	r0, r0, #528	; 0x210
    9284:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    9288:	cmp	r0, #0
    928a:	beq.n	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    928c:	add	r0, r9
    928e:	mov	r2, r5
    9290:	mov	r1, sl
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    9292:	add	r9, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    9294:	bl	cfd4 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    9298:	cmp.w	r9, #512	; 0x200
    929c:	beq.w	93b4 <ExFatFile::write(void const*, unsigned int)+0x220>
    92a0:	mov	r0, r5
    92a2:	movs	r1, #0
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    92a4:	ldrd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    92a8:	ldrd	r6, r7, [r4, #16]
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    92ac:	adds	r2, r2, r0
    92ae:	adcs	r3, r1
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    92b0:	cmp	r7, r3
    92b2:	it	eq
    92b4:	cmpeq	r6, r2
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    92b6:	add	sl, r5
    toWrite -= n;
    92b8:	rsb	r8, r5, r8
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    92bc:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    92c0:	bcs.n	92d2 <ExFatFile::write(void const*, unsigned int)+0x13e>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    92c2:	ldrb.w	r1, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    92c6:	strd	r2, r3, [r4, #16]
    }
    m_curPosition += n;
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
    92ca:	orn	r1, r1, #127	; 0x7f
    92ce:	strb.w	r1, [r4, #51]	; 0x33
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    92d2:	cmp.w	r8, #0
    92d6:	bne.n	91de <ExFatFile::write(void const*, unsigned int)+0x4a>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    92d8:	ldrd	r0, r1, [r4, #8]
    92dc:	cmp	r1, r3
    92de:	it	eq
    92e0:	cmpeq	r0, r2
    92e2:	bcc.n	93d6 <ExFatFile::write(void const*, unsigned int)+0x242>
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    92e4:	ldr	r3, [pc, #268]	; (93f4 <ExFatFile::write(void const*, unsigned int)+0x260>)
    92e6:	ldr	r3, [r3, #0]
    92e8:	cmp	r3, #0
    92ea:	beq.n	93ea <ExFatFile::write(void const*, unsigned int)+0x256>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    92ec:	ldrb.w	r3, [r4, #51]	; 0x33
    92f0:	ldr	r0, [sp, #0]
    92f2:	orn	r3, r3, #127	; 0x7f
    92f6:	strb.w	r3, [r4, #51]	; 0x33
    92fa:	b.n	91b6 <ExFatFile::write(void const*, unsigned int)+0x22>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    92fc:	cmp.w	r8, #1024	; 0x400
    9300:	bcc.n	9358 <ExFatFile::write(void const*, unsigned int)+0x1c4>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    9302:	lsl.w	r3, fp, lr
    9306:	subs	r5, r3, r5
    9308:	ldr.w	r2, [r0, #540]	; 0x21c
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    930c:	mov.w	r3, r8, lsr #9
    9310:	cmp	r3, r5
    9312:	it	cs
    9314:	movcs	r3, r5
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    9316:	cmp	r1, r2
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    9318:	mov.w	r5, r3, lsl #9
    931c:	bhi.n	9330 <ExFatFile::write(void const*, unsigned int)+0x19c>
    931e:	adds	r6, r1, r3
    9320:	cmp	r2, r6
    9322:	bcs.n	9330 <ExFatFile::write(void const*, unsigned int)+0x19c>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    9324:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    9328:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    932c:	str.w	r2, [r0, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    9330:	ldr.w	r0, [r0, #532]	; 0x214
    9334:	ldr	r6, [r0, #0]
    9336:	mov	r2, sl
    9338:	ldr	r6, [r6, #32]
    933a:	blx	r6
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    933c:	cmp	r0, #0
    933e:	bne.n	92a0 <ExFatFile::write(void const*, unsigned int)+0x10c>
    9340:	b.n	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    9342:	rsb	r5, r9, #512	; 0x200
    9346:	cmp	r5, r8
    9348:	it	cs
    934a:	movcs	r5, r8
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    934c:	movs	r2, #1
    934e:	b.n	9280 <ExFatFile::write(void const*, unsigned int)+0xec>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    9350:	ldr	r6, [r4, #28]
    9352:	cbz	r6, 9384 <ExFatFile::write(void const*, unsigned int)+0x1f0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    9354:	str	r6, [r4, #24]
    9356:	b.n	9240 <ExFatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    9358:	ldr.w	r3, [r0, #540]	; 0x21c
    935c:	cmp	r1, r3
    935e:	beq.n	93a6 <ExFatFile::write(void const*, unsigned int)+0x212>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    9360:	ldr.w	r0, [r0, #532]	; 0x214
    9364:	ldr	r3, [r0, #0]
    9366:	mov	r2, sl
    9368:	ldr	r3, [r3, #28]
    936a:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    936c:	cmp	r0, #0
    936e:	beq.w	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
    9372:	mov.w	r0, #512	; 0x200
    9376:	movs	r1, #0
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    9378:	mov.w	r5, #512	; 0x200
    937c:	b.n	92a4 <ExFatFile::write(void const*, unsigned int)+0x110>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    937e:	adds	r6, r1, #1
    9380:	str	r6, [r4, #24]
    9382:	b.n	9240 <ExFatFile::write(void const*, unsigned int)+0xac>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    9384:	mov	r0, r4
    9386:	bl	8a84 <ExFatFile::addCluster()>
    938a:	cmp	r0, #0
    938c:	beq.w	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    9390:	ldr	r6, [r4, #24]
    9392:	str	r6, [r4, #28]
    9394:	ldr	r0, [r4, #32]
    9396:	b.n	9240 <ExFatFile::write(void const*, unsigned int)+0xac>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    9398:	ldr	r2, [sp, #4]
    939a:	bl	87cc <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    939e:	cmp	r0, #0
    93a0:	bne.w	923c <ExFatFile::write(void const*, unsigned int)+0xa8>
    93a4:	b.n	9232 <ExFatFile::write(void const*, unsigned int)+0x9e>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    93a6:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    93aa:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    93ae:	str.w	r3, [r0, #540]	; 0x21c
    93b2:	b.n	9360 <ExFatFile::write(void const*, unsigned int)+0x1cc>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    93b4:	ldr	r0, [r4, #32]
    93b6:	add.w	r0, r0, #528	; 0x210
    93ba:	bl	779c <FsCache::sync()>
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->dataCacheSync()) {
    93be:	cmp	r0, #0
    93c0:	bne.w	92a0 <ExFatFile::write(void const*, unsigned int)+0x10c>
    93c4:	b.n	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    93c6:	ldrd	r2, r3, [r0, #16]
    93ca:	bl	7cc8 <ExFatFile::seekSet(unsigned long long)>
    93ce:	cmp	r0, #0
    93d0:	beq.w	91a6 <ExFatFile::write(void const*, unsigned int)+0x12>
    93d4:	b.n	91c4 <ExFatFile::write(void const*, unsigned int)+0x30>
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    93d6:	ldrb.w	r1, [r4, #51]	; 0x33
    93da:	ldr	r0, [sp, #0]
    93dc:	orn	r1, r1, #127	; 0x7f
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    93e0:	strd	r2, r3, [r4, #8]
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    93e4:	strb.w	r1, [r4, #51]	; 0x33
    93e8:	b.n	91b6 <ExFatFile::write(void const*, unsigned int)+0x22>
    93ea:	ldr	r0, [sp, #0]
    93ec:	b.n	91b6 <ExFatFile::write(void const*, unsigned int)+0x22>
    93ee:	ldrd	r2, r3, [r4]
    93f2:	b.n	92d8 <ExFatFile::write(void const*, unsigned int)+0x144>
    93f4:	.word	0x200050e0

000093f8 <FatFile::openRoot(FatVolume*) [clone .part.38]>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    93f8:	push	{r3, r4, r5, lr}
    93fa:	mov	r4, r0
    93fc:	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    93fe:	movs	r2, #36	; 0x24
    9400:	movs	r1, #0
    9402:	bl	1001c <memset>

  m_vol = vol;
    9406:	str	r5, [r4, #8]
  switch (vol->fatType()) {
    9408:	ldrb	r3, [r5, #7]
    940a:	cmp	r3, #16
    940c:	beq.n	9420 <FatFile::openRoot(FatVolume*) [clone .part.38]+0x28>
    940e:	cmp	r3, #32
    9410:	bne.n	941c <FatFile::openRoot(FatVolume*) [clone .part.38]+0x24>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    9412:	movs	r3, #64	; 0x40
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9414:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    9416:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9418:	strb	r0, [r4, #2]
    941a:	pop	{r3, r4, r5, pc}
  return true;

 fail:
  return false;
    941c:	movs	r0, #0
}
    941e:	pop	{r3, r4, r5, pc}
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    9420:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9422:	movs	r0, #1
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    9424:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9426:	strb	r0, [r4, #2]
    9428:	pop	{r3, r4, r5, pc}
    942a:	nop

0000942c <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    942c:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    942e:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    9430:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    9434:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    9436:	mov	r1, r5
    9438:	ldr	r0, [r0, #8]
    943a:	bl	a450 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    943e:	cbz	r0, 9456 <FatFile::addCluster()+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    9440:	cbz	r5, 9458 <FatFile::addCluster()+0x2c>
    m_flags |= FILE_FLAG_CONTIGUOUS;
  } else if (m_curCluster != (cc + 1)) {
    9442:	ldr	r3, [r4, #16]
    9444:	adds	r5, #1
    9446:	cmp	r3, r5
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    9448:	ldrb	r3, [r4, #2]
    944a:	it	ne
    944c:	andne.w	r3, r3, #191	; 0xbf
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9450:	orn	r3, r3, #127	; 0x7f
    9454:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    9456:	pop	{r3, r4, r5, pc}
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    9458:	ldrb	r3, [r4, #2]
    945a:	orr.w	r3, r3, #64	; 0x40
    945e:	b.n	9450 <FatFile::addCluster()+0x24>

00009460 <FatFile::addDirCluster()>:
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    9460:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    9464:	ldrb	r3, [r0, #0]
    9466:	and.w	r3, r3, #32
    946a:	cbnz	r3, 9478 <FatFile::addDirCluster()+0x18>
    946c:	and.w	r4, r3, #255	; 0xff
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    9470:	ldr	r1, [r0, #20]
    9472:	ldr	r3, [pc, #128]	; (94f4 <FatFile::addDirCluster()+0x94>)
    9474:	cmp	r1, r3
    9476:	bls.n	9480 <FatFile::addDirCluster()+0x20>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    9478:	movs	r6, #0
}
    947a:	mov	r0, r6
    947c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9480:	mov	r5, r0
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    9482:	bl	942c <FatFile::addCluster()>
    9486:	mov	r6, r0
    9488:	cmp	r0, #0
    948a:	beq.n	9478 <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    948c:	ldr	r0, [r5, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    948e:	ldr	r3, [r5, #16]
    9490:	ldrb	r7, [r0, #6]
    9492:	ldr	r2, [r0, #20]
    9494:	subs	r3, #2
    9496:	lsls	r3, r7
    9498:	adds	r7, r3, r2
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    949a:	adds	r0, #36	; 0x24
    949c:	mov	r1, r7
    949e:	movs	r2, #5
    94a0:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    94a4:	mov	r8, r0
    94a6:	cmp	r0, #0
    94a8:	beq.n	9478 <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    94aa:	mov.w	r2, #512	; 0x200
    94ae:	mov	r1, r4
    94b0:	bl	1001c <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    94b4:	ldr	r3, [r5, #8]
    94b6:	ldrb	r2, [r3, #4]
    94b8:	cmp	r2, #1
    94ba:	bls.n	94de <FatFile::addDirCluster()+0x7e>
    94bc:	movs	r4, #1
    94be:	b.n	94c8 <FatFile::addDirCluster()+0x68>
    94c0:	ldr	r3, [r5, #8]
    94c2:	ldrb	r2, [r3, #4]
    94c4:	cmp	r2, r4
    94c6:	bls.n	94de <FatFile::addDirCluster()+0x7e>
    94c8:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    94ca:	ldr	r3, [r0, #0]
    94cc:	adds	r1, r4, r7
    94ce:	ldr	r3, [r3, #28]
    94d0:	mov	r2, r8
    94d2:	blx	r3
    94d4:	adds	r4, #1
    94d6:	uxtb	r4, r4
    if (!m_vol->writeSector(sector + i, pc->data)) {
    94d8:	cmp	r0, #0
    94da:	bne.n	94c0 <FatFile::addDirCluster()+0x60>
    94dc:	b.n	9478 <FatFile::addDirCluster()+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    94de:	ldrb	r3, [r3, #6]
    94e0:	ldr	r1, [r5, #20]
    94e2:	mov.w	r2, #512	; 0x200
    94e6:	lsl.w	r3, r2, r3
    94ea:	uxtah	r3, r1, r3
    94ee:	str	r3, [r5, #20]
    94f0:	b.n	947a <FatFile::addDirCluster()+0x1a>
    94f2:	nop
    94f4:	.word	0x001ffdff

000094f8 <FatFile::cacheDirEntry(unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    94f8:	push	{r4, lr}
    94fa:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    94fc:	ldr	r0, [r0, #8]
    94fe:	mov	r2, r1
    9500:	adds	r0, #36	; 0x24
    9502:	ldr	r1, [r4, #24]
    9504:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    9508:	cbz	r0, 9514 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    950a:	ldrh	r3, [r4, #4]
    950c:	and.w	r3, r3, #15
    9510:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    9514:	pop	{r4, pc}
    9516:	nop

00009518 <FatFile::sync() [clone .part.42]>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    9518:	push	{r4, r5, r6, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    951a:	ldrsb.w	r3, [r0, #2]
    951e:	cmp	r3, #0
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    9520:	sub	sp, #8
    9522:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    9524:	blt.n	955a <FatFile::sync() [clone .part.42]+0x42>
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
  }
  if (m_vol->cacheSync()) {
    9526:	ldr	r5, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9528:	add.w	r0, r5, #36	; 0x24
    952c:	bl	779c <FsCache::sync()>
    9530:	cbnz	r0, 9540 <FatFile::sync() [clone .part.42]+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    9532:	ldrb	r3, [r4, #1]
    9534:	orr.w	r3, r3, #1
    9538:	strb	r3, [r4, #1]
  return false;
    953a:	movs	r0, #0
}
    953c:	add	sp, #8
    953e:	pop	{r4, r5, r6, pc}
    9540:	add.w	r0, r5, #564	; 0x234
    9544:	bl	779c <FsCache::sync()>
    9548:	cmp	r0, #0
    954a:	beq.n	9532 <FatFile::sync() [clone .part.42]+0x1a>
    954c:	ldr	r0, [r5, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    954e:	ldr	r3, [r0, #0]
    9550:	ldr	r3, [r3, #24]
    9552:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9554:	cmp	r0, #0
    9556:	beq.n	9532 <FatFile::sync() [clone .part.42]+0x1a>
    9558:	b.n	953c <FatFile::sync() [clone .part.42]+0x24>
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    955a:	movs	r1, #1
    955c:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    9560:	mov	r5, r0
    9562:	cmp	r0, #0
    9564:	beq.n	9532 <FatFile::sync() [clone .part.42]+0x1a>
    9566:	ldrb	r3, [r0, #0]
    9568:	cmp	r3, #229	; 0xe5
    956a:	beq.n	9532 <FatFile::sync() [clone .part.42]+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    956c:	ldrb	r3, [r4, #0]
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    956e:	ldr	r2, [pc, #56]	; (95a8 <FatFile::sync() [clone .part.42]+0x90>)
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    9570:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    9572:	itt	mi
    9574:	ldrmi	r3, [r4, #28]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    9576:	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    9578:	ldr	r3, [r4, #32]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    957a:	ldr	r6, [r2, #0]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    957c:	strh	r3, [r0, #26]
    957e:	lsrs	r3, r3, #16
    9580:	strh	r3, [r0, #20]
    9582:	cbz	r6, 959e <FatFile::sync() [clone .part.42]+0x86>
      FsDateTime::callback(&date, &time, &ms10);
    9584:	add.w	r2, sp, #3
    9588:	add.w	r1, sp, #6
    958c:	add	r0, sp, #4
    958e:	blx	r6
      setLe16(dir->modifyDate, date);
    9590:	ldrh.w	r3, [sp, #4]
    9594:	ldrh.w	r2, [sp, #6]
    9598:	strh	r3, [r5, #24]
    959a:	strh	r3, [r5, #18]
    959c:	strh	r2, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    959e:	ldrb	r3, [r4, #2]
    95a0:	and.w	r3, r3, #127	; 0x7f
    95a4:	strb	r3, [r4, #2]
    95a6:	b.n	9526 <FatFile::sync() [clone .part.42]+0xe>
    95a8:	.word	0x200050e0

000095ac <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    95ac:	push	{r4, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    95ae:	ldrb	r3, [r0, #0]

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    95b0:	mov	r4, r0
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    95b2:	cbnz	r3, 95be <FatFile::close()+0x12>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    95b4:	movs	r3, #0
    95b6:	strb	r3, [r4, #0]
  m_flags = 0;
    95b8:	strb	r3, [r4, #2]
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    95ba:	movs	r0, #1
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return rtn;
}
    95bc:	pop	{r4, pc}
    95be:	bl	9518 <FatFile::sync() [clone .part.42]>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    95c2:	movs	r3, #0
    95c4:	strb	r3, [r4, #0]
  m_flags = 0;
    95c6:	strb	r3, [r4, #2]
  return rtn;
}
    95c8:	pop	{r4, pc}
    95ca:	nop

000095cc <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    95cc:	push	{r3, r4, r5, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    95ce:	ldrb	r3, [r0, #0]
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    95d0:	mov	r5, r0
    95d2:	mov	r4, r1
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    95d4:	cbnz	r3, 9604 <FatFile::dirEntry(DirFat_t*)+0x38>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    95d6:	mov	r0, r5
    95d8:	movs	r1, #0
    95da:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    95de:	cbz	r0, 960c <FatFile::dirEntry(DirFat_t*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    95e0:	ldr	r1, [r0, #0]
    95e2:	ldr	r2, [r0, #4]
    95e4:	ldr	r3, [r0, #8]
    95e6:	ldr	r5, [r0, #12]
    95e8:	str	r5, [r4, #12]
    95ea:	str	r1, [r4, #0]
    95ec:	str	r2, [r4, #4]
    95ee:	str	r3, [r4, #8]
    95f0:	ldr	r1, [r0, #16]
    95f2:	ldr	r2, [r0, #20]
    95f4:	ldr	r3, [r0, #24]
    95f6:	ldr	r5, [r0, #28]
    95f8:	str	r5, [r4, #28]
    95fa:	str	r1, [r4, #16]
    95fc:	str	r2, [r4, #20]
    95fe:	str	r3, [r4, #24]
  return true;
    9600:	movs	r0, #1

 fail:
  return false;
}
    9602:	pop	{r3, r4, r5, pc}
    9604:	bl	9518 <FatFile::sync() [clone .part.42]>
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    9608:	cmp	r0, #0
    960a:	bne.n	95d6 <FatFile::dirEntry(DirFat_t*)+0xa>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    960c:	movs	r0, #0
    960e:	pop	{r3, r4, r5, pc}

00009610 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    9610:	push	{r4, r5, lr}
    9612:	sub	sp, #36	; 0x24
    9614:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    9616:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    9618:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    961a:	bl	95cc <FatFile::dirEntry(DirFat_t*)>
    961e:	cbz	r0, 962c <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    9620:	ldrh.w	r2, [sp, #24]
  *ptime = getLe16(dir.modifyTime);
    9624:	ldrh.w	r3, [sp, #22]
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    9628:	strh	r2, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    962a:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    962c:	add	sp, #36	; 0x24
    962e:	pop	{r4, r5, pc}

00009630 <FatFile::mkdir(FatFile*, fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    9630:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    9634:	ldrb	r4, [r1, #0]
    9636:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    963a:	sub	sp, #36	; 0x24
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    963c:	bne.n	9646 <FatFile::mkdir(FatFile*, fname_t*)+0x16>
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
}
    963e:	movs	r0, #0
    9640:	add	sp, #36	; 0x24
    9642:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    9646:	movw	r3, #2562	; 0xa02
    964a:	mov	r5, r0
    964c:	mov	r4, r1
    964e:	bl	ad2c <FatFile::open(FatFile*, fname_t*, int)>
    9652:	cmp	r0, #0
    9654:	beq.n	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    9656:	movs	r2, #1
  m_attributes = FILE_ATTR_SUBDIR;
    9658:	movs	r3, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    965a:	strb	r2, [r5, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    965c:	strb	r3, [r5, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    965e:	mov	r0, r5
    9660:	bl	9460 <FatFile::addDirCluster()>
    9664:	cmp	r0, #0
    9666:	beq.n	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    9668:	ldrb	r3, [r5, #0]
  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    966a:	ldr	r2, [r5, #16]
    966c:	str	r2, [r5, #32]
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    966e:	cmp	r3, #0
    9670:	bne.n	975e <FatFile::mkdir(FatFile*, fname_t*)+0x12e>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    9672:	movs	r1, #1
    9674:	mov	r0, r5
    9676:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    967a:	mov	r6, r0
    967c:	cmp	r0, #0
    967e:	beq.n	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    9680:	movs	r3, #16
    9682:	strb	r3, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    9684:	ldr	r2, [r0, #8]
    9686:	ldr	r1, [r6, #4]
    9688:	ldr	r3, [r6, #12]
    968a:	ldr	r0, [r0, #0]
    968c:	ldrh.w	r8, [r6, #20]
    9690:	ldrh.w	r9, [r6, #26]
    9694:	mov	r7, sp
    9696:	stmia	r7!, {r0, r1, r2, r3}
    9698:	ldr	r1, [r6, #20]
    969a:	ldr	r2, [r6, #24]
    969c:	ldr	r3, [r6, #28]
    969e:	ldr	r0, [r6, #16]
  dot.name[0] = '.';
    96a0:	add	r6, sp, #32
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    96a2:	stmia	r7!, {r0, r1, r2, r3}
  dot.name[0] = '.';
    96a4:	movs	r3, #46	; 0x2e
    96a6:	strb.w	r3, [r6, #-32]!
    96aa:	add.w	r1, sp, #10
    96ae:	mov	r3, r6
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    96b0:	movs	r2, #32
    96b2:	strb.w	r2, [r3, #1]!
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    96b6:	cmp	r3, r1
    96b8:	bne.n	96b2 <FatFile::mkdir(FatFile*, fname_t*)+0x82>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    96ba:	ldr	r0, [r5, #8]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    96bc:	ldr	r3, [r5, #32]
    96be:	ldrb	r2, [r0, #6]
    96c0:	ldr	r1, [r0, #20]
    96c2:	subs	r3, #2
    96c4:	lsls	r3, r2
    96c6:	add	r1, r3
    96c8:	adds	r0, #36	; 0x24
    96ca:	movs	r2, #1
    96cc:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    96d0:	mov	lr, r0
    96d2:	cmp	r0, #0
    96d4:	beq.n	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    96d6:	mov	r7, r6
    96d8:	strh.w	r8, [sp, #20]
    96dc:	strh.w	r9, [sp, #26]
    96e0:	ldmia	r7!, {r0, r1, r2, r3}
    96e2:	str.w	r0, [lr]
    96e6:	str.w	r1, [lr, #4]
    96ea:	str.w	r2, [lr, #8]
    96ee:	str.w	r3, [lr, #12]
    96f2:	ldmia	r7!, {r0, r1, r2, r3}
    96f4:	str.w	r0, [lr, #16]
    96f8:	str.w	r1, [lr, #20]
    96fc:	str.w	r2, [lr, #24]
    9700:	str.w	r3, [lr, #28]
  // make entry for '..'
  dot.name[1] = '.';
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    9704:	ldr	r3, [r4, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    9706:	strh.w	r3, [sp, #26]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    970a:	movs	r2, #46	; 0x2e
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    970c:	lsrs	r3, r3, #16
    970e:	mov	r4, r6
    9710:	strh.w	r3, [sp, #20]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    9714:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    9718:	ldmia	r4!, {r0, r1, r2, r3}
    971a:	add.w	r6, lr, #32
    971e:	str.w	r0, [lr, #32]
    9722:	str	r1, [r6, #4]
    9724:	str	r2, [r6, #8]
    9726:	str	r3, [r6, #12]
    9728:	ldmia	r4!, {r0, r1, r2, r3}
    972a:	str	r0, [r6, #16]
    972c:	str	r1, [r6, #20]
    972e:	str	r2, [r6, #24]
    9730:	str	r3, [r6, #28]
  // write first sector
  return m_vol->cacheSync();
    9732:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9734:	add.w	r0, r4, #36	; 0x24
    9738:	bl	779c <FsCache::sync()>
    973c:	cmp	r0, #0
    973e:	beq.w	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    9742:	add.w	r0, r4, #564	; 0x234
    9746:	bl	779c <FsCache::sync()>
    974a:	cmp	r0, #0
    974c:	beq.w	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    9750:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9752:	ldr	r3, [r0, #0]
    9754:	ldr	r3, [r3, #24]

 fail:
  return false;
}
    9756:	add	sp, #36	; 0x24
    9758:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    975c:	bx	r3
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    975e:	ldr	r3, [r5, #20]
    9760:	cbz	r3, 9770 <FatFile::mkdir(FatFile*, fname_t*)+0x140>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9762:	ldrb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    9764:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9766:	bic.w	r3, r3, #32
    976a:	strb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    976c:	str	r2, [r5, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    976e:	str	r2, [r5, #20]
    9770:	mov	r0, r5
    9772:	bl	9518 <FatFile::sync() [clone .part.42]>
  }
  m_firstCluster = m_curCluster;
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    9776:	cmp	r0, #0
    9778:	beq.w	963e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    977c:	b.n	9672 <FatFile::mkdir(FatFile*, fname_t*)+0x42>
    977e:	nop

00009780 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    9780:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9784:	mov	r6, r0
    9786:	sub	sp, #72	; 0x48
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    9788:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    978a:	str	r2, [sp, #4]
    978c:	movs	r0, #0
    978e:	strb.w	r0, [sp, #36]	; 0x24
    9792:	strb.w	r0, [sp, #37]	; 0x25
    9796:	strb.w	r0, [sp, #38]	; 0x26
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    979a:	cbnz	r5, 97a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    979c:	mov	r8, r3
    979e:	ldrb	r3, [r1, #0]
    97a0:	tst.w	r3, #112	; 0x70
    97a4:	mov	r4, r1
    97a6:	bne.n	97b0 <FatFile::mkdir(FatFile*, char const*, bool)+0x30>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    97a8:	movs	r0, #0
}
    97aa:	add	sp, #72	; 0x48
    97ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    97b0:	ldrb	r3, [r2, #0]
    97b2:	cmp	r3, #47	; 0x2f
    97b4:	mov	r0, r2
    97b6:	beq.n	980e <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    97b8:	movs	r7, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    97ba:	add	r2, sp, #4
    97bc:	add	r1, sp, #12
    97be:	bl	a844 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    97c2:	add	r2, sp, #12
    97c4:	mov	r1, r4
    97c6:	movs	r3, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    97c8:	cmp	r0, #0
    97ca:	beq.n	97a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    97cc:	ldr	r5, [sp, #4]
    97ce:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    97d0:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    97d2:	cmp	r5, #0
    97d4:	beq.n	9832 <FatFile::mkdir(FatFile*, char const*, bool)+0xb2>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    97d6:	bl	ad2c <FatFile::open(FatFile*, fname_t*, int)>
    97da:	cbnz	r0, 97f0 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      if (!pFlag || !mkdir(parent, &fname)) {
    97dc:	cmp.w	r8, #0
    97e0:	beq.n	97a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    97e2:	mov	r1, r4
    97e4:	add	r2, sp, #12
    97e6:	mov	r0, r6
    97e8:	bl	9630 <FatFile::mkdir(FatFile*, fname_t*)>
    97ec:	cmp	r0, #0
    97ee:	beq.n	97a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    97f0:	mov	r5, r6
    97f2:	ldmia	r5!, {r0, r1, r2, r3}
    97f4:	add	r4, sp, #36	; 0x24
    97f6:	stmia	r4!, {r0, r1, r2, r3}
    97f8:	ldmia	r5!, {r0, r1, r2, r3}
    97fa:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    97fc:	ldrb	r3, [r6, #0]
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    97fe:	ldr	r2, [r5, #0]
    9800:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9802:	cbnz	r3, 982a <FatFile::mkdir(FatFile*, char const*, bool)+0xaa>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9804:	strb	r7, [r6, #0]
  m_flags = 0;
    9806:	strb	r7, [r6, #2]
    9808:	ldr	r0, [sp, #4]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    980a:	add	r4, sp, #36	; 0x24
    980c:	b.n	97ba <FatFile::mkdir(FatFile*, char const*, bool)+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    980e:	adds	r0, #1
    9810:	str	r0, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    9812:	ldrb	r3, [r0, #0]
    9814:	cmp	r3, #47	; 0x2f
    9816:	beq.n	980e <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    9818:	ldr	r1, [r4, #8]
    981a:	add	r0, sp, #36	; 0x24
    981c:	bl	93f8 <FatFile::openRoot(FatVolume*) [clone .part.38]>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    9820:	cmp	r0, #0
    9822:	beq.n	97a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    9824:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    9826:	add	r4, sp, #36	; 0x24
    9828:	b.n	97b8 <FatFile::mkdir(FatFile*, char const*, bool)+0x38>
    982a:	mov	r0, r6
    982c:	bl	9518 <FatFile::sync() [clone .part.42]>
    9830:	b.n	9804 <FatFile::mkdir(FatFile*, char const*, bool)+0x84>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    9832:	add	r2, sp, #12
    9834:	mov	r1, r4
    9836:	mov	r0, r6
    9838:	bl	9630 <FatFile::mkdir(FatFile*, fname_t*)>

 fail:
  return false;
}
    983c:	add	sp, #72	; 0x48
    983e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9842:	nop

00009844 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    9844:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9848:	mov	r6, r0
    984a:	sub	sp, #72	; 0x48
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    984c:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    984e:	str	r2, [sp, #4]
    9850:	movs	r0, #0
    9852:	strb.w	r0, [sp, #36]	; 0x24
    9856:	strb.w	r0, [sp, #37]	; 0x25
    985a:	strb.w	r0, [sp, #38]	; 0x26
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    985e:	cbnz	r5, 986c <FatFile::open(FatFile*, char const*, int)+0x28>
    9860:	mov	r8, r3
    9862:	ldrb	r3, [r1, #0]
    9864:	tst.w	r3, #112	; 0x70
    9868:	mov	r4, r1
    986a:	bne.n	9874 <FatFile::open(FatFile*, char const*, int)+0x30>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    986c:	movs	r0, #0
}
    986e:	add	sp, #72	; 0x48
    9870:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    9874:	ldrb	r3, [r2, #0]
    9876:	cmp	r3, #47	; 0x2f
    9878:	mov	r0, r2
    987a:	beq.n	98c8 <FatFile::open(FatFile*, char const*, int)+0x84>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    987c:	movs	r7, #0
    987e:	b.n	9888 <FatFile::open(FatFile*, char const*, int)+0x44>
    9880:	ldr	r0, [sp, #4]
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9882:	strb	r7, [r6, #0]
  m_flags = 0;
    9884:	strb	r7, [r6, #2]
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    9886:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9888:	add	r2, sp, #4
    988a:	add	r1, sp, #12
    988c:	bl	a844 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9890:	add	r2, sp, #12
    9892:	mov	r1, r4
    9894:	movs	r3, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9896:	cmp	r0, #0
    9898:	beq.n	986c <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    989a:	ldr	r5, [sp, #4]
    989c:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    989e:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    98a0:	cbz	r5, 98e6 <FatFile::open(FatFile*, char const*, int)+0xa2>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    98a2:	bl	ad2c <FatFile::open(FatFile*, fname_t*, int)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    98a6:	mov	r5, r6
    98a8:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    98aa:	cmp	r0, #0
    98ac:	beq.n	986c <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    98ae:	ldmia	r5!, {r0, r1, r2, r3}
    98b0:	stmia	r4!, {r0, r1, r2, r3}
    98b2:	ldmia	r5!, {r0, r1, r2, r3}
    98b4:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    98b6:	ldrb	r3, [r6, #0]
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    98b8:	ldr	r2, [r5, #0]
    98ba:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    98bc:	cmp	r3, #0
    98be:	beq.n	9880 <FatFile::open(FatFile*, char const*, int)+0x3c>
    98c0:	mov	r0, r6
    98c2:	bl	9518 <FatFile::sync() [clone .part.42]>
    98c6:	b.n	9880 <FatFile::open(FatFile*, char const*, int)+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    98c8:	adds	r0, #1
    98ca:	str	r0, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    98cc:	ldrb	r3, [r0, #0]
    98ce:	cmp	r3, #47	; 0x2f
    98d0:	beq.n	98c8 <FatFile::open(FatFile*, char const*, int)+0x84>
      path++;
    }
    if (*path == 0) {
    98d2:	cbz	r3, 98f8 <FatFile::open(FatFile*, char const*, int)+0xb4>
    98d4:	ldr	r1, [r4, #8]
    98d6:	add	r0, sp, #36	; 0x24
    98d8:	bl	93f8 <FatFile::openRoot(FatVolume*) [clone .part.38]>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    98dc:	cmp	r0, #0
    98de:	beq.n	986c <FatFile::open(FatFile*, char const*, int)+0x28>
    98e0:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    98e2:	add	r4, sp, #36	; 0x24
    98e4:	b.n	987c <FatFile::open(FatFile*, char const*, int)+0x38>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    98e6:	mov	r3, r8
    98e8:	add	r2, sp, #12
    98ea:	mov	r1, r4
    98ec:	mov	r0, r6
    98ee:	bl	ad2c <FatFile::open(FatFile*, fname_t*, int)>

 fail:
  return false;
}
    98f2:	add	sp, #72	; 0x48
    98f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    98f8:	ldr	r1, [r4, #8]
    98fa:	mov	r0, r6
    98fc:	bl	93f8 <FatFile::openRoot(FatVolume*) [clone .part.38]>
    9900:	b.n	986e <FatFile::open(FatFile*, char const*, int)+0x2a>
    9902:	nop

00009904 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    9904:	cbz	r1, 990e <FatFile::open(FatVolume*, char const*, int)+0xa>
    9906:	addw	r1, r1, #1092	; 0x444
    990a:	b.w	9844 <FatFile::open(FatFile*, char const*, int)>
}
    990e:	mov	r0, r1
    9910:	bx	lr
    9912:	nop

00009914 <FatFile::openRoot(FatVolume*)>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    9914:	ldrb	r3, [r0, #0]
    9916:	cbz	r3, 991c <FatFile::openRoot(FatVolume*)+0x8>
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
}
    9918:	movs	r0, #0
    991a:	bx	lr
    991c:	b.w	93f8 <FatFile::openRoot(FatVolume*) [clone .part.38]>

00009920 <FatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    9920:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    9924:	ldrb	r3, [r0, #2]
    9926:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    9928:	sub	sp, #12
    992a:	mov	r5, r0
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    992c:	bpl.w	9a54 <FatFile::read(void*, unsigned int)+0x134>
    9930:	mov	r7, r1
    9932:	ldrb	r1, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    9934:	lsls	r6, r1, #28
    9936:	mov	r9, r2
    9938:	bmi.w	9a66 <FatFile::read(void*, unsigned int)+0x146>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    993c:	lsls	r4, r1, #26
    993e:	bpl.n	9952 <FatFile::read(void*, unsigned int)+0x32>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    9940:	ldr	r2, [r0, #8]
    if (nbyte > tmp16) {
    9942:	ldr	r3, [r0, #20]
    9944:	ldrh	r2, [r2, #8]
    9946:	rsb	r3, r3, r2, lsl #5
    994a:	uxth	r3, r3
    994c:	cmp	r9, r3
    994e:	it	cs
    9950:	movcs	r9, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    9952:	cmp.w	r9, #0
    9956:	beq.w	9ab2 <FatFile::read(void*, unsigned int)+0x192>
    995a:	ldr	r3, [r5, #20]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    995c:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    995e:	lsls	r0, r1, #26
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    9960:	mov	r6, r9
    9962:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    9966:	add.w	sl, r5, #16
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    996a:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    996e:	bpl.n	99f2 <FatFile::read(void*, unsigned int)+0xd2>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    9970:	ldr	r1, [r2, #32]
    9972:	add.w	r1, r1, r3, lsr #9
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    9976:	cmp.w	fp, #0
    997a:	bne.n	9a28 <FatFile::read(void*, unsigned int)+0x108>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    997c:	cmp.w	r6, #512	; 0x200
    9980:	bcc.n	9a28 <FatFile::read(void*, unsigned int)+0x108>
    9982:	ldr	r3, [r2, #48]	; 0x30
        || sector == m_vol->cacheSectorNumber()) {
    9984:	cmp	r1, r3
    9986:	beq.n	9a28 <FatFile::read(void*, unsigned int)+0x108>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    9988:	cmp.w	r6, #1024	; 0x400
    998c:	bcc.n	9a78 <FatFile::read(void*, unsigned int)+0x158>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    998e:	ldrb	r0, [r5, #0]
    9990:	lsls	r0, r0, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    9992:	mov.w	fp, r6, lsr #9
      if (!isRootFixed()) {
    9996:	bmi.n	99a4 <FatFile::read(void*, unsigned int)+0x84>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    9998:	ldrb	r0, [r2, #4]
    999a:	rsb	r0, r8, r0
    999e:	cmp	fp, r0
    99a0:	it	cs
    99a2:	movcs	fp, r0
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    99a4:	cmp	r1, r3
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    99a6:	mov.w	r4, fp, lsl #9
    99aa:	bhi.n	99c8 <FatFile::read(void*, unsigned int)+0xa8>
    99ac:	add.w	r0, r1, fp
    99b0:	cmp	r3, r0
    99b2:	bcs.n	99c8 <FatFile::read(void*, unsigned int)+0xa8>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    99b4:	add.w	r0, r2, #36	; 0x24
    99b8:	str	r1, [sp, #4]
    99ba:	str	r2, [sp, #0]
    99bc:	bl	779c <FsCache::sync()>
    99c0:	ldr	r2, [sp, #0]
    99c2:	ldr	r1, [sp, #4]
    99c4:	cmp	r0, #0
    99c6:	beq.n	9a54 <FatFile::read(void*, unsigned int)+0x134>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    99c8:	ldr	r0, [r2, #40]	; 0x28
    99ca:	ldr	r2, [r0, #0]
    99cc:	mov	r3, fp
    99ce:	ldr.w	fp, [r2, #16]
    99d2:	mov	r2, r7
    99d4:	blx	fp
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    99d6:	cmp	r0, #0
    99d8:	beq.n	9a54 <FatFile::read(void*, unsigned int)+0x134>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    99da:	ldr	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    99dc:	subs	r6, r6, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    99de:	add	r3, r4
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    99e0:	add	r7, r4
    m_curPosition += n;
    99e2:	str	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    99e4:	beq.n	9ab2 <FatFile::read(void*, unsigned int)+0x192>
    99e6:	ldrb	r1, [r5, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    99e8:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    99ea:	lsls	r0, r1, #26
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    99ec:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    99f0:	bmi.n	9970 <FatFile::read(void*, unsigned int)+0x50>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    99f2:	ldrb.w	r8, [r2, #5]
    99f6:	and.w	r8, r8, r3, lsr #9
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    99fa:	cmp.w	fp, #0
    99fe:	bne.n	9a74 <FatFile::read(void*, unsigned int)+0x154>
    9a00:	cmp.w	r8, #0
    9a04:	bne.n	9a74 <FatFile::read(void*, unsigned int)+0x154>
        // start of new cluster
        if (m_curPosition == 0) {
    9a06:	cmp	r3, #0
    9a08:	bne.n	9a8c <FatFile::read(void*, unsigned int)+0x16c>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    9a0a:	lsls	r1, r1, #25
    9a0c:	ite	mi
    9a0e:	ldrmi	r4, [r2, #32]
    9a10:	ldrpl	r4, [r5, #32]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    9a12:	str	r4, [r5, #16]
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    9a14:	ldrb	r1, [r2, #6]
    9a16:	ldr	r0, [r2, #20]
    9a18:	subs	r4, #2
    9a1a:	lsls	r4, r1
    9a1c:	add.w	r1, r8, r0
    9a20:	add	r1, r4
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    9a22:	cmp.w	fp, #0
    9a26:	beq.n	997c <FatFile::read(void*, unsigned int)+0x5c>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    9a28:	add.w	r0, r2, #36	; 0x24
    9a2c:	movs	r2, #0
    9a2e:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    9a32:	cbz	r0, 9a54 <FatFile::read(void*, unsigned int)+0x134>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    9a34:	rsb	r4, fp, #512	; 0x200
    9a38:	cmp	r4, r6
    9a3a:	it	cs
    9a3c:	movcs	r4, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    9a3e:	add.w	r1, r0, fp
    9a42:	mov	r2, r4
    9a44:	mov	r0, r7
    9a46:	bl	cfd4 <memcpy>
    9a4a:	b.n	99da <FatFile::read(void*, unsigned int)+0xba>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    9a4c:	ldrb	r3, [r5, #0]
    9a4e:	tst.w	r3, #112	; 0x70
    9a52:	bne.n	9ab4 <FatFile::read(void*, unsigned int)+0x194>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    9a54:	ldrb	r3, [r5, #1]
  return -1;
    9a56:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    9a5a:	orr.w	r3, r3, #2
    9a5e:	strb	r3, [r5, #1]
  return -1;
}
    9a60:	add	sp, #12
    9a62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    uint32_t tmp32 = m_fileSize - m_curPosition;
    9a66:	ldr	r3, [r0, #28]
    9a68:	ldr	r2, [r0, #20]
    9a6a:	subs	r3, r3, r2
    9a6c:	cmp	r9, r3
    9a6e:	it	cs
    9a70:	movcs	r9, r3
    9a72:	b.n	9952 <FatFile::read(void*, unsigned int)+0x32>
    9a74:	ldr	r4, [r5, #16]
    9a76:	b.n	9a14 <FatFile::read(void*, unsigned int)+0xf4>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    9a78:	ldr	r0, [r2, #40]	; 0x28
    9a7a:	ldr	r3, [r0, #0]
    9a7c:	mov	r2, r7
    9a7e:	ldr	r3, [r3, #12]
    9a80:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    9a82:	cmp	r0, #0
    9a84:	beq.n	9a54 <FatFile::read(void*, unsigned int)+0x134>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    9a86:	mov.w	r4, #512	; 0x200
    9a8a:	b.n	99da <FatFile::read(void*, unsigned int)+0xba>
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    9a8c:	lsls	r3, r1, #28
    9a8e:	bpl.n	9a9c <FatFile::read(void*, unsigned int)+0x17c>
    9a90:	ldrb	r3, [r5, #2]
    9a92:	lsls	r4, r3, #25
    9a94:	bpl.n	9a9c <FatFile::read(void*, unsigned int)+0x17c>
          m_curCluster++;
    9a96:	ldr	r4, [r5, #16]
    9a98:	adds	r4, #1
    9a9a:	b.n	9a12 <FatFile::read(void*, unsigned int)+0xf2>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    9a9c:	mov	r0, r2
    9a9e:	ldr	r1, [r5, #16]
    9aa0:	mov	r2, sl
    9aa2:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    9aa6:	cmp	r0, #0
    9aa8:	blt.n	9a54 <FatFile::read(void*, unsigned int)+0x134>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    9aaa:	beq.n	9a4c <FatFile::read(void*, unsigned int)+0x12c>
    9aac:	ldr	r2, [r5, #8]
    9aae:	ldr	r4, [r5, #16]
    9ab0:	b.n	9a14 <FatFile::read(void*, unsigned int)+0xf4>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    9ab2:	movs	r6, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    9ab4:	rsb	r0, r6, r9

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    9ab8:	add	sp, #12
    9aba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9abe:	nop

00009ac0 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    9ac0:	push	{r4, r5, r6, lr}
    9ac2:	sub	sp, #8
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    9ac4:	movs	r2, #1
    9ac6:	add.w	r1, sp, #7
    9aca:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    9acc:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    9ace:	ldr	r5, [r0, #16]
    9ad0:	bl	9920 <FatFile::read(void*, unsigned int)>
    9ad4:	cmp	r0, #1
    9ad6:	it	eq
    9ad8:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    9adc:	str	r6, [r4, #20]
    9ade:	it	ne
    9ae0:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    9ae4:	str	r5, [r4, #16]
  return c;
}
    9ae6:	add	sp, #8
    9ae8:	pop	{r4, r5, r6, pc}
    9aea:	nop

00009aec <FatFile::readDirCache(bool)>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    9aec:	push	{r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
    9aee:	ldr	r3, [r0, #20]
    9af0:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    9af4:	sub	sp, #12
    9af6:	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    9af8:	cbz	r5, 9afc <FatFile::readDirCache(bool)+0x10>
    9afa:	cbnz	r1, 9b20 <FatFile::readDirCache(bool)+0x34>
    int8_t n = read(&n, 1);
    9afc:	movs	r2, #1
    9afe:	add.w	r1, sp, #7
    9b02:	mov	r0, r4
    9b04:	bl	9920 <FatFile::read(void*, unsigned int)>
    9b08:	sxtb	r0, r0
    if  (n != 1) {
    9b0a:	cmp	r0, #1
    9b0c:	bne.n	9b26 <FatFile::readDirCache(bool)+0x3a>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    9b0e:	ldr	r3, [r4, #20]
    9b10:	adds	r3, #31
    9b12:	str	r3, [r4, #20]
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    9b14:	ldr	r0, [r4, #8]
    9b16:	adds	r0, #52	; 0x34
  } else {
    m_curPosition += 32;
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    9b18:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    9b1c:	add	sp, #12
    9b1e:	pop	{r4, r5, pc}
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    9b20:	adds	r3, #32
    9b22:	str	r3, [r0, #20]
    9b24:	b.n	9b14 <FatFile::readDirCache(bool)+0x28>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    9b26:	movs	r0, #0
}
    9b28:	add	sp, #12
    9b2a:	pop	{r4, r5, pc}

00009b2c <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    9b2c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    9b30:	ldrb	r5, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    9b32:	sub	sp, #104	; 0x68
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    9b34:	movs	r4, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    9b36:	tst.w	r5, #24
    9b3a:	strb.w	r4, [sp, #32]
    9b3e:	strb.w	r4, [sp, #33]	; 0x21
    9b42:	strb.w	r4, [sp, #34]	; 0x22
    9b46:	strb.w	r4, [sp, #68]	; 0x44
    9b4a:	strb.w	r4, [sp, #69]	; 0x45
    9b4e:	strb.w	r4, [sp, #70]	; 0x46
    9b52:	beq.n	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    9b54:	ldr	r6, [r0, #8]
    9b56:	ldr	r5, [r1, #8]
    9b58:	cmp	r6, r5
    9b5a:	mov	r3, r0
    9b5c:	beq.n	9b66 <FatFile::rename(FatFile*, char const*)+0x3a>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    9b5e:	movs	r0, #0
}
    9b60:	add	sp, #104	; 0x68
    9b62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9b66:	mov	r5, r3
    9b68:	mov	r8, r2
    9b6a:	mov	r6, r1
    9b6c:	bl	9518 <FatFile::sync() [clone .part.42]>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    9b70:	mov	lr, r5
    9b72:	ldmia.w	lr!, {r0, r1, r2, r3}
    9b76:	add	r7, sp, #68	; 0x44
    9b78:	stmia	r7!, {r0, r1, r2, r3}
    9b7a:	ldmia.w	lr!, {r0, r1, r2, r3}
    9b7e:	stmia	r7!, {r0, r1, r2, r3}
    9b80:	ldr.w	r3, [lr]
    9b84:	str	r3, [r7, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    9b86:	mov	r1, r4
    9b88:	mov	r0, r5
    9b8a:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    9b8e:	mov	lr, r0
    9b90:	cmp	r0, #0
    9b92:	beq.n	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    9b94:	ldr.w	r1, [lr, #4]
    9b98:	ldr.w	r2, [lr, #8]
    9b9c:	ldr.w	r3, [lr, #12]
    9ba0:	ldr	r0, [r0, #0]
  // make directory entry for new path
  if (isFile()) {
    9ba2:	ldrb.w	ip, [r5]
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    9ba6:	mov	r7, sp
    9ba8:	stmia	r7!, {r0, r1, r2, r3}
    9baa:	ldr.w	r1, [lr, #20]
    9bae:	ldr.w	r2, [lr, #24]
    9bb2:	ldr.w	r3, [lr, #28]
    9bb6:	ldr.w	r0, [lr, #16]
  // make directory entry for new path
  if (isFile()) {
    9bba:	and.w	lr, ip, #8
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    9bbe:	stmia	r7!, {r0, r1, r2, r3}
  // make directory entry for new path
  if (isFile()) {
    9bc0:	and.w	r3, lr, #255	; 0xff
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    9bc4:	mov	r2, r8
    9bc6:	mov	r1, r6
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    9bc8:	cmp.w	lr, #0
    9bcc:	beq.w	9cf0 <FatFile::rename(FatFile*, char const*)+0x1c4>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    9bd0:	movw	r3, #2561	; 0xa01
    9bd4:	add	r0, sp, #32
    9bd6:	bl	9844 <FatFile::open(FatFile*, char const*, int)>
    9bda:	cmp	r0, #0
    9bdc:	beq.n	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    9bde:	ldr	r0, [sp, #56]	; 0x38
  m_dirIndex = file.m_dirIndex;
    9be0:	ldrh.w	r1, [sp, #36]	; 0x24
  m_lfnOrd = file.m_lfnOrd;
    9be4:	ldrb.w	r2, [sp, #35]	; 0x23
  m_dirCluster = file.m_dirCluster;
    9be8:	ldr	r3, [sp, #44]	; 0x2c
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    9bea:	str	r0, [r5, #24]
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    9bec:	movs	r6, #0
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
    9bee:	strh	r1, [r5, #4]
  m_lfnOrd = file.m_lfnOrd;
    9bf0:	strb	r2, [r5, #3]
  m_dirCluster = file.m_dirCluster;
    9bf2:	str	r3, [r5, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    9bf4:	movs	r1, #1
    9bf6:	mov	r0, r5
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    9bf8:	strb.w	r6, [sp, #32]
  file.m_flags = 0;
    9bfc:	strb.w	r6, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    9c00:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    9c04:	cmp	r0, #0
    9c06:	beq.n	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    9c08:	add	r3, sp, #104	; 0x68
  dir->attributes = entry.attributes;
    9c0a:	ldrb.w	r2, [sp, #11]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    9c0e:	ldr.w	r7, [r3, #-91]!
    9c12:	str.w	r7, [r0, #13]
    9c16:	ldr	r7, [r3, #4]
    9c18:	str.w	r7, [r0, #17]
    9c1c:	ldr	r7, [r3, #8]
    9c1e:	str.w	r7, [r0, #21]
    9c22:	ldr	r7, [r3, #12]
    9c24:	str.w	r7, [r0, #25]
    9c28:	ldrh	r7, [r3, #16]
    9c2a:	ldrb	r3, [r3, #18]
    9c2c:	strh.w	r7, [r0, #29]
    9c30:	strb	r3, [r0, #31]
  dir->attributes = entry.attributes;
    9c32:	strb	r2, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    9c34:	cmp	r4, #0
    9c36:	beq.n	9cac <FatFile::rename(FatFile*, char const*)+0x180>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    9c38:	ldr	r0, [r5, #8]
    9c3a:	ldrb	r2, [r0, #6]
    9c3c:	ldr	r1, [r0, #20]
    9c3e:	subs	r3, r4, #2
    9c40:	lsls	r3, r2
    9c42:	add	r1, r3
    9c44:	mov	r2, r6
    9c46:	adds	r0, #36	; 0x24
    9c48:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    9c4c:	cmp	r0, #0
    9c4e:	beq.n	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    9c50:	mov	r6, r0
    9c52:	mov	r7, sp
    9c54:	ldr.w	r0, [r6, #32]!
    9c58:	ldr	r1, [r6, #4]
    9c5a:	ldr	r2, [r6, #8]
    9c5c:	ldr	r3, [r6, #12]
    9c5e:	stmia	r7!, {r0, r1, r2, r3}
    9c60:	ldr	r0, [r6, #16]
    9c62:	ldr	r1, [r6, #20]
    9c64:	ldr	r2, [r6, #24]
    9c66:	ldr	r3, [r6, #28]
    9c68:	stmia	r7!, {r0, r1, r2, r3}

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    9c6a:	mov	r1, r4
    9c6c:	ldr	r0, [r5, #8]
    9c6e:	bl	a4d4 <FatPartition::freeChain(unsigned long)>
    9c72:	cmp	r0, #0
    9c74:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    9c78:	ldr	r0, [r5, #8]
    9c7a:	ldr	r3, [r5, #32]
    9c7c:	ldrb	r2, [r0, #6]
    9c7e:	ldr	r1, [r0, #20]
    9c80:	subs	r3, #2
    9c82:	lsls	r3, r2
    9c84:	add	r1, r3
    9c86:	adds	r0, #36	; 0x24
    9c88:	movs	r2, #1
    9c8a:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    9c8e:	mov	r7, r0
    9c90:	cmp	r0, #0
    9c92:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    9c96:	mov	r4, sp
    9c98:	ldmia	r4!, {r0, r1, r2, r3}
    9c9a:	str	r0, [r7, #32]
    9c9c:	str	r1, [r7, #36]	; 0x24
    9c9e:	str	r2, [r7, #40]	; 0x28
    9ca0:	str	r3, [r7, #44]	; 0x2c
    9ca2:	ldmia	r4!, {r0, r1, r2, r3}
    9ca4:	str	r0, [r7, #48]	; 0x30
    9ca6:	str	r1, [r7, #52]	; 0x34
    9ca8:	str	r2, [r7, #56]	; 0x38
    9caa:	str	r3, [r7, #60]	; 0x3c
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    9cac:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    9cae:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    9cb0:	movs	r3, #8
  if (!oldFile.remove()) {
    9cb2:	add	r0, sp, #68	; 0x44
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    9cb4:	str	r1, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    9cb6:	strb.w	r2, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
    9cba:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    9cbe:	bl	ab4c <FatFile::remove()>
    9cc2:	cmp	r0, #0
    9cc4:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    9cc8:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9cca:	add.w	r0, r4, #36	; 0x24
    9cce:	bl	779c <FsCache::sync()>
    9cd2:	cmp	r0, #0
    9cd4:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    9cd8:	add.w	r0, r4, #564	; 0x234
    9cdc:	bl	779c <FsCache::sync()>
    9ce0:	cmp	r0, #0
    9ce2:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
    9ce6:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9ce8:	ldr	r3, [r0, #0]
    9cea:	ldr	r3, [r3, #24]
    9cec:	blx	r3
    9cee:	b.n	9b60 <FatFile::rename(FatFile*, char const*)+0x34>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    9cf0:	add	r0, sp, #32
    9cf2:	bl	9780 <FatFile::mkdir(FatFile*, char const*, bool)>
    9cf6:	cmp	r0, #0
    9cf8:	beq.w	9b5e <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    9cfc:	ldr	r4, [sp, #64]	; 0x40
    9cfe:	b.n	9bde <FatFile::rename(FatFile*, char const*)+0xb2>

00009d00 <FatFile::rmdir()>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    9d00:	ldrb	r3, [r0, #0]
    9d02:	lsls	r2, r3, #27
    9d04:	bpl.n	9d3c <FatFile::rmdir()+0x3c>
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    9d06:	ldr	r3, [r0, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    9d08:	push	{r4, lr}
    9d0a:	mov	r4, r0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    9d0c:	cbz	r3, 9d1c <FatFile::rmdir()+0x1c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9d0e:	ldrb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    9d10:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9d12:	bic.w	r3, r3, #32
    9d16:	strb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    9d18:	str	r2, [r0, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    9d1a:	str	r2, [r0, #20]
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    9d1c:	movs	r1, #1
    9d1e:	mov	r0, r4
    9d20:	bl	9aec <FatFile::readDirCache(bool)>
    if (!dir) {
    9d24:	cbz	r0, 9d40 <FatFile::rmdir()+0x40>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    9d26:	ldrb	r3, [r0, #0]
    9d28:	cbz	r3, 9d46 <FatFile::rmdir()+0x46>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    9d2a:	cmp	r3, #229	; 0xe5
    9d2c:	beq.n	9d1c <FatFile::rmdir()+0x1c>
    9d2e:	cmp	r3, #46	; 0x2e
    9d30:	beq.n	9d1c <FatFile::rmdir()+0x1c>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    9d32:	ldrb	r3, [r0, #11]
    9d34:	lsls	r3, r3, #28
    9d36:	bmi.n	9d1c <FatFile::rmdir()+0x1c>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
}
    9d38:	movs	r0, #0
    9d3a:	pop	{r4, pc}
    9d3c:	movs	r0, #0
    9d3e:	bx	lr
  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
    9d40:	ldrb	r3, [r4, #1]
    9d42:	cmp	r3, #0
    9d44:	bne.n	9d38 <FatFile::rmdir()+0x38>
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    9d46:	ldrb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    9d48:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    9d4a:	orr.w	r3, r3, #2
    9d4e:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    9d50:	strb	r2, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    9d52:	mov	r0, r4

 fail:
  return false;
}
    9d54:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    9d58:	b.w	ab4c <FatFile::remove()>

00009d5c <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    9d5c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9d60:	ldrb	r3, [r0, #0]
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    9d62:	ldr	r7, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    9d64:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    9d66:	cbz	r3, 9d96 <FatFile::seekSet(unsigned long)+0x3a>
    9d68:	mov	r5, r1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    9d6a:	ldr	r1, [r0, #20]
    9d6c:	cmp	r1, r5
    9d6e:	beq.n	9dc8 <FatFile::seekSet(unsigned long)+0x6c>
    return true;
  }
  if (pos == 0) {
    9d70:	cbnz	r5, 9d84 <FatFile::seekSet(unsigned long)+0x28>
    9d72:	ldrb	r3, [r0, #2]
    // set position to start of file
    m_curCluster = 0;
    9d74:	str	r5, [r0, #16]
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9d76:	bic.w	r3, r3, #32
    9d7a:	strb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    9d7c:	str	r5, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;
    9d7e:	movs	r0, #1
    9d80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    9d84:	lsls	r0, r3, #28
    9d86:	bmi.n	9d9e <FatFile::seekSet(unsigned long)+0x42>
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    9d88:	lsls	r2, r3, #26
    9d8a:	bpl.n	9da4 <FatFile::seekSet(unsigned long)+0x48>
    9d8c:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    9d8e:	ldrh	r3, [r3, #8]
    9d90:	cmp.w	r5, r3, lsl #5
    9d94:	bls.n	9e00 <FatFile::seekSet(unsigned long)+0xa4>
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;

 fail:
  m_curCluster = tmp;
    9d96:	str	r7, [r4, #16]
  return false;
    9d98:	movs	r0, #0
    9d9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_fileSize) {
    9d9e:	ldr	r2, [r4, #28]
    9da0:	cmp	r5, r2
    9da2:	bhi.n	9d96 <FatFile::seekSet(unsigned long)+0x3a>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    9da4:	ldr.w	lr, [r4, #8]
    9da8:	ldrb	r2, [r4, #2]
    9daa:	ldrb.w	r0, [lr, #6]
    9dae:	adds	r0, #9
    9db0:	uxtb	r0, r0
    9db2:	subs	r6, r5, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    9db4:	tst.w	r2, #64	; 0x40
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    9db8:	lsr.w	r6, r6, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    9dbc:	beq.n	9dce <FatFile::seekSet(unsigned long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    9dbe:	ldr	r3, [r4, #32]
    9dc0:	add	r6, r3
    9dc2:	str	r6, [r4, #16]
    goto done;
    9dc4:	mov	r3, r2
    9dc6:	b.n	9d76 <FatFile::seekSet(unsigned long)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    9dc8:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    9dca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    9dce:	subs	r2, r1, #1
    9dd0:	lsr.w	r0, r2, r0

  if (nNew < nCur || m_curPosition == 0) {
    9dd4:	cmp	r6, r0
    9dd6:	bcs.n	9e04 <FatFile::seekSet(unsigned long)+0xa8>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    9dd8:	lsls	r3, r3, #25
    9dda:	ite	mi
    9ddc:	ldrmi.w	r3, [lr, #32]
    9de0:	ldrpl	r3, [r4, #32]
    9de2:	str	r3, [r4, #16]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    9de4:	add.w	r8, r4, #16
    9de8:	b.n	9dfa <FatFile::seekSet(unsigned long)+0x9e>
    9dea:	ldr	r1, [r4, #16]
    9dec:	ldr	r0, [r4, #8]
    9dee:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
    9df2:	cmp	r0, #0
    9df4:	add.w	r6, r6, #4294967295
    9df8:	ble.n	9d96 <FatFile::seekSet(unsigned long)+0x3a>
    9dfa:	mov	r2, r8
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    9dfc:	cmp	r6, #0
    9dfe:	bne.n	9dea <FatFile::seekSet(unsigned long)+0x8e>
    9e00:	ldrb	r3, [r4, #2]
    9e02:	b.n	9d76 <FatFile::seekSet(unsigned long)+0x1a>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());

  if (nNew < nCur || m_curPosition == 0) {
    9e04:	cmp	r1, #0
    9e06:	beq.n	9dd8 <FatFile::seekSet(unsigned long)+0x7c>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    9e08:	subs	r6, r6, r0
    9e0a:	b.n	9de4 <FatFile::seekSet(unsigned long)+0x88>

00009e0c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    9e0c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e10:	mov	r5, r1
    9e12:	mov	r8, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    9e14:	movs	r1, #0
    9e16:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    9e18:	mov	r4, r0
    9e1a:	mov	r7, r3
    9e1c:	ldrb.w	r6, [sp, #24]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    9e20:	bl	1001c <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    9e24:	ldr	r0, [r5, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    9e26:	ldr	r3, [r5, #32]
    9e28:	str	r3, [r4, #12]
    9e2a:	add.w	r2, r0, #52	; 0x34
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    9e2e:	and.w	r3, r8, #15
    9e32:	add.w	r2, r2, r3, lsl #5
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    9e36:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
    9e38:	strh.w	r8, [r4, #4]
    9e3c:	ldrb	r1, [r2, #11]
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    9e3e:	lsls	r5, r1, #28
    9e40:	bmi.n	9e68 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    9e42:	and.w	r1, r1, #23
    9e46:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    9e48:	ldrb	r3, [r2, #11]
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    9e4a:	strb	r6, [r4, #3]
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    9e4c:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
    9e50:	it	eq
    9e52:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    9e56:	and.w	r3, r7, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    9e5a:	it	eq
    9e5c:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    9e5e:	cmp	r3, #1
    9e60:	beq.n	9e72 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
    9e62:	cmp	r3, #2
    9e64:	beq.n	9eba <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xae>
    9e66:	cbz	r3, 9eb0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa4>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    9e68:	movs	r0, #0
    9e6a:	strb	r0, [r4, #0]
  m_flags = 0;
    9e6c:	strb	r0, [r4, #2]
  return false;
    9e6e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    9e72:	movs	r3, #2
    9e74:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    9e76:	ldrb	r1, [r4, #0]
    9e78:	tst.w	r1, #17
    9e7c:	bne.n	9e68 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    9e7e:	sxtb	r1, r3
    9e80:	and.w	r5, r7, #1024	; 0x400
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    9e84:	and.w	r3, r7, #8
    9e88:	orrs	r3, r1
    9e8a:	uxtb	r3, r3
    9e8c:	strb	r3, [r4, #2]

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    9e8e:	ldrh.w	lr, [r2, #20]
    9e92:	ldrh	r1, [r2, #26]
    9e94:	ldr	r6, [r0, #48]	; 0x30
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);

  m_dirSector = m_vol->cacheSectorNumber();
    9e96:	str	r6, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    9e98:	orr.w	r1, r1, lr, lsl #16

  if (oflag & O_TRUNC) {
    9e9c:	cbz	r5, 9ec0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    9e9e:	cbnz	r1, 9ed6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xca>
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    9ea0:	orn	r3, r3, #127	; 0x7f
    9ea4:	strb	r3, [r4, #2]
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    9ea6:	lsls	r3, r7, #17
    9ea8:	bmi.n	9ec8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    9eaa:	movs	r0, #1
    9eac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    9eb0:	ands.w	r5, r7, #1024	; 0x400
    9eb4:	bne.n	9e68 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    9eb6:	movs	r1, #1
    9eb8:	b.n	9e84 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x78>
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    9eba:	movs	r3, #3
    9ebc:	strb	r3, [r4, #2]
      break;
    9ebe:	b.n	9e76 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x6a>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    9ec0:	str	r1, [r4, #32]
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    9ec2:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    9ec4:	str	r3, [r4, #28]
    9ec6:	b.n	9ea6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9a>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    9ec8:	ldr	r1, [r4, #28]
    9eca:	mov	r0, r4
    9ecc:	bl	9d5c <FatFile::seekSet(unsigned long)>
    9ed0:	cmp	r0, #0
    9ed2:	bne.n	9eaa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
    9ed4:	b.n	9e68 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);

  if (oflag & O_TRUNC) {
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    9ed6:	bl	a4d4 <FatPartition::freeChain(unsigned long)>
    9eda:	cmp	r0, #0
    9edc:	beq.n	9e68 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    9ede:	ldrb	r3, [r4, #2]
    9ee0:	b.n	9ea0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x94>
    9ee2:	nop

00009ee4 <FatFile::openNext(FatFile*, int)>:
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    9ee4:	ldrb	r3, [r0, #0]
    9ee6:	cbnz	r3, 9ef0 <FatFile::openNext(FatFile*, int)+0xc>
    9ee8:	ldrb	r3, [r1, #0]
    9eea:	tst.w	r3, #112	; 0x70
    9eee:	bne.n	9ef4 <FatFile::openNext(FatFile*, int)+0x10>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    9ef0:	movs	r0, #0
}
    9ef2:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    9ef4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9ef8:	ldr	r6, [r1, #20]
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    9efa:	ands.w	r7, r6, #31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    9efe:	sub	sp, #8
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    9f00:	bne.n	9f46 <FatFile::openNext(FatFile*, int)+0x62>
    9f02:	mov	r9, r2
    9f04:	mov	r5, r1
    9f06:	mov	r8, r0
    9f08:	mov	sl, r7
    9f0a:	b.n	9f10 <FatFile::openNext(FatFile*, int)+0x2c>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    9f0c:	movs	r7, #0
    9f0e:	ldr	r6, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    9f10:	movs	r1, #0
    9f12:	mov	r0, r5
    9f14:	bl	9aec <FatFile::readDirCache(bool)>
    if (!dir) {
    9f18:	cbz	r0, 9f46 <FatFile::openNext(FatFile*, int)+0x62>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    9f1a:	ldrb	r3, [r0, #0]
    9f1c:	cbz	r3, 9f46 <FatFile::openNext(FatFile*, int)+0x62>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    9f1e:	cmp	r3, #46	; 0x2e
    9f20:	beq.n	9f0c <FatFile::openNext(FatFile*, int)+0x28>
    9f22:	cmp	r3, #229	; 0xe5
    9f24:	beq.n	9f0c <FatFile::openNext(FatFile*, int)+0x28>
    9f26:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    9f28:	lsls	r1, r2, #28
    9f2a:	bpl.n	9f4e <FatFile::openNext(FatFile*, int)+0x6a>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    9f2c:	cmp	r2, #15
    9f2e:	bne.n	9f0c <FatFile::openNext(FatFile*, int)+0x28>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    9f30:	lsls	r2, r3, #25
    9f32:	bpl.n	9f0e <FatFile::openNext(FatFile*, int)+0x2a>
        lfnOrd = ldir->order & 0X1F;
    9f34:	and.w	r7, r3, #31
        checksum = ldir->checksum;
    9f38:	ldrb.w	sl, [r0, #13]
    9f3c:	b.n	9f0e <FatFile::openNext(FatFile*, int)+0x2a>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    9f3e:	bl	a704 <FatFile::lfnChecksum(unsigned char*)>
    9f42:	cmp	r0, sl
    9f44:	beq.n	9f52 <FatFile::openNext(FatFile*, int)+0x6e>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    9f46:	movs	r0, #0
}
    9f48:	add	sp, #8
    9f4a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    9f4e:	cmp	r7, #0
    9f50:	bne.n	9f3e <FatFile::openNext(FatFile*, int)+0x5a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    9f52:	str	r7, [sp, #0]
    9f54:	mov	r3, r9
    9f56:	ubfx	r2, r6, #5, #16
    9f5a:	mov	r1, r5
    9f5c:	mov	r0, r8
    9f5e:	bl	9e0c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    9f62:	b.n	9f48 <FatFile::openNext(FatFile*, int)+0x64>

00009f64 <FatFile::sync()>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9f64:	ldrb	r3, [r0, #0]
    9f66:	cbz	r3, 9f6c <FatFile::sync()+0x8>
    9f68:	b.w	9518 <FatFile::sync() [clone .part.42]>
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    9f6c:	movs	r0, #1
    9f6e:	bx	lr

00009f70 <FatFile::truncate()>:
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    9f70:	ldrb	r3, [r0, #2]
    9f72:	lsls	r3, r3, #30
    9f74:	bpl.n	9fac <FatFile::truncate()+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    9f76:	ldr	r3, [r0, #32]
    9f78:	cbz	r3, 9fa8 <FatFile::truncate()+0x38>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    9f7a:	push	{r4, lr}
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    9f7c:	ldr	r1, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    9f7e:	sub	sp, #8
    9f80:	mov	r4, r0
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    9f82:	cbnz	r1, 9fc2 <FatFile::truncate()+0x52>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    9f84:	str	r3, [sp, #4]
    m_firstCluster = 0;
    9f86:	str	r1, [r0, #32]
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    9f88:	mov	r1, r3
    9f8a:	ldr	r0, [r4, #8]
    9f8c:	bl	a4d4 <FatPartition::freeChain(unsigned long)>
    9f90:	cbz	r0, 9fbe <FatFile::truncate()+0x4e>
    }
  }
  m_fileSize = m_curPosition;

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9f92:	ldrb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9f94:	ldrb	r2, [r4, #0]
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    9f96:	ldr	r1, [r4, #20]
    9f98:	str	r1, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9f9a:	orn	r3, r3, #127	; 0x7f
    9f9e:	strb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9fa0:	cbnz	r2, 9fde <FatFile::truncate()+0x6e>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    9fa2:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    9fa4:	add	sp, #8
    9fa6:	pop	{r4, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    9fa8:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    9faa:	bx	lr
    goto fail;
  }
  return true;

 fail:
  return false;
    9fac:	movs	r0, #0
}
    9fae:	bx	lr
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    9fb0:	mvn.w	r2, #4026531840	; 0xf0000000
    9fb4:	ldr	r1, [r4, #16]
    9fb6:	ldr	r0, [r4, #8]
    9fb8:	bl	a3e8 <FatPartition::fatPut(unsigned long, unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    9fbc:	cbnz	r0, 9fd6 <FatFile::truncate()+0x66>
    goto fail;
  }
  return true;

 fail:
  return false;
    9fbe:	movs	r0, #0
    9fc0:	b.n	9fa4 <FatFile::truncate()+0x34>
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    toFree = 0;
    9fc2:	add	r2, sp, #8
    9fc4:	movs	r3, #0
    9fc6:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    9fca:	ldr	r0, [r0, #8]
    9fcc:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    9fd0:	cmp	r0, #0
    9fd2:	blt.n	9fbe <FatFile::truncate()+0x4e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    9fd4:	bne.n	9fb0 <FatFile::truncate()+0x40>
    }
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    9fd6:	ldr	r3, [sp, #4]
    9fd8:	cmp	r3, #0
    9fda:	beq.n	9f92 <FatFile::truncate()+0x22>
    9fdc:	b.n	9f88 <FatFile::truncate()+0x18>
    9fde:	mov	r0, r4
    9fe0:	bl	9518 <FatFile::sync() [clone .part.42]>
    9fe4:	b.n	9fa4 <FatFile::truncate()+0x34>
    9fe6:	nop

00009fe8 <FatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    9fe8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9fec:	ldrb	r3, [r0, #2]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    9fee:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    9ff0:	mov	r4, r0
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    9ff2:	bmi.n	a004 <FatFile::write(void const*, unsigned int)+0x1c>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    9ff4:	ldrb	r3, [r4, #1]
    9ff6:	orr.w	r3, r3, #1
    9ffa:	strb	r3, [r4, #1]
  return -1;
    9ffc:	mov.w	r0, #4294967295
    a000:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a004:	mov	r8, r2
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    a006:	lsls	r2, r3, #28
    a008:	mov	r7, r1
    a00a:	bmi.w	a1aa <FatFile::write(void const*, unsigned int)+0x1c2>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    a00e:	ldr	r2, [r4, #20]
    a010:	mvns	r3, r2
    a012:	cmp	r8, r3
    a014:	bhi.n	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a016:	cmp.w	r8, #0
    a01a:	beq.w	a1cc <FatFile::write(void const*, unsigned int)+0x1e4>
    a01e:	mov	r6, r8
    a020:	b.n	a098 <FatFile::write(void const*, unsigned int)+0xb0>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a022:	cmp.w	r9, #0
    a026:	bne.n	a0da <FatFile::write(void const*, unsigned int)+0xf2>
      // start of new cluster
      if (m_curCluster != 0) {
    a028:	ldr	r1, [r4, #16]
    a02a:	cmp	r1, #0
    a02c:	beq.w	a156 <FatFile::write(void const*, unsigned int)+0x16e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    a030:	ldrb	r3, [r4, #2]
    a032:	lsls	r3, r3, #25
    a034:	bpl.w	a16a <FatFile::write(void const*, unsigned int)+0x182>
    a038:	ldr	r3, [r4, #28]
    a03a:	cmp	r3, r2
    a03c:	bls.w	a16a <FatFile::write(void const*, unsigned int)+0x182>
          m_curCluster++;
    a040:	adds	r3, r1, #1
    a042:	str	r3, [r4, #16]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    a044:	ldrb	r2, [r0, #6]
    a046:	ldr	r3, [r0, #20]
    a048:	subs	r1, #1
    a04a:	lsls	r1, r2
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    a04c:	cmp.w	r6, #512	; 0x200
    a050:	add	r1, r3
    a052:	bcs.n	a0f6 <FatFile::write(void const*, unsigned int)+0x10e>
    a054:	cmp.w	r6, #512	; 0x200
    a058:	mov	r5, r6
    a05a:	it	cs
    a05c:	movcs.w	r5, #512	; 0x200
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    a060:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    a062:	tst.w	r3, #32
    a066:	ite	eq
    a068:	moveq	r2, #1
    a06a:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a06c:	adds	r0, #36	; 0x24
    a06e:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    a072:	cmp	r0, #0
    a074:	beq.n	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    a076:	add	r0, r9
    a078:	mov	r2, r5
    a07a:	mov	r1, r7
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a07c:	add	r9, r5
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    a07e:	bl	cfd4 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a082:	cmp.w	r9, #512	; 0x200
    a086:	beq.w	a19a <FatFile::write(void const*, unsigned int)+0x1b2>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a08a:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a08c:	subs	r6, r6, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a08e:	add	r2, r5
    src += n;
    a090:	add	r7, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a092:	str	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a094:	beq.w	a1cc <FatFile::write(void const*, unsigned int)+0x1e4>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    a098:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    a09a:	ldrb	r3, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a09c:	ands.w	r5, r3, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    a0a0:	ubfx	r9, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a0a4:	beq.n	a022 <FatFile::write(void const*, unsigned int)+0x3a>
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;
    a0a6:	ldr	r3, [r4, #16]
    a0a8:	ldrb	r1, [r0, #6]
    a0aa:	ldr	r2, [r0, #20]
    a0ac:	subs	r3, #2
    a0ae:	lsl.w	r1, r3, r1
    a0b2:	add	r1, r2
    a0b4:	add	r1, r5

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    a0b6:	cmp.w	r9, #0
    a0ba:	bne.n	a0e8 <FatFile::write(void const*, unsigned int)+0x100>
    a0bc:	cmp.w	r6, #512	; 0x200
    a0c0:	bcs.n	a0f6 <FatFile::write(void const*, unsigned int)+0x10e>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    a0c2:	ldr	r2, [r4, #20]
    a0c4:	ldr	r3, [r4, #28]
    a0c6:	cmp.w	r6, #512	; 0x200
    a0ca:	mov	r5, r6
    a0cc:	it	cs
    a0ce:	movcs.w	r5, #512	; 0x200
    a0d2:	cmp	r2, r3
    a0d4:	bcc.n	a060 <FatFile::write(void const*, unsigned int)+0x78>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    a0d6:	movs	r2, #5
    a0d8:	b.n	a06c <FatFile::write(void const*, unsigned int)+0x84>
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    a0da:	ldr	r3, [r4, #16]
    a0dc:	ldrb	r1, [r0, #6]
    a0de:	ldr	r2, [r0, #20]
    a0e0:	subs	r3, #2
    a0e2:	lsl.w	r1, r3, r1
    a0e6:	add	r1, r2
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    a0e8:	rsb	r5, r9, #512	; 0x200
    a0ec:	cmp	r5, r6
    a0ee:	it	cs
    a0f0:	movcs	r5, r6
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    a0f2:	movs	r2, #1
    a0f4:	b.n	a06c <FatFile::write(void const*, unsigned int)+0x84>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    a0f6:	cmp.w	r6, #1024	; 0x400
    a0fa:	bcc.n	a13a <FatFile::write(void const*, unsigned int)+0x152>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    a0fc:	ldrb	r3, [r0, #4]
    a0fe:	ldr.w	lr, [r0, #48]	; 0x30
    a102:	subs	r3, r3, r5
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    a104:	lsrs	r2, r6, #9
    a106:	cmp	r3, r2
    a108:	it	cs
    a10a:	movcs	r3, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    a10c:	cmp	lr, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    a10e:	mov.w	r5, r3, lsl #9
    a112:	bcc.n	a128 <FatFile::write(void const*, unsigned int)+0x140>
    a114:	adds	r2, r3, r1
    a116:	cmp	lr, r2
    a118:	bcs.n	a128 <FatFile::write(void const*, unsigned int)+0x140>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a11a:	mov.w	lr, #0
    m_sector = 0XFFFFFFFF;
    a11e:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a122:	strb.w	lr, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    a126:	str	r2, [r0, #48]	; 0x30
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    a128:	ldr	r0, [r0, #40]	; 0x28
    a12a:	ldr	r2, [r0, #0]
    a12c:	ldr.w	r9, [r2, #32]
    a130:	mov	r2, r7
    a132:	blx	r9
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    a134:	cmp	r0, #0
    a136:	bne.n	a08a <FatFile::write(void const*, unsigned int)+0xa2>
    a138:	b.n	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    a13a:	ldr	r3, [r0, #48]	; 0x30
    a13c:	cmp	r3, r1
    a13e:	beq.n	a18c <FatFile::write(void const*, unsigned int)+0x1a4>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    a140:	ldr	r0, [r0, #40]	; 0x28
    a142:	ldr	r3, [r0, #0]
    a144:	mov	r2, r7
    a146:	ldr	r3, [r3, #28]
    a148:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    a14a:	cmp	r0, #0
    a14c:	beq.w	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    a150:	mov.w	r5, #512	; 0x200
    a154:	b.n	a08a <FatFile::write(void const*, unsigned int)+0xa2>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    a156:	ldr	r3, [r4, #32]
    a158:	cbz	r3, a1b8 <FatFile::write(void const*, unsigned int)+0x1d0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    a15a:	str	r3, [r4, #16]
    a15c:	ldrb	r1, [r0, #6]
    a15e:	ldr	r2, [r0, #20]
    a160:	subs	r3, #2
    a162:	lsl.w	r1, r3, r1
    a166:	add	r1, r2
    a168:	b.n	a0bc <FatFile::write(void const*, unsigned int)+0xd4>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    a16a:	add.w	r2, r4, #16
    a16e:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    a172:	cmp	r0, #0
    a174:	blt.w	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    a178:	bne.n	a186 <FatFile::write(void const*, unsigned int)+0x19e>
          // add cluster if at end of chain
          if (!addCluster()) {
    a17a:	mov	r0, r4
    a17c:	bl	942c <FatFile::addCluster()>
    a180:	cmp	r0, #0
    a182:	beq.w	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
    a186:	ldr	r3, [r4, #16]
    a188:	ldr	r0, [r4, #8]
    a18a:	b.n	a15c <FatFile::write(void const*, unsigned int)+0x174>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a18c:	movs	r2, #0
    m_sector = 0XFFFFFFFF;
    a18e:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a192:	strb.w	r2, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    a196:	str	r3, [r0, #48]	; 0x30
    a198:	b.n	a140 <FatFile::write(void const*, unsigned int)+0x158>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    a19a:	ldr	r0, [r4, #8]
    a19c:	adds	r0, #36	; 0x24
    a19e:	bl	779c <FsCache::sync()>
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->cacheSyncData()) {
    a1a2:	cmp	r0, #0
    a1a4:	bne.w	a08a <FatFile::write(void const*, unsigned int)+0xa2>
    a1a8:	b.n	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    a1aa:	ldr	r1, [r0, #28]
    a1ac:	bl	9d5c <FatFile::seekSet(unsigned long)>
    a1b0:	cmp	r0, #0
    a1b2:	beq.w	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
    a1b6:	b.n	a00e <FatFile::write(void const*, unsigned int)+0x26>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    a1b8:	mov	r0, r4
    a1ba:	bl	942c <FatFile::addCluster()>
    a1be:	cmp	r0, #0
    a1c0:	beq.w	9ff4 <FatFile::write(void const*, unsigned int)+0xc>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    a1c4:	ldr	r3, [r4, #16]
    a1c6:	str	r3, [r4, #32]
    a1c8:	ldr	r0, [r4, #8]
    a1ca:	b.n	a15c <FatFile::write(void const*, unsigned int)+0x174>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    a1cc:	ldr	r3, [r4, #28]
    a1ce:	cmp	r3, r2
    a1d0:	bcc.n	a1e6 <FatFile::write(void const*, unsigned int)+0x1fe>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    a1d2:	ldr	r3, [pc, #40]	; (a1fc <FatFile::write(void const*, unsigned int)+0x214>)
    a1d4:	ldr	r3, [r3, #0]
    a1d6:	cbz	r3, a1f6 <FatFile::write(void const*, unsigned int)+0x20e>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a1d8:	ldrb	r3, [r4, #2]
    a1da:	orn	r3, r3, #127	; 0x7f
    a1de:	strb	r3, [r4, #2]
    a1e0:	mov	r0, r8
    a1e2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a1e6:	ldrb	r3, [r4, #2]
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    a1e8:	str	r2, [r4, #28]
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a1ea:	orn	r3, r3, #127	; 0x7f
    a1ee:	strb	r3, [r4, #2]
    a1f0:	mov	r0, r8
    a1f2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a1f6:	mov	r0, r8
    a1f8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a1fc:	.word	0x200050e0

0000a200 <FatFile::printModifyDateTime(Print*)>:
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::printModifyDateTime(print_t* pr) {
    a200:	push	{r4, lr}
    a202:	sub	sp, #8
    a204:	mov	r4, r1
  uint16_t date;
  uint16_t time;
  if (getModifyDateTime(&date, &time)) {
    a206:	add.w	r2, sp, #6
    a20a:	add	r1, sp, #4
    a20c:	bl	9610 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
    a210:	cbz	r0, a220 <FatFile::printModifyDateTime(Print*)+0x20>
    return fsPrintDateTime(pr, date, time);
    a212:	mov	r0, r4
    a214:	ldrh.w	r2, [sp, #6]
    a218:	ldrh.w	r1, [sp, #4]
    a21c:	bl	78dc <fsPrintDateTime(Print*, unsigned short, unsigned short)>
  }
  return 0;
}
    a220:	add	sp, #8
    a222:	pop	{r4, pc}

0000a224 <FatFile::printFileSize(Print*)>:
//------------------------------------------------------------------------------
size_t FatFile::printFileSize(print_t* pr) {
    a224:	push	{r4, r5, lr}
    a226:	sub	sp, #20
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
    a228:	movs	r3, #0
    return fsPrintDateTime(pr, date, time);
  }
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::printFileSize(print_t* pr) {
    a22a:	mov	r5, r1
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
  ptr = fmtBase10(ptr, fileSize());
    a22c:	ldr	r1, [r0, #28]
}
//------------------------------------------------------------------------------
size_t FatFile::printFileSize(print_t* pr) {
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
    a22e:	strb.w	r3, [sp, #14]
  ptr = fmtBase10(ptr, fileSize());
    a232:	add.w	r0, sp, #14
    a236:	bl	7800 <fmtBase10(char*, unsigned long)>
    a23a:	add	r4, sp, #4
  while (ptr > buf) {
    a23c:	cmp	r0, r4
    *--ptr = ' ';
    a23e:	it	hi
    a240:	movhi	r3, #32
size_t FatFile::printFileSize(print_t* pr) {
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
  ptr = fmtBase10(ptr, fileSize());
  while (ptr > buf) {
    a242:	bls.n	a24c <FatFile::printFileSize(Print*)+0x28>
    *--ptr = ' ';
    a244:	strb.w	r3, [r0, #-1]!
size_t FatFile::printFileSize(print_t* pr) {
  char buf[11];
  char *ptr = buf + sizeof(buf);
  *--ptr = 0;
  ptr = fmtBase10(ptr, fileSize());
  while (ptr > buf) {
    a248:	cmp	r0, r4
    a24a:	bne.n	a244 <FatFile::printFileSize(Print*)+0x20>
    a24c:	mov	r0, r4
    a24e:	bl	10680 <strlen>
    a252:	ldr	r3, [r5, #0]
    a254:	mov	r2, r0
    a256:	mov	r1, r4
    a258:	ldr	r3, [r3, #4]
    a25a:	mov	r0, r5
    a25c:	blx	r3
    *--ptr = ' ';
  }
  return pr->write(buf);
}
    a25e:	add	sp, #20
    a260:	pop	{r4, r5, pc}
    a262:	nop

0000a264 <FatFile::ls(Print*, unsigned char, unsigned char)>:
  }
  pr->write('\r');
  pr->write('\n');
}
//------------------------------------------------------------------------------
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
    a264:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  FatFile file;
  if (!isDir()) {
    a268:	ldrb	r4, [r0, #0]
  }
  pr->write('\r');
  pr->write('\n');
}
//------------------------------------------------------------------------------
bool FatFile::ls(print_t* pr, uint8_t flags, uint8_t indent) {
    a26a:	sub	sp, #40	; 0x28
    a26c:	movs	r6, #0
  FatFile file;
  if (!isDir()) {
    a26e:	ands.w	r4, r4, #112	; 0x70
    a272:	strb.w	r6, [sp, #4]
    a276:	strb.w	r6, [sp, #5]
    a27a:	strb.w	r6, [sp, #6]
    a27e:	bne.n	a288 <FatFile::ls(Print*, unsigned char, unsigned char)+0x24>
    goto fail;
  }
  return true;

 fail:
  return false;
    a280:	mov	r0, r4
}
    a282:	add	sp, #40	; 0x28
    a284:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a288:	mov	r8, r2
    a28a:	mov	r9, r0
    a28c:	mov	r5, r1
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    a28e:	mov	r1, r6
    a290:	mov	r7, r3
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    a292:	and.w	sl, r8, #2
    a296:	bl	9d5c <FatFile::seekSet(unsigned long)>
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    a29a:	movs	r2, #0
    a29c:	mov	r1, r9
    a29e:	add	r0, sp, #4
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    a2a0:	uxtb.w	sl, sl
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    a2a4:	bl	9ee4 <FatFile::openNext(FatFile*, int)>
    a2a8:	cmp	r0, #0
    a2aa:	beq.n	a334 <FatFile::ls(Print*, unsigned char, unsigned char)+0xd0>
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
    a2ac:	ldrb.w	r3, [sp, #4]
    a2b0:	lsls	r3, r3, #30
    a2b2:	bpl.n	a2ba <FatFile::ls(Print*, unsigned char, unsigned char)+0x56>
    a2b4:	tst.w	r8, #1
    a2b8:	beq.n	a320 <FatFile::ls(Print*, unsigned char, unsigned char)+0xbc>
      for (uint8_t i = 0; i < indent; i++) {
    a2ba:	movs	r4, #0
    a2bc:	cbz	r7, a2d0 <FatFile::ls(Print*, unsigned char, unsigned char)+0x6c>
        pr->write(' ');
    a2be:	ldr	r3, [r5, #0]
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    a2c0:	adds	r4, #1
        pr->write(' ');
    a2c2:	movs	r1, #32
    a2c4:	ldr	r6, [r3, #0]
    a2c6:	mov	r0, r5
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    a2c8:	uxtb	r4, r4
        pr->write(' ');
    a2ca:	blx	r6
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    // indent for dir level
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
    a2cc:	cmp	r7, r4
    a2ce:	bne.n	a2be <FatFile::ls(Print*, unsigned char, unsigned char)+0x5a>
        pr->write(' ');
      }
      if (flags & LS_DATE) {
    a2d0:	cmp.w	sl, #0
    a2d4:	bne.n	a364 <FatFile::ls(Print*, unsigned char, unsigned char)+0x100>
        file.printModifyDateTime(pr);
        pr->write(' ');
      }
      if (flags & LS_SIZE) {
    a2d6:	tst.w	r8, #4
    a2da:	bne.n	a350 <FatFile::ls(Print*, unsigned char, unsigned char)+0xec>
        file.printFileSize(pr);
        pr->write(' ');
      }
      file.printName(pr);
    a2dc:	mov	r1, r5
    a2de:	add	r0, sp, #4
    a2e0:	bl	aa90 <FatFile::printName(Print*)>
      if (file.isDir()) {
    a2e4:	ldrb.w	r3, [sp, #4]
    a2e8:	tst.w	r3, #112	; 0x70
    a2ec:	bne.n	a344 <FatFile::ls(Print*, unsigned char, unsigned char)+0xe0>
        pr->write('/');
      }
      pr->write('\r');
    a2ee:	ldr	r3, [r5, #0]
    a2f0:	movs	r1, #13
    a2f2:	ldr	r3, [r3, #0]
    a2f4:	mov	r0, r5
    a2f6:	blx	r3
      pr->write('\n');
    a2f8:	ldr	r3, [r5, #0]
    a2fa:	movs	r1, #10
    a2fc:	ldr	r3, [r3, #0]
    a2fe:	mov	r0, r5
    a300:	blx	r3
      if ((flags & LS_R) && file.isDir()) {
    a302:	tst.w	r8, #8
    a306:	beq.n	a320 <FatFile::ls(Print*, unsigned char, unsigned char)+0xbc>
    a308:	ldrb.w	r3, [sp, #4]
    a30c:	tst.w	r3, #112	; 0x70
    a310:	beq.n	a320 <FatFile::ls(Print*, unsigned char, unsigned char)+0xbc>
        file.ls(pr, flags, indent + 2);
    a312:	adds	r3, r7, #2
    a314:	uxtb	r3, r3
    a316:	mov	r2, r8
    a318:	mov	r1, r5
    a31a:	add	r0, sp, #4
    a31c:	bl	a264 <FatFile::ls(Print*, unsigned char, unsigned char)>
      }
    }
    file.close();
    a320:	add	r0, sp, #4
    a322:	bl	95ac <FatFile::close()>
  if (!isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  rewind();
  while (file.openNext(this, O_RDONLY)) {
    a326:	movs	r2, #0
    a328:	mov	r1, r9
    a32a:	add	r0, sp, #4
    a32c:	bl	9ee4 <FatFile::openNext(FatFile*, int)>
    a330:	cmp	r0, #0
    a332:	bne.n	a2ac <FatFile::ls(Print*, unsigned char, unsigned char)+0x48>
        file.ls(pr, flags, indent + 2);
      }
    }
    file.close();
  }
  if (getError()) {
    a334:	ldrb.w	r0, [r9, #1]
    a338:	clz	r0, r0
    a33c:	lsrs	r0, r0, #5
  }
  return true;

 fail:
  return false;
}
    a33e:	add	sp, #40	; 0x28
    a340:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        file.printFileSize(pr);
        pr->write(' ');
      }
      file.printName(pr);
      if (file.isDir()) {
        pr->write('/');
    a344:	ldr	r3, [r5, #0]
    a346:	movs	r1, #47	; 0x2f
    a348:	ldr	r3, [r3, #0]
    a34a:	mov	r0, r5
    a34c:	blx	r3
    a34e:	b.n	a2ee <FatFile::ls(Print*, unsigned char, unsigned char)+0x8a>
      if (flags & LS_DATE) {
        file.printModifyDateTime(pr);
        pr->write(' ');
      }
      if (flags & LS_SIZE) {
        file.printFileSize(pr);
    a350:	mov	r1, r5
    a352:	add	r0, sp, #4
    a354:	bl	a224 <FatFile::printFileSize(Print*)>
        pr->write(' ');
    a358:	ldr	r3, [r5, #0]
    a35a:	movs	r1, #32
    a35c:	ldr	r3, [r3, #0]
    a35e:	mov	r0, r5
    a360:	blx	r3
    a362:	b.n	a2dc <FatFile::ls(Print*, unsigned char, unsigned char)+0x78>
    if (!file.isHidden() || (flags & LS_A)) {
      for (uint8_t i = 0; i < indent; i++) {
        pr->write(' ');
      }
      if (flags & LS_DATE) {
        file.printModifyDateTime(pr);
    a364:	mov	r1, r5
    a366:	add	r0, sp, #4
    a368:	bl	a200 <FatFile::printModifyDateTime(Print*)>
        pr->write(' ');
    a36c:	ldr	r3, [r5, #0]
    a36e:	movs	r1, #32
    a370:	ldr	r3, [r3, #0]
    a372:	mov	r0, r5
    a374:	blx	r3
    a376:	b.n	a2d6 <FatFile::ls(Print*, unsigned char, unsigned char)+0x72>

0000a378 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a378:	cmp	r1, #1
    a37a:	bls.n	a3e0 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
    a37c:	ldr	r3, [r0, #28]
    a37e:	cmp	r1, r3
    a380:	bhi.n	a3e0 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    a382:	push	{r4, r5, r6, lr}
    a384:	ldrb	r3, [r0, #7]
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    a386:	cmp	r3, #32
    a388:	mov	r6, r2
    a38a:	mov	r5, r0
    a38c:	mov	r4, r1
    a38e:	beq.n	a3c2 <FatPartition::fatGet(unsigned long, unsigned long*)+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    a390:	cmp	r3, #16
    a392:	bne.n	a3bc <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    a394:	ldr	r3, [r0, #24]
    a396:	ubfx	r1, r1, #8, #8
    a39a:	add	r1, r3
    a39c:	movs	r2, #2
    a39e:	add.w	r0, r0, #564	; 0x234
    a3a2:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    a3a6:	cbz	r0, a3bc <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    a3a8:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    a3aa:	ldrh.w	r3, [r0, r1, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    a3ae:	ldr	r2, [r5, #28]
    a3b0:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    a3b2:	itte	ls
    a3b4:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    a3b6:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    a3b8:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    a3ba:	pop	{r4, r5, r6, pc}
  }
  *value = next;
  return 1;

 fail:
  return -1;
    a3bc:	mov.w	r0, #4294967295
    a3c0:	pop	{r4, r5, r6, pc}
    a3c2:	ldr	r1, [r0, #24]
    a3c4:	movs	r2, #2
    a3c6:	add.w	r1, r1, r4, lsr #7
    a3ca:	add.w	r0, r0, #564	; 0x234
    a3ce:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    a3d2:	cmp	r0, #0
    a3d4:	beq.n	a3bc <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    a3d6:	and.w	r1, r4, #127	; 0x7f
    a3da:	ldr.w	r3, [r0, r1, lsl #2]
    a3de:	b.n	a3ae <FatPartition::fatGet(unsigned long, unsigned long*)+0x36>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    a3e0:	mov.w	r0, #4294967295
}
    a3e4:	bx	lr
    a3e6:	nop

0000a3e8 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a3e8:	cmp	r1, #1
    a3ea:	bls.n	a428 <FatPartition::fatPut(unsigned long, unsigned long)+0x40>
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    a3ec:	push	{r3, r4, r5, lr}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a3ee:	ldr	r3, [r0, #28]
    a3f0:	cmp	r1, r3
    a3f2:	bhi.n	a402 <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
    a3f4:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    a3f6:	cmp	r3, #32
    a3f8:	mov	r5, r2
    a3fa:	mov	r4, r1
    a3fc:	beq.n	a42c <FatPartition::fatPut(unsigned long, unsigned long)+0x44>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    a3fe:	cmp	r3, #16
    a400:	beq.n	a406 <FatPartition::fatPut(unsigned long, unsigned long)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    a402:	movs	r0, #0
    a404:	pop	{r3, r4, r5, pc}
    a406:	ldr	r3, [r0, #24]
    a408:	ubfx	r1, r1, #8, #8
    a40c:	add	r1, r3
    a40e:	add.w	r0, r0, #564	; 0x234
    a412:	movs	r2, #3
    a414:	bl	773c <FsCache::get(unsigned long, unsigned char)>

  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    a418:	mov	r3, r0
    a41a:	cmp	r0, #0
    a41c:	beq.n	a402 <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    a41e:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    a420:	movs	r0, #1
    a422:	strh.w	r5, [r3, r1, lsl #1]
    goto fail;
  }

 fail:
  return false;
}
    a426:	pop	{r3, r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    a428:	movs	r0, #0
}
    a42a:	bx	lr
    a42c:	ldr	r1, [r0, #24]
    a42e:	movs	r2, #3
    a430:	add.w	r0, r0, #564	; 0x234
    a434:	add.w	r1, r1, r4, lsr #7
    a438:	bl	773c <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    a43c:	mov	r3, r0
    a43e:	cmp	r0, #0
    a440:	beq.n	a402 <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    a442:	and.w	r1, r4, #127	; 0x7f
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
    a446:	movs	r0, #1
    a448:	str.w	r5, [r3, r1, lsl #2]
    a44c:	pop	{r3, r4, r5, pc}
    a44e:	nop

0000a450 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    a450:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    a454:	ldr	r4, [r0, #12]
    a456:	cmp	r4, r1
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    a458:	sub	sp, #8
    a45a:	mov	r5, r0
    a45c:	mov	r7, r1
    a45e:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    a460:	itte	cc
    a462:	movcc	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    a464:	movcc	r6, #0
  } else {
    find = m_allocSearchStart;
    setStart = true;
    a466:	movcs	r6, #1
    a468:	ldr	r3, [r5, #28]
  }
  while (1) {
    find++;
    a46a:	adds	r4, #1
    if (find > m_lastCluster) {
    a46c:	cmp	r4, r3
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a46e:	add	r2, sp, #4
    a470:	mov	r0, r5
    a472:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    a474:	bls.n	a48a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x3a>
      if (setStart) {
    a476:	cbnz	r6, a4c8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    a478:	ldr	r4, [r5, #12]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    a47a:	adds	r4, #1
    if (find > m_lastCluster) {
    a47c:	cmp	r4, r3
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
      setStart = true;
    a47e:	mov.w	r6, #1
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a482:	add	r2, sp, #4
    a484:	mov	r0, r5
    a486:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    a488:	bhi.n	a476 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x26>
      }
      find = m_allocSearchStart;
      setStart = true;
      continue;
    }
    if (find == current) {
    a48a:	cmp	r7, r4
    a48c:	beq.n	a4c8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a48e:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    a492:	cmp	r0, #0
    a494:	blt.n	a4c8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    a496:	beq.n	a468 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
    a498:	ldr	r3, [sp, #4]
    a49a:	cmp	r3, #0
    a49c:	bne.n	a468 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
      break;
    }
  }
  if (setStart) {
    a49e:	cbz	r6, a4a2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
    m_allocSearchStart = find;
    a4a0:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    a4a2:	mvn.w	r2, #4026531840	; 0xf0000000
    a4a6:	mov	r1, r4
    a4a8:	mov	r0, r5
    a4aa:	bl	a3e8 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    a4ae:	mov	r6, r0
    a4b0:	cbz	r0, a4c8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    a4b2:	cbnz	r7, a4ba <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x6a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    a4b4:	str.w	r4, [r8]
  return true;
    a4b8:	b.n	a4ca <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x7a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
    a4ba:	mov	r1, r7
    a4bc:	mov	r0, r5
    a4be:	mov	r2, r4
    a4c0:	bl	a3e8 <FatPartition::fatPut(unsigned long, unsigned long)>
    a4c4:	cmp	r0, #0
    a4c6:	bne.n	a4b4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    a4c8:	movs	r6, #0
}
    a4ca:	mov	r0, r6
    a4cc:	add	sp, #8
    a4ce:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4d2:	nop

0000a4d4 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    a4d4:	push	{r4, r5, r6, lr}
    a4d6:	mov	r5, r0
    a4d8:	sub	sp, #8
    a4da:	mov	r4, r1
    a4dc:	b.n	a4f4 <FatPartition::freeChain(unsigned long)+0x20>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    a4de:	bl	a3e8 <FatPartition::fatPut(unsigned long, unsigned long)>
    a4e2:	cbz	r0, a50a <FatPartition::freeChain(unsigned long)+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    a4e4:	ldr	r3, [r5, #12]
    a4e6:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    a4e8:	itt	cc
    a4ea:	addcc.w	r4, r4, #4294967295
    a4ee:	strcc	r4, [r5, #12]
    }
    cluster = next;
    a4f0:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    a4f2:	cbz	r6, a50c <FatPartition::freeChain(unsigned long)+0x38>
    fg = fatGet(cluster, &next);
    a4f4:	add	r2, sp, #4
    a4f6:	mov	r1, r4
    a4f8:	mov	r0, r5
    a4fa:	bl	a378 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    a4fe:	subs	r6, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    a500:	mov	r1, r4
    a502:	mov.w	r2, #0
    a506:	mov	r0, r5
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    if (fg < 0) {
    a508:	bge.n	a4de <FatPartition::freeChain(unsigned long)+0xa>
  } while (fg);

  return true;

 fail:
  return false;
    a50a:	movs	r0, #0
}
    a50c:	add	sp, #8
    a50e:	pop	{r4, r5, r6, pc}

0000a510 <FatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    a510:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a514:	ldrb	r3, [r0, #7]
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    a516:	ldr	r2, [r0, #28]
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    a518:	cmp	r3, #16
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    a51a:	add.w	r8, r2, #1
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    a51e:	beq.n	a52c <FatPartition::freeClusterCount()+0x1c>
    a520:	cmp	r3, #32
    a522:	beq.n	a52c <FatPartition::freeClusterCount()+0x1c>
  }
  setFreeClusterCount(free);
  return free;

 fail:
  return -1;
    a524:	mov.w	r0, #4294967295
    a528:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    a52c:	ldr	r5, [r0, #24]
    while (todo) {
    a52e:	cmp.w	r8, #0
    a532:	beq.n	a5b2 <FatPartition::freeClusterCount()+0xa2>
    a534:	mov	r6, r0
    a536:	add.w	r7, r0, #564	; 0x234
    a53a:	movs	r4, #0
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    a53c:	mov	r1, r5
    a53e:	movs	r2, #2
    a540:	mov	r0, r7
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
    a542:	adds	r5, #1
    a544:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      if (!pc) {
    a548:	cmp	r0, #0
    a54a:	beq.n	a524 <FatPartition::freeClusterCount()+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    a54c:	ldrb	r3, [r6, #7]
    a54e:	cmp	r3, #16
    a550:	beq.n	a580 <FatPartition::freeClusterCount()+0x70>
      if (todo < n) {
    a552:	cmp.w	r8, #127	; 0x7f
    a556:	bhi.n	a5aa <FatPartition::freeClusterCount()+0x9a>
        n = todo;
    a558:	uxth.w	r1, r8
    a55c:	mov	lr, r8
    a55e:	subs	r1, #1
    a560:	uxth	r1, r1
    a562:	add.w	r1, r0, r1, lsl #2
    a566:	subs	r3, r0, #4
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat32[i] == 0) {
    a568:	ldr.w	r2, [r3, #4]!
    a56c:	cbnz	r2, a570 <FatPartition::freeClusterCount()+0x60>
            free++;
    a56e:	adds	r4, #1
          if (pc->fat16[i] == 0) {
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
    a570:	cmp	r3, r1
    a572:	bne.n	a568 <FatPartition::freeClusterCount()+0x58>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    a574:	subs.w	r8, r8, lr
    a578:	bne.n	a53c <FatPartition::freeClusterCount()+0x2c>
    a57a:	mov	r0, r4
    a57c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    a580:	cmp.w	r8, #255	; 0xff
    a584:	bls.n	a5b8 <FatPartition::freeClusterCount()+0xa8>
    a586:	mov.w	lr, #256	; 0x100
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    a58a:	mov	r3, lr
    a58c:	subs	r1, r3, #1
    a58e:	uxth	r1, r1
    a590:	add.w	r1, r0, r1, lsl #1
    a594:	subs	r3, r0, #2
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat16[i] == 0) {
    a596:	ldrh.w	r2, [r3, #2]!
    a59a:	cbnz	r2, a59e <FatPartition::freeClusterCount()+0x8e>
            free++;
    a59c:	adds	r4, #1
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
    a59e:	cmp	r1, r3
    a5a0:	bne.n	a596 <FatPartition::freeClusterCount()+0x86>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    a5a2:	subs.w	r8, r8, lr
    a5a6:	bne.n	a53c <FatPartition::freeClusterCount()+0x2c>
    a5a8:	b.n	a57a <FatPartition::freeClusterCount()+0x6a>
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    a5aa:	mov.w	lr, #128	; 0x80
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    a5ae:	mov	r1, lr
    a5b0:	b.n	a55e <FatPartition::freeClusterCount()+0x4e>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    a5b2:	mov	r0, r8
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
  }
  setFreeClusterCount(free);
  return free;
    a5b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
    a5b8:	uxth.w	r3, r8
    a5bc:	mov	lr, r8
    a5be:	b.n	a58c <FatPartition::freeClusterCount()+0x7c>

0000a5c0 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:

 fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    a5c0:	push	{r3, r4, r5, r6, r7, lr}
    a5c2:	mov	r4, r0
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    a5c4:	movs	r3, #0
  m_allocSearchStart = 1;
    a5c6:	movs	r5, #1
    a5c8:	mov.w	r0, #4294967295
    a5cc:	str	r5, [r4, #12]
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    a5ce:	str	r1, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    a5d0:	str	r1, [r4, #40]	; 0x28
    a5d2:	str.w	r1, [r4, #568]	; 0x238
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    a5d6:	strb	r3, [r4, #7]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a5d8:	strb.w	r3, [r4, #36]	; 0x24
    a5dc:	strb.w	r3, [r4, #564]	; 0x234
    m_sector = 0XFFFFFFFF;
    a5e0:	str	r0, [r4, #48]	; 0x30
    a5e2:	str.w	r0, [r4, #576]	; 0x240
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    a5e6:	mov	r5, r2
    a5e8:	cbz	r2, a622 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x62>
    if (part > 4) {
    a5ea:	cmp	r2, #4
    a5ec:	bls.n	a5f2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x32>
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    a5ee:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    a5f0:	pop	{r3, r4, r5, r6, r7, pc}
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a5f2:	add.w	r6, r4, #36	; 0x24
    a5f6:	mov	r2, r3
    a5f8:	mov	r1, r3
    a5fa:	mov	r0, r6
    a5fc:	bl	773c <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    mbr = reinterpret_cast<MbrSector_t*>
          (cacheFetchData(0, FsCache::CACHE_FOR_READ));
    MbrPart_t* mp = mbr->part + part - 1;
    a600:	add.w	r5, r5, #268435456	; 0x10000000
    a604:	subs	r5, #1
    a606:	lsls	r5, r5, #4
    a608:	add.w	r3, r0, #446	; 0x1be
    a60c:	adds	r2, r3, r5

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
    a60e:	cmp	r0, #0
    a610:	beq.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    a612:	ldrb	r1, [r2, #4]
    a614:	cmp	r1, #0
    a616:	beq.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    a618:	ldrb	r3, [r3, r5]
    a61a:	lsls	r3, r3, #25
    a61c:	bne.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    a61e:	ldr	r5, [r2, #8]
    a620:	b.n	a626 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x66>
    a622:	add.w	r6, r4, #36	; 0x24
    a626:	mov	r0, r6
    a628:	movs	r2, #0
    a62a:	mov	r1, r5
    a62c:	bl	773c <FsCache::get(unsigned long, unsigned char)>
    volumeStartSector = getLe32(mp->relativeSectors);
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    a630:	cmp	r0, #0
    a632:	beq.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    a634:	ldrb	r3, [r0, #16]
    a636:	cmp	r3, #2
    a638:	bne.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    a63a:	ldrh.w	r3, [r0, #11]
    a63e:	cmp.w	r3, #512	; 0x200
    a642:	bne.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    a644:	ldrb	r6, [r0, #13]
    a646:	strb	r6, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    a648:	subs	r3, r6, #1
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    a64a:	movs	r2, #0
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    a64c:	cmp	r6, #1
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    a64e:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    a650:	strb	r2, [r4, #6]
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    a652:	beq.n	a674 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb4>
    a654:	movs	r2, #1
    a656:	mov	r1, r2
    a658:	b.n	a65c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9c>
    a65a:	mov	r2, r3
    a65c:	lsls	r1, r1, #1
    a65e:	uxtb	r1, r1
    a660:	adds	r3, r2, #1
    a662:	cmp	r6, r1
    a664:	uxtb	r3, r3
    a666:	beq.n	a672 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb2>
    if (tmp == 0) {
    a668:	cmp	r3, #9
    a66a:	bne.n	a65a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9a>
    a66c:	strb	r2, [r4, #6]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    a66e:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    a670:	pop	{r3, r4, r5, r6, r7, pc}
    a672:	strb	r2, [r4, #6]
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    a674:	ldrh	r6, [r0, #22]
    a676:	str	r6, [r4, #16]
  if (m_sectorsPerFat == 0) {
    a678:	cbnz	r6, a67e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xbe>
    a67a:	ldr	r6, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    a67c:	str	r6, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    a67e:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    a680:	ldrh.w	r3, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    a684:	strh	r3, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    a686:	add	r1, r5
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    a688:	lsls	r3, r3, #5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    a68a:	add.w	r7, r1, r6, lsl #1
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    a68e:	addw	r3, r3, #511	; 0x1ff
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    a692:	str	r1, [r4, #24]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    a694:	ldrh.w	r1, [r0, #19]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    a698:	str	r7, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    a69a:	add.w	r3, r7, r3, asr #9
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    a69e:	str	r3, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    a6a0:	cbnz	r1, a6a4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe4>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    a6a2:	ldr	r1, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    a6a4:	subs	r5, r5, r3
    a6a6:	add	r5, r1

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    a6a8:	lsr.w	r2, r5, r2
  m_lastCluster = clusterCount + 1;

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    a6ac:	movw	r3, #4084	; 0xff4
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    a6b0:	adds	r1, r2, #1

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    a6b2:	cmp	r2, r3
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    a6b4:	str	r1, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    a6b6:	bls.n	a6d4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x114>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    a6b8:	movw	r3, #65524	; 0xfff4
    a6bc:	cmp	r2, r3
    a6be:	ittet	hi
    a6c0:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    a6c2:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    a6c4:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    a6c6:	movhi	r3, #32
    a6c8:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    a6ca:	str	r6, [r4, #44]	; 0x2c
    a6cc:	str.w	r6, [r4, #572]	; 0x23c
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    a6d0:	movs	r0, #1
    a6d2:	pop	{r3, r4, r5, r6, r7, pc}

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    a6d4:	movs	r3, #12
    a6d6:	strb	r3, [r4, #7]
    a6d8:	b.n	a5ee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    a6da:	nop

0000a6dc <lfnGetChar(DirLfn_t*, unsigned char)>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    a6dc:	cmp	r1, #4
    a6de:	bls.n	a6fa <lfnGetChar(DirLfn_t*, unsigned char)+0x1e>
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    a6e0:	cmp	r1, #10
    a6e2:	bls.n	a6f2 <lfnGetChar(DirLfn_t*, unsigned char)+0x16>
    return getLe16(ldir->unicode2 + 2*i - 10);
  } else if (i < 13) {
    a6e4:	cmp	r1, #12
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    a6e6:	itte	ls
    a6e8:	addls.w	r1, r0, r1, lsl #1
    a6ec:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  return 0;
    a6ee:	movhi	r0, #0
}
    a6f0:	bx	lr
    a6f2:	add.w	r1, r0, r1, lsl #1
    a6f6:	ldrh	r0, [r1, #4]
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    return getLe16(ldir->unicode2 + 2*i - 10);
    a6f8:	bx	lr
    a6fa:	add.w	r1, r0, r1, lsl #1
    a6fe:	ldrh.w	r0, [r1, #1]
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
    a702:	bx	lr

0000a704 <FatFile::lfnChecksum(unsigned char*)>:
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    a704:	push	{r4}
    a706:	subs	r2, r0, #1
    a708:	add.w	r4, r0, #10
  uint8_t sum = 0;
    a70c:	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    a70e:	ldrb.w	r1, [r2, #1]!
    a712:	lsrs	r3, r0, #1
    a714:	orr.w	r0, r3, r0, lsl #7
    a718:	uxtab	r0, r1, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    a71c:	cmp	r4, r2
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    a71e:	uxtb	r0, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    a720:	bne.n	a70e <FatFile::lfnChecksum(unsigned char*)+0xa>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    a722:	ldr.w	r4, [sp], #4
    a726:	bx	lr

0000a728 <FatFile::openCluster(FatFile*)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    a728:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    a72a:	ldr	r3, [r1, #12]
    a72c:	cbz	r3, a74c <FatFile::openCluster(FatFile*)+0x24>
    a72e:	mov	r5, r0
    a730:	mov	r4, r1
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
    a732:	movs	r2, #36	; 0x24
    a734:	movs	r1, #0
    a736:	bl	1001c <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    a73a:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    a73c:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    a73e:	strb	r3, [r5, #0]
  m_flags = FILE_FLAG_READ;
    a740:	strb	r0, [r5, #2]
  m_vol = file->m_vol;
    a742:	ldr	r2, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    a744:	ldr	r3, [r4, #12]
    a746:	str	r3, [r5, #32]
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
    a748:	str	r2, [r5, #8]
  m_firstCluster = file->m_dirCluster;
  return true;
}
    a74a:	pop	{r3, r4, r5, pc}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    a74c:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    a74e:	ldmia.w	sp!, {r3, r4, r5, lr}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    a752:	b.w	9914 <FatFile::openRoot(FatVolume*)>
    a756:	nop

0000a758 <FatFile::getName(char*, unsigned int)>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    a758:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a75c:	sub	sp, #52	; 0x34
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    a75e:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    a760:	movs	r4, #0
    a762:	strb.w	r4, [sp, #12]
    a766:	strb.w	r4, [sp, #13]
    a76a:	strb.w	r4, [sp, #14]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    a76e:	mov	r8, r1
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    a770:	cbz	r3, a778 <FatFile::getName(char*, unsigned int)+0x20>
    a772:	cmp	r2, #12
    a774:	mov	r9, r2
    a776:	bhi.n	a784 <FatFile::getName(char*, unsigned int)+0x2c>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
    a778:	movs	r0, #0
    a77a:	strb.w	r0, [r8]
  return 0;
}
    a77e:	add	sp, #52	; 0x34
    a780:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    a784:	ldrb	r3, [r0, #3]
    a786:	mov	r7, r0
    a788:	cmp	r3, #0
    a78a:	beq.n	a832 <FatFile::getName(char*, unsigned int)+0xda>
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    a78c:	add	r0, sp, #12
    a78e:	mov	r1, r7
    a790:	bl	a728 <FatFile::openCluster(FatFile*)>
    a794:	cmp	r0, #0
    a796:	beq.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    a798:	ldrb	r3, [r7, #3]
    a79a:	cmp	r3, #0
    a79c:	beq.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    a79e:	str	r4, [sp, #4]
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    a7a0:	movs	r6, #1
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    a7a2:	add.w	r5, r9, #4294967295
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    a7a6:	ldrh	r1, [r7, #4]
    a7a8:	subs	r1, r1, r6
    a7aa:	lsls	r1, r1, #5
    a7ac:	add	r0, sp, #12
    a7ae:	bl	9d5c <FatFile::seekSet(unsigned long)>
    a7b2:	cmp	r0, #0
    a7b4:	beq.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    a7b6:	movs	r1, #0
    a7b8:	add	r0, sp, #12
    a7ba:	bl	9aec <FatFile::readDirCache(bool)>
    if (!ldir) {
    a7be:	mov	fp, r0
    a7c0:	cmp	r0, #0
    a7c2:	beq.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
    a7c4:	ldrb	r3, [r0, #11]
    a7c6:	cmp	r3, #15
    a7c8:	bne.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (order != (ldir->order & 0X1F)) {
    a7ca:	ldrb	r3, [r0, #0]
    a7cc:	and.w	r3, r3, #31
    a7d0:	cmp	r6, r3
    a7d2:	bne.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
  return 0;
}
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
    a7d4:	subs	r3, r6, #1
    a7d6:	add.w	r4, r3, r3, lsl #1
    a7da:	add.w	r4, r3, r4, lsl #2
    a7de:	mov	r3, r4
    a7e0:	add.w	sl, r8, r4
    a7e4:	add.w	r2, r4, #13
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    a7e8:	subs	r1, r3, r4
    a7ea:	uxtb	r1, r1
    a7ec:	mov	r0, fp
    a7ee:	bl	a6dc <lfnGetChar(DirLfn_t*, unsigned char)>
    if (c == 0 || k >= (n - 1)) {
    a7f2:	cbz	r0, a83c <FatFile::getName(char*, unsigned int)+0xe4>
    a7f4:	cmp	r5, r3
    a7f6:	bls.n	a83c <FatFile::getName(char*, unsigned int)+0xe4>
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    a7f8:	cmp	r0, #126	; 0x7e
    a7fa:	add.w	r3, r3, #1
    a7fe:	ite	ls
    a800:	uxtbls	r0, r0
    a802:	movhi	r0, #63	; 0x3f
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    a804:	cmp	r2, r3
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    a806:	strb.w	r0, [sl], #1
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    a80a:	bne.n	a7e8 <FatFile::getName(char*, unsigned int)+0x90>
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte.
  if (k >= n) {  // <<----------added
    k = n - 1;   // <<--------- added
    a80c:	cmp	r9, r2
    a80e:	it	ls
    a810:	movls	r2, r5
  }             // <<---------added
  name[k] = '\0';
    a812:	ldrb.w	r3, [sp, #4]
    a816:	strb.w	r3, [r8, r2]
    if (order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    n = lfnGetName(ldir, name, size);
    if (n == 0) {
    a81a:	cmp	r2, #0
    a81c:	beq.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    a81e:	ldrb.w	r3, [fp]
    a822:	lsls	r3, r3, #25
    a824:	bmi.n	a840 <FatFile::getName(char*, unsigned int)+0xe8>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    a826:	adds	r6, #1
    a828:	ldrb	r3, [r7, #3]
    a82a:	uxtb	r6, r6
    a82c:	cmp	r3, r6
    a82e:	bcs.n	a7a6 <FatFile::getName(char*, unsigned int)+0x4e>
    a830:	b.n	a778 <FatFile::getName(char*, unsigned int)+0x20>
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    return getSFN(name);
    a832:	bl	b0bc <FatFile::getSFN(char*)>
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
  return 0;
}
    a836:	add	sp, #52	; 0x34
    a838:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    a83c:	mov	r2, r3
    a83e:	b.n	a80c <FatFile::getName(char*, unsigned int)+0xb4>
    a840:	mov	r0, r2
    a842:	b.n	a77e <FatFile::getName(char*, unsigned int)+0x26>

0000a844 <FatFile::parsePathName(char const*, fname_t*, char const**)>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    a844:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    a848:	ldrb	r3, [r0, #0]
    a84a:	cmp	r3, #32
    a84c:	bne.n	a856 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x12>
    a84e:	ldrb.w	r3, [r0, #1]!
    a852:	cmp	r3, #32
    a854:	beq.n	a84e <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa>
    path++;
  }
  fname->lfn = path;
    a856:	str	r0, [r1, #8]

  for (len = 0; ; len++) {
    c = path[len];
    a858:	ldrb	r3, [r0, #0]
    if (c == 0 || isDirSeparator(c)) {
    a85a:	cmp	r3, #0
    a85c:	beq.w	aa6e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x22a>
    a860:	cmp	r3, #47	; 0x2f
    a862:	beq.n	a8c4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x80>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    a864:	cmp	r3, #92	; 0x5c
    a866:	beq.n	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    a868:	sub.w	r4, r3, #34	; 0x22
    a86c:	uxtb	r4, r4
    a86e:	cmp	r4, #29
    a870:	bls.n	a8b4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x70>
    a872:	ldr.w	lr, [pc, #536]	; aa8c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>
    a876:	adds	r6, r0, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    a878:	movs	r4, #0
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    a87a:	cmp	r3, #124	; 0x7c
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    a87c:	sub.w	r5, r3, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    a880:	mov	r7, r6
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    a882:	beq.n	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    a884:	cmp	r5, #94	; 0x5e
    a886:	bhi.n	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    a888:	ldrb.w	r3, [r6], #1
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    a88c:	sub.w	r5, r3, #34	; 0x22
    a890:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    a892:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    a894:	cmp	r3, #0
    a896:	beq.w	aa40 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1fc>
    a89a:	cmp	r3, #47	; 0x2f
    a89c:	beq.n	a8c6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x82>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    a89e:	cmp	r3, #92	; 0x5c
    a8a0:	lsr.w	r7, lr, r5
    a8a4:	beq.n	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    a8a6:	cmp	r5, #29
    a8a8:	bhi.n	a87a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    a8aa:	lsls	r7, r7, #31
    a8ac:	bpl.n	a87a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    a8ae:	movs	r0, #0
    a8b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    a8b4:	ldr	r5, [pc, #468]	; (aa8c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>)
    a8b6:	lsr.w	r4, r5, r4
    a8ba:	lsls	r4, r4, #31
    a8bc:	bpl.n	a872 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x2e>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    a8be:	movs	r0, #0
    a8c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    a8c4:	movs	r4, #0
    a8c6:	adds	r7, r0, r4
    a8c8:	mov	r6, r7
    a8ca:	mov	r5, r4
    a8cc:	movs	r3, #47	; 0x2f
    a8ce:	b.n	a8d6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x92>
    a8d0:	ldrb.w	r3, [r6, #1]!
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    a8d4:	adds	r5, #1
    a8d6:	cmp	r3, #32
    a8d8:	beq.n	a8d0 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
    a8da:	cmp	r3, #47	; 0x2f
    a8dc:	beq.n	a8d0 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
  *ptr = &path[end];
    a8de:	add	r5, r0
    a8e0:	str	r5, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    a8e2:	cbz	r4, a8f8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb4>
    a8e4:	mov	r2, r7
    c = path[len - 1];
    a8e6:	ldrb.w	r3, [r2, #-1]!
    if (c != '.' && c != ' ') {
    a8ea:	cmp	r3, #46	; 0x2e
    a8ec:	beq.n	a8f4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb0>
    a8ee:	cmp	r3, #32
    a8f0:	bne.w	aa46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x202>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    a8f4:	subs	r4, #1
    a8f6:	bne.n	a8e6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa2>
    a8f8:	mov.w	r5, #4294967295
    a8fc:	mov	r3, r4
  // Max length of LFN is 255.
  if (len > 255) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
    a8fe:	str	r3, [r1, #4]
    a900:	add.w	r6, r1, #23
    a904:	add.w	r3, r1, #12
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    a908:	movs	r2, #32
    a90a:	strb.w	r2, [r3, #1]!
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    a90e:	cmp	r3, r6
    a910:	bne.n	a90a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xc6>
    a912:	subs	r6, r0, #1
    a914:	movs	r2, #0
    a916:	b.n	a91a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd6>
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    a918:	adds	r2, #1
    a91a:	ldrb.w	r3, [r6, #1]!
    a91e:	cmp	r3, #46	; 0x2e
    a920:	beq.n	a918 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
    a922:	cmp	r3, #32
    a924:	beq.n	a918 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    a926:	clz	ip, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    a92a:	adds	r6, r5, #1
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    a92c:	mov.w	ip, ip, lsr #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    a930:	beq.n	a94c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    a932:	ldrb	r7, [r0, r5]
    a934:	cmp	r7, #46	; 0x2e
    a936:	add.w	r6, r0, r5
    a93a:	bne.n	a946 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x102>
    a93c:	b.n	a94c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    a93e:	ldrb.w	r7, [r6, #-1]!
    a942:	cmp	r7, #46	; 0x2e
    a944:	beq.n	a94c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    a946:	adds.w	r5, r5, #4294967295
    a94a:	bcs.n	a93e <FatFile::parsePathName(char const*, fname_t*, char const**)+0xfa>
  for (; si < len; si++) {
    a94c:	cmp	r2, r4
    a94e:	mov.w	r9, #0
    a952:	bge.w	aa78 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x234>
    a956:	mov	r6, r9
    a958:	mov	sl, r9
    a95a:	movs	r7, #7
    a95c:	mov.w	r8, #8
    a960:	b.n	a9ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16a>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    a962:	cmp	r3, #46	; 0x2e
    a964:	beq.n	a9f6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b2>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    a966:	cmp	r3, #34	; 0x22
    a968:	beq.n	a982 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    a96a:	cmp	r3, #124	; 0x7c
    a96c:	beq.n	a982 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    a96e:	sub.w	lr, r3, #42	; 0x2a
    a972:	cmp.w	lr, #5
    a976:	bls.n	aa0a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1c6>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    a978:	sub.w	lr, r3, #58	; 0x3a
    a97c:	cmp.w	lr, #5
    a980:	bhi.n	aa34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1f0>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    a982:	cmp	r5, r2
    a984:	beq.n	a9fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    a986:	cmp	r7, r6
    a988:	bcc.n	a9de <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
    a98a:	mov.w	ip, #0
      c = '_';
    a98e:	movs	r3, #95	; 0x5f
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    a990:	add.w	lr, r6, #1
    a994:	add.w	fp, r1, r6
    a998:	uxtb.w	r6, lr
      if (i < 7) {
    a99c:	cmp	r6, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    a99e:	strb.w	r3, [fp, #13]
      if (i < 7) {
    a9a2:	bhi.n	a9a6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
        fname->seqPos = i;
    a9a4:	strb	r6, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    a9a6:	adds	r2, #1
    a9a8:	cmp	r2, r4
    a9aa:	bge.n	a9bc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
    a9ac:	ldrb	r3, [r0, r2]
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    a9ae:	cmp	r3, #32
    a9b0:	bne.n	a962 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x11e>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    a9b2:	adds	r2, #1
    a9b4:	cmp	r2, r4
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    a9b6:	mov.w	ip, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    a9ba:	blt.n	a9ac <FatFile::parsePathName(char const*, fname_t*, char const**)+0x168>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    a9bc:	ldrb	r3, [r1, #13]
    a9be:	cmp	r3, #32
    a9c0:	beq.w	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (is83) {
    a9c4:	cmp.w	ip, #0
    a9c8:	beq.n	aa5a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x216>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    a9ca:	tst.w	sl, r9
    a9ce:	it	ne
    a9d0:	movne.w	r9, #2
    a9d4:	strb.w	r9, [r1]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    a9d8:	movs	r0, #1
    a9da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    a9de:	cmp	r7, #10
    a9e0:	beq.n	aa52 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    a9e2:	cmp	r5, r2
    a9e4:	blt.n	aa52 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    a9e6:	mov	r2, r5
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    a9e8:	movs	r7, #10
      i = 8;    // Place for extension.
    a9ea:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    a9ec:	mov.w	r8, #16
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    a9f0:	mov.w	ip, #0
    a9f4:	b.n	a9a6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    a9f6:	cmp	r5, r2
    a9f8:	bne.n	a9b2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16e>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    a9fa:	cmp	r7, #10
    a9fc:	beq.n	aa52 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    a9fe:	mov	r2, r5
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    aa00:	movs	r7, #10
      i = 8;    // Place for extension.
    aa02:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    aa04:	mov.w	r8, #16
    aa08:	b.n	a9a6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    aa0a:	cmp	r3, #45	; 0x2d
    aa0c:	bne.n	a982 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    aa0e:	sub.w	lr, r3, #33	; 0x21
    aa12:	cmp.w	lr, #93	; 0x5d
    aa16:	bhi.n	a982 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    aa18:	cmp	r5, r2
    aa1a:	beq.n	a9fa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
    aa1c:	cmp	r7, r6
    aa1e:	bcc.n	a9de <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    aa20:	sub.w	lr, r3, #97	; 0x61
    aa24:	cmp.w	lr, #25
    aa28:	bhi.n	aa7c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x238>
        c += 'A' - 'a';
    aa2a:	subs	r3, #32
    aa2c:	uxtb	r3, r3
        lc |= bit;
    aa2e:	orr.w	r9, r8, r9
    aa32:	b.n	a990 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    aa34:	sub.w	lr, r3, #91	; 0x5b
    aa38:	cmp.w	lr, #2
    aa3c:	bls.n	a982 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    aa3e:	b.n	aa0e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1ca>
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    aa40:	str	r7, [r2, #0]
    aa42:	adds	r7, r0, r4
    aa44:	b.n	a8e4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa0>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
    aa46:	cmp	r4, #255	; 0xff
    aa48:	bgt.w	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    aa4c:	subs	r5, r4, #1
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    c = path[len - 1];
    aa4e:	mov	r3, r4
    aa50:	b.n	a8fe <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    aa52:	ldrb	r3, [r1, #13]
    aa54:	cmp	r3, #32
    aa56:	beq.w	a8ae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    aa5a:	ldrb	r3, [r1, #12]
    aa5c:	add	r3, r1
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    aa5e:	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
    aa60:	movs	r4, #126	; 0x7e
    fname->sfn[fname->seqPos + 1] = '1';
    aa62:	movs	r2, #49	; 0x31
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    aa64:	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    aa66:	strb	r4, [r3, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    aa68:	strb	r2, [r3, #14]
    aa6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    aa6e:	str	r0, [r2, #0]
    aa70:	mov	r4, r3
    aa72:	mov.w	r5, #4294967295
    aa76:	b.n	a8fe <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    aa78:	mov	sl, r9
    aa7a:	b.n	a9bc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    aa7c:	sub.w	lr, r3, #65	; 0x41
    aa80:	cmp.w	lr, #25
        uc |= bit;
    aa84:	it	ls
    aa86:	orrls.w	sl, r8, sl
    aa8a:	b.n	a990 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    aa8c:	.word	0x35000101

0000aa90 <FatFile::printName(Print*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::printName(print_t* pr) {
    aa90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    aa94:	sub	sp, #56	; 0x38
  size_t n = 0;
  uint16_t u;
  uint8_t buf[13];
  uint8_t i;

  if (!isLFN()) {
    aa96:	ldrb	r3, [r0, #3]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    aa98:	movs	r5, #0
    aa9a:	strb.w	r5, [sp, #20]
    aa9e:	strb.w	r5, [sp, #21]
    aaa2:	strb.w	r5, [sp, #22]
    aaa6:	cmp	r3, #0
    aaa8:	beq.n	ab40 <FatFile::printName(Print*)+0xb0>
    aaaa:	mov	r7, r0
    aaac:	mov	r8, r1
    return printSFN(pr);
  }
  if (!dirFile.openCluster(this)) {
    aaae:	add	r0, sp, #20
    aab0:	mov	r1, r7
    aab2:	bl	a728 <FatFile::openCluster(FatFile*)>
    aab6:	cmp	r0, #0
    aab8:	beq.n	ab34 <FatFile::printName(Print*)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    aaba:	ldrb	r3, [r7, #3]
    aabc:	cmp	r3, #0
    aabe:	beq.n	ab34 <FatFile::printName(Print*)+0xa4>
    aac0:	movs	r6, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    aac2:	ldrh	r1, [r7, #4]
    aac4:	subs	r1, r1, r6
    aac6:	lsls	r1, r1, #5
    aac8:	add	r0, sp, #20
    aaca:	bl	9d5c <FatFile::seekSet(unsigned long)>
    aace:	cbz	r0, ab34 <FatFile::printName(Print*)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    aad0:	movs	r1, #0
    aad2:	add	r0, sp, #20
    aad4:	bl	9aec <FatFile::readDirCache(bool)>
    if (!ldir) {
    aad8:	mov	r9, r0
    aada:	cbz	r0, ab34 <FatFile::printName(Print*)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    aadc:	ldrb	r3, [r0, #11]
    aade:	cmp	r3, #15
    aae0:	bne.n	ab34 <FatFile::printName(Print*)+0xa4>
    aae2:	ldrb	r3, [r0, #0]
    aae4:	and.w	r3, r3, #31
    aae8:	cmp	r6, r3
    aaea:	bne.n	ab34 <FatFile::printName(Print*)+0xa4>
    aaec:	add	r3, sp, #4
    aaee:	add.w	sl, r5, #13
    aaf2:	mov	r4, r5
    aaf4:	subs	r2, r4, r5
    aaf6:	uxtb	r2, r2
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (i = 0; i < 13; i++) {
      u = lfnGetChar(ldir, i);
    aaf8:	mov	r1, r2
    aafa:	mov	r0, r9
    aafc:	bl	a6dc <lfnGetChar(DirLfn_t*, unsigned char)>
      if (u == 0) {
    ab00:	cbz	r0, ab3c <FatFile::printName(Print*)+0xac>
        // End of name.
        break;
      }
      buf[i] = u < 0X7F ? u : '?';
    ab02:	cmp	r0, #126	; 0x7e
      n++;
    ab04:	add.w	r4, r4, #1
      u = lfnGetChar(ldir, i);
      if (u == 0) {
        // End of name.
        break;
      }
      buf[i] = u < 0X7F ? u : '?';
    ab08:	ite	ls
    ab0a:	uxtbls	r0, r0
    ab0c:	movhi	r0, #63	; 0x3f
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (i = 0; i < 13; i++) {
    ab0e:	cmp	r4, sl
      u = lfnGetChar(ldir, i);
      if (u == 0) {
        // End of name.
        break;
      }
      buf[i] = u < 0X7F ? u : '?';
    ab10:	strb.w	r0, [r3], #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (i = 0; i < 13; i++) {
    ab14:	bne.n	aaf4 <FatFile::printName(Print*)+0x64>
    ab16:	mov	r5, r4
    ab18:	movs	r2, #13
        break;
      }
      buf[i] = u < 0X7F ? u : '?';
      n++;
    }
    pr->write(buf, i);
    ab1a:	ldr.w	r3, [r8]
    ab1e:	add	r1, sp, #4
    ab20:	ldr	r3, [r3, #4]
    ab22:	mov	r0, r8
    ab24:	blx	r3
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ab26:	adds	r6, #1
    ab28:	ldrb	r3, [r7, #3]
    ab2a:	uxtb	r6, r6
    ab2c:	cmp	r3, r6
    ab2e:	bcs.n	aac2 <FatFile::printName(Print*)+0x32>
    ab30:	mov	r0, r4
    ab32:	b.n	ab36 <FatFile::printName(Print*)+0xa6>
    pr->write(buf, i);
  }
  return n;

 fail:
  return 0;
    ab34:	movs	r0, #0
}
    ab36:	add	sp, #56	; 0x38
    ab38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (i = 0; i < 13; i++) {
      u = lfnGetChar(ldir, i);
      if (u == 0) {
    ab3c:	mov	r5, r4
    ab3e:	b.n	ab1a <FatFile::printName(Print*)+0x8a>
  uint16_t u;
  uint8_t buf[13];
  uint8_t i;

  if (!isLFN()) {
    return printSFN(pr);
    ab40:	bl	b134 <FatFile::printSFN(Print*)>
  }
  return n;

 fail:
  return 0;
}
    ab44:	add	sp, #56	; 0x38
    ab46:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ab4a:	nop

0000ab4c <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    ab4c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    ab50:	ldrb	r2, [r0, #2]

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    ab52:	sub	sp, #40	; 0x28
    ab54:	movs	r3, #0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    ab56:	lsls	r2, r2, #30
    ab58:	strb.w	r3, [sp, #4]
    ab5c:	strb.w	r3, [sp, #5]
    ab60:	strb.w	r3, [sp, #6]
    ab64:	bpl.n	abac <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    ab66:	ldr	r1, [r0, #32]
    ab68:	mov	r5, r0
    ab6a:	cbnz	r1, abb6 <FatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    ab6c:	movs	r1, #1
    ab6e:	mov	r0, r5
    ab70:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    ab74:	cbz	r0, abac <FatFile::remove()+0x60>
    ab76:	subs	r1, r0, #1
    ab78:	add.w	r7, r0, #10
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    ab7c:	movs	r4, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    ab7e:	lsrs	r2, r4, #1
    ab80:	ldrb.w	r6, [r1, #1]!
    ab84:	orr.w	r3, r2, r4, lsl #7
    ab88:	uxtab	r3, r6, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    ab8c:	cmp	r7, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    ab8e:	uxtb	r4, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    ab90:	bne.n	ab7e <FatFile::remove()+0x32>
    goto fail;
  }
  checksum = lfnChecksum(dir->name);

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    ab92:	mov.w	r8, #229	; 0xe5
    ab96:	strb.w	r8, [r0]
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    ab9a:	ldr	r6, [r5, #8]

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    ab9c:	movs	r3, #0
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    ab9e:	add.w	r0, r6, #36	; 0x24
    aba2:	strb	r3, [r5, #0]
  m_flags = 0;
    aba4:	strb	r3, [r5, #2]
    aba6:	bl	779c <FsCache::sync()>
    abaa:	cbnz	r0, abc2 <FatFile::remove()+0x76>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    abac:	movs	r6, #0
}
    abae:	mov	r0, r6
    abb0:	add	sp, #40	; 0x28
    abb2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    abb6:	ldr	r0, [r0, #8]
    abb8:	bl	a4d4 <FatPartition::freeChain(unsigned long)>
    abbc:	cmp	r0, #0
    abbe:	bne.n	ab6c <FatFile::remove()+0x20>
    abc0:	b.n	abac <FatFile::remove()+0x60>
    abc2:	add.w	r0, r6, #564	; 0x234
    abc6:	bl	779c <FsCache::sync()>
    abca:	cmp	r0, #0
    abcc:	beq.n	abac <FatFile::remove()+0x60>
    abce:	ldr	r0, [r6, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    abd0:	ldr	r3, [r0, #0]
    abd2:	ldr	r3, [r3, #24]
    abd4:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    abd6:	mov	r6, r0
    abd8:	cmp	r0, #0
    abda:	beq.n	abac <FatFile::remove()+0x60>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    abdc:	ldrb	r3, [r5, #3]
    abde:	cmp	r3, #0
    abe0:	beq.n	abae <FatFile::remove()+0x62>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    abe2:	add	r0, sp, #4
    abe4:	mov	r1, r5
    abe6:	bl	a728 <FatFile::openCluster(FatFile*)>
    abea:	cmp	r0, #0
    abec:	beq.n	abac <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    abee:	ldrb	r3, [r5, #3]
    abf0:	cmp	r3, #0
    abf2:	beq.n	abac <FatFile::remove()+0x60>
    abf4:	movs	r7, #1
    abf6:	b.n	ac38 <FatFile::remove()+0xec>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    abf8:	add	r0, sp, #4
    abfa:	bl	9aec <FatFile::readDirCache(bool)>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    abfe:	adds	r3, r7, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
    ac00:	cmp	r0, #0
    ac02:	beq.n	abac <FatFile::remove()+0x60>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    ac04:	ldrb	r2, [r0, #11]
    ac06:	cmp	r2, #15
    ac08:	bne.n	abac <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    ac0a:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    ac0c:	and.w	r1, r2, #31
    ac10:	cmp	r7, r1
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ac12:	uxtb	r7, r3
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    ac14:	bne.n	abac <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    ac16:	ldrb	r3, [r0, #13]
    ac18:	cmp	r3, r4
    ac1a:	bne.n	abac <FatFile::remove()+0x60>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    ac1c:	strb.w	r8, [r0]
    m_vol->cacheDirty();
    ac20:	ldr	r1, [r5, #8]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    ac22:	ldrb.w	r3, [r1, #36]	; 0x24
    ac26:	orr.w	r3, r3, #1
    ac2a:	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
    ac2e:	lsls	r3, r2, #25
    ac30:	bmi.n	ac4c <FatFile::remove()+0x100>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ac32:	ldrb	r3, [r5, #3]
    ac34:	cmp	r3, r7
    ac36:	bcc.n	abac <FatFile::remove()+0x60>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    ac38:	ldrh	r1, [r5, #4]
    ac3a:	subs	r1, r1, r7
    ac3c:	lsls	r1, r1, #5
    ac3e:	add	r0, sp, #4
    ac40:	bl	9d5c <FatFile::seekSet(unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    ac44:	movs	r1, #0
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    ac46:	cmp	r0, #0
    ac48:	bne.n	abf8 <FatFile::remove()+0xac>
    ac4a:	b.n	abac <FatFile::remove()+0x60>
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
    ac4c:	ldr	r4, [r5, #8]
    ac4e:	add.w	r0, r4, #36	; 0x24
    ac52:	bl	779c <FsCache::sync()>
    ac56:	cmp	r0, #0
    ac58:	beq.n	abac <FatFile::remove()+0x60>
    ac5a:	add.w	r0, r4, #564	; 0x234
    ac5e:	bl	779c <FsCache::sync()>
    ac62:	cmp	r0, #0
    ac64:	beq.n	abac <FatFile::remove()+0x60>
    ac66:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    ac68:	ldr	r3, [r0, #0]
    ac6a:	ldr	r3, [r3, #24]
    ac6c:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    ac6e:	cmp	r0, #0
    ac70:	beq.n	abac <FatFile::remove()+0x60>
    ac72:	b.n	abae <FatFile::remove()+0x62>

0000ac74 <FatFile::lfnUniqueSfn(fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    ac74:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    ac78:	ldrb	r7, [r1, #12]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    ac7a:	mov	r6, r1
    ac7c:	mov	r4, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    ac7e:	add.w	r5, r1, #13
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    ac82:	mov.w	r8, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    ac86:	mov.w	r9, #126	; 0x7e
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    ac8a:	ldr	r0, [r6, #4]
    ac8c:	ldr	r1, [r6, #8]
    ac8e:	add.w	r3, r8, r0
    ac92:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    ac94:	cbz	r0, aca8 <FatFile::lfnUniqueSfn(fname_t*)+0x34>
    ac96:	add	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    ac98:	ldrb.w	r2, [r1], #1
    ac9c:	add.w	r3, r3, r3, lsl #5
    aca0:	eors	r3, r2
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    aca2:	cmp	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    aca4:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    aca6:	bne.n	ac98 <FatFile::lfnUniqueSfn(fname_t*)+0x24>
    aca8:	cmp	r7, #3
    acaa:	it	cs
    acac:	movcs	r7, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    acae:	adds	r2, r7, #4
    acb0:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    acb2:	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    acb6:	adds	r0, r6, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    acb8:	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    acba:	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    acbc:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    acbe:	ite	ls
    acc0:	addls	r1, #48	; 0x30
    acc2:	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    acc4:	cmp	r7, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
    acc6:	mov.w	r3, r3, lsr #4
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    acca:	strb	r1, [r0, #13]
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    accc:	bcc.n	acb2 <FatFile::lfnUniqueSfn(fname_t*)+0x3e>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    acce:	adds	r3, r6, r7
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    acd0:	movs	r1, #0
    acd2:	strb.w	r9, [r3, #13]
    acd6:	mov	r0, r4
    acd8:	bl	9d5c <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    acdc:	movs	r1, #1
    acde:	mov	r0, r4
    ace0:	bl	9aec <FatFile::readDirCache(bool)>
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    ace4:	movs	r2, #11
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    ace6:	mov	r3, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    ace8:	mov	r1, r0
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    acea:	cbz	r0, ad18 <FatFile::lfnUniqueSfn(fname_t*)+0xa4>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    acec:	ldrb.w	lr, [r3]
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    acf0:	mov	r0, r5
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    acf2:	cmp.w	lr, #0
    acf6:	beq.n	ad24 <FatFile::lfnUniqueSfn(fname_t*)+0xb0>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    acf8:	ldrb	r3, [r3, #11]
    acfa:	lsls	r3, r3, #28
    acfc:	bmi.n	acdc <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    acfe:	bl	fef0 <memcmp>
    ad02:	cmp	r0, #0
    ad04:	bne.n	acdc <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    ad06:	add.w	r8, r8, #1
    ad0a:	uxth.w	r8, r8
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    ad0e:	cmp.w	r8, #100	; 0x64
    ad12:	bne.n	ac8a <FatFile::lfnUniqueSfn(fname_t*)+0x16>
 fail:
  return false;

 done:
  return true;
}
    ad14:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
        if (!getError()) {
    ad18:	ldrb	r0, [r4, #1]
    ad1a:	clz	r0, r0
    ad1e:	lsrs	r0, r0, #5
    ad20:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

 fail:
  return false;

 done:
  return true;
    ad24:	movs	r0, #1
    ad26:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ad2a:	nop

0000ad2c <FatFile::open(FatFile*, fname_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    ad2c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    ad30:	ldrb	r4, [r1, #0]
    ad32:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    ad36:	sub	sp, #52	; 0x34
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    ad38:	beq.n	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    ad3a:	ldrb	r4, [r0, #0]
    ad3c:	cbz	r4, ad46 <FatFile::open(FatFile*, fname_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    ad3e:	movs	r0, #0
}
    ad40:	add	sp, #52	; 0x34
    ad42:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    ad46:	ldrb	r4, [r2, #0]
  uint16_t curIndex;
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;
    ad48:	ldr.w	sl, [r2, #4]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    ad4c:	lsls	r4, r4, #30
    ad4e:	bne.n	add6 <FatFile::open(FatFile*, fname_t*, int)+0xaa>
    ad50:	mov.w	r8, #1
    ad54:	mov	r6, r1
    ad56:	mov	fp, r2
    ad58:	str	r0, [sp, #36]	; 0x24
    ad5a:	movs	r1, #0
    ad5c:	mov	r0, r6
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint16_t freeIndex = 0;
    ad5e:	mov	r7, r1
    ad60:	str	r3, [sp, #28]
    ad62:	bl	9d5c <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    ad66:	add.w	r3, fp, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    ad6a:	str	r7, [sp, #24]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    ad6c:	str	r7, [sp, #12]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    ad6e:	mov	r4, r7
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    ad70:	mov	r9, r7
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    ad72:	str	r7, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    ad74:	str	r3, [sp, #16]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    ad76:	movs	r1, #1
    ad78:	mov	r0, r6
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    ad7a:	ldr	r5, [r6, #20]
    dir = dirFile->readDirCache(true);
    ad7c:	bl	9aec <FatFile::readDirCache(bool)>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    ad80:	ubfx	r5, r5, #5, #16
    dir = dirFile->readDirCache(true);
    if (!dir) {
    ad84:	mov	r3, r0
    ad86:	cmp	r0, #0
    ad88:	beq.w	aea4 <FatFile::open(FatFile*, fname_t*, int)+0x178>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    ad8c:	ldrb	r2, [r0, #0]
    ad8e:	cmp	r2, #229	; 0xe5
    ad90:	beq.n	ae08 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
    ad92:	cmp	r2, #0
    ad94:	beq.n	ae08 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
      if (dir->name[0] == FAT_NAME_FREE) {
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    ad96:	cmp	r4, r8
    ad98:	it	cc
    ad9a:	movcc	r4, #0
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    ad9c:	cmp	r2, #46	; 0x2e
    ad9e:	beq.n	ae02 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    ada0:	ldrb	r1, [r3, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    ada2:	cmp	r1, #15
    ada4:	beq.n	ae24 <FatFile::open(FatFile*, fname_t*, int)+0xf8>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
    ada6:	and.w	r1, r1, #8
    adaa:	and.w	r2, r1, #255	; 0xff
    adae:	cbnz	r1, ae02 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (lfnOrd) {
    adb0:	cmp.w	r9, #0
    adb4:	bne.w	b078 <FatFile::open(FatFile*, fname_t*, int)+0x34c>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    adb8:	mov	r0, r3
    adba:	movs	r2, #11
    adbc:	ldr	r1, [sp, #16]
    adbe:	bl	fef0 <memcmp>
    adc2:	cmp	r0, #0
    adc4:	bne.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    adc6:	ldrb.w	r3, [fp]
    adca:	lsls	r0, r3, #31
    adcc:	bpl.w	b0a0 <FatFile::open(FatFile*, fname_t*, int)+0x374>
          goto found;
        }
        fnameFound = true;
    add0:	movs	r3, #1
    add2:	str	r3, [sp, #20]
    add4:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    add6:	ldr	r5, [pc, #732]	; (b0b4 <FatFile::open(FatFile*, fname_t*, int)+0x388>)
    add8:	add.w	r4, sl, #12
    addc:	umull	r4, r8, r5, r4
    ade0:	mov.w	r8, r8, lsr #2
    ade4:	add.w	r8, r8, #1
    ade8:	uxtb.w	r8, r8
    adec:	b.n	ad54 <FatFile::open(FatFile*, fname_t*, int)+0x28>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    adee:	ldr	r1, [sp, #12]
    adf0:	subs	r1, #1
    adf2:	uxtb	r1, r1
    adf4:	cmp	r2, r1
    adf6:	str	r1, [sp, #12]
    adf8:	bne.n	ae02 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    adfa:	ldrb	r2, [r3, #13]
    adfc:	ldr	r1, [sp, #24]
    adfe:	cmp	r1, r2
    ae00:	beq.n	ae3a <FatFile::open(FatFile*, fname_t*, int)+0x10e>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    ae02:	mov.w	r9, #0
    ae06:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    ae08:	cmp	r4, #0
    ae0a:	it	eq
    ae0c:	moveq	r7, r5
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    ae0e:	cmp	r4, r8
        freeFound++;
    ae10:	itt	cc
    ae12:	addcc	r4, #1
    ae14:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    ae16:	cmp	r2, #0
    ae18:	beq.n	aeac <FatFile::open(FatFile*, fname_t*, int)+0x180>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    ae1a:	cmp	r2, #229	; 0xe5
    ae1c:	bne.n	ad9c <FatFile::open(FatFile*, fname_t*, int)+0x70>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    ae1e:	mov.w	r9, #0
    ae22:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    ae24:	cmp.w	r9, #0
    ae28:	bne.n	adee <FatFile::open(FatFile*, fname_t*, int)+0xc2>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
    ae2a:	lsls	r5, r2, #25
    ae2c:	bpl.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    ae2e:	and.w	r9, r2, #31
        checksum = ldir->checksum;
    ae32:	ldrb	r2, [r3, #13]
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    ae34:	str.w	r9, [sp, #12]
        checksum = ldir->checksum;
    ae38:	str	r2, [sp, #24]
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    ae3a:	ldr	r2, [sp, #12]
    ae3c:	subs	r2, #1
    ae3e:	add.w	r5, r2, r2, lsl #1
    ae42:	add.w	r5, r2, r5, lsl #2
      if (k >= len) {
    ae46:	cmp	sl, r5
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    ae48:	mov	r2, r5
      if (k >= len) {
    ae4a:	bls.n	ae02 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    ae4c:	add.w	r1, r5, #13
    ae50:	str.w	r9, [sp, #32]
    ae54:	mov	r9, r1
    ae56:	b.n	ae80 <FatFile::open(FatFile*, fname_t*, int)+0x154>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    ae58:	ldr.w	r0, [fp, #8]
    ae5c:	ldrb	r2, [r0, r2]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    ae5e:	cmp.w	ip, #25
    ae62:	it	ls
    ae64:	addls	r1, #32
    ae66:	sub.w	r0, r2, #65	; 0x41
    ae6a:	it	ls
    ae6c:	uxtbls	r1, r1
    ae6e:	cmp	r0, #25
    ae70:	itt	ls
    ae72:	addls	r2, #32
    ae74:	uxtbls	r2, r2
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    ae76:	cmp	r1, r2
    ae78:	bne.n	ae02 <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    ae7a:	cmp	lr, r9
    ae7c:	beq.n	af04 <FatFile::open(FatFile*, fname_t*, int)+0x1d8>
    ae7e:	mov	r2, lr
        uint16_t u = lfnGetChar(ldir, i);
    ae80:	subs	r1, r2, r5
    ae82:	uxtb	r1, r1
    ae84:	mov	r0, r3
    ae86:	bl	a6dc <lfnGetChar(DirLfn_t*, unsigned char)>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    ae8a:	uxtb	r1, r0
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    ae8c:	cmp	sl, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    ae8e:	sub.w	ip, r1, #65	; 0x41
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    ae92:	add.w	lr, r2, #1
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    ae96:	beq.w	b06a <FatFile::open(FatFile*, fname_t*, int)+0x33e>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    ae9a:	cmp	r0, #255	; 0xff
    ae9c:	bls.n	ae58 <FatFile::open(FatFile*, fname_t*, int)+0x12c>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    ae9e:	mov.w	r9, #0
    aea2:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
    aea4:	ldrb	r3, [r6, #1]
    aea6:	cmp	r3, #0
    aea8:	bne.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    aeac:	ldr	r2, [sp, #28]
    aeae:	mov	r3, r2
    aeb0:	lsls	r2, r3, #22
    aeb2:	bpl.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    aeb6:	and.w	r3, r3, #3
    aeba:	subs	r3, #1
    aebc:	cmp	r3, #1
    aebe:	bhi.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    aec2:	cmp	r4, #0
    aec4:	it	eq
    aec6:	moveq	r7, r5
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    aec8:	cmp	r4, r8
    aeca:	bcc.n	aed4 <FatFile::open(FatFile*, fname_t*, int)+0x1a8>
    aecc:	b.n	af0a <FatFile::open(FatFile*, fname_t*, int)+0x1de>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    aece:	uxtb	r4, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    aed0:	cmp	r8, r4
    aed2:	bls.n	af0a <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    dir = dirFile->readDirCache();
    aed4:	movs	r1, #0
    aed6:	mov	r0, r6
    aed8:	bl	9aec <FatFile::readDirCache(bool)>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    aedc:	adds	r3, r4, #1
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
    aede:	cmp	r0, #0
    aee0:	bne.n	aece <FatFile::open(FatFile*, fname_t*, int)+0x1a2>
      if (dirFile->getError()) {
    aee2:	ldrb	r3, [r6, #1]
    aee4:	cbz	r3, aef0 <FatFile::open(FatFile*, fname_t*, int)+0x1c4>
    aee6:	b.n	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    aee8:	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
    aeea:	ldrb	r3, [r3, #4]
    aeec:	cmp	r3, #1
    aeee:	bhi.n	af0a <FatFile::open(FatFile*, fname_t*, int)+0x1de>
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    aef0:	cmp	r8, r4
    aef2:	bls.n	af0a <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    aef4:	mov	r0, r6
    aef6:	bl	9460 <FatFile::addDirCluster()>
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
    aefa:	adds	r4, #16
    aefc:	uxtb	r4, r4
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    aefe:	cmp	r0, #0
    af00:	bne.n	aee8 <FatFile::open(FatFile*, fname_t*, int)+0x1bc>
    af02:	b.n	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    af04:	ldr.w	r9, [sp, #32]
    af08:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    af0a:	ldr	r3, [sp, #20]
    af0c:	cbz	r3, af1c <FatFile::open(FatFile*, fname_t*, int)+0x1f0>
    if (!dirFile->lfnUniqueSfn(fname)) {
    af0e:	mov	r1, fp
    af10:	mov	r0, r6
    af12:	bl	ac74 <FatFile::lfnUniqueSfn(fname_t*)>
    af16:	cmp	r0, #0
    af18:	beq.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    af1c:	lsls	r1, r7, #5
    af1e:	mov	r0, r6
    af20:	bl	9d5c <FatFile::seekSet(unsigned long)>
    af24:	cmp	r0, #0
    af26:	beq.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    af2a:	add.w	r8, r8, #4294967295
  for (order = lfnOrd ; order ; order--) {
    af2e:	ands.w	r9, r8, #255	; 0xff
    af32:	beq.n	afe8 <FatFile::open(FatFile*, fname_t*, int)+0x2bc>
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    af34:	orr.w	r4, r9, #64	; 0x40
    af38:	uxtb	r4, r4
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    af3a:	mov	r5, r9
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    af3c:	movs	r7, #0
    af3e:	movs	r1, #0
    af40:	mov	r0, r6
    af42:	bl	9aec <FatFile::readDirCache(bool)>
    if (!ldir) {
    af46:	cmp	r0, #0
    af48:	beq.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    af4c:	ldr	r2, [r6, #8]
    af4e:	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    af52:	cmp	r9, r5
    af54:	orr.w	r3, r3, #1
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    af58:	mov.w	ip, #15
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    af5c:	ite	ne
    af5e:	movne	r1, r5
    af60:	moveq	r1, r4
    af62:	strb.w	r3, [r2, #36]	; 0x24
    af66:	add.w	lr, fp, #12
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    af6a:	strb.w	ip, [r0, #11]
    ldir->mustBeZero1 = 0;
    af6e:	strb	r7, [r0, #12]
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    af70:	strb	r1, [r0, #0]
    af72:	add.w	ip, fp, #23
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    af76:	movs	r3, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    af78:	ldrb.w	r8, [lr, #1]!
    af7c:	lsrs	r2, r3, #1
    af7e:	orr.w	r3, r2, r3, lsl #7
    af82:	uxtab	r3, r8, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    af86:	cmp	lr, ip
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    af88:	uxtb	r3, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    af8a:	bne.n	af78 <FatFile::open(FatFile*, fname_t*, int)+0x24c>
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    af8c:	and.w	r1, r1, #31
    af90:	subs	r1, #1
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    af92:	strb	r3, [r0, #13]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    af94:	add.w	r2, r1, r1, lsl #1
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
    af98:	ldr.w	lr, [fp, #8]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    af9c:	strh	r7, [r0, #26]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    af9e:	add.w	r2, r1, r2, lsl #2
    afa2:	adds	r0, #4
  for (uint8_t i = 0; i < 13; i++, k++) {
    afa4:	movs	r3, #0
    afa6:	b.n	afc8 <FatFile::open(FatFile*, fname_t*, int)+0x29c>
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    afa8:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    afaa:	ldrb.w	r1, [lr, r2]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    afae:	bls.n	afda <FatFile::open(FatFile*, fname_t*, int)+0x2ae>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    afb0:	cmp	r3, #10
    afb2:	ite	ls
    afb4:	strhls	r1, [r0, #0]
    afb6:	strhhi	r1, [r0, #2]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    afb8:	adds	r3, #1
    afba:	uxtb	r3, r3
    afbc:	cmp	r3, #13
    afbe:	add.w	r2, r2, #1
    afc2:	add.w	r0, r0, #2
    afc6:	beq.n	afe0 <FatFile::open(FatFile*, fname_t*, int)+0x2b4>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    afc8:	cmp	sl, r2
    afca:	bhi.n	afa8 <FatFile::open(FatFile*, fname_t*, int)+0x27c>
    afcc:	ite	ne
    afce:	movne.w	r1, #4294967295
    afd2:	moveq	r1, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    afd4:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    afd6:	uxth	r1, r1
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    afd8:	bhi.n	afb0 <FatFile::open(FatFile*, fname_t*, int)+0x284>
    afda:	strh.w	r1, [r0, #-3]
    afde:	b.n	afb8 <FatFile::open(FatFile*, fname_t*, int)+0x28c>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    afe0:	subs	r5, #1
    afe2:	ands.w	r5, r5, #255	; 0xff
    afe6:	bne.n	af3e <FatFile::open(FatFile*, fname_t*, int)+0x212>
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
    afe8:	movs	r1, #0
    afea:	mov	r0, r6
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    afec:	ldr	r5, [r6, #20]
  dir = dirFile->readDirCache();
    afee:	bl	9aec <FatFile::readDirCache(bool)>
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    aff2:	ubfx	r5, r5, #5, #16
  dir = dirFile->readDirCache();
  if (!dir) {
    aff6:	mov	r4, r0
    aff8:	cmp	r0, #0
    affa:	beq.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    affe:	movs	r2, #32
    b000:	movs	r1, #0
    b002:	bl	1001c <memset>
  memcpy(dir->name, fname->sfn, 11);
    b006:	mov	r3, fp

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;

  // Set timestamps.
  if (FsDateTime::callback) {
    b008:	ldr	r2, [pc, #172]	; (b0b8 <FatFile::open(FatFile*, fname_t*, int)+0x38c>)
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);
    b00a:	ldr.w	r1, [r3, #13]!
    b00e:	ldr	r0, [r3, #4]
    b010:	str	r0, [r4, #4]
    b012:	str	r1, [r4, #0]
    b014:	ldrh	r1, [r3, #8]
    b016:	ldrb	r3, [r3, #10]
    b018:	strb	r3, [r4, #10]
    b01a:	strh	r1, [r4, #8]

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    b01c:	ldrb.w	r3, [fp]

  // Set timestamps.
  if (FsDateTime::callback) {
    b020:	ldr	r7, [r2, #0]
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    b022:	and.w	r3, r3, #24
    b026:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    b028:	cmp	r7, #0
    b02a:	beq.n	b0a8 <FatFile::open(FatFile*, fname_t*, int)+0x37c>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    b02c:	add.w	r2, sp, #43	; 0x2b
    b030:	add.w	r1, sp, #46	; 0x2e
    b034:	add	r0, sp, #44	; 0x2c
    b036:	blx	r7
    b038:	ldrh.w	r1, [sp, #44]	; 0x2c
    b03c:	ldrh.w	r2, [sp, #46]	; 0x2e
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    b040:	ldrb.w	r3, [sp, #43]	; 0x2b
    b044:	strh	r1, [r4, #16]
    b046:	strh	r2, [r4, #14]
    b048:	strb	r3, [r4, #13]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    b04a:	ldr	r2, [r6, #8]
    b04c:	ldrb.w	r3, [r2, #36]	; 0x24
    b050:	orr.w	r3, r3, #1
    b054:	strb.w	r3, [r2, #36]	; 0x24

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    b058:	str.w	r9, [sp]
    b05c:	ldr	r3, [sp, #28]
    b05e:	ldr	r0, [sp, #36]	; 0x24
    b060:	mov	r2, r5
    b062:	mov	r1, r6
    b064:	bl	9e0c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    b068:	b.n	ad40 <FatFile::open(FatFile*, fname_t*, int)+0x14>
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    b06a:	cmp	r0, #0
    b06c:	ldr.w	r9, [sp, #32]
    b070:	it	ne
    b072:	movne.w	r9, #0
    b076:	b.n	ad76 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    b078:	ldr	r1, [sp, #12]
    b07a:	cmp	r1, #1
    b07c:	bne.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b080:	subs	r4, r3, #1
    b082:	adds	r3, #10
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b084:	ldrb.w	r0, [r4, #1]!
    b088:	lsrs	r1, r2, #1
    b08a:	orr.w	r2, r1, r2, lsl #7
    b08e:	uxtab	r2, r0, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b092:	cmp	r4, r3
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b094:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b096:	bne.n	b084 <FatFile::open(FatFile*, fname_t*, int)+0x358>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    b098:	ldr	r3, [sp, #24]
    b09a:	cmp	r3, r2
    b09c:	bne.w	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    b0a0:	ldr	r3, [sp, #28]
    b0a2:	lsls	r1, r3, #20
    b0a4:	bpl.n	b058 <FatFile::open(FatFile*, fname_t*, int)+0x32c>
    b0a6:	b.n	ad3e <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b0a8:	movw	r3, #21025	; 0x5221
    b0ac:	strh	r3, [r4, #16]
    b0ae:	strh	r3, [r4, #24]
    b0b0:	strh	r3, [r4, #18]
    b0b2:	b.n	b04a <FatFile::open(FatFile*, fname_t*, int)+0x31e>
    b0b4:	.word	0x4ec4ec4f
    b0b8:	.word	0x200050e0

0000b0bc <FatFile::getSFN(char*)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name) {
    b0bc:	push	{r3, r4, r5, r6, r7, lr}
    b0be:	ldrb	r3, [r0, #0]
    b0c0:	mov	r5, r1
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t* dir;

  if (!isOpen()) {
    b0c2:	cbz	r3, b0d6 <FatFile::getSFN(char*)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    b0c4:	ands.w	r4, r3, #96	; 0x60
    b0c8:	beq.n	b0dc <FatFile::getSFN(char*)+0x20>
    name[0] = '/';
    b0ca:	movs	r2, #47	; 0x2f
    name[1] = '\0';
    b0cc:	movs	r3, #0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    name[0] = '/';
    b0ce:	strb	r2, [r1, #0]
    name[1] = '\0';
    b0d0:	strb	r3, [r1, #1]
    return 1;
    b0d2:	movs	r0, #1
    b0d4:	pop	{r3, r4, r5, r6, r7, pc}
  }
  name[j] = '\0';
  return j;

 fail:
  name[0] = '\0';
    b0d6:	movs	r0, #0
    b0d8:	strb	r0, [r5, #0]
  return 0;
}
    b0da:	pop	{r3, r4, r5, r6, r7, pc}
    name[0] = '/';
    name[1] = '\0';
    return 1;
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FsCache::CACHE_FOR_READ));
    b0dc:	mov	r1, r4
    b0de:	bl	94f8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    b0e2:	cmp	r0, #0
    b0e4:	beq.n	b0d6 <FatFile::getSFN(char*)+0x1a>
    b0e6:	mov	r1, r4
    b0e8:	mov	r3, r4
    b0ea:	movs	r7, #8
    b0ec:	subs	r4, r0, #1
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    b0ee:	mov.w	lr, #46	; 0x2e
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    b0f2:	ldrb.w	r2, [r4, #1]!
    b0f6:	cmp	r2, #32
    b0f8:	beq.n	b116 <FatFile::getSFN(char*)+0x5a>
      continue;
    }
    if (i == 8) {
    b0fa:	cmp	r1, #8
    b0fc:	beq.n	b124 <FatFile::getSFN(char*)+0x68>
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    }
    char c = dir->name[i];
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    b0fe:	sub.w	r6, r2, #65	; 0x41
    b102:	cmp	r6, #25
    b104:	bhi.n	b110 <FatFile::getSFN(char*)+0x54>
    b106:	ldrb	r6, [r0, #12]
    b108:	tst	r7, r6
      c += 'a' - 'A';
    b10a:	itt	ne
    b10c:	addne	r2, #32
    b10e:	uxtbne	r2, r2
    }
    name[j++] = c;
    b110:	strb	r2, [r5, r3]
    b112:	adds	r3, #1
    b114:	uxtb	r3, r3
    b116:	adds	r1, #1
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    b118:	cmp	r1, #11
    b11a:	bne.n	b0f2 <FatFile::getSFN(char*)+0x36>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = '\0';
    b11c:	movs	r2, #0
    b11e:	strb	r2, [r5, r3]
  return j;
    b120:	mov	r0, r3
    b122:	pop	{r3, r4, r5, r6, r7, pc}
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    b124:	strb.w	lr, [r5, r3]
    b128:	adds	r3, #1
    b12a:	uxtb	r3, r3
    b12c:	ldrb	r2, [r4, #0]
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
    b12e:	movs	r7, #16
    b130:	b.n	b0fe <FatFile::getSFN(char*)+0x42>
    b132:	nop

0000b134 <FatFile::printSFN(Print*)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::printSFN(print_t* pr) {
    b134:	push	{r4, lr}
    b136:	sub	sp, #16
    b138:	mov	r4, r1
  char name[13];
  if (!getSFN(name)) {
    b13a:	mov	r1, sp
    b13c:	bl	b0bc <FatFile::getSFN(char*)>
    b140:	cbz	r0, b154 <FatFile::printSFN(Print*)+0x20>
    b142:	mov	r0, sp
    b144:	bl	10680 <strlen>
    b148:	ldr	r3, [r4, #0]
    b14a:	mov	r2, r0
    b14c:	mov	r1, sp
    b14e:	ldr	r3, [r3, #4]
    b150:	mov	r0, r4
    b152:	blx	r3
  }
  return pr->write(name);

 fail:
  return 0;
}
    b154:	add	sp, #16
    b156:	pop	{r4, pc}

0000b158 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    b158:	push	{r3, r4, r5, r6, r7, lr}
    b15a:	movs	r5, #0
    b15c:	str	r5, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    b15e:	ldr	r4, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    b160:	str	r5, [r0, #60]	; 0x3c
    b162:	mov	r6, r0
    b164:	mov	r7, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    b166:	cbz	r4, b18c <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    b168:	mov	r1, r0
    b16a:	movs	r0, #36	; 0x24
    b16c:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    b170:	strb	r5, [r0, #0]
    b172:	strb	r5, [r0, #1]
    b174:	strb	r5, [r0, #2]
    b176:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    b178:	ldr	r5, [r7, #56]	; 0x38
    b17a:	mov	r4, r0
    b17c:	ldmia	r5!, {r0, r1, r2, r3}
    b17e:	stmia	r4!, {r0, r1, r2, r3}
    b180:	ldmia	r5!, {r0, r1, r2, r3}
    b182:	stmia	r4!, {r0, r1, r2, r3}
    b184:	ldr	r3, [r5, #0]
    b186:	str	r3, [r4, #0]
  } else if (from.m_xFile) {
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
}
    b188:	mov	r0, r6
    b18a:	pop	{r3, r4, r5, r6, r7, pc}
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    *m_fFile = *from.m_fFile;
  } else if (from.m_xFile) {
    b18c:	ldr	r3, [r1, #60]	; 0x3c
    b18e:	cmp	r3, #0
    b190:	beq.n	b188 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>
    m_xFile = new (m_fileMem) ExFatFile;
    b192:	mov	r1, r0
    b194:	movs	r0, #56	; 0x38
    b196:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
    b19a:	strb.w	r4, [r0, #49]	; 0x31
    b19e:	strb.w	r4, [r0, #50]	; 0x32
    b1a2:	strb.w	r4, [r0, #51]	; 0x33
    b1a6:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    b1a8:	ldr	r3, [r7, #60]	; 0x3c
    b1aa:	mov	r2, r0
    b1ac:	add.w	r1, r3, #48	; 0x30
    b1b0:	ldr	r5, [r3, #0]
    b1b2:	ldr	r4, [r3, #4]
    b1b4:	ldr	r0, [r3, #8]
    b1b6:	ldr	r7, [r3, #12]
    b1b8:	str	r7, [r2, #12]
    b1ba:	adds	r3, #16
    b1bc:	cmp	r3, r1
    b1be:	str	r5, [r2, #0]
    b1c0:	str	r4, [r2, #4]
    b1c2:	str	r0, [r2, #8]
    b1c4:	add.w	r2, r2, #16
    b1c8:	bne.n	b1b0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x58>
    b1ca:	ldr	r3, [r3, #0]
    b1cc:	str	r3, [r2, #0]
    b1ce:	b.n	b188 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>

0000b1d0 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    b1d0:	push	{r4, lr}
    b1d2:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    b1d4:	ldr	r0, [r0, #56]	; 0x38
    b1d6:	cbz	r0, b1e4 <FsBaseFile::close()+0x14>
    b1d8:	bl	95ac <FatFile::close()>
    b1dc:	cbz	r0, b1e4 <FsBaseFile::close()+0x14>
    m_fFile = nullptr;
    b1de:	movs	r3, #0
    b1e0:	str	r3, [r4, #56]	; 0x38
    return true;
    b1e2:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    b1e4:	ldr	r0, [r4, #60]	; 0x3c
    b1e6:	cbz	r0, b1f4 <FsBaseFile::close()+0x24>
    b1e8:	bl	7920 <ExFatFile::close()>
    b1ec:	cbz	r0, b1f4 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    b1ee:	movs	r3, #0
    b1f0:	str	r3, [r4, #60]	; 0x3c
    b1f2:	pop	{r4, pc}
    return true;
  }
  return false;
    b1f4:	movs	r0, #0
}
    b1f6:	pop	{r4, pc}

0000b1f8 <FsBaseFile::open(FsVolume*, char const*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    b1f8:	cbz	r1, b26e <FsBaseFile::open(FsVolume*, char const*, int)+0x76>
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    b1fa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b1fe:	mov	r4, r1
    b200:	mov	r5, r0
    b202:	mov	r8, r3
    b204:	mov	r7, r2
  if (!vol) {
    return false;
  }
  close();
    b206:	bl	b1d0 <FsBaseFile::close()>
  if (vol->m_fVol) {
    b20a:	ldr.w	r6, [r4, #1152]	; 0x480
    b20e:	cbz	r6, b23c <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    b210:	mov	r1, r5
    b212:	movs	r0, #36	; 0x24
    b214:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
    b218:	movs	r1, #0
    b21a:	strb	r1, [r0, #0]
    b21c:	strb	r1, [r0, #1]
    b21e:	strb	r1, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    b220:	ldr.w	r1, [r4, #1152]	; 0x480
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    b224:	str	r0, [r5, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    b226:	mov	r3, r8
    b228:	mov	r2, r7
    b22a:	bl	9904 <FatFile::open(FatVolume*, char const*, int)>
    b22e:	cbz	r0, b236 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    b230:	movs	r0, #1
    b232:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
    b236:	str	r0, [r5, #56]	; 0x38
    b238:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (vol->m_xVol) {
    b23c:	ldr.w	r3, [r4, #1156]	; 0x484
    b240:	cbz	r3, b272 <FsBaseFile::open(FsVolume*, char const*, int)+0x7a>
    m_xFile = new (m_fileMem) ExFatFile;
    b242:	mov	r1, r5
    b244:	movs	r0, #56	; 0x38
    b246:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
    b24a:	strb.w	r6, [r0, #49]	; 0x31
    b24e:	strb.w	r6, [r0, #50]	; 0x32
    b252:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    b256:	ldr.w	r1, [r4, #1156]	; 0x484
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    b25a:	str	r0, [r5, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    b25c:	mov	r3, r8
    b25e:	mov	r2, r7
    b260:	bl	82a4 <ExFatFile::open(ExFatVolume*, char const*, int)>
    b264:	cmp	r0, #0
    b266:	bne.n	b230 <FsBaseFile::open(FsVolume*, char const*, int)+0x38>
      return true;
    }
    m_xFile = nullptr;
    b268:	str	r0, [r5, #60]	; 0x3c
  }
  return false;
}
    b26a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    b26e:	movs	r0, #0
      return true;
    }
    m_xFile = nullptr;
  }
  return false;
}
    b270:	bx	lr
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    b272:	movs	r0, #0
    b274:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000b278 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    b278:	push	{r3, r4, r5, r6, r7, lr}
    b27a:	mov	r5, r1
    b27c:	mov	r7, r2
    b27e:	mov	r4, r0
  close();
    b280:	bl	b1d0 <FsBaseFile::close()>
  if (dir->m_fFile) {
    b284:	ldr	r6, [r5, #56]	; 0x38
    b286:	cbz	r6, b2ac <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    b288:	mov	r1, r4
    b28a:	movs	r0, #36	; 0x24
    b28c:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
    b290:	movs	r2, #0
    b292:	strb	r2, [r0, #0]
    b294:	strb	r2, [r0, #1]
    b296:	strb	r2, [r0, #2]
    b298:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    b29a:	mov	r2, r7
    b29c:	ldr	r1, [r5, #56]	; 0x38
    b29e:	bl	9ee4 <FatFile::openNext(FatFile*, int)>
    b2a2:	cbz	r0, b2a8 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    b2a4:	movs	r0, #1
    b2a6:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    b2a8:	str	r0, [r4, #56]	; 0x38
    b2aa:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    b2ac:	ldr	r0, [r5, #60]	; 0x3c
    b2ae:	cbz	r0, b2d4 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    b2b0:	mov	r1, r4
    b2b2:	movs	r0, #56	; 0x38
    b2b4:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
    b2b8:	strb.w	r6, [r0, #49]	; 0x31
    b2bc:	strb.w	r6, [r0, #50]	; 0x32
    b2c0:	strb.w	r6, [r0, #51]	; 0x33
    b2c4:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    b2c6:	mov	r2, r7
    b2c8:	ldr	r1, [r5, #60]	; 0x3c
    b2ca:	bl	82b4 <ExFatFile::openNext(ExFatFile*, int)>
    b2ce:	cmp	r0, #0
    b2d0:	bne.n	b2a4 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    b2d2:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    b2d4:	pop	{r3, r4, r5, r6, r7, pc}
    b2d6:	nop

0000b2d8 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    b2d8:	push	{r4, r5, r6, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    b2da:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    b2dc:	mov	r4, r0
  m_blockDev = blockDev;
    b2de:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    b2e2:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    b2e6:	mov	r1, r0
    b2e8:	mov.w	r0, #1152	; 0x480
    b2ec:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    b2f0:	strb.w	r6, [r0, #1092]	; 0x444
    b2f4:	strb.w	r6, [r0, #1145]	; 0x479
    b2f8:	strb.w	r6, [r0, #1146]	; 0x47a
    b2fc:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    b300:	movs	r2, #1
    b302:	ldr.w	r1, [r4, #1160]	; 0x488
    b306:	str.w	r0, [r4, #1156]	; 0x484
    b30a:	mov	r5, r0
    b30c:	bl	88f8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    b310:	cbnz	r0, b34e <FsVolume::begin(BlockDeviceInterface*)+0x76>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    b312:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    b314:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    b316:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    b31a:	mov.w	r0, #1128	; 0x468
    b31e:	bl	b3c8 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    b322:	strb	r6, [r0, #7]
    b324:	strb.w	r6, [r0, #1092]	; 0x444
    b328:	strb.w	r6, [r0, #1093]	; 0x445
    b32c:	strb.w	r6, [r0, #1094]	; 0x446
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    b330:	movs	r2, #1
    b332:	ldr.w	r1, [r4, #1160]	; 0x488
    b336:	str.w	r0, [r4, #1152]	; 0x480
    b33a:	mov	r5, r0
    b33c:	bl	a5c0 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    b340:	cbnz	r0, b372 <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    b342:	ldr	r3, [pc, #80]	; (b394 <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
    b344:	movs	r0, #0
    b346:	str	r0, [r3, #0]
  m_fVol = nullptr;
    b348:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    b34c:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    b34e:	add.w	r6, r5, #1096	; 0x448
    b352:	mov	r0, r6
    b354:	bl	7920 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    b358:	mov	r1, r5
    b35a:	mov	r0, r6
    b35c:	bl	7a04 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    b360:	cmp	r0, #0
    b362:	beq.n	b312 <FsVolume::begin(BlockDeviceInterface*)+0x3a>
      return false;
    }
    if (setCwv || !m_cwv) {
    b364:	ldr	r3, [pc, #48]	; (b398 <FsVolume::begin(BlockDeviceInterface*)+0xc0>)
    b366:	ldr	r2, [r3, #0]
    b368:	cbz	r2, b390 <FsVolume::begin(BlockDeviceInterface*)+0xb8>
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    b36a:	ldr	r3, [pc, #40]	; (b394 <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
  return true;
    b36c:	movs	r0, #1
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    b36e:	str	r4, [r3, #0]
  return true;
    b370:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    b372:	addw	r6, r5, #1092	; 0x444
    b376:	mov	r0, r6
    b378:	bl	95ac <FatFile::close()>
    return m_vwd.openRoot(this);
    b37c:	mov	r1, r5
    b37e:	mov	r0, r6
    b380:	bl	9914 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    b384:	cmp	r0, #0
    b386:	beq.n	b342 <FsVolume::begin(BlockDeviceInterface*)+0x6a>
      return false;
    }
    if (setCwv || !m_cwv) {
    b388:	ldr	r3, [pc, #16]	; (b39c <FsVolume::begin(BlockDeviceInterface*)+0xc4>)
    b38a:	ldr	r2, [r3, #0]
    b38c:	cmp	r2, #0
    b38e:	bne.n	b36a <FsVolume::begin(BlockDeviceInterface*)+0x92>
      m_cwv = this;
    b390:	str	r5, [r3, #0]
    b392:	b.n	b36a <FsVolume::begin(BlockDeviceInterface*)+0x92>
    b394:	.word	0x200050ec
    b398:	.word	0x200050e4
    b39c:	.word	0x200050e8

0000b3a0 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    b3a0:	push	{r3, r4, r5, r6, r7, lr}
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    b3a2:	movs	r5, #0
    b3a4:	mov.w	r7, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    b3a8:	ldr	r6, [pc, #24]	; (b3c4 <FsVolume::open(char const*, int)+0x24>)
    b3aa:	str	r7, [r0, #8]
    b3ac:	mov	r4, r0
    b3ae:	strb	r5, [r0, #4]
    b3b0:	strb	r5, [r0, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    b3b2:	str	r5, [r0, #72]	; 0x48
    b3b4:	str	r5, [r0, #76]	; 0x4c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    b3b6:	str.w	r6, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    b3ba:	bl	b1f8 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    b3be:	mov	r0, r4
    b3c0:	pop	{r3, r4, r5, r6, r7, pc}
    b3c2:	nop
    b3c4:	.word	0x20000050

0000b3c8 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    b3c8:	mov	r0, r1
    b3ca:	bx	lr

0000b3cc <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    b3cc:	ldrb	r0, [r0, #19]
    b3ce:	bx	lr

0000b3d0 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    b3d0:	ldrb	r0, [r0, #21]
    b3d2:	bx	lr

0000b3d4 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    b3d4:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    b3d6:	ldr	r4, [r0, #0]
    b3d8:	ldr	r4, [r4, #16]
    b3da:	movs	r3, #1
    b3dc:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    b3de:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    b3e2:	bx	ip

0000b3e4 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    b3e4:	ldrb	r0, [r0, #22]
    b3e6:	bx	lr

0000b3e8 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    b3e8:	bx	lr
    b3ea:	nop

0000b3ec <SdSpiCard::~SdSpiCard()>:
    b3ec:	push	{r4, lr}
    b3ee:	movs	r1, #24
    b3f0:	mov	r4, r0
    b3f2:	bl	ea80 <operator delete(void*, unsigned int)>
    b3f6:	mov	r0, r4
    b3f8:	pop	{r4, pc}
    b3fa:	nop

0000b3fc <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>:
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    b3fc:	push	{r4, lr}
    b3fe:	mov	r4, r0
  bool waitNotBusy(SdMillis_t timeoutMS);
  bool writeData(uint8_t token, const uint8_t* src);

#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
    b400:	adds	r0, #4
    b402:	bl	ce20 <SdSpiArduinoDriver::activate()>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    b406:	ldrb	r0, [r4, #18]
    b408:	movs	r1, #0
    b40a:	bl	cfd0 <sdCsWrite(unsigned char, bool)>
  if (!m_spiActive) {
    spiActivate();
    spiSelect();
    m_spiActive = true;
    b40e:	movs	r3, #1
    b410:	strb	r3, [r4, #20]
    b412:	pop	{r4, pc}

0000b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    b414:	push	{r3, r4, r5, lr}
    b416:	mov	r4, r0
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b418:	movs	r1, #1
    b41a:	ldrb	r0, [r0, #18]
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b41c:	adds	r5, r4, #4
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b41e:	bl	cfd0 <sdCsWrite(unsigned char, bool)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b422:	mov	r0, r5
    b424:	movs	r1, #255	; 0xff
    b426:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
    b42a:	mov	r0, r5
    b42c:	bl	cee8 <SdSpiArduinoDriver::deactivate()>
  if (m_spiActive) {
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
    b430:	movs	r3, #0
    b432:	strb	r3, [r4, #20]
    b434:	pop	{r3, r4, r5, pc}
    b436:	nop

0000b438 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    b438:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b43c:	mov	r6, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b43e:	ldrb	r1, [r0, #16]
    b440:	cmp	r1, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    b442:	mov	r5, r0
    b444:	mov	r4, r2
    b446:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b448:	beq.n	b48e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x56>
    if (!writeStart(sector)) {
    b44a:	ldr	r3, [r5, #0]
    b44c:	mov	r1, r6
    b44e:	ldr	r3, [r3, #72]	; 0x48
    b450:	mov	r0, r5
    b452:	blx	r3
    b454:	cbz	r0, b47a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    b456:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    b458:	str	r6, [r5, #12]
    m_curState = WRITE_STATE;
    b45a:	strb	r3, [r5, #16]
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    b45c:	movs	r6, #0
    b45e:	cbnz	r7, b466 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2e>
    b460:	b.n	b496 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    b462:	cmp	r7, r6
    b464:	beq.n	b496 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    if (!writeData(src)) {
    b466:	ldr	r3, [r5, #0]
    b468:	mov	r1, r4
    b46a:	ldr	r3, [r3, #68]	; 0x44
    b46c:	mov	r0, r5
    b46e:	blx	r3
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    b470:	adds	r6, #1
    b472:	add.w	r4, r4, #512	; 0x200
    if (!writeData(src)) {
    b476:	cmp	r0, #0
    b478:	bne.n	b462 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b47a:	ldrb	r0, [r5, #20]
    b47c:	cbnz	r0, b482 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    b47e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b482:	mov	r0, r5
    b484:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
    b488:	movs	r0, #0
}
    b48a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b48e:	ldr	r3, [r0, #12]
    b490:	cmp	r3, r6
    b492:	bne.n	b44a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x12>
    b494:	b.n	b45c <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x24>
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    b496:	ldr	r3, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    b498:	ldrb	r2, [r5, #17]
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    b49a:	add	r7, r3
    b49c:	str	r7, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    b49e:	cbnz	r2, b4a6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6e>
    b4a0:	movs	r0, #1
    b4a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b4a6:	ldr	r3, [r5, #0]
    b4a8:	mov	r0, r5
    b4aa:	ldr	r3, [r3, #24]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    b4ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    b4b0:	bx	r3
    b4b2:	nop

0000b4b4 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    b4b4:	push	{r3, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    b4b6:	ldrb	r3, [r0, #16]
    b4b8:	cmp	r3, #1
    b4ba:	beq.n	b4fe <SdSpiCard::isBusy()+0x4a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
  bool spiActive = m_spiActive;
    b4bc:	ldrb	r7, [r0, #20]
    b4be:	mov	r5, r0
  if (!spiActive) {
    b4c0:	cbz	r7, b4ee <SdSpiCard::isBusy()+0x3a>
    b4c2:	adds	r6, r5, #4
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    b4c4:	movs	r4, #8
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b4c6:	mov	r0, r6
    b4c8:	bl	cf20 <SdSpiArduinoDriver::receive()>
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
    b4cc:	cmp	r0, #255	; 0xff
    b4ce:	add.w	r3, r4, #4294967295
    b4d2:	beq.n	b4e6 <SdSpiCard::isBusy()+0x32>
  bool rtn = true;
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    b4d4:	ands.w	r4, r3, #255	; 0xff
    b4d8:	bne.n	b4c6 <SdSpiCard::isBusy()+0x12>
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
    b4da:	movs	r4, #1
    if (0XFF == spiReceive()) {
      rtn = false;
      break;
    }
  }
  if (!spiActive) {
    b4dc:	cbnz	r7, b4e2 <SdSpiCard::isBusy()+0x2e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b4de:	ldrb	r3, [r5, #20]
    b4e0:	cbnz	r3, b4f4 <SdSpiCard::isBusy()+0x40>
    }
  }
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    b4e2:	mov	r0, r4
}
    b4e4:	pop	{r3, r4, r5, r6, r7, pc}
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
      rtn = false;
    b4e6:	movs	r4, #0
      break;
    }
  }
  if (!spiActive) {
    b4e8:	cmp	r7, #0
    b4ea:	beq.n	b4de <SdSpiCard::isBusy()+0x2a>
    b4ec:	b.n	b4e2 <SdSpiCard::isBusy()+0x2e>
    b4ee:	bl	b3fc <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    b4f2:	b.n	b4c2 <SdSpiCard::isBusy()+0xe>
    b4f4:	mov	r0, r5
    b4f6:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    spiStop();
  }
  return rtn;
    b4fa:	mov	r0, r4
    b4fc:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    b4fe:	movs	r0, #0
    b500:	pop	{r3, r4, r5, r6, r7, pc}
    b502:	nop

0000b504 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    b504:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b508:	ldr	r6, [pc, #116]	; (b580 <SdSpiCard::readData(unsigned char*, unsigned int)+0x7c>)
    b50a:	sub	sp, #12
    b50c:	ldr	r3, [r6, #0]
    b50e:	str	r3, [sp, #0]
	return ret;
    b510:	ldr	r5, [sp, #0]
    b512:	mov	r4, r0
    b514:	mov	r8, r1
    b516:	mov	r9, r2

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    b518:	uxth	r5, r5
    b51a:	adds	r7, r0, #4
    b51c:	b.n	b52e <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b51e:	ldr	r3, [r6, #0]
    b520:	str	r3, [sp, #4]
	return ret;
    b522:	ldr	r3, [sp, #4]
    b524:	uxth	r3, r3
    b526:	subs	r3, r3, r5
    b528:	cmp.w	r3, #300	; 0x12c
    b52c:	bgt.n	b554 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
    b52e:	mov	r0, r7
    b530:	bl	cf20 <SdSpiArduinoDriver::receive()>
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    b534:	cmp	r0, #255	; 0xff
    b536:	strb	r0, [r4, #21]
    b538:	beq.n	b51e <SdSpiCard::readData(unsigned char*, unsigned int)+0x1a>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    b53a:	cmp	r0, #254	; 0xfe
    b53c:	beq.n	b55a <SdSpiCard::readData(unsigned char*, unsigned int)+0x56>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b53e:	movs	r3, #24
    b540:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b542:	ldrb	r0, [r4, #20]
    b544:	cbz	r0, b54e <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    b546:	mov	r0, r4
    b548:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
  return false;
    b54c:	movs	r0, #0
}
    b54e:	add	sp, #12
    b550:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    b554:	movs	r3, #29
    b556:	strb	r3, [r4, #19]
    b558:	b.n	b542 <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
    b55a:	mov	r2, r9
    b55c:	mov	r1, r8
    b55e:	mov	r0, r7
    b560:	bl	cf3c <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>
  if (m_status != DATA_START_SECTOR) {
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    b564:	strb	r0, [r4, #21]
    b566:	cbz	r0, b56e <SdSpiCard::readData(unsigned char*, unsigned int)+0x6a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b568:	movs	r3, #37	; 0x25
    b56a:	strb	r3, [r4, #19]
    b56c:	b.n	b542 <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b56e:	mov	r0, r7
    b570:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b574:	mov	r0, r7
    b576:	bl	cf20 <SdSpiArduinoDriver::receive()>
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
  spiReceive();
#endif  // USE_SD_CRC
  return true;
    b57a:	movs	r0, #1
    b57c:	b.n	b54e <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    b57e:	nop
    b580:	.word	0x20005150

0000b584 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    b584:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b586:	ldr	r5, [pc, #52]	; (b5bc <SdSpiCard::waitNotBusy(unsigned short)+0x38>)
    b588:	sub	sp, #12
    b58a:	ldr	r3, [r5, #0]
    b58c:	str	r3, [sp, #0]
	return ret;
    b58e:	ldr	r4, [sp, #0]
    b590:	mov	r7, r1
    b592:	adds	r6, r0, #4
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    b594:	uxth	r4, r4
    b596:	b.n	b5a6 <SdSpiCard::waitNotBusy(unsigned short)+0x22>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b598:	ldr	r3, [r5, #0]
    b59a:	str	r3, [sp, #4]
	return ret;
    b59c:	ldr	r3, [sp, #4]
    b59e:	uxth	r3, r3
    b5a0:	subs	r3, r3, r4
    b5a2:	cmp	r3, r7
    b5a4:	bgt.n	b5b6 <SdSpiCard::waitNotBusy(unsigned short)+0x32>
    b5a6:	mov	r0, r6
    b5a8:	bl	cf20 <SdSpiArduinoDriver::receive()>
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    b5ac:	cmp	r0, #255	; 0xff
    b5ae:	bne.n	b598 <SdSpiCard::waitNotBusy(unsigned short)+0x14>
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    }
  }
  return true;
    b5b0:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    b5b2:	add	sp, #12
    b5b4:	pop	{r4, r5, r6, r7, pc}
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    b5b6:	movs	r0, #0
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
    b5b8:	add	sp, #12
    b5ba:	pop	{r4, r5, r6, r7, pc}
    b5bc:	.word	0x20005150

0000b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    b5c0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b5c4:	sub	sp, #8
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    b5c6:	ldrb	r3, [r0, #16]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    b5c8:	str	r2, [sp, #4]
    b5ca:	mov	r4, r0
    b5cc:	mov	r7, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    b5ce:	cbnz	r3, b630 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x70>
    return 0XFF;
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    b5d0:	ldrb	r3, [r4, #20]
    b5d2:	cmp	r3, #0
    b5d4:	beq.n	b64e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x8e>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    b5d6:	cmp	r7, #0
    b5d8:	bne.n	b642 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x82>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b5da:	adds	r5, r4, #4
    b5dc:	mov	r0, r5
    b5de:	orr.w	r1, r7, #64	; 0x40
    b5e2:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
    b5e6:	add.w	r8, sp, #4
    b5ea:	add	r6, sp, #8
    b5ec:	ldrb.w	r1, [r6, #-1]!
    b5f0:	mov	r0, r5
    b5f2:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    b5f6:	cmp	r8, r6
    b5f8:	bne.n	b5ec <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2c>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    b5fa:	cmp	r7, #0
    b5fc:	ite	eq
    b5fe:	moveq	r1, #149	; 0x95
    b600:	movne	r1, #135	; 0x87
    b602:	mov	r0, r5
    b604:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b608:	mov	r0, r5
    b60a:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b60e:	movs	r6, #11
    b610:	mov	r0, r5
    b612:	bl	cf20 <SdSpiArduinoDriver::receive()>

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    b616:	lsls	r3, r0, #24
    b618:	strb	r0, [r4, #21]
    b61a:	bmi.n	b622 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x62>
  }
  return m_status;
}
    b61c:	add	sp, #8
    b61e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b622:	subs	r3, r6, #1

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    b624:	ands.w	r6, r3, #255	; 0xff
    b628:	bne.n	b610 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x50>
  }
  return m_status;
}
    b62a:	add	sp, #8
    b62c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    b630:	ldr	r3, [r0, #0]
    b632:	ldr	r3, [r3, #24]
    b634:	blx	r3
    b636:	cmp	r0, #0
    b638:	bne.n	b5d0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x10>
    return 0XFF;
    b63a:	movs	r0, #255	; 0xff

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
  }
  return m_status;
}
    b63c:	add	sp, #8
    b63e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    b642:	mov.w	r1, #300	; 0x12c
    b646:	mov	r0, r4
    b648:	bl	b584 <SdSpiCard::waitNotBusy(unsigned short)>
    b64c:	b.n	b5da <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x1a>
    b64e:	mov	r0, r4
    b650:	bl	b3fc <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    b654:	b.n	b5d6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x16>
    b656:	nop

0000b658 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    b658:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b65c:	sub	sp, #40	; 0x28
    b65e:	add	r5, sp, #4
    b660:	stmia.w	r5, {r1, r2, r3}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b664:	ldr	r7, [pc, #492]	; (b854 <SdSpiCard::begin(SdSpiConfig)+0x1fc>)
    b666:	ldrb.w	r3, [sp, #4]
    b66a:	ldr	r2, [r7, #0]
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
  m_errorCode = SD_CARD_ERROR_NONE;
  m_type = 0;
  m_csPin = spiConfig.csPin;
    b66c:	strb	r3, [r0, #18]
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    b66e:	mov	r6, r0
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    b670:	mov.w	sl, #0
    b674:	str	r2, [sp, #20]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    b676:	mov	r0, r3
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    b678:	strb.w	sl, [r6, #20]
  m_errorCode = SD_CARD_ERROR_NONE;
    b67c:	strb.w	sl, [r6, #19]
  m_type = 0;
    b680:	strb.w	sl, [r6, #22]
    b684:	ldrb.w	r4, [sp, #5]
	return ret;
    b688:	ldr.w	r8, [sp, #20]
    b68c:	ldr.w	r9, [sp, #8]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    b690:	bl	cfc8 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b694:	ldrb	r0, [r6, #18]
    b696:	movs	r1, #1
    b698:	bl	cfd0 <sdCsWrite(unsigned char, bool)>
    b69c:	ldmia.w	r5, {r0, r1, r2}
    b6a0:	add	r3, sp, #28
    b6a2:	stmia.w	r3, {r0, r1, r2}
#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
    b6a6:	adds	r5, r6, #4
  /** Save high speed SPISettings after SD initialization.
   *
   * \param[in] maxSck Maximum SCK frequency.
   */
  void setSckSpeed(uint32_t maxSck) {
    m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0);
    b6a8:	ldr	r2, [pc, #428]	; (b858 <SdSpiCard::begin(SdSpiConfig)+0x200>)
    b6aa:	str	r2, [r6, #8]
    b6ac:	mov	r0, r5
    b6ae:	ldmia	r3, {r1, r2, r3}
    b6b0:	bl	ce98 <SdSpiArduinoDriver::begin(SdSpiConfig)>
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    b6b4:	and.w	r3, r4, #1
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    b6b8:	ldrb	r2, [r6, #20]
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    b6ba:	strb.w	sl, [r6, #16]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    b6be:	eor.w	r3, r3, #1
    b6c2:	strb	r3, [r6, #17]
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    b6c4:	cmp	r2, #0
    b6c6:	beq.w	b7e0 <SdSpiCard::begin(SdSpiConfig)+0x188>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b6ca:	movs	r1, #1
    b6cc:	ldrb	r0, [r6, #18]
    b6ce:	bl	cfd0 <sdCsWrite(unsigned char, bool)>
    b6d2:	movs	r4, #10
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b6d4:	movs	r1, #255	; 0xff
    b6d6:	mov	r0, r5
    b6d8:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
    b6dc:	subs	r3, r4, #1
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    b6de:	ands.w	r4, r3, #255	; 0xff
    b6e2:	bne.n	b6d4 <SdSpiCard::begin(SdSpiConfig)+0x7c>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    b6e4:	mov	r1, r4
    b6e6:	ldrb	r0, [r6, #18]
    b6e8:	bl	cfd0 <sdCsWrite(unsigned char, bool)>
    b6ec:	mov.w	sl, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    b6f0:	movs	r2, #0
    b6f2:	mov	r1, r2
    b6f4:	mov	r0, r6
    b6f6:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b6fa:	cmp	r0, #1
    b6fc:	mov	r4, r0
    b6fe:	beq.n	b73e <SdSpiCard::begin(SdSpiConfig)+0xe6>
    b700:	add.w	r3, sl, #4294967295
      break;
    }
    if (i == SD_CMD0_RETRY) {
    b704:	ands.w	sl, r3, #255	; 0xff
    b708:	beq.n	b722 <SdSpiCard::begin(SdSpiConfig)+0xca>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b70a:	movs	r1, #253	; 0xfd
    b70c:	mov	r0, r5
    b70e:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
    b712:	mov.w	r4, #520	; 0x208
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b716:	mov	r0, r5
    b718:	bl	cf20 <SdSpiArduinoDriver::receive()>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    b71c:	subs	r4, #1
    b71e:	bne.n	b716 <SdSpiCard::begin(SdSpiConfig)+0xbe>
    b720:	b.n	b6f0 <SdSpiCard::begin(SdSpiConfig)+0x98>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b722:	movs	r3, #1
    b724:	strb	r3, [r6, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b726:	ldrb	r0, [r6, #20]
    b728:	cbnz	r0, b730 <SdSpiCard::begin(SdSpiConfig)+0xd8>
  return true;

 fail:
  spiStop();
  return false;
}
    b72a:	add	sp, #40	; 0x28
    b72c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b730:	mov	r0, r6
    b732:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
  return false;
    b736:	movs	r0, #0
}
    b738:	add	sp, #40	; 0x28
    b73a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    b73e:	mov.w	r2, #426	; 0x1aa
    b742:	movs	r1, #8
    b744:	mov	r0, r6
    b746:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b74a:	lsls	r3, r0, #29
    b74c:	bpl.n	b7e8 <SdSpiCard::begin(SdSpiConfig)+0x190>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    b74e:	strb	r4, [r6, #22]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    b750:	ldr	r3, [r6, #0]
    b752:	ldr.w	sl, [pc, #276]	; b868 <SdSpiCard::begin(SdSpiConfig)+0x210>
    b756:	ldr	r3, [r3, #64]	; 0x40
    b758:	cmp	r3, sl
    b75a:	bne.n	b80e <SdSpiCard::begin(SdSpiConfig)+0x1b6>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    b75c:	ldrb	r0, [r6, #22]
    b75e:	cmp	r0, #2
    b760:	ite	eq
    b762:	moveq.w	r4, #1073741824	; 0x40000000
    b766:	movne	r4, #0
    b768:	b.n	b77a <SdSpiCard::begin(SdSpiConfig)+0x122>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b76a:	ldr	r3, [r7, #0]
    b76c:	str	r3, [sp, #24]
	return ret;
    b76e:	ldr	r3, [sp, #24]
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    b770:	uxth	r3, r3
    b772:	subs	r3, r3, r2
    b774:	cmp.w	r3, #2000	; 0x7d0
    b778:	bgt.n	b808 <SdSpiCard::begin(SdSpiConfig)+0x1b0>
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    b77a:	movs	r2, #0
    b77c:	movs	r1, #55	; 0x37
    b77e:	mov	r0, r6
    b780:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    b784:	mov	r2, r4
    b786:	movs	r1, #41	; 0x29
    b788:	mov	r0, r6
    b78a:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b78e:	uxth.w	r2, r8
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    b792:	cmp	r0, #0
    b794:	bne.n	b76a <SdSpiCard::begin(SdSpiConfig)+0x112>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    b796:	ldr	r3, [r6, #0]
    b798:	ldr	r3, [r3, #64]	; 0x40
    b79a:	cmp	r3, sl
    b79c:	bne.n	b814 <SdSpiCard::begin(SdSpiConfig)+0x1bc>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    b79e:	ldrb	r0, [r6, #22]
    b7a0:	cmp	r0, #2
    b7a2:	beq.n	b81a <SdSpiCard::begin(SdSpiConfig)+0x1c2>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b7a4:	ldrb	r3, [r6, #20]
    b7a6:	cbz	r3, b7ae <SdSpiCard::begin(SdSpiConfig)+0x156>
    b7a8:	mov	r0, r6
    b7aa:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    b7ae:	ldr	r1, [pc, #172]	; (b85c <SdSpiCard::begin(SdSpiConfig)+0x204>)
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    b7b0:	ldr	r4, [pc, #172]	; (b860 <SdSpiCard::begin(SdSpiConfig)+0x208>)
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    b7b2:	movs	r3, #0
    b7b4:	b.n	b7bc <SdSpiCard::begin(SdSpiConfig)+0x164>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    b7b6:	cmp	r0, #23
    b7b8:	beq.n	b7cc <SdSpiCard::begin(SdSpiConfig)+0x174>
    b7ba:	mov	r3, r0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    b7bc:	ldrh.w	r2, [r1, #2]!
    b7c0:	sdiv	r2, r4, r2
    b7c4:	cmp	r9, r2
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    b7c6:	add.w	r0, r3, #1
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    b7ca:	bcc.n	b7b6 <SdSpiCard::begin(SdSpiConfig)+0x15e>
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    b7cc:	ldr	r2, [pc, #148]	; (b864 <SdSpiCard::begin(SdSpiConfig)+0x20c>)
    b7ce:	ldr.w	r3, [r2, r3, lsl #2]
      spiReceive();
    }
  }
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    b7d2:	movs	r0, #1
    b7d4:	orr.w	r3, r3, #939524096	; 0x38000000
    b7d8:	str	r3, [r6, #8]

 fail:
  spiStop();
  return false;
}
    b7da:	add	sp, #40	; 0x28
    b7dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b7e0:	mov	r0, r6
    b7e2:	bl	b3fc <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    b7e6:	b.n	b6ca <SdSpiCard::begin(SdSpiConfig)+0x72>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    b7e8:	movs	r3, #2
    b7ea:	strb	r3, [r6, #22]
    b7ec:	movs	r4, #4
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b7ee:	mov	r0, r5
    b7f0:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b7f4:	subs	r4, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    b7f6:	ands.w	r4, r4, #255	; 0xff
      m_status = spiReceive();
    b7fa:	strb	r0, [r6, #21]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    b7fc:	bne.n	b7ee <SdSpiCard::begin(SdSpiConfig)+0x196>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    b7fe:	cmp	r0, #170	; 0xaa
    b800:	beq.n	b750 <SdSpiCard::begin(SdSpiConfig)+0xf8>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b802:	movs	r3, #6
    b804:	strb	r3, [r6, #19]
    b806:	b.n	b726 <SdSpiCard::begin(SdSpiConfig)+0xce>
    b808:	movs	r3, #23
    b80a:	strb	r3, [r6, #19]
    b80c:	b.n	b726 <SdSpiCard::begin(SdSpiConfig)+0xce>
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    b80e:	mov	r0, r6
    b810:	blx	r3
    b812:	b.n	b75e <SdSpiCard::begin(SdSpiConfig)+0x106>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    b814:	mov	r0, r6
    b816:	blx	r3
    b818:	b.n	b7a0 <SdSpiCard::begin(SdSpiConfig)+0x148>
    if (cardCommand(CMD58, 0)) {
    b81a:	movs	r2, #0
    b81c:	movs	r1, #58	; 0x3a
    b81e:	mov	r0, r6
    b820:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b824:	cbz	r0, b82c <SdSpiCard::begin(SdSpiConfig)+0x1d4>
    b826:	movs	r3, #18
    b828:	strb	r3, [r6, #19]
    b82a:	b.n	b726 <SdSpiCard::begin(SdSpiConfig)+0xce>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b82c:	mov	r0, r5
    b82e:	bl	cf20 <SdSpiArduinoDriver::receive()>
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    b832:	and.w	r0, r0, #192	; 0xc0
    b836:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    b838:	itt	eq
    b83a:	moveq	r3, #3
    b83c:	strbeq	r3, [r6, #22]
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b83e:	mov	r0, r5
    b840:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b844:	mov	r0, r5
    b846:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b84a:	mov	r0, r5
    b84c:	bl	cf20 <SdSpiArduinoDriver::receive()>
    b850:	b.n	b7a4 <SdSpiCard::begin(SdSpiConfig)+0x14c>
    b852:	nop
    b854:	.word	0x20005150
    b858:	.word	0x38005006
    b85c:	.word	0x20000456
    b860:	.word	0x02dc6c00
    b864:	.word	0x2000051c
    b868:	.word	0x0000b3e5

0000b86c <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    b86c:	push	{r3, r4, r5, r6, r7, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    b86e:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    b870:	mov	r5, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    b872:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    b874:	mov	r6, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    b876:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b87a:	cbnz	r0, b898 <SdSpiCard::readOCR(unsigned long*)+0x2c>
    b87c:	adds	r7, r6, #4
    b87e:	adds	r4, r5, #4
    b880:	mov	r0, r7
    b882:	bl	cf20 <SdSpiArduinoDriver::receive()>
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    b886:	strb.w	r0, [r4, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    b88a:	cmp	r5, r4
    b88c:	bne.n	b880 <SdSpiCard::readOCR(unsigned long*)+0x14>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b88e:	ldrb	r4, [r6, #20]
    b890:	cbnz	r4, b8ae <SdSpiCard::readOCR(unsigned long*)+0x42>
    b892:	movs	r4, #1
  return true;

 fail:
  spiStop();
  return false;
}
    b894:	mov	r0, r4
    b896:	pop	{r3, r4, r5, r6, r7, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b898:	ldrb	r4, [r6, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b89a:	movs	r3, #18
    b89c:	strb	r3, [r6, #19]
    b89e:	cmp	r4, #0
    b8a0:	beq.n	b894 <SdSpiCard::readOCR(unsigned long*)+0x28>
    b8a2:	mov	r0, r6
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    b8a4:	movs	r4, #0
    b8a6:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    b8aa:	mov	r0, r4
    b8ac:	pop	{r3, r4, r5, r6, r7, pc}
    b8ae:	mov	r0, r6
    b8b0:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    b8b4:	mov	r0, r4
    b8b6:	pop	{r3, r4, r5, r6, r7, pc}

0000b8b8 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    b8b8:	push	{r3, r4, r5, lr}
    b8ba:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    b8bc:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    b8be:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    b8c0:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b8c4:	cbz	r0, b8d8 <SdSpiCard::readRegister(unsigned char, void*)+0x20>
    b8c6:	movs	r3, #27
    b8c8:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b8ca:	ldrb	r0, [r4, #20]
    b8cc:	cbz	r0, b8d6 <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    b8ce:	mov	r0, r4
    b8d0:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    b8d4:	movs	r0, #0
}
    b8d6:	pop	{r3, r4, r5, pc}
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    b8d8:	mov	r1, r5
    b8da:	movs	r2, #16
    b8dc:	mov	r0, r4
    b8de:	bl	b504 <SdSpiCard::readData(unsigned char*, unsigned int)>
    b8e2:	cmp	r0, #0
    b8e4:	beq.n	b8ca <SdSpiCard::readRegister(unsigned char, void*)+0x12>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b8e6:	ldrb	r5, [r4, #20]
    b8e8:	cmp	r5, #0
    b8ea:	beq.n	b8d6 <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    b8ec:	mov	r0, r4
    b8ee:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    b8f2:	mov	r0, r5
    b8f4:	pop	{r3, r4, r5, pc}
    b8f6:	nop

0000b8f8 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    b8f8:	mov	r2, r1
    b8fa:	movs	r1, #9
    b8fc:	b.w	b8b8 <SdSpiCard::readRegister(unsigned char, void*)>

0000b900 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    b900:	mov	r2, r1
    b902:	movs	r1, #10
    b904:	b.w	b8b8 <SdSpiCard::readRegister(unsigned char, void*)>

0000b908 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    b908:	push	{r4, r5, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    b90a:	ldr	r3, [r0, #0]
    b90c:	ldr	r2, [pc, #140]	; (b99c <SdSpiCard::sectorCount()+0x94>)
    b90e:	ldr	r3, [r3, #52]	; 0x34
    b910:	cmp	r3, r2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    b912:	sub	sp, #20
    b914:	bne.n	b976 <SdSpiCard::sectorCount()+0x6e>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    b916:	mov	r2, sp
    b918:	movs	r1, #9
    b91a:	bl	b8b8 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    b91e:	cbz	r0, b930 <SdSpiCard::sectorCount()+0x28>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    b920:	ldrb.w	r3, [sp]
    b924:	ands.w	r3, r3, #192	; 0xc0
    b928:	beq.n	b934 <SdSpiCard::sectorCount()+0x2c>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    b92a:	cmp	r3, #64	; 0x40
    b92c:	beq.n	b97c <SdSpiCard::sectorCount()+0x74>
    b92e:	movs	r0, #0
}
    b930:	add	sp, #20
    b932:	pop	{r4, r5, pc}
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    b934:	ldrb.w	r4, [sp, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    b938:	ldrb.w	r3, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    b93c:	ldrb.w	r2, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    b940:	ldrb.w	r0, [sp, #10]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    b944:	ldrb.w	r1, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    b948:	ldrb.w	r5, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    b94c:	and.w	r4, r4, #3
    b950:	lsls	r4, r4, #1
    b952:	lsls	r2, r2, #2
    b954:	and.w	r3, r3, #3
    b958:	orr.w	r0, r4, r0, lsr #7
    b95c:	and.w	r1, r1, #15
    b960:	orr.w	r3, r2, r3, lsl #10
    b964:	add	r0, r1
    b966:	orr.w	r3, r3, r5, lsr #6
    b96a:	adds	r3, #1
    b96c:	subs	r0, #7
    b96e:	lsl.w	r0, r3, r0
    b972:	add	sp, #20
    b974:	pop	{r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    b976:	mov	r1, sp
    b978:	blx	r3
    b97a:	b.n	b91e <SdSpiCard::sectorCount()+0x16>
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    b97c:	ldrb.w	r3, [sp, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    b980:	ldrb.w	r1, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    b984:	ldrb.w	r0, [sp, #8]
    b988:	adds	r2, r3, #1
    b98a:	and.w	r3, r1, #63	; 0x3f
    b98e:	add.w	r3, r2, r3, lsl #16
    b992:	add.w	r0, r3, r0, lsl #8
    b996:	lsls	r0, r0, #10
}
    b998:	add	sp, #20
    b99a:	pop	{r4, r5, pc}
    b99c:	.word	0x0000b8f9

0000b9a0 <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    b9a0:	push	{r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    b9a2:	ldr	r3, [r0, #0]
    b9a4:	ldr	r5, [pc, #68]	; (b9ec <SdSpiCard::readStart(unsigned long)+0x4c>)
    b9a6:	ldr	r3, [r3, #64]	; 0x40
    b9a8:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    b9aa:	sub	sp, #12
    b9ac:	mov	r4, r0
    b9ae:	mov	r2, r1
    b9b0:	bne.n	b9e2 <SdSpiCard::readStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    b9b2:	ldrb	r0, [r0, #22]
  if (type() != SD_CARD_TYPE_SDHC) {
    b9b4:	cmp	r0, #3
    sector <<= 9;
    b9b6:	it	ne
    b9b8:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD18, sector)) {
    b9ba:	movs	r1, #18
    b9bc:	mov	r0, r4
    b9be:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    b9c2:	cbz	r0, b9dc <SdSpiCard::readStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b9c4:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b9c6:	movs	r3, #12
    b9c8:	strb	r3, [r4, #19]
    b9ca:	cbnz	r0, b9d0 <SdSpiCard::readStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    b9cc:	add	sp, #12
    b9ce:	pop	{r4, r5, pc}
    b9d0:	mov	r0, r4
    b9d2:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    b9d6:	movs	r0, #0
    b9d8:	add	sp, #12
    b9da:	pop	{r4, r5, pc}
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
    b9dc:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    b9de:	add	sp, #12
    b9e0:	pop	{r4, r5, pc}
    b9e2:	str	r1, [sp, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
  if (type() != SD_CARD_TYPE_SDHC) {
    b9e4:	blx	r3
    b9e6:	ldr	r2, [sp, #4]
    b9e8:	b.n	b9b4 <SdSpiCard::readStart(unsigned long)+0x14>
    b9ea:	nop
    b9ec:	.word	0x0000b3e5

0000b9f0 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    b9f0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b9f4:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    b9f6:	ldrb	r1, [r0, #16]
    b9f8:	cmp	r1, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    b9fa:	mov	r6, r0
    b9fc:	mov	r4, r2
    b9fe:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    ba00:	beq.n	ba38 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    if (!readStart(sector)) {
    ba02:	mov	r1, r5
    ba04:	mov	r0, r6
    ba06:	bl	b9a0 <SdSpiCard::readStart(unsigned long)>
    ba0a:	cbz	r0, ba32 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    ba0c:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    ba0e:	str	r5, [r6, #12]
    m_curState = READ_STATE;
    ba10:	strb	r3, [r6, #16]
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    ba12:	movs	r5, #0
    ba14:	cbnz	r7, ba1c <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2c>
    ba16:	b.n	ba40 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    ba18:	cmp	r7, r5
    ba1a:	beq.n	ba40 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    if (!readData(dst, 512)) {
    ba1c:	mov	r1, r4
    ba1e:	mov.w	r2, #512	; 0x200
    ba22:	mov	r0, r6
    ba24:	bl	b504 <SdSpiCard::readData(unsigned char*, unsigned int)>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    ba28:	adds	r5, #1
    ba2a:	add.w	r4, r4, #512	; 0x200
    if (!readData(dst, 512)) {
    ba2e:	cmp	r0, #0
    ba30:	bne.n	ba18 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    ba32:	movs	r0, #0
    ba34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    ba38:	ldr	r3, [r0, #12]
    ba3a:	cmp	r3, r5
    ba3c:	bne.n	ba02 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x12>
    ba3e:	b.n	ba12 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    ba40:	ldr	r3, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    ba42:	ldrb	r2, [r6, #17]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    ba44:	add	r7, r3
    ba46:	str	r7, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    ba48:	cbnz	r2, ba50 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    ba4a:	movs	r0, #1
    ba4c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ba50:	ldr	r3, [r6, #0]
    ba52:	mov	r0, r6
    ba54:	ldr	r3, [r3, #24]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    ba56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    ba5a:	bx	r3

0000ba5c <SdSpiCard::readStop()>:
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    ba5c:	push	{r3, r4, r5, lr}
  if (cardCommand(CMD12, 0)) {
    ba5e:	movs	r2, #0
    ba60:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    ba62:	mov	r5, r0
  if (cardCommand(CMD12, 0)) {
    ba64:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    ba68:	ldrb	r4, [r5, #20]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    ba6a:	cbz	r0, ba76 <SdSpiCard::readStop()+0x1a>
    ba6c:	movs	r3, #9
    ba6e:	strb	r3, [r5, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    ba70:	cbnz	r4, ba88 <SdSpiCard::readStop()+0x2c>
  return true;

 fail:
  spiStop();
  return false;
}
    ba72:	mov	r0, r4
    ba74:	pop	{r3, r4, r5, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    ba76:	cbnz	r4, ba7e <SdSpiCard::readStop()+0x22>
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
  return true;
    ba78:	movs	r4, #1

 fail:
  spiStop();
  return false;
}
    ba7a:	mov	r0, r4
    ba7c:	pop	{r3, r4, r5, pc}
    ba7e:	mov	r0, r5
    ba80:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    ba84:	mov	r0, r4
    ba86:	pop	{r3, r4, r5, pc}
    ba88:	mov	r0, r5
    ba8a:	movs	r4, #0
    ba8c:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    ba90:	mov	r0, r4
    ba92:	pop	{r3, r4, r5, pc}

0000ba94 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    ba94:	ldrb	r2, [r0, #16]
  m_curState = IDLE_STATE;
    ba96:	movs	r1, #0
  if (state == WRITE_STATE) {
    ba98:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    ba9a:	strb	r1, [r0, #16]
  if (state == WRITE_STATE) {
    ba9c:	beq.n	baaa <SdSpiCard::syncDevice()+0x16>
    return writeStop();
  }
  if (state == READ_STATE) {
    ba9e:	cmp	r2, #1
    baa0:	beq.n	baa6 <SdSpiCard::syncDevice()+0x12>
    return readStop();
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    baa2:	movs	r0, #1
    baa4:	bx	lr
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
  }
  if (state == READ_STATE) {
    return readStop();
    baa6:	b.w	ba5c <SdSpiCard::readStop()>
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
    baaa:	ldr	r3, [r0, #0]
    baac:	ldr	r3, [r3, #76]	; 0x4c
    baae:	bx	r3

0000bab0 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    bab0:	push	{r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    bab2:	ldr	r3, [r0, #0]
    bab4:	ldr	r5, [pc, #68]	; (bafc <SdSpiCard::writeStart(unsigned long)+0x4c>)
    bab6:	ldr	r3, [r3, #64]	; 0x40
    bab8:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    baba:	sub	sp, #12
    babc:	mov	r4, r0
    babe:	mov	r2, r1
    bac0:	bne.n	baf2 <SdSpiCard::writeStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    bac2:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    bac4:	cmp	r0, #3
    sector <<= 9;
    bac6:	it	ne
    bac8:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD25, sector)) {
    baca:	movs	r1, #25
    bacc:	mov	r0, r4
    bace:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bad2:	cbz	r0, baec <SdSpiCard::writeStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bad4:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bad6:	movs	r3, #14
    bad8:	strb	r3, [r4, #19]
    bada:	cbnz	r0, bae0 <SdSpiCard::writeStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    badc:	add	sp, #12
    bade:	pop	{r4, r5, pc}
    bae0:	mov	r0, r4
    bae2:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bae6:	movs	r0, #0
    bae8:	add	sp, #12
    baea:	pop	{r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    baec:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    baee:	add	sp, #12
    baf0:	pop	{r4, r5, pc}
    baf2:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    baf4:	blx	r3
    baf6:	ldr	r2, [sp, #4]
    baf8:	b.n	bac4 <SdSpiCard::writeStart(unsigned long)+0x14>
    bafa:	nop
    bafc:	.word	0x0000b3e5

0000bb00 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    bb00:	push	{r4, r5, r6, r7, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    bb02:	ldr	r3, [r0, #0]
    bb04:	ldr	r7, [pc, #172]	; (bbb4 <SdSpiCard::erase(unsigned long, unsigned long)+0xb4>)
    bb06:	ldr	r3, [r3, #52]	; 0x34
    bb08:	cmp	r3, r7
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    bb0a:	sub	sp, #20
    bb0c:	mov	r4, r0
    bb0e:	mov	r5, r1
    bb10:	mov	r6, r2
    bb12:	bne.n	bb70 <SdSpiCard::erase(unsigned long, unsigned long)+0x70>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    bb14:	mov	r2, sp
    bb16:	movs	r1, #9
    bb18:	bl	b8b8 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  if (!readCSD(&csd)) {
    bb1c:	cbz	r0, bb44 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    bb1e:	ldrb.w	r3, [sp, #10]
    bb22:	lsls	r2, r3, #25
    bb24:	bpl.n	bb54 <SdSpiCard::erase(unsigned long, unsigned long)+0x54>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    bb26:	ldrb	r3, [r4, #22]
    bb28:	cmp	r3, #3
    firstSector <<= 9;
    bb2a:	it	ne
    bb2c:	lslne	r5, r5, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    bb2e:	mov	r2, r5
    bb30:	mov.w	r1, #32
    bb34:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    bb36:	it	ne
    bb38:	lslne	r6, r6, #9
  }
  if (cardCommand(CMD32, firstSector)
    bb3a:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    bb3e:	cbz	r0, bb76 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bb40:	movs	r3, #38	; 0x26
    bb42:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bb44:	ldrb	r0, [r4, #20]
    bb46:	cbz	r0, bb50 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bb48:	mov	r0, r4
    bb4a:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    bb4e:	movs	r0, #0
}
    bb50:	add	sp, #20
    bb52:	pop	{r4, r5, r6, r7, pc}
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    bb54:	and.w	r3, r3, #63	; 0x3f
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    bb58:	ldrb.w	r1, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    bb5c:	lsls	r3, r3, #1
    bb5e:	adds	r2, r6, #1
    bb60:	orr.w	r3, r3, r1, lsr #7
    bb64:	orrs	r2, r5
    bb66:	tst	r3, r2
    bb68:	beq.n	bb26 <SdSpiCard::erase(unsigned long, unsigned long)+0x26>
    bb6a:	movs	r3, #39	; 0x27
    bb6c:	strb	r3, [r4, #19]
    bb6e:	b.n	bb44 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
  csd_t csd;
  if (!readCSD(&csd)) {
    bb70:	mov	r1, sp
    bb72:	blx	r3
    bb74:	b.n	bb1c <SdSpiCard::erase(unsigned long, unsigned long)+0x1c>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    bb76:	mov	r2, r6
    bb78:	movs	r1, #33	; 0x21
    bb7a:	mov	r0, r4
    bb7c:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bb80:	cmp	r0, #0
    bb82:	bne.n	bb40 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
      || cardCommand(CMD38, 0)) {
    bb84:	mov	r2, r0
    bb86:	movs	r1, #38	; 0x26
    bb88:	mov	r0, r4
    bb8a:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bb8e:	cmp	r0, #0
    bb90:	bne.n	bb40 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    bb92:	movw	r1, #10000	; 0x2710
    bb96:	mov	r0, r4
    bb98:	bl	b584 <SdSpiCard::waitNotBusy(unsigned short)>
    bb9c:	cbnz	r0, bba4 <SdSpiCard::erase(unsigned long, unsigned long)+0xa4>
    bb9e:	movs	r3, #40	; 0x28
    bba0:	strb	r3, [r4, #19]
    bba2:	b.n	bb44 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bba4:	ldrb	r5, [r4, #20]
    bba6:	cmp	r5, #0
    bba8:	beq.n	bb50 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bbaa:	mov	r0, r4
    bbac:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;
    bbb0:	mov	r0, r5
    bbb2:	b.n	bb50 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bbb4:	.word	0x0000b8f9

0000bbb8 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    bbb8:	push	{r4, r5, r6, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bbba:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    bbbe:	mov	r5, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bbc0:	bl	b584 <SdSpiCard::waitNotBusy(unsigned short)>
    bbc4:	mov	r6, r0
    bbc6:	cbnz	r0, bbe0 <SdSpiCard::writeStop()+0x28>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bbc8:	ldrb	r4, [r5, #20]
    bbca:	movs	r3, #30
    bbcc:	strb	r3, [r5, #19]
    bbce:	cbnz	r4, bbd4 <SdSpiCard::writeStop()+0x1c>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    bbd0:	mov	r0, r4
    bbd2:	pop	{r4, r5, r6, pc}
    bbd4:	mov	r0, r5
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
    bbd6:	mov	r4, r6
    bbd8:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    bbdc:	mov	r0, r4
    bbde:	pop	{r4, r5, r6, pc}
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    bbe0:	movs	r1, #253	; 0xfd
    bbe2:	adds	r0, r5, #4
    bbe4:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bbe8:	ldrb	r4, [r5, #20]
    bbea:	cbnz	r4, bbf2 <SdSpiCard::writeStop()+0x3a>
    bbec:	mov	r4, r6

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    bbee:	mov	r0, r4
    bbf0:	pop	{r4, r5, r6, pc}
    bbf2:	mov	r0, r5
    bbf4:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bbf8:	b.n	bbd0 <SdSpiCard::writeStop()+0x18>
    bbfa:	nop

0000bbfc <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    bbfc:	push	{r4, r5, r6, lr}
    bbfe:	adds	r4, r0, #4
    bc00:	mov	r6, r2
    bc02:	mov	r5, r0
    bc04:	mov	r0, r4
    bc06:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver.send(buf, n);
    bc0a:	mov.w	r2, #512	; 0x200
    bc0e:	mov	r1, r6
    bc10:	mov	r0, r4
    bc12:	bl	cf74 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    bc16:	mov	r0, r4
    bc18:	movs	r1, #255	; 0xff
    bc1a:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
    bc1e:	mov	r0, r4
    bc20:	movs	r1, #255	; 0xff
    bc22:	bl	cf5c <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    bc26:	mov	r0, r4
    bc28:	bl	cf20 <SdSpiArduinoDriver::receive()>
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    bc2c:	and.w	r3, r0, #31
    bc30:	cmp	r3, #5
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    bc32:	strb	r0, [r5, #21]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    bc34:	beq.n	bc4a <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x4e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bc36:	ldrb	r0, [r5, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bc38:	movs	r3, #32
    bc3a:	strb	r3, [r5, #19]
    bc3c:	cbnz	r0, bc40 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x44>
  return true;

 fail:
  spiStop();
  return false;
}
    bc3e:	pop	{r4, r5, r6, pc}
    bc40:	mov	r0, r5
    bc42:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    bc46:	movs	r0, #0
    bc48:	pop	{r4, r5, r6, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    bc4a:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    bc4c:	pop	{r4, r5, r6, pc}
    bc4e:	nop

0000bc50 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    bc50:	push	{r3, r4, r5, lr}
    bc52:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bc54:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    bc58:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bc5a:	bl	b584 <SdSpiCard::waitNotBusy(unsigned short)>
    bc5e:	cbnz	r0, bc72 <SdSpiCard::writeData(unsigned char const*)+0x22>
    bc60:	movs	r3, #36	; 0x24
    bc62:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bc64:	ldrb	r0, [r4, #20]
    bc66:	cbz	r0, bc70 <SdSpiCard::writeData(unsigned char const*)+0x20>
    bc68:	mov	r0, r4
    bc6a:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    bc6e:	movs	r0, #0
}
    bc70:	pop	{r3, r4, r5, pc}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    bc72:	mov	r2, r5
    bc74:	movs	r1, #252	; 0xfc
    bc76:	mov	r0, r4
    bc78:	bl	bbfc <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    bc7c:	cmp	r0, #0
    bc7e:	beq.n	bc64 <SdSpiCard::writeData(unsigned char const*)+0x14>
  return true;

 fail:
  spiStop();
  return false;
}
    bc80:	pop	{r3, r4, r5, pc}
    bc82:	nop

0000bc84 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    bc84:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    bc86:	ldr	r3, [r0, #0]
    bc88:	ldr	r5, [pc, #88]	; (bce4 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x60>)
    bc8a:	ldr	r3, [r3, #64]	; 0x40
    bc8c:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    bc8e:	sub	sp, #8
    bc90:	mov	r4, r0
    bc92:	mov	r6, r2
    bc94:	bne.n	bcdc <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x58>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    bc96:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    bc98:	cmp	r0, #3
    sector <<= 9;
    bc9a:	it	ne
    bc9c:	lslne	r1, r1, #9
  }
  if (cardCommand(CMD24, sector)) {
    bc9e:	mov	r2, r1
    bca0:	mov	r0, r4
    bca2:	movs	r1, #24
    bca4:	bl	b5c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bca8:	cbz	r0, bcbe <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bcaa:	movs	r3, #13
    bcac:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bcae:	ldrb	r0, [r4, #20]
    bcb0:	cbz	r0, bcba <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    bcb2:	mov	r0, r4
    bcb4:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    bcb8:	movs	r0, #0
}
    bcba:	add	sp, #8
    bcbc:	pop	{r4, r5, r6, pc}
  }
  if (cardCommand(CMD24, sector)) {
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    bcbe:	mov	r2, r6
    bcc0:	movs	r1, #254	; 0xfe
    bcc2:	mov	r0, r4
    bcc4:	bl	bbfc <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    bcc8:	cmp	r0, #0
    bcca:	beq.n	bcae <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bccc:	ldrb	r5, [r4, #20]
    bcce:	cmp	r5, #0
    bcd0:	beq.n	bcba <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    bcd2:	mov	r0, r4
    bcd4:	bl	b414 <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bcd8:	mov	r0, r5
    bcda:	b.n	bcba <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    bcdc:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    bcde:	blx	r3
    bce0:	ldr	r1, [sp, #4]
    bce2:	b.n	bc98 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x14>
    bce4:	.word	0x0000b3e5

0000bce8 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    bce8:	push	{r4}
    if (m_sharedSpi) {
    bcea:	ldrb	r4, [r0, #17]
    bcec:	cbnz	r4, bcfc <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0x14>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    bcee:	ldr	r4, [r0, #0]
    bcf0:	ldr	r4, [r4, #32]
    bcf2:	movs	r3, #1
    bcf4:	mov	ip, r4
    }
  }
    bcf6:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    bcfa:	bx	ip
    }
  }
    bcfc:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    bd00:	b.w	bc84 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>

0000bd04 <sdIrs()>:
#endif  // USE_DEBUG_MODE
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
    bd04:	push	{r4}
  SDHC_IRQSIGEN = 0;
    bd06:	ldr	r4, [pc, #28]	; (bd24 <sdIrs()+0x20>)
  m_irqstat = SDHC_IRQSTAT;
    bd08:	ldr	r2, [pc, #28]	; (bd28 <sdIrs()+0x24>)
    bd0a:	ldr	r1, [pc, #32]	; (bd2c <sdIrs()+0x28>)
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    bd0c:	ldr	r0, [pc, #32]	; (bd30 <sdIrs()+0x2c>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    bd0e:	movs	r3, #0
    bd10:	str	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    bd12:	ldr	r4, [r2, #0]
    bd14:	str	r4, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    bd16:	ldr	r1, [r1, #0]
    bd18:	str	r1, [r2, #0]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
}
    bd1a:	ldr.w	r4, [sp], #4
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    bd1e:	strb	r3, [r0, #0]
}
    bd20:	bx	lr
    bd22:	nop
    bd24:	.word	0x400b1038
    bd28:	.word	0x400b1030
    bd2c:	.word	0x20005118
    bd30:	.word	0x20005130

0000bd34 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    bd34:	ldr	r3, [pc, #12]	; (bd44 <isBusyCommandComplete()+0x10>)
    bd36:	ldr	r0, [pc, #16]	; (bd48 <isBusyCommandComplete()+0x14>)
    bd38:	ldr	r3, [r3, #0]
    bd3a:	ands	r0, r3
}
    bd3c:	clz	r0, r0
    bd40:	lsrs	r0, r0, #5
    bd42:	bx	lr
    bd44:	.word	0x400b1030
    bd48:	.word	0x000f0001

0000bd4c <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    bd4c:	ldr	r3, [pc, #8]	; (bd58 <isBusyCommandInhibit()+0xc>)
    bd4e:	ldr	r0, [r3, #0]
}
    bd50:	and.w	r0, r0, #1
    bd54:	bx	lr
    bd56:	nop
    bd58:	.word	0x400b1024

0000bd5c <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    bd5c:	ldr	r3, [pc, #12]	; (bd6c <isBusyDat()+0x10>)
    bd5e:	ldr	r0, [r3, #0]
    bd60:	eor.w	r0, r0, #16777216	; 0x1000000
}
    bd64:	ubfx	r0, r0, #24, #1
    bd68:	bx	lr
    bd6a:	nop
    bd6c:	.word	0x400b1024

0000bd70 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    bd70:	ldr	r3, [pc, #4]	; (bd78 <isBusyDMA()+0x8>)
    bd72:	ldrb	r0, [r3, #0]
}
    bd74:	bx	lr
    bd76:	nop
    bd78:	.word	0x20005130

0000bd7c <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    bd7c:	ldr	r3, [pc, #12]	; (bd8c <isBusyFifoRead()+0x10>)
    bd7e:	ldr	r0, [r3, #0]
    bd80:	eor.w	r0, r0, #2048	; 0x800
}
    bd84:	ubfx	r0, r0, #11, #1
    bd88:	bx	lr
    bd8a:	nop
    bd8c:	.word	0x400b1024

0000bd90 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    bd90:	ldr	r3, [pc, #12]	; (bda0 <isBusyFifoWrite()+0x10>)
    bd92:	ldr	r0, [r3, #0]
    bd94:	eor.w	r0, r0, #1024	; 0x400
}
    bd98:	ubfx	r0, r0, #10, #1
    bd9c:	bx	lr
    bd9e:	nop
    bda0:	.word	0x400b1024

0000bda4 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    bda4:	ldr	r3, [pc, #12]	; (bdb4 <isBusyTransferComplete()+0x10>)
    bda6:	ldr	r0, [pc, #16]	; (bdb8 <isBusyTransferComplete()+0x14>)
    bda8:	ldr	r3, [r3, #0]
    bdaa:	ands	r0, r3
}
    bdac:	clz	r0, r0
    bdb0:	lsrs	r0, r0, #5
    bdb2:	bx	lr
    bdb4:	.word	0x400b1030
    bdb8:	.word	0x117f0002

0000bdbc <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    bdbc:	mov.w	r2, #1000	; 0x3e8
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    bdc0:	ldr	r3, [pc, #176]	; (be74 <setSdclk(unsigned long)+0xb8>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    bdc2:	mul.w	r0, r2, r0
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    bdc6:	cmp	r0, r3
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    bdc8:	push	{r4, r5, r6, r7}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    bdca:	bhi.n	be64 <setSdclk(unsigned long)+0xa8>
    bdcc:	ldr	r5, [pc, #168]	; (be78 <setSdclk(unsigned long)+0xbc>)
    bdce:	movs	r2, #8
    bdd0:	movs	r1, #1
    sdclkfs <<= 1;
    bdd2:	lsls	r1, r1, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    bdd4:	lsls	r3, r1, #4
    bdd6:	udiv	r3, r5, r3
    bdda:	cmp	r0, r3
    bddc:	ldr	r4, [pc, #152]	; (be78 <setSdclk(unsigned long)+0xbc>)
    bdde:	bcs.n	be5c <setSdclk(unsigned long)+0xa0>
    bde0:	subs	r2, #1
    bde2:	bne.n	bdd2 <setSdclk(unsigned long)+0x16>
    bde4:	udiv	r4, r4, r1
    bde8:	lsrs	r3, r1, #1
    bdea:	lsls	r7, r3, #8
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    bdec:	cmp	r0, r4
    bdee:	bcs.n	be6c <setSdclk(unsigned long)+0xb0>
    bdf0:	ldr	r6, [pc, #132]	; (be78 <setSdclk(unsigned long)+0xbc>)
    bdf2:	lsls	r3, r1, #1
    bdf4:	movs	r2, #1
    bdf6:	b.n	bdfa <setSdclk(unsigned long)+0x3e>
    bdf8:	mov	r3, r4
    bdfa:	udiv	r4, r6, r3
    bdfe:	cmp	r0, r4
    dvs++;
    be00:	add.w	r5, r2, #1
    be04:	add.w	r4, r3, r1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    be08:	bcs.n	be58 <setSdclk(unsigned long)+0x9c>
    be0a:	cmp	r5, #16
    be0c:	mov	r2, r5
    be0e:	bne.n	bdf8 <setSdclk(unsigned long)+0x3c>
    be10:	movs	r2, #240	; 0xf0
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    be12:	ldr	r6, [pc, #104]	; (be7c <setSdclk(unsigned long)+0xc0>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    be14:	ldr	r4, [pc, #104]	; (be80 <setSdclk(unsigned long)+0xc4>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    be16:	ldr	r0, [pc, #96]	; (be78 <setSdclk(unsigned long)+0xbc>)

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    be18:	ldr	r1, [pc, #104]	; (be84 <setSdclk(unsigned long)+0xc8>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    be1a:	mov.w	r5, #1000	; 0x3e8
    be1e:	mul.w	r3, r5, r3
    be22:	udiv	r3, r0, r3
    be26:	str	r3, [r6, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    be28:	ldr	r3, [r4, #0]
    be2a:	bic.w	r3, r3, #8
    be2e:	str	r3, [r4, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    be30:	ldr	r0, [r4, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    be32:	bic.w	r3, r0, #1044480	; 0xff000
    be36:	bic.w	r3, r3, #4080	; 0xff0
    be3a:	orr.w	r3, r3, #917504	; 0xe0000
    be3e:	orrs	r3, r7
    be40:	orrs	r2, r3
    be42:	str	r2, [r4, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    be44:	ldr	r3, [r1, #0]
    be46:	lsls	r3, r3, #28
    be48:	bpl.n	be44 <setSdclk(unsigned long)+0x88>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    be4a:	ldr	r2, [pc, #52]	; (be80 <setSdclk(unsigned long)+0xc4>)
    be4c:	ldr	r3, [r2, #0]
    be4e:	orr.w	r3, r3, #8
    be52:	str	r3, [r2, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
    be54:	pop	{r4, r5, r6, r7}
    be56:	bx	lr
    be58:	lsls	r2, r2, #4
    be5a:	b.n	be12 <setSdclk(unsigned long)+0x56>
    be5c:	udiv	r4, r4, r1
    be60:	lsls	r7, r1, #7
    be62:	b.n	bdec <setSdclk(unsigned long)+0x30>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    be64:	ldr	r4, [pc, #16]	; (be78 <setSdclk(unsigned long)+0xbc>)
    be66:	movs	r7, #0
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    be68:	movs	r1, #1
    be6a:	b.n	bdec <setSdclk(unsigned long)+0x30>
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    be6c:	mov	r3, r1
    be6e:	movs	r2, #0
    be70:	b.n	be12 <setSdclk(unsigned long)+0x56>
    be72:	nop
    be74:	.word	0x005b8d7f
    be78:	.word	0x05b8d800
    be7c:	.word	0x20005134
    be80:	.word	0x400b102c
    be84:	.word	0x400b1024

0000be88 <SdioCard::errorCode() const>:
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
    be88:	ldr	r3, [pc, #4]	; (be90 <SdioCard::errorCode() const+0x8>)
}
    be8a:	ldrb	r0, [r3, #0]
    be8c:	bx	lr
    be8e:	nop
    be90:	.word	0x20000be0

0000be94 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    be94:	ldr	r3, [pc, #4]	; (be9c <SdioCard::errorData() const+0x8>)
    be96:	ldr	r0, [r3, #0]
}
    be98:	bx	lr
    be9a:	nop
    be9c:	.word	0x20005118

0000bea0 <SdioCard::readCID(CID*)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    bea0:	push	{r4, r5}
  memcpy(cid, &m_cid, 16);
    bea2:	ldr	r4, [pc, #20]	; (beb8 <SdioCard::readCID(CID*)+0x18>)
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    bea4:	mov	r5, r1
  memcpy(cid, &m_cid, 16);
    bea6:	ldmia	r4!, {r0, r1, r2, r3}
    bea8:	str	r0, [r5, #0]
    beaa:	str	r1, [r5, #4]
    beac:	str	r2, [r5, #8]
    beae:	str	r3, [r5, #12]
  return true;
}
    beb0:	movs	r0, #1
    beb2:	pop	{r4, r5}
    beb4:	bx	lr
    beb6:	nop
    beb8:	.word	0x200050f4

0000bebc <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    bebc:	push	{r4, r5}
  memcpy(csd, &m_csd, 16);
    bebe:	ldr	r4, [pc, #20]	; (bed4 <SdioCard::readCSD(csd_t*)+0x18>)
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    bec0:	mov	r5, r1
  memcpy(csd, &m_csd, 16);
    bec2:	ldmia	r4!, {r0, r1, r2, r3}
    bec4:	str	r0, [r5, #0]
    bec6:	str	r1, [r5, #4]
    bec8:	str	r2, [r5, #8]
    beca:	str	r3, [r5, #12]
  return true;
}
    becc:	movs	r0, #1
    bece:	pop	{r4, r5}
    bed0:	bx	lr
    bed2:	nop
    bed4:	.word	0x20005120

0000bed8 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    bed8:	ldr	r3, [pc, #8]	; (bee4 <SdioCard::readOCR(unsigned long*)+0xc>)
    beda:	ldr	r3, [r3, #0]
    bedc:	str	r3, [r1, #0]
  return true;
}
    bede:	movs	r0, #1
    bee0:	bx	lr
    bee2:	nop
    bee4:	.word	0x2000510c

0000bee8 <SdioCard::~SdioCard()>:
    bee8:	bx	lr
    beea:	nop

0000beec <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    beec:	push	{r3, r4, r5, r6, r7, lr}
    beee:	mov	r5, r0
  uint32_t m = micros();
    bef0:	bl	da0c <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    bef4:	ldr	r7, [pc, #24]	; (bf10 <waitTimeout(bool (*)())+0x24>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    bef6:	mov	r6, r0
    bef8:	b.n	bf04 <waitTimeout(bool (*)())+0x18>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    befa:	bl	da0c <micros>
    befe:	subs	r0, r0, r6
    bf00:	cmp	r0, r7
    bf02:	bhi.n	bf0c <waitTimeout(bool (*)())+0x20>
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
  while (fcn()) {
    bf04:	blx	r5
    bf06:	mov	r4, r0
    bf08:	cmp	r0, #0
    bf0a:	bne.n	befa <waitTimeout(bool (*)())+0xe>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    bf0c:	mov	r0, r4
    bf0e:	pop	{r3, r4, r5, r6, r7, pc}
    bf10:	.word	0x000f4240

0000bf14 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    bf14:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    bf18:	ldr.w	r8, [pc, #64]	; bf5c <yieldTimeout(bool (*)())+0x48>
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    bf1c:	ldr	r7, [pc, #56]	; (bf58 <yieldTimeout(bool (*)())+0x44>)
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    bf1e:	str.w	r0, [r8]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    bf22:	mov	r5, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    bf24:	bl	da0c <micros>
    bf28:	mov	r6, r0
    bf2a:	b.n	bf3a <yieldTimeout(bool (*)())+0x26>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    bf2c:	bl	da0c <micros>
    bf30:	subs	r0, r0, r6
    bf32:	cmp	r0, r7
    bf34:	bhi.n	bf4c <yieldTimeout(bool (*)())+0x38>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    bf36:	bl	e748 <yield>
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    bf3a:	blx	r5
    bf3c:	mov	r4, r0
    bf3e:	cmp	r0, #0
    bf40:	bne.n	bf2c <yieldTimeout(bool (*)())+0x18>
      m_busyFcn = 0;
      return true;
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    bf42:	str.w	r0, [r8]
  return false;  // Caller will set errorCode.
}
    bf46:	mov	r0, r4
    bf48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      m_busyFcn = 0;
    bf4c:	movs	r3, #0
    bf4e:	str.w	r3, [r8]
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
    bf52:	mov	r0, r4
    bf54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bf58:	.word	0x000f4240
    bf5c:	.word	0x20005104

0000bf60 <SdioCard::~SdioCard()>:
    bf60:	push	{r4, lr}
    bf62:	movs	r1, #12
    bf64:	mov	r4, r0
    bf66:	bl	ea80 <operator delete(void*, unsigned int)>
    bf6a:	mov	r0, r4
    bf6c:	pop	{r4, pc}
    bf6e:	nop

0000bf70 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    bf70:	ldr	r3, [pc, #20]	; (bf88 <SdioCard::type() const+0x18>)
    bf72:	ldrb	r3, [r3, #0]
    bf74:	cbz	r3, bf84 <SdioCard::type() const+0x14>
    bf76:	ldr	r3, [pc, #20]	; (bf8c <SdioCard::type() const+0x1c>)
    bf78:	ldrb	r3, [r3, #0]
    bf7a:	cmp	r3, #0
    bf7c:	ite	ne
    bf7e:	movne	r0, #3
    bf80:	moveq	r0, #2
    bf82:	bx	lr
    bf84:	movs	r0, #1
}
    bf86:	bx	lr
    bf88:	.word	0x200050f0
    bf8c:	.word	0x20005108

0000bf90 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    bf90:	push	{r3, r4, r5, lr}
    bf92:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    bf94:	ldr	r0, [pc, #60]	; (bfd4 <cardCommand(unsigned long, unsigned long)+0x44>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    bf96:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    bf98:	bl	beec <waitTimeout(bool (*)())>
    bf9c:	cbz	r0, bfa2 <cardCommand(unsigned long, unsigned long)+0x12>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    bf9e:	movs	r0, #0
    bfa0:	pop	{r3, r4, r5, pc}
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    bfa2:	ldr	r2, [pc, #52]	; (bfd8 <cardCommand(unsigned long, unsigned long)+0x48>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    bfa4:	ldr	r3, [pc, #52]	; (bfdc <cardCommand(unsigned long, unsigned long)+0x4c>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    bfa6:	str	r5, [r2, #0]
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    bfa8:	ldr	r0, [pc, #52]	; (bfe0 <cardCommand(unsigned long, unsigned long)+0x50>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    bfaa:	str	r4, [r3, #0]
  if (waitTimeout(isBusyCommandComplete)) {
    bfac:	bl	beec <waitTimeout(bool (*)())>
    bfb0:	cmp	r0, #0
    bfb2:	bne.n	bf9e <cardCommand(unsigned long, unsigned long)+0xe>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    bfb4:	ldr	r2, [pc, #44]	; (bfe4 <cardCommand(unsigned long, unsigned long)+0x54>)
    bfb6:	ldr	r3, [pc, #48]	; (bfe8 <cardCommand(unsigned long, unsigned long)+0x58>)
    bfb8:	ldr	r1, [r2, #0]
    bfba:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    bfbc:	ldr	r1, [r3, #0]
    bfbe:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    bfc0:	ldr	r2, [r3, #0]
    bfc2:	lsls	r2, r2, #31
    bfc4:	bpl.n	bf9e <cardCommand(unsigned long, unsigned long)+0xe>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    bfc6:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    bfc8:	tst.w	r3, #983040	; 0xf0000
    bfcc:	bne.n	bf9e <cardCommand(unsigned long, unsigned long)+0xe>
    bfce:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    bfd0:	pop	{r3, r4, r5, pc}
    bfd2:	nop
    bfd4:	.word	0x0000bd4d
    bfd8:	.word	0x400b1008
    bfdc:	.word	0x400b100c
    bfe0:	.word	0x0000bd35
    bfe4:	.word	0x400b1030
    bfe8:	.word	0x20005118

0000bfec <isBusyCMD13()>:
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    bfec:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    bfee:	ldr	r3, [pc, #28]	; (c00c <isBusyCMD13()+0x20>)
    bff0:	ldr	r0, [pc, #28]	; (c010 <isBusyCMD13()+0x24>)
    bff2:	ldr	r1, [r3, #0]
    bff4:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    bff8:	cbz	r0, c008 <isBusyCMD13()+0x1c>
    bffa:	ldr	r3, [pc, #24]	; (c014 <isBusyCMD13()+0x28>)
    bffc:	ldr	r0, [r3, #0]
    bffe:	eor.w	r0, r0, #256	; 0x100
    c002:	ubfx	r0, r0, #8, #1
    c006:	pop	{r3, pc}
    c008:	movs	r0, #1
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
    c00a:	pop	{r3, pc}
    c00c:	.word	0x20005110
    c010:	.word	0x0d1a0000
    c014:	.word	0x400b1010

0000c018 <SdioCard::status()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
    c018:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    c01a:	ldr	r3, [pc, #16]	; (c02c <SdioCard::status()+0x14>)
    c01c:	ldr	r0, [pc, #16]	; (c030 <SdioCard::status()+0x18>)
    c01e:	ldr	r1, [r3, #0]
    c020:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c024:	cbz	r0, c02a <SdioCard::status()+0x12>
    c026:	ldr	r3, [pc, #12]	; (c034 <SdioCard::status()+0x1c>)
    c028:	ldr	r0, [r3, #0]
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
    c02a:	pop	{r3, pc}
    c02c:	.word	0x20005110
    c030:	.word	0x0d1a0000
    c034:	.word	0x400b1010

0000c038 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    c038:	push	{r4, r5, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    c03a:	ldr	r3, [pc, #84]	; (c090 <readReg16(unsigned long, void*)+0x58>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    c03c:	sub	sp, #20
    c03e:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    c040:	ldr	r1, [r3, #0]
    c042:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c046:	cbz	r0, c08a <readReg16(unsigned long, void*)+0x52>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    c048:	ldr	r2, [pc, #72]	; (c094 <readReg16(unsigned long, void*)+0x5c>)
    c04a:	ldr	r3, [pc, #76]	; (c098 <readReg16(unsigned long, void*)+0x60>)
    c04c:	ldr	r2, [r2, #0]
    c04e:	str	r2, [sp, #0]
    c050:	ldr	r1, [r3, #0]
    c052:	str	r1, [sp, #4]
    c054:	ldr	r1, [r3, #4]
    c056:	str	r1, [sp, #8]
    c058:	adds	r3, #8
    c05a:	add.w	r4, r5, #15
    c05e:	ldr	r3, [r3, #0]
    c060:	str	r3, [sp, #12]
  for (int i = 0; i < 15; i++) {
    c062:	movs	r3, #0
    c064:	b.n	c06a <readReg16(unsigned long, void*)+0x32>
    c066:	ldr.w	r2, [r1, #-16]
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c06a:	and.w	r1, r3, #3
    c06e:	lsls	r1, r1, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c070:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c072:	lsrs	r2, r1
    c074:	add.w	lr, sp, #16
    c078:	bic.w	r1, r3, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c07c:	cmp	r3, #15
    c07e:	add	r1, lr
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c080:	strb.w	r2, [r4, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c084:	bne.n	c066 <readReg16(unsigned long, void*)+0x2e>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    c086:	movs	r3, #0
    c088:	strb	r3, [r5, #15]
  return true;
}
    c08a:	add	sp, #20
    c08c:	pop	{r4, r5, pc}
    c08e:	nop
    c090:	.word	0x20005110
    c094:	.word	0x400b1010
    c098:	.word	0x400b1014

0000c09c <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    c09c:	ldr	r3, [pc, #20]	; (c0b4 <waitDmaStatus() [clone .part.4]+0x18>)
    c09e:	ldr	r0, [r3, #0]
    c0a0:	ands.w	r0, r0, #2
    c0a4:	beq.n	c0b2 <waitDmaStatus() [clone .part.4]+0x16>
    c0a6:	ldr	r3, [r3, #0]
    c0a8:	ldr	r0, [pc, #12]	; (c0b8 <waitDmaStatus() [clone .part.4]+0x1c>)
    c0aa:	ands	r0, r3
    c0ac:	clz	r0, r0
    c0b0:	lsrs	r0, r0, #5
}
    c0b2:	bx	lr
    c0b4:	.word	0x20005118
    c0b8:	.word	0x117f0000

0000c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    c0bc:	push	{r3, r4, r5, r6, r7, lr}
  if ((3 & (uint32_t)buf) || n == 0) {
    c0be:	lsls	r4, r2, #30
    c0c0:	bne.n	c0c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8>
    c0c2:	cbnz	r3, c0d6 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c0c4:	ldr	r1, [pc, #124]	; (c144 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    c0c6:	ldr	r3, [pc, #128]	; (c148 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c0c8:	movs	r0, #37	; 0x25
  m_errorLine = line;
    c0ca:	movw	r2, #503	; 0x1f7
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c0ce:	strb	r0, [r1, #0]
  m_errorLine = line;
    c0d0:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    c0d2:	movs	r0, #0
    c0d4:	pop	{r3, r4, r5, r6, r7, pc}
    c0d6:	mov	r6, r0
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    c0d8:	ldr	r0, [pc, #112]	; (c14c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
    c0da:	mov	r4, r3
    c0dc:	mov	r7, r1
    c0de:	mov	r5, r2
    c0e0:	bl	bf14 <yieldTimeout(bool (*)())>
    c0e4:	cbnz	r0, c12e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c0e6:	ldr	r1, [pc, #104]	; (c150 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    c0e8:	ldr	r2, [pc, #104]	; (c154 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    c0ea:	ldr.w	lr, [pc, #128]	; c16c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xb0>
    c0ee:	mov.w	ip, #1
    c0f2:	strb.w	ip, [lr]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c0f6:	lsls	r3, r4, #16
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c0f8:	str	r0, [r1, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c0fa:	ldr	r4, [pc, #92]	; (c158 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x9c>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    c0fc:	str	r5, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c0fe:	ldr	r2, [pc, #92]	; (c15c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa0>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c100:	ldr	r1, [pc, #92]	; (c160 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa4>)
    c102:	ldr	r0, [pc, #96]	; (c164 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa8>)
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c104:	orr.w	r3, r3, #512	; 0x200
    c108:	str	r3, [r4, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c10a:	ldrb	r3, [r2, #0]
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c10c:	str	r0, [r1, #0]
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c10e:	cbnz	r3, c13e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x82>
    c110:	lsls	r1, r7, #9
    c112:	mov	r0, r6
    c114:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c118:	cmp	r0, #0
    c11a:	beq.n	c0d2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    c11c:	ldr	r0, [pc, #72]	; (c168 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xac>)
    c11e:	bl	bf14 <yieldTimeout(bool (*)())>
    c122:	cmp	r0, #0
    c124:	bne.n	c0d2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    c126:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    c12a:	b.w	c09c <waitDmaStatus() [clone .part.4]>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c12e:	ldr	r1, [pc, #20]	; (c144 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    c130:	ldr	r3, [pc, #20]	; (c148 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c132:	movs	r0, #10
  m_errorLine = line;
    c134:	mov.w	r2, #506	; 0x1fa
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c138:	strb	r0, [r1, #0]
  m_errorLine = line;
    c13a:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c13c:	b.n	c0d2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c13e:	mov	r1, r7
    c140:	b.n	c112 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x56>
    c142:	nop
    c144:	.word	0x20000be0
    c148:	.word	0x20005138
    c14c:	.word	0x0000bfed
    c150:	.word	0x20005118
    c154:	.word	0x400b1000
    c158:	.word	0x400b1004
    c15c:	.word	0x20005108
    c160:	.word	0x400b1038
    c164:	.word	0x117f0002
    c168:	.word	0x0000bd71
    c16c:	.word	0x20005130

0000c170 <SdioCard::sectorCount()>:
//------------------------------------------------------------------------------
bool SdioCard::readStop() {
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
    c170:	push	{r4, r5, r6}
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    c172:	ldr	r1, [pc, #100]	; (c1d8 <SdioCard::sectorCount()+0x68>)
    c174:	ldrb	r3, [r1, #0]
    c176:	ands.w	r3, r3, #192	; 0xc0
    c17a:	beq.n	c1a0 <SdioCard::sectorCount()+0x30>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    c17c:	cmp	r3, #64	; 0x40
    c17e:	beq.n	c186 <SdioCard::sectorCount()+0x16>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
  } else {
    return 0;
    c180:	movs	r0, #0
  return sdCardCapacity(&m_csd);
}
    c182:	pop	{r4, r5, r6}
    c184:	bx	lr
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    c186:	ldrb	r3, [r1, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    c188:	ldrb	r4, [r1, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    c18a:	ldrb	r0, [r1, #8]
    c18c:	adds	r2, r3, #1
    c18e:	and.w	r3, r4, #63	; 0x3f
    c192:	add.w	r3, r2, r3, lsl #16
    c196:	add.w	r0, r3, r0, lsl #8
    c19a:	lsls	r0, r0, #10
    c19c:	pop	{r4, r5, r6}
    c19e:	bx	lr
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    c1a0:	ldrb	r5, [r1, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    c1a2:	ldrb	r3, [r1, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    c1a4:	ldrb	r2, [r1, #7]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    c1a6:	ldrb	r4, [r1, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    c1a8:	ldrb	r6, [r1, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    c1aa:	ldrb	r0, [r1, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    c1ac:	and.w	r1, r5, #3
    c1b0:	lsls	r1, r1, #1
    c1b2:	and.w	r3, r3, #3
    c1b6:	lsls	r2, r2, #2
    c1b8:	orr.w	r0, r1, r0, lsr #7
    c1bc:	orr.w	r3, r2, r3, lsl #10
    c1c0:	and.w	r1, r4, #15
    c1c4:	orr.w	r3, r3, r6, lsr #6
    c1c8:	add	r0, r1
    c1ca:	subs	r0, #7
    c1cc:	adds	r3, #1
    c1ce:	lsl.w	r0, r3, r0
    c1d2:	pop	{r4, r5, r6}
    c1d4:	bx	lr
    c1d6:	nop
    c1d8:	.word	0x20005120

0000c1dc <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    c1dc:	push	{r4, r5, r6, lr}
    c1de:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c1e0:	ldrb	r1, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    c1e2:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c1e4:	cbnz	r1, c242 <SdioCard::erase(unsigned long, unsigned long)+0x66>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    c1e6:	ldr	r2, [pc, #192]	; (c2a8 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    c1e8:	ldrb	r3, [r2, #10]
    c1ea:	and.w	r0, r3, #64	; 0x40
    c1ee:	and.w	r4, r0, #255	; 0xff
    c1f2:	cbz	r0, c21c <SdioCard::erase(unsigned long, unsigned long)+0x40>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    c1f4:	ldr	r3, [pc, #180]	; (c2ac <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    c1f6:	ldrb	r3, [r3, #0]
    c1f8:	cbnz	r3, c1fe <SdioCard::erase(unsigned long, unsigned long)+0x22>
    firstSector <<= 9;
    c1fa:	lsls	r5, r5, #9
    lastSector <<= 9;
    c1fc:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    c1fe:	mov	r1, r5
    c200:	ldr	r0, [pc, #172]	; (c2b0 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    c202:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c206:	mov	r4, r0
    c208:	cbnz	r0, c252 <SdioCard::erase(unsigned long, unsigned long)+0x76>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c20a:	ldr	r1, [pc, #168]	; (c2b4 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c20c:	ldr	r3, [pc, #168]	; (c2b8 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c20e:	movs	r0, #15
  m_errorLine = line;
    c210:	mov.w	r2, #752	; 0x2f0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c214:	strb	r0, [r1, #0]
  m_errorLine = line;
    c216:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c218:	mov	r0, r4
    c21a:	pop	{r4, r5, r6, pc}
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    c21c:	ldrb	r1, [r2, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    c21e:	and.w	r3, r3, #63	; 0x3f
    c222:	lsls	r3, r3, #1
    c224:	adds	r2, r6, #1
    c226:	orr.w	r3, r3, r1, lsr #7
    c22a:	orrs	r2, r5
    c22c:	tst	r3, r2
    c22e:	beq.n	c1f4 <SdioCard::erase(unsigned long, unsigned long)+0x18>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c230:	ldr	r1, [pc, #128]	; (c2b4 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c232:	ldr	r3, [pc, #132]	; (c2b8 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c234:	movs	r0, #39	; 0x27
  m_errorLine = line;
    c236:	mov.w	r2, #744	; 0x2e8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c23a:	strb	r0, [r1, #0]
  m_errorLine = line;
    c23c:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c23e:	mov	r0, r4
    c240:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c242:	ldr	r3, [r0, #0]
    c244:	ldr	r3, [r3, #24]
    c246:	blx	r3
    c248:	mov	r4, r0
    c24a:	cmp	r0, #0
    c24c:	bne.n	c1e6 <SdioCard::erase(unsigned long, unsigned long)+0xa>
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c24e:	mov	r0, r4
    c250:	pop	{r4, r5, r6, pc}
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    c252:	mov	r1, r6
    c254:	ldr	r0, [pc, #100]	; (c2bc <SdioCard::erase(unsigned long, unsigned long)+0xe0>)
    c256:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c25a:	mov	r4, r0
    c25c:	cbnz	r0, c26e <SdioCard::erase(unsigned long, unsigned long)+0x92>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c25e:	ldr	r1, [pc, #84]	; (c2b4 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c260:	ldr	r3, [pc, #84]	; (c2b8 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c262:	movs	r0, #16
  m_errorLine = line;
    c264:	movw	r2, #755	; 0x2f3
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c268:	strb	r0, [r1, #0]
  m_errorLine = line;
    c26a:	str	r2, [r3, #0]
    c26c:	b.n	c218 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    c26e:	movs	r1, #0
    c270:	ldr	r0, [pc, #76]	; (c2c0 <SdioCard::erase(unsigned long, unsigned long)+0xe4>)
    c272:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c276:	mov	r4, r0
    c278:	cbnz	r0, c28a <SdioCard::erase(unsigned long, unsigned long)+0xae>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c27a:	ldr	r1, [pc, #56]	; (c2b4 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c27c:	ldr	r3, [pc, #56]	; (c2b8 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c27e:	movs	r0, #17
  m_errorLine = line;
    c280:	movw	r2, #758	; 0x2f6
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c284:	strb	r0, [r1, #0]
  m_errorLine = line;
    c286:	str	r2, [r3, #0]
    c288:	b.n	c218 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    c28a:	ldr	r0, [pc, #56]	; (c2c4 <SdioCard::erase(unsigned long, unsigned long)+0xe8>)
    c28c:	bl	beec <waitTimeout(bool (*)())>
    c290:	cmp	r0, #0
    c292:	beq.n	c218 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c294:	ldr	r1, [pc, #28]	; (c2b4 <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c296:	ldr	r3, [pc, #32]	; (c2b8 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c298:	movs	r0, #40	; 0x28
  m_errorLine = line;
    c29a:	movw	r2, #761	; 0x2f9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c29e:	strb	r0, [r1, #0]
  m_errorLine = line;
    c2a0:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    c2a2:	movs	r4, #0
    c2a4:	b.n	c218 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    c2a6:	nop
    c2a8:	.word	0x20005120
    c2ac:	.word	0x20005108
    c2b0:	.word	0x201a0000
    c2b4:	.word	0x20000be0
    c2b8:	.word	0x20005138
    c2bc:	.word	0x211a0000
    c2c0:	.word	0x261b0000
    c2c4:	.word	0x0000bfed

0000c2c8 <waitTransferComplete() [clone .part.8]>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    c2c8:	push	{r4, lr}
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    c2ca:	ldr	r0, [pc, #56]	; (c304 <waitTransferComplete() [clone .part.8]+0x3c>)
    c2cc:	bl	beec <waitTimeout(bool (*)())>
  m_transferActive = false;
    c2d0:	ldr	r1, [pc, #52]	; (c308 <waitTransferComplete() [clone .part.8]+0x40>)
  m_irqstat = SDHC_IRQSTAT;
    c2d2:	ldr	r2, [pc, #56]	; (c30c <waitTransferComplete() [clone .part.8]+0x44>)
    c2d4:	ldr	r3, [pc, #56]	; (c310 <waitTransferComplete() [clone .part.8]+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    c2d6:	movs	r4, #0
    c2d8:	strb	r4, [r1, #0]
  m_irqstat = SDHC_IRQSTAT;
    c2da:	ldr	r1, [r2, #0]
    c2dc:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    c2de:	ldr	r1, [r3, #0]
    c2e0:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    c2e2:	cbnz	r0, c2ec <waitTransferComplete() [clone .part.8]+0x24>
    c2e4:	ldr	r2, [r3, #0]
    c2e6:	ldr	r3, [pc, #44]	; (c314 <waitTransferComplete() [clone .part.8]+0x4c>)
    c2e8:	ands	r3, r2
    c2ea:	cbz	r3, c2fe <waitTransferComplete() [clone .part.8]+0x36>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c2ec:	ldr	r1, [pc, #40]	; (c318 <waitTransferComplete() [clone .part.8]+0x50>)
  m_errorLine = line;
    c2ee:	ldr	r3, [pc, #44]	; (c31c <waitTransferComplete() [clone .part.8]+0x54>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c2f0:	movs	r0, #31
  m_errorLine = line;
    c2f2:	movw	r2, #638	; 0x27e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c2f6:	strb	r0, [r1, #0]
  m_errorLine = line;
    c2f8:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    c2fa:	movs	r0, #0
  }
  return true;
}
    c2fc:	pop	{r4, pc}
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
  }
  return true;
    c2fe:	movs	r0, #1
    c300:	pop	{r4, pc}
    c302:	nop
    c304:	.word	0x0000bda5
    c308:	.word	0x20005114
    c30c:	.word	0x400b1030
    c310:	.word	0x20005118
    c314:	.word	0x117f0000
    c318:	.word	0x20000be0
    c31c:	.word	0x20005138

0000c320 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    c320:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c322:	ldr	r4, [pc, #104]	; (c38c <SdioCard::readStop()+0x6c>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    c324:	ldr	r0, [pc, #104]	; (c390 <SdioCard::readStop()+0x70>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c326:	ldr	r3, [r4, #0]
    c328:	bic.w	r3, r3, #65536	; 0x10000
    c32c:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    c32e:	movs	r1, #0
    c330:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c334:	mov	r5, r0
    c336:	cbnz	r0, c34a <SdioCard::readStop()+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c338:	ldr	r1, [pc, #88]	; (c394 <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    c33a:	ldr	r3, [pc, #92]	; (c398 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c33c:	movs	r0, #9
  m_errorLine = line;
    c33e:	movw	r2, #575	; 0x23f
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c342:	strb	r0, [r1, #0]
  m_errorLine = line;
    c344:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c346:	mov	r0, r5
    c348:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    c34a:	ldr	r0, [pc, #80]	; (c39c <SdioCard::readStop()+0x7c>)
    c34c:	bl	bf14 <yieldTimeout(bool (*)())>
    c350:	cbnz	r0, c376 <SdioCard::readStop()+0x56>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    c352:	ldr	r3, [pc, #76]	; (c3a0 <SdioCard::readStop()+0x80>)
    c354:	ldr	r3, [r3, #0]
    c356:	lsls	r3, r3, #30
    c358:	bpl.n	c346 <SdioCard::readStop()+0x26>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    c35a:	ldr	r1, [pc, #72]	; (c3a4 <SdioCard::readStop()+0x84>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c35c:	ldr	r0, [pc, #72]	; (c3a8 <SdioCard::readStop()+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    c35e:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    c360:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c362:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    c364:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c368:	orr.w	r2, r2, #67108864	; 0x4000000
    c36c:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    c36e:	str	r6, [r1, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c370:	mov	r0, r5
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    SDHC_PROCTL = proctl;
    c372:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c374:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c376:	ldr	r1, [pc, #28]	; (c394 <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    c378:	ldr	r3, [pc, #28]	; (c398 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c37a:	movs	r0, #10
  m_errorLine = line;
    c37c:	movw	r2, #579	; 0x243
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c380:	strb	r0, [r1, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c382:	movs	r5, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c384:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c386:	mov	r0, r5
    c388:	pop	{r4, r5, r6, pc}
    c38a:	nop
    c38c:	.word	0x400b1028
    c390:	.word	0x0cdb0000
    c394:	.word	0x20000be0
    c398:	.word	0x20005138
    c39c:	.word	0x0000bd5d
    c3a0:	.word	0x400b1024
    c3a4:	.word	0x400b1034
    c3a8:	.word	0x400b102c

0000c3ac <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    c3ac:	push	{r4, r5, r6, lr}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c3ae:	ldr	r6, [pc, #124]	; (c42c <SdioCard::writeData(unsigned char const*)+0x80>)
    c3b0:	ldrb	r3, [r6, #0]
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    c3b2:	mov	r5, r1
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c3b4:	cmp	r3, #0
    c3b6:	bne.n	c420 <SdioCard::writeData(unsigned char const*)+0x74>
  if (!waitTransferComplete()) {
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    c3b8:	ldr	r3, [pc, #116]	; (c430 <SdioCard::writeData(unsigned char const*)+0x84>)
    c3ba:	ldr	r3, [r3, #0]
    c3bc:	lsls	r1, r3, #23
    c3be:	bmi.n	c3d2 <SdioCard::writeData(unsigned char const*)+0x26>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c3c0:	ldr	r3, [pc, #112]	; (c434 <SdioCard::writeData(unsigned char const*)+0x88>)
    c3c2:	ldr	r2, [r3, #0]
    c3c4:	bic.w	r2, r2, #65536	; 0x10000
    c3c8:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    c3ca:	ldr	r2, [r3, #0]
    c3cc:	orr.w	r2, r2, #131072	; 0x20000
    c3d0:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    c3d2:	ldr	r2, [pc, #96]	; (c434 <SdioCard::writeData(unsigned char const*)+0x88>)
  if (waitTimeout(isBusyFifoWrite)) {
    c3d4:	ldr	r0, [pc, #96]	; (c438 <SdioCard::writeData(unsigned char const*)+0x8c>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    c3d6:	ldr	r3, [r2, #0]
    c3d8:	orr.w	r3, r3, #65536	; 0x10000
    c3dc:	str	r3, [r2, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    c3de:	bl	beec <waitTimeout(bool (*)())>
    c3e2:	cbnz	r0, c40e <SdioCard::writeData(unsigned char const*)+0x62>
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    c3e4:	ldr	r4, [pc, #72]	; (c430 <SdioCard::writeData(unsigned char const*)+0x84>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    c3e6:	ldr	r0, [pc, #84]	; (c43c <SdioCard::writeData(unsigned char const*)+0x90>)
    c3e8:	subs	r3, r5, #4
    c3ea:	add.w	r5, r5, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    c3ee:	ldr	r2, [r4, #0]
    c3f0:	lsls	r2, r2, #21
    c3f2:	bpl.n	c3ee <SdioCard::writeData(unsigned char const*)+0x42>
    c3f4:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    c3f8:	ldr.w	r2, [r3, #4]!
    c3fc:	str	r2, [r0, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    c3fe:	cmp	r1, r3
    c400:	bne.n	c3f8 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    c402:	cmp	r5, r1
    c404:	mov	r3, r1
    c406:	bne.n	c3ee <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    c408:	movs	r0, #1
    c40a:	strb	r0, [r6, #0]
    c40c:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c40e:	ldr	r1, [pc, #48]	; (c440 <SdioCard::writeData(unsigned char const*)+0x94>)
  m_errorLine = line;
    c410:	ldr	r3, [pc, #48]	; (c444 <SdioCard::writeData(unsigned char const*)+0x98>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c412:	movs	r0, #33	; 0x21
  m_errorLine = line;
    c414:	mov.w	r2, #1012	; 0x3f4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c418:	strb	r0, [r1, #0]
  m_errorLine = line;
    c41a:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    c41c:	movs	r0, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    c41e:	pop	{r4, r5, r6, pc}
    c420:	bl	c2c8 <waitTransferComplete() [clone .part.8]>
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    c424:	cmp	r0, #0
    c426:	bne.n	c3b8 <SdioCard::writeData(unsigned char const*)+0xc>
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    c428:	pop	{r4, r5, r6, pc}
    c42a:	nop
    c42c:	.word	0x20005114
    c430:	.word	0x400b1024
    c434:	.word	0x400b1028
    c438:	.word	0x0000bd91
    c43c:	.word	0x400b1020
    c440:	.word	0x20000be0
    c444:	.word	0x20005138

0000c448 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    c448:	push	{r3, r4, r5, lr}
  if (yieldTimeout(isBusyCMD13)) {
    c44a:	ldr	r0, [pc, #80]	; (c49c <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    c44c:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    c44e:	bl	bf14 <yieldTimeout(bool (*)())>
    c452:	cbnz	r0, c488 <SdioCard::writeStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c454:	ldr	r2, [pc, #72]	; (c4a0 <SdioCard::writeStart(unsigned long)+0x58>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c456:	ldr	r1, [pc, #76]	; (c4a4 <SdioCard::writeStart(unsigned long)+0x5c>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c458:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    c45a:	ldr	r0, [pc, #76]	; (c4a8 <SdioCard::writeStart(unsigned long)+0x60>)
    c45c:	ldr	r5, [pc, #76]	; (c4ac <SdioCard::writeStart(unsigned long)+0x64>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c45e:	bic.w	r3, r3, #65536	; 0x10000
    c462:	str	r3, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c464:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    c466:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c468:	cbnz	r3, c484 <SdioCard::writeStart(unsigned long)+0x3c>
    c46a:	lsls	r1, r4, #9
    c46c:	ldr	r0, [pc, #64]	; (c4b0 <SdioCard::writeStart(unsigned long)+0x68>)
    c46e:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c472:	cbnz	r0, c482 <SdioCard::writeStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c474:	ldr	r1, [pc, #60]	; (c4b4 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    c476:	ldr	r3, [pc, #64]	; (c4b8 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c478:	movs	r4, #14
  m_errorLine = line;
    c47a:	mov.w	r2, #1128	; 0x468
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c47e:	strb	r4, [r1, #0]
  m_errorLine = line;
    c480:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    c482:	pop	{r3, r4, r5, pc}
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c484:	mov	r1, r4
    c486:	b.n	c46c <SdioCard::writeStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c488:	ldr	r1, [pc, #40]	; (c4b4 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    c48a:	ldr	r3, [pc, #44]	; (c4b8 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c48c:	movs	r0, #10
  m_errorLine = line;
    c48e:	movw	r2, #1116	; 0x45c
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c492:	strb	r0, [r1, #0]
  m_errorLine = line;
    c494:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c496:	movs	r0, #0
    c498:	pop	{r3, r4, r5, pc}
    c49a:	nop
    c49c:	.word	0x0000bfed
    c4a0:	.word	0x400b1028
    c4a4:	.word	0x20005108
    c4a8:	.word	0x400b1004
    c4ac:	.word	0xffff0200
    c4b0:	.word	0x193a0022
    c4b4:	.word	0x20000be0
    c4b8:	.word	0x20005138

0000c4bc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    c4bc:	push	{r3, r4, r5, r6, r7, lr}
    c4be:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    c4c0:	ldrb	r0, [r0, #8]
    c4c2:	lsls	r0, r0, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    c4c4:	mov	r4, r1
    c4c6:	mov	r5, r2
    c4c8:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    c4ca:	bmi.n	c4f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    c4cc:	cbz	r3, c4f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    c4ce:	add	r7, r1
    c4d0:	b.n	c4d6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1a>
    c4d2:	cmp	r4, r7
    c4d4:	beq.n	c4f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
      if (!writeSector(sector + i, src + i*512UL)) {
    c4d6:	ldr	r3, [r6, #0]
    c4d8:	mov	r2, r5
    c4da:	mov	r1, r4
    c4dc:	ldr	r3, [r3, #28]
    c4de:	mov	r0, r6
    c4e0:	blx	r3
    c4e2:	adds	r4, #1
    c4e4:	add.w	r5, r5, #512	; 0x200
    c4e8:	cmp	r0, #0
    c4ea:	bne.n	c4d2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x16>
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
    c4ec:	movs	r0, #0
    c4ee:	pop	{r3, r4, r5, r6, r7, pc}
      if (!writeSector(sector + i, src + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    c4f0:	movs	r0, #1
    c4f2:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    c4f4:	lsls	r0, r2, #30
    c4f6:	beq.n	c51e <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    c4f8:	cmp	r3, #0
    c4fa:	beq.n	c4f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    c4fc:	add	r7, r1
    c4fe:	b.n	c504 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x48>
    c500:	cmp	r7, r4
    c502:	beq.n	c4f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
        if (!writeSector(sector, ptr)) {
    c504:	ldr	r3, [r6, #0]
    c506:	mov	r2, r5
    c508:	mov	r1, r4
    c50a:	ldr	r3, [r3, #28]
    c50c:	mov	r0, r6
    c50e:	blx	r3
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    c510:	adds	r4, #1
    c512:	add.w	r5, r5, #512	; 0x200
        if (!writeSector(sector, ptr)) {
    c516:	cmp	r0, #0
    c518:	bne.n	c500 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x44>
          return false;  // writeSector will set errorCode.
    c51a:	movs	r0, #0
    c51c:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    c51e:	ldr	r0, [pc, #24]	; (c538 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x7c>)
    c520:	bl	c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    c524:	cmp	r0, #0
    c526:	bne.n	c4f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c528:	ldr	r1, [pc, #16]	; (c53c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x80>)
  m_errorLine = line;
    c52a:	ldr	r3, [pc, #20]	; (c540 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c52c:	movs	r4, #14
  m_errorLine = line;
    c52e:	movw	r2, #1102	; 0x44e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c532:	strb	r4, [r1, #0]
  m_errorLine = line;
    c534:	str	r2, [r3, #0]
    c536:	pop	{r3, r4, r5, r6, r7, pc}
    c538:	.word	0x193a0027
    c53c:	.word	0x20000be0
    c540:	.word	0x20005138

0000c544 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c544:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    c546:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c548:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    c54a:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c54c:	sub.w	sp, sp, #512	; 0x200
    c550:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    c552:	bpl.n	c588 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    c554:	lsls	r3, r5, #30
    c556:	beq.n	c566 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x22>
      ptr = aligned;
      memcpy(aligned, src, 512);
    c558:	mov	r1, r5
    c55a:	mov	r0, sp
    c55c:	mov.w	r2, #512	; 0x200
    c560:	bl	cfd4 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    c564:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    c566:	mov	r2, r5
    c568:	mov	r1, r6
    c56a:	movs	r3, #1
    c56c:	ldr	r0, [pc, #144]	; (c600 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    c56e:	bl	c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    c572:	cbnz	r0, c582 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c574:	ldr	r1, [pc, #140]	; (c604 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc0>)
  m_errorLine = line;
    c576:	ldr	r3, [pc, #144]	; (c608 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c578:	movs	r4, #13
  m_errorLine = line;
    c57a:	movw	r2, #1046	; 0x416
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c57e:	strb	r4, [r1, #0]
  m_errorLine = line;
    c580:	str	r2, [r3, #0]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    c582:	add.w	sp, sp, #512	; 0x200
    c586:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c588:	ldr	r3, [pc, #128]	; (c60c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc8>)
    c58a:	ldrb	r3, [r3, #0]
    c58c:	mov	r4, r0
    c58e:	cbnz	r3, c5b2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
    if (!waitTransferComplete()) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    c590:	ldr	r3, [pc, #124]	; (c610 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xcc>)
    c592:	ldr	r3, [r3, #0]
    c594:	lsrs	r3, r3, #16
    c596:	lsls	r3, r3, #16
    c598:	cbz	r3, c5f0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xac>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    c59a:	ldrb	r3, [r4, #9]
    c59c:	cmp	r3, #2
    c59e:	beq.n	c5be <SdioCard::writeSector(unsigned long, unsigned char const*)+0x7a>
      if (!syncDevice()) {
    c5a0:	ldr	r3, [r4, #0]
    c5a2:	mov	r0, r4
    c5a4:	ldr	r3, [r3, #24]
    c5a6:	blx	r3
    c5a8:	cbnz	r0, c5c6 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x82>
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    c5aa:	movs	r0, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    c5ac:	add.w	sp, sp, #512	; 0x200
    c5b0:	pop	{r4, r5, r6, pc}
    c5b2:	bl	c2c8 <waitTransferComplete() [clone .part.8]>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    c5b6:	cmp	r0, #0
    c5b8:	bne.n	c590 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4c>
      return false;
    c5ba:	movs	r0, #0
    c5bc:	b.n	c5ac <SdioCard::writeSector(unsigned long, unsigned char const*)+0x68>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    c5be:	ldr	r3, [r4, #4]
    c5c0:	cmp	r6, r3
    c5c2:	bne.n	c5a0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x5c>
    c5c4:	b.n	c5da <SdioCard::writeSector(unsigned long, unsigned char const*)+0x96>
      if (!syncDevice()) {
        return false;
      }
      if (!writeStart(sector )) {
    c5c6:	ldr	r3, [r4, #0]
    c5c8:	mov	r1, r6
    c5ca:	ldr	r3, [r3, #72]	; 0x48
    c5cc:	mov	r0, r4
    c5ce:	blx	r3
    c5d0:	cmp	r0, #0
    c5d2:	beq.n	c5aa <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    c5d4:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    c5d6:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    c5d8:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    c5da:	ldr	r3, [r4, #0]
    c5dc:	mov	r1, r5
    c5de:	ldr	r3, [r3, #68]	; 0x44
    c5e0:	mov	r0, r4
    c5e2:	blx	r3
    c5e4:	cmp	r0, #0
    c5e6:	beq.n	c5aa <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
      return false;
    }
    m_curSector++;
    c5e8:	ldr	r3, [r4, #4]
    c5ea:	adds	r3, #1
    c5ec:	str	r3, [r4, #4]
    c5ee:	b.n	c582 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    c5f0:	ldr	r3, [r4, #0]
    c5f2:	mov	r0, r4
    c5f4:	ldr	r3, [r3, #24]
    c5f6:	blx	r3
    c5f8:	cmp	r0, #0
    c5fa:	bne.n	c59a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x56>
    c5fc:	b.n	c5aa <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
    c5fe:	nop
    c600:	.word	0x183a0001
    c604:	.word	0x20000be0
    c608:	.word	0x20005138
    c60c:	.word	0x20005114
    c610:	.word	0x400b1004

0000c614 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    c614:	push	{r3, r4, r5, r6, r7, lr}
    c616:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    c618:	ldrb	r0, [r0, #8]
    c61a:	lsls	r0, r0, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    c61c:	mov	r4, r1
    c61e:	mov	r5, r2
    c620:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    c622:	bmi.n	c64c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    c624:	cbz	r3, c648 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    c626:	add	r7, r1
    c628:	b.n	c62e <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1a>
    c62a:	cmp	r4, r7
    c62c:	beq.n	c648 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
      if (!readSector(sector + i, dst + i*512UL)) {
    c62e:	ldr	r3, [r6, #0]
    c630:	mov	r2, r5
    c632:	mov	r1, r4
    c634:	ldr	r3, [r3, #12]
    c636:	mov	r0, r6
    c638:	blx	r3
    c63a:	adds	r4, #1
    c63c:	add.w	r5, r5, #512	; 0x200
    c640:	cmp	r0, #0
    c642:	bne.n	c62a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x16>
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
    c644:	movs	r0, #0
    c646:	pop	{r3, r4, r5, r6, r7, pc}
      if (!readSector(sector + i, dst + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    c648:	movs	r0, #1
    c64a:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
    c64c:	lsls	r0, r2, #30
    c64e:	beq.n	c676 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    c650:	cmp	r3, #0
    c652:	beq.n	c648 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    c654:	add	r7, r1
    c656:	b.n	c65c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    c658:	cmp	r7, r4
    c65a:	beq.n	c648 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
        if (!readSector(sector, dst)) {
    c65c:	ldr	r3, [r6, #0]
    c65e:	mov	r2, r5
    c660:	mov	r1, r4
    c662:	ldr	r3, [r3, #12]
    c664:	mov	r0, r6
    c666:	blx	r3
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    c668:	adds	r4, #1
    c66a:	add.w	r5, r5, #512	; 0x200
        if (!readSector(sector, dst)) {
    c66e:	cmp	r0, #0
    c670:	bne.n	c658 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x44>
          return false;  // readSector will set errorCode.
    c672:	movs	r0, #0
    c674:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    c676:	ldr	r0, [pc, #24]	; (c690 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x7c>)
    c678:	bl	c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    c67c:	cmp	r0, #0
    c67e:	bne.n	c648 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c680:	ldr	r1, [pc, #16]	; (c694 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x80>)
  m_errorLine = line;
    c682:	ldr	r3, [pc, #20]	; (c698 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c684:	movs	r4, #12
  m_errorLine = line;
    c686:	movw	r2, #909	; 0x38d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c68a:	strb	r4, [r1, #0]
  m_errorLine = line;
    c68c:	str	r2, [r3, #0]
    c68e:	pop	{r3, r4, r5, r6, r7, pc}
    c690:	.word	0x123a0037
    c694:	.word	0x20000be0
    c698:	.word	0x20005138

0000c69c <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    c69c:	push	{r3, r4, r5, r6, r7, lr}
    c69e:	mov	r5, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    c6a0:	ldr	r0, [pc, #116]	; (c718 <cardCMD6(unsigned long, unsigned char*)+0x7c>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    c6a2:	mov	r4, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    c6a4:	bl	beec <waitTimeout(bool (*)())>
    c6a8:	cbz	r0, c6bc <cardCMD6(unsigned long, unsigned char*)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6aa:	ldr	r1, [pc, #112]	; (c71c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    c6ac:	ldr	r3, [pc, #112]	; (c720 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6ae:	movs	r0, #10
  m_errorLine = line;
    c6b0:	mov.w	r2, #410	; 0x19a
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6b4:	strb	r0, [r1, #0]
  m_errorLine = line;
    c6b6:	str	r2, [r3, #0]
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c6b8:	movs	r0, #0
    c6ba:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c6bc:	ldr	r2, [pc, #100]	; (c724 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    c6be:	ldr.w	lr, [pc, #132]	; c744 <cardCMD6(unsigned long, unsigned char*)+0xa8>
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    c6c2:	ldr	r7, [pc, #100]	; (c728 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    c6c4:	ldr	r6, [pc, #100]	; (c72c <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c6c6:	ldr	r3, [pc, #104]	; (c730 <cardCMD6(unsigned long, unsigned char*)+0x94>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    c6c8:	mov.w	ip, #1
    c6cc:	strb.w	ip, [lr]
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    c6d0:	mov	r1, r5
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c6d2:	str	r0, [r2, #0]
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    c6d4:	ldr	r5, [pc, #92]	; (c734 <cardCMD6(unsigned long, unsigned char*)+0x98>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c6d6:	ldr	r2, [pc, #96]	; (c738 <cardCMD6(unsigned long, unsigned char*)+0x9c>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    c6d8:	str	r4, [r7, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    c6da:	ldr	r0, [pc, #96]	; (c73c <cardCMD6(unsigned long, unsigned char*)+0xa0>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    c6dc:	str	r5, [r6, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c6de:	str	r2, [r3, #0]
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    c6e0:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c6e4:	cbnz	r0, c6f6 <cardCMD6(unsigned long, unsigned char*)+0x5a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6e6:	ldr	r1, [pc, #52]	; (c71c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    c6e8:	ldr	r3, [pc, #52]	; (c720 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6ea:	movs	r4, #4
  m_errorLine = line;
    c6ec:	movw	r2, #417	; 0x1a1
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6f0:	strb	r4, [r1, #0]
  m_errorLine = line;
    c6f2:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    c6f4:	pop	{r3, r4, r5, r6, r7, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    c6f6:	ldr	r0, [pc, #72]	; (c740 <cardCMD6(unsigned long, unsigned char*)+0xa4>)
    c6f8:	bl	bf14 <yieldTimeout(bool (*)())>
    c6fc:	cbnz	r0, c706 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    c6fe:	bl	c09c <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    c702:	cbz	r0, c706 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    c704:	pop	{r3, r4, r5, r6, r7, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c706:	ldr	r1, [pc, #20]	; (c71c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    c708:	ldr	r3, [pc, #20]	; (c720 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c70a:	movs	r0, #37	; 0x25
  m_errorLine = line;
    c70c:	mov.w	r2, #420	; 0x1a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c710:	strb	r0, [r1, #0]
  m_errorLine = line;
    c712:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    c714:	movs	r0, #0
    c716:	pop	{r3, r4, r5, r6, r7, pc}
    c718:	.word	0x0000bfed
    c71c:	.word	0x20000be0
    c720:	.word	0x20005138
    c724:	.word	0x20005118
    c728:	.word	0x400b1000
    c72c:	.word	0x400b1004
    c730:	.word	0x400b1038
    c734:	.word	0x00010040
    c738:	.word	0x117f0002
    c73c:	.word	0x063a0011
    c740:	.word	0x0000bd71
    c744:	.word	0x20005130

0000c748 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    c748:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    c74c:	ldr	r5, [pc, #568]	; (c988 <SdioCard::begin(SdioConfig)+0x240>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    c74e:	ldr	r4, [pc, #572]	; (c98c <SdioCard::begin(SdioConfig)+0x244>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    c750:	ldr.w	r8, [pc, #684]	; ca00 <SdioCard::begin(SdioConfig)+0x2b8>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    c754:	ldr	r7, [pc, #568]	; (c990 <SdioCard::begin(SdioConfig)+0x248>)
  m_version2 = false;
    c756:	ldr	r6, [pc, #572]	; (c994 <SdioCard::begin(SdioConfig)+0x24c>)
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    c758:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    c75a:	movs	r3, #0
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    c75c:	strb	r3, [r5, #0]
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
    c75e:	strb	r3, [r0, #9]
  m_initDone = false;
    c760:	strb.w	r3, [r8]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    c764:	strb	r3, [r7, #0]
  m_version2 = false;
    c766:	strb	r3, [r6, #0]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    c768:	ldr	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    c76a:	ldr	r2, [pc, #556]	; (c998 <SdioCard::begin(SdioConfig)+0x250>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    c76c:	ldr	r0, [pc, #556]	; (c99c <SdioCard::begin(SdioConfig)+0x254>)
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    c76e:	ldr	r1, [pc, #560]	; (c9a0 <SdioCard::begin(SdioConfig)+0x258>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    c770:	ldr.w	lr, [pc, #656]	; ca04 <SdioCard::begin(SdioConfig)+0x2bc>
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    c774:	orr.w	r3, r3, #201326592	; 0xc000000
    c778:	str	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    c77a:	ldr	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    c77c:	add.w	r4, r4, #260096	; 0x3f800
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    c780:	orr.w	r3, r3, #131072	; 0x20000
    c784:	str	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    c786:	adds	r4, #12
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    c788:	add.w	r2, r2, #428032	; 0x68800
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    c78c:	movw	r3, #259	; 0x103
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    c790:	addw	r2, r2, #2044	; 0x7fc
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    c794:	str	r3, [r0, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    c796:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    c79a:	str	r3, [r1, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    c79c:	str	r3, [r4, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    c79e:	str	r3, [r0, #16]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    c7a0:	str	r3, [r1, #12]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    c7a2:	ldr	r3, [r2, #0]
    c7a4:	orr.w	r3, r3, #16777216	; 0x1000000
    c7a8:	orr.w	r3, r3, #32768	; 0x8000
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    c7ac:	sub	sp, #68	; 0x44
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    c7ae:	str	r3, [r2, #0]

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    c7b0:	ldr	r3, [r2, #0]
    c7b2:	ldr	r4, [pc, #496]	; (c9a4 <SdioCard::begin(SdioConfig)+0x25c>)
    c7b4:	lsls	r1, r3, #7
    c7b6:	bmi.n	c7b0 <SdioCard::begin(SdioConfig)+0x68>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    c7b8:	mov.w	r0, #400	; 0x190
    c7bc:	bl	bdbc <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    c7c0:	ldr.w	ip, [pc, #472]	; c99c <SdioCard::begin(SdioConfig)+0x254>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    c7c4:	ldr.w	lr, [pc, #572]	; ca04 <SdioCard::begin(SdioConfig)+0x2bc>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    c7c8:	ldr	r1, [pc, #468]	; (c9a0 <SdioCard::begin(SdioConfig)+0x258>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    c7ca:	ldr	r2, [pc, #476]	; (c9a8 <SdioCard::begin(SdioConfig)+0x260>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    c7cc:	ldr	r0, [pc, #476]	; (c9ac <SdioCard::begin(SdioConfig)+0x264>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    c7ce:	movw	r3, #1091	; 0x443
    c7d2:	str.w	r3, [ip]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    c7d6:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    c7da:	mov.w	lr, #1088	; 0x440
    c7de:	str.w	lr, [r1]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    c7e2:	str	r3, [r2, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    c7e4:	add.w	r2, r2, #409600	; 0x64000
    c7e8:	adds	r2, #40	; 0x28

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    c7ea:	str	r3, [r0, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    c7ec:	ldr	r0, [pc, #448]	; (c9b0 <SdioCard::begin(SdioConfig)+0x268>)
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    c7ee:	str	r3, [r1, #12]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    c7f0:	str	r0, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    c7f2:	ldr	r1, [pc, #448]	; (c9b4 <SdioCard::begin(SdioConfig)+0x26c>)
    c7f4:	movs	r0, #81	; 0x51
    c7f6:	bl	d9c0 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    c7fa:	ldr	r3, [pc, #444]	; (c9b8 <SdioCard::begin(SdioConfig)+0x270>)

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    c7fc:	ldr	r1, [pc, #444]	; (c9bc <SdioCard::begin(SdioConfig)+0x274>)
    c7fe:	movs	r0, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    c800:	mov.w	r2, #131072	; 0x20000

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    c804:	strb	r0, [r1, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    c806:	str	r2, [r3, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    c808:	ldr	r3, [r4, #0]
    c80a:	orr.w	r3, r3, #134217728	; 0x8000000
    c80e:	str	r3, [r4, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    c810:	ldr	r1, [r4, #0]
    c812:	ands.w	r1, r1, #134217728	; 0x8000000
    c816:	bne.n	c810 <SdioCard::begin(SdioConfig)+0xc8>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    c818:	mov	r0, r1
    c81a:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c81e:	mov	r4, r0
    c820:	cmp	r0, #0
    c822:	beq.n	c8c2 <SdioCard::begin(SdioConfig)+0x17a>
    c824:	movs	r4, #3
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    c826:	mov.w	r1, #426	; 0x1aa
    c82a:	ldr	r0, [pc, #404]	; (c9c0 <SdioCard::begin(SdioConfig)+0x278>)
    c82c:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c830:	cmp	r0, #0
    c832:	bne.n	c8f0 <SdioCard::begin(SdioConfig)+0x1a8>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    c834:	subs	r4, #1
    c836:	bne.n	c826 <SdioCard::begin(SdioConfig)+0xde>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    c838:	ldrb	r3, [r6, #0]
    c83a:	ldr	r6, [pc, #392]	; (c9c4 <SdioCard::begin(SdioConfig)+0x27c>)
    c83c:	cmp	r3, #0
    c83e:	it	eq
    c840:	moveq.w	r6, #3145728	; 0x300000
  int m = micros();
    c844:	bl	da0c <micros>
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    c848:	ldr	r4, [pc, #380]	; (c9c8 <SdioCard::begin(SdioConfig)+0x280>)
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
    c84a:	mov	r9, r0
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    c84c:	movs	r1, #0
    c84e:	ldr	r0, [pc, #380]	; (c9cc <SdioCard::begin(SdioConfig)+0x284>)
    c850:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c854:	cbnz	r0, c86c <SdioCard::begin(SdioConfig)+0x124>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c856:	ldr	r2, [pc, #376]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c858:	mov.w	r1, #676	; 0x2a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c85c:	movs	r3, #23
  m_errorLine = line;
    c85e:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c860:	strb	r3, [r5, #0]
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    c862:	movs	r4, #0

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    c864:	mov	r0, r4
    c866:	add	sp, #68	; 0x44
    c868:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    c86c:	mov	r1, r6
    c86e:	ldr	r0, [pc, #356]	; (c9d4 <SdioCard::begin(SdioConfig)+0x28c>)
    c870:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c874:	cmp	r0, #0
    c876:	beq.n	c856 <SdioCard::begin(SdioConfig)+0x10e>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    c878:	bl	da0c <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    c87c:	ldr	r3, [pc, #344]	; (c9d8 <SdioCard::begin(SdioConfig)+0x290>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    c87e:	ldr	r2, [pc, #328]	; (c9c8 <SdioCard::begin(SdioConfig)+0x280>)
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    c880:	rsb	r0, r9, r0
    c884:	cmp	r0, r3
    c886:	bhi.n	c856 <SdioCard::begin(SdioConfig)+0x10e>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    c888:	ldr	r3, [r4, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    c88a:	cmp	r3, #0
    c88c:	bge.n	c84c <SdioCard::begin(SdioConfig)+0x104>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    c88e:	ldr	r3, [pc, #332]	; (c9dc <SdioCard::begin(SdioConfig)+0x294>)
    c890:	ldr	r1, [r2, #0]
    c892:	str	r1, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    c894:	ldr	r3, [r2, #0]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    c896:	ldr	r0, [pc, #328]	; (c9e0 <SdioCard::begin(SdioConfig)+0x298>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    c898:	lsls	r2, r3, #1
    // Is high capacity.
    m_highCapacity = true;
    c89a:	it	mi
    c89c:	movmi	r3, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    c89e:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    c8a2:	it	mi
    c8a4:	strbmi	r3, [r7, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    c8a6:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c8aa:	mov	r4, r0
    c8ac:	cbnz	r0, c8d6 <SdioCard::begin(SdioConfig)+0x18e>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8ae:	ldr	r2, [pc, #288]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c8b0:	movw	r1, #685	; 0x2ad
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8b4:	movs	r3, #2

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    c8b6:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8b8:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8ba:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    c8bc:	add	sp, #68	; 0x44
    c8be:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8c2:	ldr	r2, [pc, #268]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c8c4:	movw	r1, #659	; 0x293
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8c8:	movs	r3, #1

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    c8ca:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8cc:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8ce:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    c8d0:	add	sp, #68	; 0x44
    c8d2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    c8d6:	movs	r1, #0
    c8d8:	ldr	r0, [pc, #264]	; (c9e4 <SdioCard::begin(SdioConfig)+0x29c>)
    c8da:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c8de:	mov	r4, r0
    c8e0:	cbnz	r0, c912 <SdioCard::begin(SdioConfig)+0x1ca>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8e2:	ldr	r2, [pc, #236]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c8e4:	mov.w	r1, #688	; 0x2b0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8e8:	movs	r3, #3
  m_errorLine = line;
    c8ea:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c8ec:	strb	r3, [r5, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
    c8ee:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
    c8f0:	ldr	r3, [pc, #212]	; (c9c8 <SdioCard::begin(SdioConfig)+0x280>)
    c8f2:	ldr	r3, [r3, #0]
    c8f4:	cmp.w	r3, #426	; 0x1aa
    c8f8:	beq.n	c90a <SdioCard::begin(SdioConfig)+0x1c2>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c8fa:	ldr	r2, [pc, #212]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c8fc:	movw	r1, #665	; 0x299
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c900:	movs	r3, #6
  m_errorLine = line;
    c902:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c904:	strb	r3, [r5, #0]
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
    c906:	movs	r4, #0
    c908:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
      }
      m_version2 = true;
    c90a:	movs	r3, #1
    c90c:	strb	r3, [r6, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    c90e:	ldr	r6, [pc, #180]	; (c9c4 <SdioCard::begin(SdioConfig)+0x27c>)
    c910:	b.n	c844 <SdioCard::begin(SdioConfig)+0xfc>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    c912:	ldr	r3, [pc, #180]	; (c9c8 <SdioCard::begin(SdioConfig)+0x280>)
    c914:	ldr	r6, [pc, #208]	; (c9e8 <SdioCard::begin(SdioConfig)+0x2a0>)
    c916:	ldr	r3, [r3, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    c918:	ldr	r1, [pc, #208]	; (c9ec <SdioCard::begin(SdioConfig)+0x2a4>)
    c91a:	ldr	r0, [pc, #212]	; (c9f0 <SdioCard::begin(SdioConfig)+0x2a8>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    c91c:	lsrs	r3, r3, #16
    c91e:	lsls	r3, r3, #16
    c920:	str	r3, [r6, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    c922:	bl	c038 <readReg16(unsigned long, void*)>
    c926:	mov	r4, r0
    c928:	cbnz	r0, c938 <SdioCard::begin(SdioConfig)+0x1f0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c92a:	ldr	r2, [pc, #164]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c92c:	movw	r1, #693	; 0x2b5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c930:	movs	r3, #7
  m_errorLine = line;
    c932:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c934:	strb	r3, [r5, #0]
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
    c936:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    c938:	ldr	r1, [pc, #184]	; (c9f4 <SdioCard::begin(SdioConfig)+0x2ac>)
    c93a:	ldr	r0, [pc, #188]	; (c9f8 <SdioCard::begin(SdioConfig)+0x2b0>)
    c93c:	bl	c038 <readReg16(unsigned long, void*)>
    c940:	mov	r4, r0
    c942:	cbnz	r0, c952 <SdioCard::begin(SdioConfig)+0x20a>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c944:	ldr	r2, [pc, #136]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c946:	mov.w	r1, #696	; 0x2b8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c94a:	movs	r3, #8
  m_errorLine = line;
    c94c:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c94e:	strb	r3, [r5, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
    c950:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    c952:	ldr	r1, [r6, #0]
    c954:	ldr	r0, [pc, #164]	; (c9fc <SdioCard::begin(SdioConfig)+0x2b4>)
    c956:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c95a:	mov	r4, r0
    c95c:	cbnz	r0, c96c <SdioCard::begin(SdioConfig)+0x224>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c95e:	ldr	r2, [pc, #112]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c960:	movw	r1, #699	; 0x2bb
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c964:	movs	r3, #5
  m_errorLine = line;
    c966:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c968:	strb	r3, [r5, #0]
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
    c96a:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    c96c:	ldr	r1, [r6, #0]
    c96e:	ldr	r0, [pc, #92]	; (c9cc <SdioCard::begin(SdioConfig)+0x284>)
    c970:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    c974:	cmp	r0, #0
    c976:	bne.n	ca08 <SdioCard::begin(SdioConfig)+0x2c0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c978:	ldr	r2, [pc, #84]	; (c9d0 <SdioCard::begin(SdioConfig)+0x288>)
    c97a:	movw	r1, #703	; 0x2bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c97e:	movs	r3, #20
  m_errorLine = line;
    c980:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c982:	strb	r3, [r5, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    c984:	movs	r4, #0
    c986:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>
    c988:	.word	0x20000be0
    c98c:	.word	0x4000d800
    c990:	.word	0x20005108
    c994:	.word	0x200050f0
    c998:	.word	0x40048030
    c99c:	.word	0x4004d000
    c9a0:	.word	0x4004d008
    c9a4:	.word	0x400b102c
    c9a8:	.word	0x4004d00c
    c9ac:	.word	0x4004d010
    c9b0:	.word	0x117f000b
    c9b4:	.word	0x0000bd05
    c9b8:	.word	0xe000e108
    c9bc:	.word	0xe000e451
    c9c0:	.word	0x081a0000
    c9c4:	.word	0x40300000
    c9c8:	.word	0x400b1010
    c9cc:	.word	0x371a0000
    c9d0:	.word	0x20005138
    c9d4:	.word	0x29020000
    c9d8:	.word	0x000f4240
    c9dc:	.word	0x2000510c
    c9e0:	.word	0x02090000
    c9e4:	.word	0x031a0000
    c9e8:	.word	0x20005110
    c9ec:	.word	0x20005120
    c9f0:	.word	0x09090000
    c9f4:	.word	0x200050f4
    c9f8:	.word	0x0a090000
    c9fc:	.word	0x071b0000
    ca00:	.word	0x2000511c
    ca04:	.word	0x4004d004
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    ca08:	movs	r1, #2
    ca0a:	ldr	r0, [pc, #168]	; (cab4 <SdioCard::begin(SdioConfig)+0x36c>)
    ca0c:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    ca10:	mov	r4, r0
    ca12:	cmp	r0, #0
    ca14:	beq.n	c978 <SdioCard::begin(SdioConfig)+0x230>
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    ca16:	ldr	r3, [pc, #160]	; (cab8 <SdioCard::begin(SdioConfig)+0x370>)
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ca18:	ldr	r0, [pc, #160]	; (cabc <SdioCard::begin(SdioConfig)+0x374>)
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    ca1a:	ldr	r2, [r3, #0]
    ca1c:	bic.w	r2, r2, #6
    ca20:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    ca22:	ldr	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ca24:	mov.w	r5, #1048592	; 0x100010
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    ca28:	orr.w	r2, r2, #2
    ca2c:	str	r2, [r3, #0]
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ca2e:	mov	r1, sp
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ca30:	str	r5, [r0, #0]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ca32:	mvn.w	r0, #4278190080	; 0xff000000
    ca36:	bl	c69c <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    ca3a:	cbz	r0, ca44 <SdioCard::begin(SdioConfig)+0x2fc>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ca3c:	ldrb.w	r3, [sp, #13]
    ca40:	lsls	r3, r3, #30
    ca42:	bmi.n	ca96 <SdioCard::begin(SdioConfig)+0x34e>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    ca44:	movw	r0, #25000	; 0x61a8
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ca48:	ldr.w	fp, [pc, #132]	; cad0 <SdioCard::begin(SdioConfig)+0x388>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ca4c:	ldr.w	sl, [pc, #132]	; cad4 <SdioCard::begin(SdioConfig)+0x38c>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ca50:	ldr.w	r9, [pc, #132]	; cad8 <SdioCard::begin(SdioConfig)+0x390>
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ca54:	ldr	r7, [pc, #104]	; (cac0 <SdioCard::begin(SdioConfig)+0x378>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ca56:	ldr	r6, [pc, #108]	; (cac4 <SdioCard::begin(SdioConfig)+0x37c>)
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ca58:	ldr	r5, [pc, #108]	; (cac8 <SdioCard::begin(SdioConfig)+0x380>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ca5a:	movw	r3, #259	; 0x103
    ca5e:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ca62:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ca66:	str.w	r3, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ca6a:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ca6c:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ca6e:	str	r3, [r5, #0]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    ca70:	bl	bdbc <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ca74:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ca78:	mov.w	r1, #1088	; 0x440
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    ca7c:	movs	r2, #1
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ca7e:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ca82:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ca86:	str.w	r1, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ca8a:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ca8c:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ca8e:	str	r3, [r5, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    ca90:	strb.w	r2, [r8]
  return true;
    ca94:	b.n	c864 <SdioCard::begin(SdioConfig)+0x11c>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    ca96:	mov	r1, sp
    ca98:	ldr	r0, [pc, #48]	; (cacc <SdioCard::begin(SdioConfig)+0x384>)
    ca9a:	bl	c69c <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ca9e:	cmp	r0, #0
    caa0:	beq.n	ca44 <SdioCard::begin(SdioConfig)+0x2fc>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    caa2:	ldrb.w	r3, [sp, #16]
    caa6:	and.w	r3, r3, #15
    caaa:	cmp	r3, #1
    caac:	bne.n	ca44 <SdioCard::begin(SdioConfig)+0x2fc>
    kHzSdClk = 50000;
    caae:	movw	r0, #50000	; 0xc350
    cab2:	b.n	ca48 <SdioCard::begin(SdioConfig)+0x300>
    cab4:	.word	0x061a0000
    cab8:	.word	0x400b1028
    cabc:	.word	0x400b1044
    cac0:	.word	0x4004d00c
    cac4:	.word	0x4004d010
    cac8:	.word	0x4004d014
    cacc:	.word	0x80fffff1
    cad0:	.word	0x4004d000
    cad4:	.word	0x4004d004
    cad8:	.word	0x4004d008

0000cadc <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    cadc:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    cade:	ldr	r3, [pc, #160]	; (cb80 <SdioCard::readData(unsigned char*)+0xa4>)
    cae0:	ldr	r3, [r3, #0]
    cae2:	lsls	r0, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    cae4:	mov	r5, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    cae6:	bmi.n	cb06 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cae8:	ldr	r3, [pc, #152]	; (cb84 <SdioCard::readData(unsigned char*)+0xa8>)
    caea:	ldr	r2, [r3, #0]
    caec:	bic.w	r2, r2, #65536	; 0x10000
    caf0:	str	r2, [r3, #0]
    noInterrupts();
    caf2:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    caf4:	ldr	r2, [r3, #0]
    caf6:	orr.w	r2, r2, #131072	; 0x20000
    cafa:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cafc:	ldr	r2, [r3, #0]
    cafe:	orr.w	r2, r2, #65536	; 0x10000
    cb02:	str	r2, [r3, #0]
    interrupts();
    cb04:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    cb06:	ldr	r0, [pc, #128]	; (cb88 <SdioCard::readData(unsigned char*)+0xac>)
    cb08:	bl	beec <waitTimeout(bool (*)())>
    cb0c:	cmp	r0, #0
    cb0e:	bne.n	cb6e <SdioCard::readData(unsigned char*)+0x92>
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    cb10:	ldr	r4, [pc, #108]	; (cb80 <SdioCard::readData(unsigned char*)+0xa4>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    cb12:	ldr	r0, [pc, #120]	; (cb8c <SdioCard::readData(unsigned char*)+0xb0>)
    cb14:	subs	r3, r5, #4
    cb16:	add.w	r5, r5, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    cb1a:	ldr	r2, [r4, #0]
    cb1c:	lsls	r1, r2, #20
    cb1e:	bpl.n	cb1a <SdioCard::readData(unsigned char*)+0x3e>
    cb20:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    cb24:	ldr	r2, [r0, #0]
    cb26:	str.w	r2, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    cb2a:	cmp	r1, r3
    cb2c:	bne.n	cb24 <SdioCard::readData(unsigned char*)+0x48>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    cb2e:	cmp	r5, r1
    cb30:	mov	r3, r1
    cb32:	bne.n	cb1a <SdioCard::readData(unsigned char*)+0x3e>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    cb34:	ldr	r0, [pc, #88]	; (cb90 <SdioCard::readData(unsigned char*)+0xb4>)
    cb36:	bl	beec <waitTimeout(bool (*)())>
    cb3a:	cbnz	r0, cb5c <SdioCard::readData(unsigned char*)+0x80>
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    cb3c:	ldr	r2, [pc, #84]	; (cb94 <SdioCard::readData(unsigned char*)+0xb8>)
    cb3e:	ldr	r3, [pc, #88]	; (cb98 <SdioCard::readData(unsigned char*)+0xbc>)
    cb40:	ldr	r1, [r2, #0]
    cb42:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    cb44:	ldr	r1, [r3, #0]
    cb46:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    cb48:	ldr	r2, [r3, #0]
    cb4a:	lsls	r2, r2, #30
    cb4c:	bpl.n	cb7e <SdioCard::readData(unsigned char*)+0xa2>
    cb4e:	ldr	r3, [r3, #0]
    cb50:	ldr	r0, [pc, #72]	; (cb9c <SdioCard::readData(unsigned char*)+0xc0>)
    cb52:	ands	r0, r3
    cb54:	clz	r0, r0
    cb58:	lsrs	r0, r0, #5
    cb5a:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb5c:	ldr	r1, [pc, #64]	; (cba0 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    cb5e:	ldr	r3, [pc, #68]	; (cba4 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb60:	movs	r0, #29
  m_errorLine = line;
    cb62:	movw	r2, #843	; 0x34b
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb66:	strb	r0, [r1, #0]
  m_errorLine = line;
    cb68:	str	r2, [r3, #0]
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
    cb6a:	movs	r0, #0
    cb6c:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb6e:	ldr	r1, [pc, #48]	; (cba0 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    cb70:	ldr	r3, [pc, #48]	; (cba4 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb72:	movs	r0, #26
  m_errorLine = line;
    cb74:	mov.w	r2, #832	; 0x340
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb78:	strb	r0, [r1, #0]
  m_errorLine = line;
    cb7a:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    cb7c:	movs	r0, #0
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    cb7e:	pop	{r3, r4, r5, pc}
    cb80:	.word	0x400b1024
    cb84:	.word	0x400b1028
    cb88:	.word	0x0000bd7d
    cb8c:	.word	0x400b1020
    cb90:	.word	0x0000bda5
    cb94:	.word	0x400b1030
    cb98:	.word	0x20005118
    cb9c:	.word	0x117f0000
    cba0:	.word	0x20000be0
    cba4:	.word	0x20005138

0000cba8 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    cba8:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    cbaa:	ldr	r0, [pc, #80]	; (cbfc <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    cbac:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    cbae:	bl	bf14 <yieldTimeout(bool (*)())>
    cbb2:	cbnz	r0, cbe8 <SdioCard::readStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cbb4:	ldr	r2, [pc, #72]	; (cc00 <SdioCard::readStart(unsigned long)+0x58>)
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cbb6:	ldr	r1, [pc, #76]	; (cc04 <SdioCard::readStart(unsigned long)+0x5c>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cbb8:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    cbba:	ldr	r0, [pc, #76]	; (cc08 <SdioCard::readStart(unsigned long)+0x60>)
    cbbc:	ldr	r5, [pc, #76]	; (cc0c <SdioCard::readStart(unsigned long)+0x64>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cbbe:	orr.w	r3, r3, #65536	; 0x10000
    cbc2:	str	r3, [r2, #0]
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cbc4:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    cbc6:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cbc8:	cbnz	r3, cbe4 <SdioCard::readStart(unsigned long)+0x3c>
    cbca:	lsls	r1, r4, #9
    cbcc:	ldr	r0, [pc, #64]	; (cc10 <SdioCard::readStart(unsigned long)+0x68>)
    cbce:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    cbd2:	cbnz	r0, cbe2 <SdioCard::readStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbd4:	ldr	r1, [pc, #60]	; (cc14 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    cbd6:	ldr	r3, [pc, #64]	; (cc18 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbd8:	movs	r4, #12
  m_errorLine = line;
    cbda:	movw	r2, #937	; 0x3a9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbde:	strb	r4, [r1, #0]
  m_errorLine = line;
    cbe0:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    cbe2:	pop	{r3, r4, r5, pc}
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cbe4:	mov	r1, r4
    cbe6:	b.n	cbcc <SdioCard::readStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbe8:	ldr	r1, [pc, #40]	; (cc14 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    cbea:	ldr	r3, [pc, #44]	; (cc18 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbec:	movs	r0, #10
  m_errorLine = line;
    cbee:	movw	r2, #925	; 0x39d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cbf2:	strb	r0, [r1, #0]
  m_errorLine = line;
    cbf4:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    cbf6:	movs	r0, #0
    cbf8:	pop	{r3, r4, r5, pc}
    cbfa:	nop
    cbfc:	.word	0x0000bfed
    cc00:	.word	0x400b1028
    cc04:	.word	0x20005108
    cc08:	.word	0x400b1004
    cc0c:	.word	0xffff0200
    cc10:	.word	0x123a0032
    cc14:	.word	0x20000be0
    cc18:	.word	0x20005138

0000cc1c <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    cc1c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    cc1e:	ldrb	r3, [r0, #8]
    cc20:	lsls	r4, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    cc22:	sub.w	sp, sp, #512	; 0x200
    cc26:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    cc28:	bpl.n	cc50 <SdioCard::readSector(unsigned long, unsigned char*)+0x34>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    cc2a:	lsls	r3, r2, #30
    cc2c:	beq.n	cc74 <SdioCard::readSector(unsigned long, unsigned char*)+0x58>

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    cc2e:	mov	r2, sp
    cc30:	movs	r3, #1
    cc32:	ldr	r0, [pc, #196]	; (ccf8 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    cc34:	bl	c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    cc38:	cbz	r0, cc80 <SdioCard::readSector(unsigned long, unsigned char*)+0x64>
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    cc3a:	mov	r1, sp
    cc3c:	mov	r0, r5
    cc3e:	mov.w	r2, #512	; 0x200
    cc42:	bl	cfd4 <memcpy>
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
    cc46:	movs	r5, #1
}
    cc48:	mov	r0, r5
    cc4a:	add.w	sp, sp, #512	; 0x200
    cc4e:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    cc50:	ldr	r3, [pc, #168]	; (ccfc <SdioCard::readSector(unsigned long, unsigned char*)+0xe0>)
    cc52:	ldrb	r3, [r3, #0]
    cc54:	mov	r4, r0
    cc56:	mov	r6, r1
    cc58:	cbnz	r3, ccac <SdioCard::readSector(unsigned long, unsigned char*)+0x90>
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    cc5a:	ldrb	r3, [r4, #9]
    cc5c:	cmp	r3, #1
    cc5e:	beq.n	cc98 <SdioCard::readSector(unsigned long, unsigned char*)+0x7c>
      if (!syncDevice()) {
    cc60:	ldr	r3, [r4, #0]
    cc62:	mov	r0, r4
    cc64:	ldr	r3, [r3, #24]
    cc66:	blx	r3
    cc68:	cbnz	r0, ccb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    cc6a:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    cc6c:	mov	r0, r5
    cc6e:	add.w	sp, sp, #512	; 0x200
    cc72:	pop	{r4, r5, r6, pc}
  if (m_sdioConfig.useDma()) {
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    cc74:	movs	r3, #1
    cc76:	ldr	r0, [pc, #128]	; (ccf8 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    cc78:	bl	c0bc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    cc7c:	cmp	r0, #0
    cc7e:	bne.n	cc46 <SdioCard::readSector(unsigned long, unsigned char*)+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cc80:	ldr	r1, [pc, #124]	; (cd00 <SdioCard::readSector(unsigned long, unsigned char*)+0xe4>)
  m_errorLine = line;
    cc82:	ldr	r3, [pc, #128]	; (cd04 <SdioCard::readSector(unsigned long, unsigned char*)+0xe8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cc84:	movs	r0, #11
  m_errorLine = line;
    cc86:	movw	r2, #862	; 0x35e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cc8a:	strb	r0, [r1, #0]
  m_errorLine = line;
    cc8c:	str	r2, [r3, #0]
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    cc8e:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    cc90:	mov	r0, r5
    cc92:	add.w	sp, sp, #512	; 0x200
    cc96:	pop	{r4, r5, r6, pc}
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    cc98:	ldr	r3, [r4, #4]
    cc9a:	cmp	r6, r3
    cc9c:	beq.n	ccca <SdioCard::readSector(unsigned long, unsigned char*)+0xae>
      if (!syncDevice()) {
    cc9e:	ldr	r3, [r4, #0]
    cca0:	mov	r0, r4
    cca2:	ldr	r3, [r3, #24]
    cca4:	blx	r3
    cca6:	cmp	r0, #0
    cca8:	beq.n	cc6a <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    ccaa:	b.n	ccb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
    ccac:	bl	c2c8 <waitTransferComplete() [clone .part.8]>
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    ccb0:	cmp	r0, #0
    ccb2:	bne.n	cc5a <SdioCard::readSector(unsigned long, unsigned char*)+0x3e>
      return false;
    ccb4:	movs	r5, #0
    ccb6:	b.n	cc6c <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
      if (!syncDevice()) {
        return false;
      }
      if (!readStart(sector)) {
    ccb8:	mov	r1, r6
    ccba:	mov	r0, r4
    ccbc:	bl	cba8 <SdioCard::readStart(unsigned long)>
    ccc0:	cmp	r0, #0
    ccc2:	beq.n	cc6a <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    ccc4:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    ccc6:	str	r6, [r4, #4]
      m_curState = READ_STATE;
    ccc8:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    ccca:	mov	r1, r5
    cccc:	mov	r0, r4
    ccce:	bl	cadc <SdioCard::readData(unsigned char*)>
    ccd2:	mov	r5, r0
    ccd4:	cmp	r0, #0
    ccd6:	beq.n	cc6a <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    ccd8:	ldr	r3, [pc, #44]	; (cd08 <SdioCard::readSector(unsigned long, unsigned char*)+0xec>)
    ccda:	ldr	r3, [r3, #0]
    ccdc:	lsrs	r3, r3, #16
    ccde:	lsls	r3, r3, #16
    cce0:	cbz	r3, ccea <SdioCard::readSector(unsigned long, unsigned char*)+0xce>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    cce2:	ldr	r3, [r4, #4]
    cce4:	adds	r3, #1
    cce6:	str	r3, [r4, #4]
    cce8:	b.n	cc90 <SdioCard::readSector(unsigned long, unsigned char*)+0x74>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    ccea:	ldr	r3, [r4, #0]
    ccec:	mov	r0, r4
    ccee:	ldr	r3, [r3, #24]
    ccf0:	blx	r3
    ccf2:	cmp	r0, #0
    ccf4:	bne.n	cce2 <SdioCard::readSector(unsigned long, unsigned char*)+0xc6>
    ccf6:	b.n	cc6a <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    ccf8:	.word	0x113a0011
    ccfc:	.word	0x20005114
    cd00:	.word	0x20000be0
    cd04:	.word	0x20005138
    cd08:	.word	0x400b1004

0000cd0c <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    cd0c:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cd0e:	ldr	r2, [pc, #80]	; (cd60 <SdioCard::stopTransmission(bool)+0x54>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    cd10:	movs	r5, #0
    cd12:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cd14:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    cd16:	ldr	r0, [pc, #76]	; (cd64 <SdioCard::stopTransmission(bool)+0x58>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cd18:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    cd1c:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cd1e:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    cd20:	mov	r1, r5
    cd22:	bl	bf90 <cardCommand(unsigned long, unsigned long)>
    cd26:	mov	r4, r0
    cd28:	cbz	r0, cd4e <SdioCard::stopTransmission(bool)+0x42>
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    cd2a:	cbnz	r6, cd30 <SdioCard::stopTransmission(bool)+0x24>
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    cd2c:	mov	r0, r4
    cd2e:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
    cd30:	ldr	r0, [pc, #52]	; (cd68 <SdioCard::stopTransmission(bool)+0x5c>)
    cd32:	bl	bf14 <yieldTimeout(bool (*)())>
    cd36:	cmp	r0, #0
    cd38:	beq.n	cd2c <SdioCard::stopTransmission(bool)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd3a:	ldr	r1, [pc, #48]	; (cd6c <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    cd3c:	ldr	r3, [pc, #48]	; (cd70 <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd3e:	movs	r0, #10
  m_errorLine = line;
    cd40:	movw	r2, #963	; 0x3c3
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    cd44:	mov	r4, r5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd46:	strb	r0, [r1, #0]
  m_errorLine = line;
    cd48:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    cd4a:	mov	r0, r4
    cd4c:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd4e:	ldr	r1, [pc, #28]	; (cd6c <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    cd50:	ldr	r3, [pc, #28]	; (cd70 <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd52:	movs	r0, #9
  m_errorLine = line;
    cd54:	movw	r2, #959	; 0x3bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd58:	strb	r0, [r1, #0]
  m_errorLine = line;
    cd5a:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    cd5c:	mov	r0, r4
    cd5e:	pop	{r4, r5, r6, pc}
    cd60:	.word	0x400b1028
    cd64:	.word	0x0cdb0000
    cd68:	.word	0x0000bd5d
    cd6c:	.word	0x20000be0
    cd70:	.word	0x20005138

0000cd74 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    cd74:	push	{r4, r5, r6, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    cd76:	ldrb	r3, [r0, #8]
    cd78:	ands.w	r3, r3, #1
    cd7c:	beq.n	cd8a <SdioCard::isBusy()+0x16>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    cd7e:	ldr	r3, [pc, #88]	; (cdd8 <SdioCard::isBusy()+0x64>)
    cd80:	ldr	r3, [r3, #0]
    cd82:	cbz	r3, cdbc <SdioCard::isBusy()+0x48>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    cd84:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    cd88:	bx	r3
  } else {
    if (m_transferActive) {
    cd8a:	ldr	r2, [pc, #80]	; (cddc <SdioCard::isBusy()+0x68>)
    cd8c:	ldrb	r4, [r2, #0]
    cd8e:	cbnz	r4, cda0 <SdioCard::isBusy()+0x2c>
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    cd90:	ldr	r3, [pc, #76]	; (cde0 <SdioCard::isBusy()+0x6c>)
    cd92:	ldr	r4, [r3, #0]
    cd94:	eor.w	r4, r4, #16777216	; 0x1000000
    cd98:	ubfx	r4, r4, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    cd9c:	mov	r0, r4
    cd9e:	pop	{r4, r5, r6, pc}
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    cda0:	ldr	r5, [pc, #64]	; (cde4 <SdioCard::isBusy()+0x70>)
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    cda2:	ldr	r1, [pc, #68]	; (cde8 <SdioCard::isBusy()+0x74>)
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    cda4:	ldr	r5, [r5, #0]
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    cda6:	ands	r1, r5
    cda8:	cmp	r1, #0
    cdaa:	beq.n	cd9c <SdioCard::isBusy()+0x28>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    cdac:	ldr	r1, [pc, #60]	; (cdec <SdioCard::isBusy()+0x78>)
    cdae:	ldr	r5, [r1, #0]
    cdb0:	lsrs	r5, r5, #16
    cdb2:	lsls	r5, r5, #16
    cdb4:	cbz	r5, cdcc <SdioCard::isBusy()+0x58>
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    cdb6:	mov	r4, r3
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    cdb8:	mov	r0, r4
    cdba:	pop	{r4, r5, r6, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    cdbc:	ldr	r3, [pc, #48]	; (cdf0 <SdioCard::isBusy()+0x7c>)
    cdbe:	ldrb	r4, [r3, #0]
    cdc0:	cmp	r4, #0
    cdc2:	beq.n	cd9c <SdioCard::isBusy()+0x28>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    cdc4:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    cdc8:	b.w	bfec <isBusyCMD13()>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
      stopTransmission(false);
    cdcc:	mov	r1, r5
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
    cdce:	strb	r5, [r2, #0]
      stopTransmission(false);
    cdd0:	bl	cd0c <SdioCard::stopTransmission(bool)>
    cdd4:	b.n	cd9c <SdioCard::isBusy()+0x28>
    cdd6:	nop
    cdd8:	.word	0x20005104
    cddc:	.word	0x20005114
    cde0:	.word	0x400b1024
    cde4:	.word	0x400b1030
    cde8:	.word	0x117f0002
    cdec:	.word	0x400b1004
    cdf0:	.word	0x2000511c

0000cdf4 <SdioCard::syncDevice()>:
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    cdf4:	ldr	r3, [pc, #36]	; (ce1c <SdioCard::syncDevice()+0x28>)
    cdf6:	ldrb	r3, [r3, #0]
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    cdf8:	push	{r4, lr}
    cdfa:	mov	r4, r0
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    cdfc:	cbnz	r3, ce12 <SdioCard::syncDevice()+0x1e>
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    cdfe:	ldrb	r3, [r4, #9]
    ce00:	cbnz	r3, ce06 <SdioCard::syncDevice()+0x12>
    if (!writeStop()) {
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
    ce02:	movs	r0, #1
    ce04:	pop	{r4, pc}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    ce06:	mov	r0, r4
    ce08:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    ce0a:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    ce0e:	b.w	cd0c <SdioCard::stopTransmission(bool)>
    ce12:	bl	c2c8 <waitTransferComplete() [clone .part.8]>
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    ce16:	cmp	r0, #0
    ce18:	bne.n	cdfe <SdioCard::syncDevice()+0xa>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    ce1a:	pop	{r4, pc}
    ce1c:	.word	0x20005114

0000ce20 <SdSpiArduinoDriver::activate()>:
 */
#include "SdSpiDriver.h"
#if defined(SD_USE_CUSTOM_SPI) &&  defined(__arm__) && defined(CORE_TEENSY)
#define USE_BLOCK_TRANSFER 1
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::activate() {
    ce20:	push	{r4}
  m_spi->beginTransaction(m_spiSettings);
    ce22:	ldr	r3, [r0, #0]
    ce24:	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    ce26:	ldrb	r1, [r3, #11]
    ce28:	cbz	r1, ce58 <SdSpiArduinoDriver::activate()+0x38>
			__disable_irq();
    ce2a:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    ce2c:	ldrb	r1, [r3, #11]
    ce2e:	lsls	r4, r1, #31
    ce30:	bpl.n	ce40 <SdSpiArduinoDriver::activate()+0x20>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    ce32:	ldr	r0, [pc, #80]	; (ce84 <SdSpiArduinoDriver::activate()+0x64>)
    ce34:	ldr	r1, [r3, #12]
    ce36:	ldr	r4, [r0, #0]
    ce38:	ands	r1, r4
    ce3a:	str	r1, [r3, #24]
				NVIC_ICER0 = interruptSave[0];
    ce3c:	str	r1, [r0, #0]
    ce3e:	ldrb	r1, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    ce40:	lsls	r0, r1, #30
    ce42:	bpl.n	ce52 <SdSpiArduinoDriver::activate()+0x32>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    ce44:	ldr	r0, [pc, #64]	; (ce88 <SdSpiArduinoDriver::activate()+0x68>)
    ce46:	ldr	r1, [r3, #16]
    ce48:	ldr	r4, [r0, #0]
    ce4a:	ands	r1, r4
    ce4c:	str	r1, [r3, #28]
				NVIC_ICER1 = interruptSave[1];
    ce4e:	str	r1, [r0, #0]
    ce50:	ldrb	r1, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    ce52:	lsls	r1, r1, #29
    ce54:	bmi.n	ce76 <SdSpiArduinoDriver::activate()+0x56>
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    ce56:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    ce58:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    ce5a:	ldr	r1, [r3, #12]
    ce5c:	cmp	r1, r2
    ce5e:	beq.n	ce70 <SdSpiArduinoDriver::activate()+0x50>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    ce60:	ldr	r0, [pc, #40]	; (ce8c <SdSpiArduinoDriver::activate()+0x6c>)
    ce62:	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    ce64:	ldr	r1, [pc, #40]	; (ce90 <SdSpiArduinoDriver::activate()+0x70>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    ce66:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    ce68:	orr.w	r0, r2, #1073741824	; 0x40000000
    ce6c:	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    ce6e:	str	r1, [r3, #0]
}
    ce70:	ldr.w	r4, [sp], #4
    ce74:	bx	lr
				NVIC_ICER1 = interruptSave[1];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    ce76:	ldr	r0, [pc, #28]	; (ce94 <SdSpiArduinoDriver::activate()+0x74>)
    ce78:	ldr	r1, [r3, #20]
    ce7a:	ldr	r4, [r0, #0]
    ce7c:	ands	r1, r4
    ce7e:	str	r1, [r3, #32]
				NVIC_ICER2 = interruptSave[2];
    ce80:	str	r1, [r0, #0]
    ce82:	b.n	ce56 <SdSpiArduinoDriver::activate()+0x36>
    ce84:	.word	0xe000e180
    ce88:	.word	0xe000e184
    ce8c:	.word	0x003f4001
    ce90:	.word	0x803f0000
    ce94:	.word	0xe000e188

0000ce98 <SdSpiArduinoDriver::begin(SdSpiConfig)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
    ce98:	push	{r4, lr}
    ce9a:	sub	sp, #16
    ce9c:	add	r4, sp, #16
    ce9e:	stmdb	r4, {r1, r2, r3}
    cea2:	ldr	r3, [sp, #12]
  if (spiConfig.spiPort) {
    cea4:	cbz	r3, ceb4 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x1c>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    cea6:	str	r3, [r0, #0]
    cea8:	mov	r0, r3
  }
  m_spi->begin();
}
    ceaa:	add	sp, #16
    ceac:	ldmia.w	sp!, {r4, lr}
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
  }
  m_spi->begin();
    ceb0:	b.w	70e8 <SPIClass::begin()>
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
  if (spiConfig.spiPort) {
    m_spi = spiConfig.spiPort;
#if defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else if (spiConfig.csPin == SDCARD_SS_PIN) {
    ceb4:	ldrb.w	r3, [sp, #4]
    ceb8:	cmp	r3, #62	; 0x3e
    ceba:	beq.n	cec0 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x28>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    cebc:	ldr	r3, [pc, #32]	; (cee0 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x48>)
    cebe:	b.n	cea6 <SdSpiArduinoDriver::begin(SdSpiConfig)+0xe>
    cec0:	mov	r4, r0
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
  if (spiConfig.spiPort) {
    m_spi = spiConfig.spiPort;
#if defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else if (spiConfig.csPin == SDCARD_SS_PIN) {
    m_spi = &SDCARD_SPI;
    cec2:	ldr	r0, [pc, #32]	; (cee4 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x4c>)
    cec4:	str	r0, [r4, #0]
    m_spi->setMISO(SDCARD_MISO_PIN);
    cec6:	movs	r1, #59	; 0x3b
    cec8:	bl	7208 <SPIClass::setMISO(unsigned char)>
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    cecc:	movs	r1, #61	; 0x3d
    cece:	ldr	r0, [r4, #0]
    ced0:	bl	7164 <SPIClass::setMOSI(unsigned char)>
    m_spi->setSCK(SDCARD_SCK_PIN);
    ced4:	ldr	r0, [r4, #0]
    ced6:	movs	r1, #60	; 0x3c
    ced8:	bl	72a8 <SPIClass::setSCK(unsigned char)>
    cedc:	ldr	r0, [r4, #0]
    cede:	b.n	ceaa <SdSpiArduinoDriver::begin(SdSpiConfig)+0x12>
    cee0:	.word	0x20000b6c
    cee4:	.word	0x20000ba4

0000cee8 <SdSpiArduinoDriver::deactivate()>:
  }
  m_spi->begin();
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::deactivate() {
  m_spi->endTransaction();
    cee8:	ldr	r2, [r0, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    ceea:	ldrb	r3, [r2, #11]
    ceec:	cbz	r3, cf10 <SdSpiArduinoDriver::deactivate()+0x28>
			if (interruptMasksUsed & 0x01) {
    ceee:	lsls	r0, r3, #31
    cef0:	bpl.n	cefa <SdSpiArduinoDriver::deactivate()+0x12>
				NVIC_ISER0 = interruptSave[0];
    cef2:	ldr	r3, [pc, #32]	; (cf14 <SdSpiArduinoDriver::deactivate()+0x2c>)
    cef4:	ldr	r1, [r2, #24]
    cef6:	str	r1, [r3, #0]
    cef8:	ldrb	r3, [r2, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    cefa:	lsls	r1, r3, #30
    cefc:	bpl.n	cf06 <SdSpiArduinoDriver::deactivate()+0x1e>
				NVIC_ISER1 = interruptSave[1];
    cefe:	ldr	r3, [pc, #24]	; (cf18 <SdSpiArduinoDriver::deactivate()+0x30>)
    cf00:	ldr	r1, [r2, #28]
    cf02:	str	r1, [r3, #0]
    cf04:	ldrb	r3, [r2, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    cf06:	lsls	r3, r3, #29
    cf08:	bpl.n	cf10 <SdSpiArduinoDriver::deactivate()+0x28>
				NVIC_ISER2 = interruptSave[2];
    cf0a:	ldr	r3, [pc, #16]	; (cf1c <SdSpiArduinoDriver::deactivate()+0x34>)
    cf0c:	ldr	r2, [r2, #32]
    cf0e:	str	r2, [r3, #0]
    cf10:	bx	lr
    cf12:	nop
    cf14:	.word	0xe000e100
    cf18:	.word	0xe000e104
    cf1c:	.word	0xe000e108

0000cf20 <SdSpiArduinoDriver::receive()>:
}
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive() {
    cf20:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    cf22:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    cf24:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    cf28:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    cf2a:	str	r1, [r2, #44]	; 0x2c
		port().PUSHR = data;
    cf2c:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    cf2e:	ldr	r3, [r2, #44]	; 0x2c
    cf30:	cmp	r3, #0
    cf32:	bge.n	cf2e <SdSpiArduinoDriver::receive()+0xe>
		return port().POPR;
    cf34:	ldr	r0, [r2, #56]	; 0x38
  return m_spi->transfer(0XFF);
}
    cf36:	uxtb	r0, r0
    cf38:	bx	lr
    cf3a:	nop

0000cf3c <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive(uint8_t* buf, size_t count) {
    cf3c:	push	{r4, r5, r6, lr}
    cf3e:	mov	r5, r0
    cf40:	mov	r4, r1
    cf42:	mov	r6, r2
#if USE_BLOCK_TRANSFER
  memset(buf, 0XFF, count);
    cf44:	mov	r0, r1
    cf46:	movs	r1, #255	; 0xff
    cf48:	bl	1001c <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    cf4c:	ldr	r0, [r5, #0]
    cf4e:	mov	r3, r6
    cf50:	mov	r2, r4
    cf52:	mov	r1, r4
    cf54:	bl	7358 <SPIClass::transfer(void const*, void*, unsigned int)>
  for (size_t i = 0; i < count; i++) {
    buf[i] = m_spi->transfer(0XFF);
  }
#endif  // USE_BLOCK_TRANSFER
  return 0;
}
    cf58:	movs	r0, #0
    cf5a:	pop	{r4, r5, r6, pc}

0000cf5c <SdSpiArduinoDriver::send(unsigned char)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
    cf5c:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    cf5e:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    cf60:	mov.w	r3, #2147483648	; 0x80000000
    cf64:	str	r3, [r2, #44]	; 0x2c
		port().PUSHR = data;
    cf66:	str	r1, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    cf68:	ldr	r3, [r2, #44]	; 0x2c
    cf6a:	cmp	r3, #0
    cf6c:	bge.n	cf68 <SdSpiArduinoDriver::send(unsigned char)+0xc>
		return port().POPR;
    cf6e:	ldr	r3, [r2, #56]	; 0x38
    cf70:	bx	lr
    cf72:	nop

0000cf74 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>:
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    cf74:	push	{r4, r5, lr}
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    cf76:	subs	r5, r2, #1
    cf78:	cmp.w	r5, #512	; 0x200
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    cf7c:	sub.w	sp, sp, #516	; 0x204
    cf80:	mov	r3, r2
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    cf82:	bcc.n	cfaa <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x36>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    cf84:	cbz	r2, cfa4 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x30>
    cf86:	ldr	r2, [r0, #0]
    cf88:	ldr	r2, [r2, #0]
    cf8a:	adds	r0, r1, r3
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    cf8c:	mov.w	r4, #2147483648	; 0x80000000
    m_spi->transfer(buf[i]);
    cf90:	ldrb.w	r3, [r1], #1
    cf94:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    cf96:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    cf98:	ldr	r3, [r2, #44]	; 0x2c
    cf9a:	cmp	r3, #0
    cf9c:	bge.n	cf98 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x24>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    cf9e:	cmp	r1, r0
		return port().POPR;
    cfa0:	ldr	r3, [r2, #56]	; 0x38
    cfa2:	bne.n	cf90 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x1c>
    m_spi->transfer(buf[i]);
  }
}
    cfa4:	add.w	sp, sp, #516	; 0x204
    cfa8:	pop	{r4, r5, pc}
    cfaa:	mov	r5, r0
    cfac:	mov	r4, r2
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    memcpy(tmp, buf, count);
    cfae:	mov	r0, sp
    cfb0:	bl	cfd4 <memcpy>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    cfb4:	mov	r3, r4
    cfb6:	mov	r2, sp
    cfb8:	mov	r1, sp
    cfba:	ldr	r0, [r5, #0]
    cfbc:	bl	7358 <SPIClass::transfer(void const*, void*, unsigned int)>
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    m_spi->transfer(buf[i]);
  }
}
    cfc0:	add.w	sp, sp, #516	; 0x204
    cfc4:	pop	{r4, r5, pc}
    cfc6:	nop

0000cfc8 <sdCsInit(unsigned char)>:
#include "SdSpiDriver.h"
#if ENABLE_ARDUINO_FEATURES
#if SD_CHIP_SELECT_MODE == 0
//------------------------------------------------------------------------------
void sdCsInit(SdCsPin_t pin) {
  pinMode(pin, OUTPUT);
    cfc8:	movs	r1, #1
    cfca:	b.w	da00 <pinMode>
    cfce:	nop

0000cfd0 <sdCsWrite(unsigned char, bool)>:
}
//------------------------------------------------------------------------------
void sdCsWrite(SdCsPin_t pin, bool level) {
  digitalWrite(pin, level);
    cfd0:	b.w	d9f4 <digitalWrite>

0000cfd4 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    cfd4:	push	{r0}
#endif
	orr	r3, r1, r0
    cfd6:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    cfda:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    cfde:	bne.n	d0c0 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    cfe0:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    cfe2:	bcc.n	d068 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    cfe4:	ldr.w	r3, [r1], #4
    cfe8:	str.w	r3, [r0], #4
    cfec:	ldr.w	r3, [r1], #4
    cff0:	str.w	r3, [r0], #4
    cff4:	ldr.w	r3, [r1], #4
    cff8:	str.w	r3, [r0], #4
    cffc:	ldr.w	r3, [r1], #4
    d000:	str.w	r3, [r0], #4
    d004:	ldr.w	r3, [r1], #4
    d008:	str.w	r3, [r0], #4
    d00c:	ldr.w	r3, [r1], #4
    d010:	str.w	r3, [r0], #4
    d014:	ldr.w	r3, [r1], #4
    d018:	str.w	r3, [r0], #4
    d01c:	ldr.w	r3, [r1], #4
    d020:	str.w	r3, [r0], #4
    d024:	ldr.w	r3, [r1], #4
    d028:	str.w	r3, [r0], #4
    d02c:	ldr.w	r3, [r1], #4
    d030:	str.w	r3, [r0], #4
    d034:	ldr.w	r3, [r1], #4
    d038:	str.w	r3, [r0], #4
    d03c:	ldr.w	r3, [r1], #4
    d040:	str.w	r3, [r0], #4
    d044:	ldr.w	r3, [r1], #4
    d048:	str.w	r3, [r0], #4
    d04c:	ldr.w	r3, [r1], #4
    d050:	str.w	r3, [r0], #4
    d054:	ldr.w	r3, [r1], #4
    d058:	str.w	r3, [r0], #4
    d05c:	ldr.w	r3, [r1], #4
    d060:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    d064:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    d066:	bcs.n	cfe4 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    d068:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    d06a:	bcc.n	d090 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    d06c:	ldr.w	r3, [r1], #4
    d070:	str.w	r3, [r0], #4
    d074:	ldr.w	r3, [r1], #4
    d078:	str.w	r3, [r0], #4
    d07c:	ldr.w	r3, [r1], #4
    d080:	str.w	r3, [r0], #4
    d084:	ldr.w	r3, [r1], #4
    d088:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    d08c:	subs	r2, #16
	bhs	.Lmid_block_loop
    d08e:	bcs.n	d06c <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    d090:	adds	r2, #12
	blo	.Lcopy_less_than_4
    d092:	bcc.n	d0a0 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    d094:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    d098:	str.w	r3, [r0], #4
	subs	r2, #4
    d09c:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    d09e:	bcs.n	d094 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    d0a0:	adds	r2, #4
	beq	.Ldone
    d0a2:	beq.n	d0ba <memcpy+0xe6>

	lsls	r2, r2, #31
    d0a4:	lsls	r2, r2, #31
	itt ne
    d0a6:	itt	ne
	ldrbne  r3, [r1], #1
    d0a8:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    d0ac:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    d0b0:	bcc.n	d0ba <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    d0b2:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    d0b4:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    d0b6:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    d0b8:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    d0ba:	pop	{r0}
#endif
	bx	lr
    d0bc:	bx	lr
    d0be:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    d0c0:	cmp	r2, #12
	blo	.Lbyte_copy
    d0c2:	bcc.n	d15a <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    d0c4:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    d0c8:	beq.n	d0ee <memcpy+0x11a>

	rsb	r3, #4
    d0ca:	rsb	r3, r3, #4
	subs	r2, r3
    d0ce:	subs	r2, r2, r3

	lsls    r3, r3, #31
    d0d0:	lsls	r3, r3, #31
	itt ne
    d0d2:	itt	ne
	ldrbne  r3, [r1], #1
    d0d4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    d0d8:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    d0dc:	bcc.n	d0ee <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    d0de:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d0e2:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    d0e6:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d0ea:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    d0ee:	ands.w	r3, r1, #3
	beq	.Lbig_block
    d0f2:	beq.w	cfe0 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    d0f6:	push	{r4, r5}
	subs	r2, #4
    d0f8:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    d0fa:	subs	r1, r1, r3
	rsb	ip, r3, #4
    d0fc:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    d100:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    d104:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    d106:	beq.n	d13c <memcpy+0x168>
	cmp	r3, #3
    d108:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    d10a:	beq.n	d124 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    d10c:	lsrs	r4, r4, #8
    d10e:	ldr.w	r3, [r1], #4
    d112:	lsls	r5, r3, #24
    d114:	orr.w	r4, r4, r5
    d118:	str.w	r4, [r0], #4
    d11c:	mov	r4, r3
    d11e:	subs	r2, #4
    d120:	bcs.n	d10c <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    d122:	b.n	d152 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    d124:	lsrs	r4, r4, #24
    d126:	ldr.w	r3, [r1], #4
    d12a:	lsls	r5, r3, #8
    d12c:	orr.w	r4, r4, r5
    d130:	str.w	r4, [r0], #4
    d134:	mov	r4, r3
    d136:	subs	r2, #4
    d138:	bcs.n	d124 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    d13a:	b.n	d152 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    d13c:	lsrs	r4, r4, #16
    d13e:	ldr.w	r3, [r1], #4
    d142:	lsls	r5, r3, #16
    d144:	orr.w	r4, r4, r5
    d148:	str.w	r4, [r0], #4
    d14c:	mov	r4, r3
    d14e:	subs	r2, #4
    d150:	bcs.n	d13c <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    d152:	adds	r2, #4
	subs	r1, ip
    d154:	subs.w	r1, r1, ip
	pop	{r4, r5}
    d158:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    d15a:	subs	r2, #4
	blo	.Lcopy_less_than_4
    d15c:	bcc.n	d0a0 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    d15e:	subs	r2, #1
	ldrb    r3, [r1], #1
    d160:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d164:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    d168:	bcs.n	d15e <memcpy+0x18a>

	ldrb	r3, [r1]
    d16a:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    d16c:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    d16e:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    d170:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    d172:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    d174:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    d176:	pop	{r0}
#endif
	bx	lr
    d178:	bx	lr
    d17a:	nop

0000d17c <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    d17c:	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    d17e:	ldr	r5, [pc, #60]	; (d1bc <usb_serial_getchar+0x40>)
    d180:	ldr	r0, [r5, #0]
    d182:	cbz	r0, d1a4 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    d184:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    d186:	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    d188:	adds	r1, r0, r3
    d18a:	adds	r3, #1
	if (i >= rx_packet->len) {
    d18c:	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    d18e:	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    d190:	bcs.n	d198 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    d192:	strh	r3, [r0, #2]
	}
	return c;
    d194:	mov	r0, r4
}
    d196:	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    d198:	bl	dc54 <usb_free>
		rx_packet = NULL;
    d19c:	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    d19e:	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    d1a0:	str	r3, [r5, #0]
    d1a2:	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d1a4:	ldr	r3, [pc, #24]	; (d1c0 <usb_serial_getchar+0x44>)
    d1a6:	ldrb	r3, [r3, #0]
    d1a8:	cbz	r3, d1b6 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    d1aa:	movs	r0, #2
    d1ac:	bl	dca0 <usb_rx>
    d1b0:	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    d1b2:	cmp	r0, #0
    d1b4:	bne.n	d184 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d1b6:	mov.w	r0, #4294967295
    d1ba:	pop	{r3, r4, r5, pc}
    d1bc:	.word	0x20005148
    d1c0:	.word	0x20005254

0000d1c4 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    d1c4:	push	{r4, lr}
	if (!rx_packet) {
    d1c6:	ldr	r4, [pc, #36]	; (d1ec <usb_serial_peekchar+0x28>)
    d1c8:	ldr	r0, [r4, #0]
    d1ca:	cbz	r0, d1d4 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    d1cc:	ldrh	r3, [r0, #2]
    d1ce:	add	r0, r3
    d1d0:	ldrb	r0, [r0, #8]
}
    d1d2:	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d1d4:	ldr	r3, [pc, #24]	; (d1f0 <usb_serial_peekchar+0x2c>)
    d1d6:	ldrb	r3, [r3, #0]
    d1d8:	cbz	r3, d1e6 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    d1da:	movs	r0, #2
    d1dc:	bl	dca0 <usb_rx>
    d1e0:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    d1e2:	cmp	r0, #0
    d1e4:	bne.n	d1cc <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d1e6:	mov.w	r0, #4294967295
    d1ea:	pop	{r4, pc}
    d1ec:	.word	0x20005148
    d1f0:	.word	0x20005254

0000d1f4 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    d1f4:	ldr	r3, [pc, #16]	; (d208 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    d1f6:	ldr	r2, [pc, #20]	; (d20c <usb_serial_available+0x18>)
    d1f8:	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    d1fa:	ldrh	r0, [r2, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    d1fc:	cbz	r3, d206 <usb_serial_available+0x12>
    d1fe:	ldrh	r2, [r3, #0]
    d200:	ldrh	r3, [r3, #2]
    d202:	subs	r3, r2, r3
    d204:	add	r0, r3
	return count;
}
    d206:	bx	lr
    d208:	.word	0x20005148
    d20c:	.word	0x200052d0

0000d210 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    d210:	ldr	r3, [pc, #44]	; (d240 <usb_serial_flush_input+0x30>)
    d212:	ldrb	r3, [r3, #0]
    d214:	cbz	r3, d23e <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    d216:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    d218:	ldr	r4, [pc, #40]	; (d244 <usb_serial_flush_input+0x34>)
    d21a:	ldr	r0, [r4, #0]
    d21c:	cbz	r0, d232 <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    d21e:	bl	dc54 <usb_free>
		rx_packet = NULL;
    d222:	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d224:	movs	r0, #2
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    d226:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d228:	bl	dca0 <usb_rx>
		if (!rx) break;
    d22c:	cbz	r0, d23c <usb_serial_flush_input+0x2c>
		usb_free(rx);
    d22e:	bl	dc54 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d232:	movs	r0, #2
    d234:	bl	dca0 <usb_rx>
		if (!rx) break;
    d238:	cmp	r0, #0
    d23a:	bne.n	d22e <usb_serial_flush_input+0x1e>
    d23c:	pop	{r4, pc}
    d23e:	bx	lr
    d240:	.word	0x20005254
    d244:	.word	0x20005148

0000d248 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    d248:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    d24c:	ldr.w	r9, [pc, #248]	; d348 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    d250:	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    d252:	movs	r2, #1
    d254:	strb.w	r2, [r9]
	while (size > 0) {
    d258:	str	r1, [sp, #4]
    d25a:	cbz	r1, d2b8 <usb_serial_write+0x70>
    d25c:	ldr.w	r8, [pc, #236]	; d34c <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d260:	ldr	r7, [pc, #216]	; (d33c <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    d262:	ldr	r6, [sp, #4]
    d264:	mov	fp, r0
		if (!tx_packet) {
    d266:	ldr.w	r0, [r8]
    d26a:	cbz	r0, d2da <usb_serial_write+0x92>
    d26c:	ldr	r5, [pc, #208]	; (d340 <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    d26e:	ldrh	r4, [r0, #2]
    d270:	rsb	r1, r4, #64	; 0x40
    d274:	cmp	r1, r6
    d276:	it	cs
    d278:	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d27a:	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    d27e:	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d280:	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    d284:	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    d286:	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d288:	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    d28c:	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    d290:	cbz	r1, d2a8 <usb_serial_write+0x60>
    d292:	subs	r4, #1
    d294:	add	r2, r4
    d296:	add	r1, fp
    d298:	ldrb.w	r4, [fp], #1
    d29c:	strb.w	r4, [r2, #1]!
    d2a0:	cmp	fp, r1
    d2a2:	bne.n	d298 <usb_serial_write+0x50>
    d2a4:	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    d2a8:	cmp.w	lr, #63	; 0x3f
    d2ac:	bhi.n	d2c6 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    d2ae:	ldr	r2, [pc, #148]	; (d344 <usb_serial_write+0xfc>)
    d2b0:	movs	r1, #5
    d2b2:	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    d2b4:	cmp	r6, #0
    d2b6:	bne.n	d266 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    d2b8:	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    d2ba:	movs	r3, #0
    d2bc:	strb.w	r3, [r9]
	return ret;
}
    d2c0:	add	sp, #12
    d2c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    d2c6:	movs	r2, #64	; 0x40
    d2c8:	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d2ca:	mov	r1, r0
    d2cc:	movs	r0, #3
    d2ce:	bl	dd8c <usb_tx>
			tx_packet = NULL;
    d2d2:	movs	r2, #0
    d2d4:	str.w	r2, [r8]
    d2d8:	b.n	d2ae <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d2da:	ldrb	r2, [r7, #0]
    d2dc:	cbz	r2, d32a <usb_serial_write+0xe2>
    d2de:	ldr	r5, [pc, #96]	; (d340 <usb_serial_write+0xf8>)
    d2e0:	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    d2e4:	mov.w	sl, #1
    d2e8:	b.n	d2fa <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d2ea:	subs	r4, #1
    d2ec:	beq.n	d31c <usb_serial_write+0xd4>
    d2ee:	ldrb	r2, [r5, #0]
    d2f0:	cbnz	r2, d31c <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    d2f2:	bl	e748 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d2f6:	ldrb	r2, [r7, #0]
    d2f8:	cbz	r2, d32a <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    d2fa:	movs	r0, #3
    d2fc:	bl	dcdc <usb_tx_packet_count>
    d300:	cmp	r0, #7
    d302:	bhi.n	d2ea <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    d304:	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    d308:	bl	dc14 <usb_malloc>
    d30c:	str.w	r0, [r8]
					if (tx_packet) break;
    d310:	cmp	r0, #0
    d312:	bne.n	d26e <usb_serial_write+0x26>
					tx_noautoflush = 0;
    d314:	ldr	r3, [pc, #48]	; (d348 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d316:	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    d318:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d31a:	bne.n	d2ee <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    d31c:	movs	r3, #1
					return -1;
    d31e:	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    d322:	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    d324:	add	sp, #12
    d326:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    d32a:	movs	r3, #0
					return -1;
    d32c:	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    d330:	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    d334:	add	sp, #12
    d336:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d33a:	nop
    d33c:	.word	0x20005254
    d340:	.word	0x20005144
    d344:	.word	0x2000513c
    d348:	.word	0x2000513d
    d34c:	.word	0x20005140

0000d350 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    d350:	push	{lr}
    d352:	sub	sp, #12
    d354:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    d356:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    d358:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    d35c:	mov	r0, r3
    d35e:	bl	d248 <usb_serial_write>
}
    d362:	add	sp, #12
    d364:	ldr.w	pc, [sp], #4

0000d368 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    d368:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    d36a:	ldr	r5, [pc, #56]	; (d3a4 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    d36c:	ldr	r4, [pc, #56]	; (d3a8 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    d36e:	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    d370:	movs	r3, #1
    d372:	strb	r3, [r4, #0]
	if (!tx_packet) {
    d374:	cbz	r0, d382 <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    d376:	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    d378:	movs	r3, #0
    d37a:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    d37c:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    d380:	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    d382:	ldr	r3, [pc, #40]	; (d3ac <usb_serial_write_buffer_free+0x44>)
    d384:	ldrb	r3, [r3, #0]
    d386:	cbnz	r3, d38e <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    d388:	movs	r0, #0
    d38a:	strb	r0, [r4, #0]
			return 0;
    d38c:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    d38e:	movs	r0, #3
    d390:	bl	dcdc <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    d394:	cmp	r0, #7
    d396:	bhi.n	d388 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    d398:	bl	dc14 <usb_malloc>
    d39c:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    d39e:	cmp	r0, #0
    d3a0:	bne.n	d376 <usb_serial_write_buffer_free+0xe>
    d3a2:	b.n	d388 <usb_serial_write_buffer_free+0x20>
    d3a4:	.word	0x20005140
    d3a8:	.word	0x2000513d
    d3ac:	.word	0x20005254

0000d3b0 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    d3b0:	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    d3b2:	ldr	r3, [pc, #68]	; (d3f8 <usb_serial_flush_output+0x48>)
    d3b4:	ldrb	r3, [r3, #0]
    d3b6:	cbz	r3, d3dc <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    d3b8:	ldr	r6, [pc, #64]	; (d3fc <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    d3ba:	ldr	r5, [pc, #68]	; (d400 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    d3bc:	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    d3be:	movs	r7, #1
    d3c0:	strb	r7, [r5, #0]
	if (tx_packet) {
    d3c2:	cbz	r4, d3de <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    d3c4:	ldr	r2, [pc, #60]	; (d404 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    d3c6:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    d3c8:	movs	r7, #0
    d3ca:	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d3cc:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    d3ce:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d3d0:	movs	r0, #3
    d3d2:	bl	dd8c <usb_tx>
		tx_packet = NULL;
    d3d6:	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    d3d8:	movs	r3, #0
    d3da:	strb	r3, [r5, #0]
    d3dc:	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    d3de:	bl	dc14 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    d3e2:	ldr	r3, [pc, #32]	; (d404 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    d3e4:	cbz	r0, d3f2 <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    d3e6:	mov	r1, r0
    d3e8:	movs	r0, #3
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    d3ea:	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    d3ec:	bl	dd8c <usb_tx>
    d3f0:	b.n	d3d8 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    d3f2:	strb	r7, [r3, #0]
    d3f4:	b.n	d3d8 <usb_serial_flush_output+0x28>
    d3f6:	nop
    d3f8:	.word	0x20005254
    d3fc:	.word	0x20005140
    d400:	.word	0x2000513d
    d404:	.word	0x2000513c

0000d408 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    d408:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    d40a:	ldr	r3, [pc, #56]	; (d444 <usb_serial_flush_callback+0x3c>)
    d40c:	ldrb	r3, [r3, #0]
    d40e:	cbnz	r3, d42e <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    d410:	ldr	r4, [pc, #52]	; (d448 <usb_serial_flush_callback+0x40>)
    d412:	ldr	r1, [r4, #0]
    d414:	cbz	r1, d430 <usb_serial_flush_callback+0x28>
    d416:	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    d41a:	ldrh	r3, [r1, #2]
    d41c:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d41e:	movs	r0, #3
    d420:	bl	dd8c <usb_tx>
		tx_packet = NULL;
    d424:	str	r5, [r4, #0]
    d426:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    d428:	ldr	r3, [pc, #32]	; (d44c <usb_serial_flush_callback+0x44>)
    d42a:	movs	r2, #1
    d42c:	strb	r2, [r3, #0]
    d42e:	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    d430:	bl	dc14 <usb_malloc>
		if (tx) {
    d434:	cmp	r0, #0
    d436:	beq.n	d428 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    d438:	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    d43a:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    d43e:	movs	r0, #3
    d440:	b.w	dd8c <usb_tx>
    d444:	.word	0x2000513d
    d448:	.word	0x20005140
    d44c:	.word	0x2000513c

0000d450 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    d450:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d452:	ldr	r4, [pc, #64]	; (d494 <fault_isr+0x44>)
    d454:	b.n	d468 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d456:	ldr	r3, [r4, #0]
    d458:	lsls	r1, r3, #21
    d45a:	bmi.n	d478 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d45c:	ldr	r3, [r4, #0]
    d45e:	lsls	r2, r3, #20
    d460:	bmi.n	d482 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d462:	ldr	r3, [r4, #0]
    d464:	lsls	r3, r3, #19
    d466:	bmi.n	d48c <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d468:	ldr	r3, [r4, #0]
    d46a:	lsls	r0, r3, #13
    d46c:	bpl.n	d456 <fault_isr+0x6>
    d46e:	bl	de10 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d472:	ldr	r3, [r4, #0]
    d474:	lsls	r1, r3, #21
    d476:	bpl.n	d45c <fault_isr+0xc>
    d478:	bl	d498 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d47c:	ldr	r3, [r4, #0]
    d47e:	lsls	r2, r3, #20
    d480:	bpl.n	d462 <fault_isr+0x12>
    d482:	bl	d498 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d486:	ldr	r3, [r4, #0]
    d488:	lsls	r3, r3, #19
    d48a:	bpl.n	d468 <fault_isr+0x18>
    d48c:	bl	d498 <unused_isr>
    d490:	b.n	d468 <fault_isr+0x18>
    d492:	nop
    d494:	.word	0x40048034

0000d498 <unused_isr>:
	}
}

void unused_isr(void)
{
    d498:	push	{r3, lr}
	fault_isr();
    d49a:	bl	d450 <fault_isr>
    d49e:	nop

0000d4a0 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    d4a0:	ldr	r3, [pc, #4]	; (d4a8 <startup_early_hook+0x8>)
    d4a2:	movs	r2, #16
    d4a4:	strh	r2, [r3, #0]
    d4a6:	bx	lr
    d4a8:	.word	0x40052000

0000d4ac <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    d4ac:	bx	lr
    d4ae:	nop

0000d4b0 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    d4b0:	ldr	r1, [pc, #36]	; (d4d8 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    d4b2:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    d4b4:	ldr	r3, [r1, #0]
	if (incr != 0) {
    d4b6:	cbz	r0, d4c6 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    d4b8:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    d4ba:	add	r0, r3
    d4bc:	sub.w	r2, r2, #8192	; 0x2000
    d4c0:	cmp	r0, r2
    d4c2:	bcs.n	d4ca <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    d4c4:	str	r0, [r1, #0]
	}
	return prev;
    d4c6:	mov	r0, r3
}
    d4c8:	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    d4ca:	bl	f838 <__errno>
    d4ce:	movs	r3, #12
    d4d0:	str	r3, [r0, #0]
			return (void *)-1;
    d4d2:	mov.w	r0, #4294967295
    d4d6:	pop	{r3, pc}
    d4d8:	.word	0x20000be4

0000d4dc <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    d4dc:	b.n	d4dc <__cxa_pure_virtual>
    d4de:	nop

0000d4e0 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    d4e0:	cpsid	i
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    d4e2:	ldr	r2, [pc, #96]	; (d544 <usb_init_serialnumber+0x64>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d4e4:	ldr	r3, [pc, #96]	; (d548 <usb_init_serialnumber+0x68>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    d4e6:	ldr	r1, [pc, #100]	; (d54c <usb_init_serialnumber+0x6c>)
    d4e8:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d4ea:	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d4ec:	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d4ee:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d4f0:	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d4f2:	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d4f4:	ldrb	r3, [r2, #0]
    d4f6:	lsls	r3, r3, #24
    d4f8:	bpl.n	d4f4 <usb_init_serialnumber+0x14>
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    d4fa:	push	{r4, lr}
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    d4fc:	ldr	r3, [pc, #80]	; (d550 <usb_init_serialnumber+0x70>)
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    d4fe:	sub	sp, #16
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    d500:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    d502:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d504:	ldr	r3, [pc, #76]	; (d554 <usb_init_serialnumber+0x74>)
    d506:	ldr	r4, [pc, #80]	; (d558 <usb_init_serialnumber+0x78>)
    d508:	cmp	r0, r3
    d50a:	it	ls
    d50c:	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    d510:	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d512:	it	ls
    d514:	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    d516:	movs	r2, #10
    d518:	bl	d55c <ultoa>
    d51c:	add	r1, sp, #4
    d51e:	mov	r0, r4
	for (i=0; i<10; i++) {
    d520:	movs	r3, #0
		char c = buf[i];
    d522:	ldrb.w	r2, [r1], #1
    d526:	adds	r3, #1
		if (!c) break;
    d528:	cbz	r2, d53a <usb_init_serialnumber+0x5a>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d52a:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    d52c:	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d530:	bne.n	d522 <usb_init_serialnumber+0x42>
    d532:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d534:	strb	r3, [r4, #0]
}
    d536:	add	sp, #16
    d538:	pop	{r4, pc}
    d53a:	lsls	r3, r3, #1
    d53c:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d53e:	strb	r3, [r4, #0]
}
    d540:	add	sp, #16
    d542:	pop	{r4, pc}
    d544:	.word	0x40020004
    d548:	.word	0x40020000
    d54c:	.word	0x41070000
    d550:	.word	0x4002000c
    d554:	.word	0x0098967f
    d558:	.word	0x20000cbc

0000d55c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    d55c:	push	{r4, r5, r6, r7}
    d55e:	subs	r5, r1, #1
    d560:	mov	r6, r5
	unsigned digit;
	int i=0, j;
    d562:	movs	r4, #0
    d564:	b.n	d568 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    d566:	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    d568:	udiv	r3, r0, r2
    d56c:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    d570:	cmp	r0, #9
    d572:	add.w	r7, r0, #48	; 0x30
    d576:	itet	hi
    d578:	addhi	r0, #55	; 0x37
    d57a:	uxtbls	r0, r7
    d57c:	uxtbhi	r0, r0
    d57e:	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    d582:	mov	r0, r3
    d584:	cmp	r3, #0
    d586:	bne.n	d566 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    d588:	adds	r2, r1, r4
    d58a:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    d58c:	cbz	r4, d5a2 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    d58e:	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    d590:	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    d594:	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    d596:	adds	r3, #1
    d598:	subs	r0, r4, r3
    d59a:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    d59c:	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    d5a0:	blt.n	d58e <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    d5a2:	mov	r0, r1
    d5a4:	pop	{r4, r5, r6, r7}
    d5a6:	bx	lr

0000d5a8 <dtostrf>:
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    d5a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d5ac:	vpush	{d8}
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
    d5b0:	vcmp.f32	s0, s0
{
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    d5b4:	eor.w	r3, r0, r0, asr #31
	if (isnanf(val)) {
    d5b8:	vmrs	APSR_nzcv, fpscr
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    d5bc:	sub	sp, #16
    d5be:	vmov.f32	s16, s0
    d5c2:	mov	r5, r0
    d5c4:	mov	r4, r2
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    d5c6:	sub.w	r3, r3, r0, asr #31
	if (isnanf(val)) {
    d5ca:	bvs.w	d828 <dtostrf+0x280>
			awidth--;
		}
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
    d5ce:	vldr	s15, [pc, #800]	; d8f0 <dtostrf+0x348>
    d5d2:	vabs.f32	s14, s0
    d5d6:	vcmp.f32	s14, s15
    d5da:	vmrs	APSR_nzcv, fpscr
    d5de:	ble.n	d666 <dtostrf+0xbe>
		int ndigs = (val<0) ? 4 : 3;
    d5e0:	vcmpe.f32	s0, #0.0
    d5e4:	vmrs	APSR_nzcv, fpscr
    d5e8:	ite	mi
    d5ea:	movmi	r0, #4
    d5ec:	movpl	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d5ee:	cmp	r0, r3
    d5f0:	blt.n	d636 <dtostrf+0x8e>
		if (width<0) {
    d5f2:	cmp	r5, #0
    d5f4:	blt.w	d8de <dtostrf+0x336>
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d5f8:	movs	r0, #0
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    d5fa:	vcmpe.f32	s16, #0.0
    d5fe:	vmrs	APSR_nzcv, fpscr
    d602:	it	mi
    d604:	movmi	r3, r4
    d606:	bmi.n	d65e <dtostrf+0xb6>
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d608:	movs	r1, #73	; 0x49
    d60a:	movs	r2, #78	; 0x4e
    d60c:	movs	r3, #70	; 0x46
    d60e:	strb	r1, [r4, #0]
    d610:	strb	r2, [r4, #1]
    d612:	strb	r3, [r4, #2]
    d614:	adds	r4, #3
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    d616:	cmp	r0, #0
    d618:	beq.w	d8e6 <dtostrf+0x33e>
    d61c:	add	r0, r4
			*buf++ = ' ';
    d61e:	movs	r3, #32
    d620:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    d624:	cmp	r0, r4
    d626:	bne.n	d620 <dtostrf+0x78>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    d628:	movs	r3, #0
    d62a:	strb	r3, [r0, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    d62c:	add	sp, #16
    d62e:	vpop	{d8}
    d632:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d636:	cmp	r5, #0
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d638:	sub.w	r0, r3, r0
		if (width<0) {
    d63c:	bge.n	d5fa <dtostrf+0x52>
			while (awidth) {
    d63e:	cmp	r0, #0
    d640:	beq.w	d8de <dtostrf+0x336>
    d644:	adds	r3, r2, r0
				*buf++ = ' ';
    d646:	movs	r2, #32
    d648:	strb.w	r2, [r4], #1
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    d64c:	cmp	r4, r3
    d64e:	bne.n	d648 <dtostrf+0xa0>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    d650:	vcmpe.f32	s16, #0.0
    d654:	vmrs	APSR_nzcv, fpscr
    d658:	bpl.w	d894 <dtostrf+0x2ec>
    d65c:	movs	r0, #0
    d65e:	movs	r2, #45	; 0x2d
    d660:	strb	r2, [r3, #0]
    d662:	adds	r4, r3, #1
    d664:	b.n	d608 <dtostrf+0x60>
    d666:	mov	r7, r1
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    d668:	add	r2, sp, #8
    d66a:	add	r1, sp, #4
    d66c:	mov	r0, r7
    d66e:	bl	f814 <fcvtf>
    d672:	mov	sl, r7
    d674:	mov	r8, r0

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    d676:	ldr.w	r9, [sp, #4]
    d67a:	cmp	r7, #0
    d67c:	beq.n	d732 <dtostrf+0x18a>
    d67e:	rsb	r3, r9, #0
		s = (*s < '5') ? "0" : "1";
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
    d682:	cmp	r3, r7
    d684:	bgt.w	d7b4 <dtostrf+0x20c>
    d688:	mov	r0, r8
    d68a:	bl	10680 <strlen>
    d68e:	mov	r6, r0
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d690:	cmp	r9, r6
    d692:	it	lt
    d694:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d696:	cmp.w	r9, #0
    d69a:	bne.w	d7d2 <dtostrf+0x22a>
    d69e:	adds	r6, #1
			if (newDecimalPoint - decpt == precision + 1) decpt++;
		}
	}

	// add 1 for sign if negative
	if (sign) reqd++;
    d6a0:	ldr.w	lr, [sp, #8]
    d6a4:	cmp.w	lr, #0
    d6a8:	beq.n	d756 <dtostrf+0x1ae>
    d6aa:	adds	r6, #1

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    d6ac:	subs	r0, r5, r6
	if (pad > 0) {
    d6ae:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    d6b0:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    d6b4:	bgt.n	d762 <dtostrf+0x1ba>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    d6b6:	mov	r3, r4
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
    d6b8:	movs	r2, #45	; 0x2d
    d6ba:	strb	r2, [r3, #0]
    d6bc:	adds	r3, #1
	if (decpt == 0 && precision > 0) {
    d6be:	cmp.w	r9, #0
    d6c2:	bne.n	d790 <dtostrf+0x1e8>
    d6c4:	cbz	r7, d6d4 <dtostrf+0x12c>
		*p++ = '0';
    d6c6:	mov	r2, r3
    d6c8:	movs	r0, #48	; 0x30
    d6ca:	strb.w	r0, [r2], #2
		*p++ = '.';
    d6ce:	movs	r0, #46	; 0x2e
    d6d0:	strb	r0, [r3, #1]
    d6d2:	mov	r3, r2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d6d4:	cmp	r3, r1
    d6d6:	bcs.n	d71a <dtostrf+0x172>
		*p++ = *s++;
    d6d8:	adds	r7, r3, #1
    d6da:	ldrb.w	r2, [r8]
    d6de:	strb	r2, [r3, #0]
		if (p == e) break;
    d6e0:	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    d6e2:	add.w	r8, r8, #1
		if (p == e) break;
    d6e6:	beq.n	d71c <dtostrf+0x174>
    d6e8:	ldr	r2, [sp, #4]
		if (--decpt == 0) *p++ = '.';
    d6ea:	mov.w	lr, #46	; 0x2e
    d6ee:	b.n	d708 <dtostrf+0x160>
    d6f0:	strb.w	lr, [r3, #1]
    d6f4:	adds	r3, #2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d6f6:	cmp	r3, r1
		*p++ = *s++;
    d6f8:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d6fc:	bcs.n	d71a <dtostrf+0x172>
		*p++ = *s++;
    d6fe:	ldrb.w	r0, [r8], #1
    d702:	strb	r0, [r3, #0]
		if (p == e) break;
    d704:	cmp	r7, r1
    d706:	beq.n	d71c <dtostrf+0x174>
		if (--decpt == 0) *p++ = '.';
    d708:	subs	r2, #1
    d70a:	str	r2, [sp, #4]
    d70c:	cmp	r2, #0
    d70e:	beq.n	d6f0 <dtostrf+0x148>
    d710:	mov	r3, r7
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d712:	cmp	r3, r1
		*p++ = *s++;
    d714:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    d718:	bcc.n	d6fe <dtostrf+0x156>
    d71a:	mov	r1, r3
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
    d71c:	cmp	r5, #0
    d71e:	blt.w	d868 <dtostrf+0x2c0>
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    d722:	movs	r3, #0

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
    d724:	mov	r0, r4
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    d726:	strb	r3, [r1, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    d728:	add	sp, #16
    d72a:	vpop	{d8}
    d72e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    d732:	cmp.w	r9, #0
    d736:	bne.n	d67e <dtostrf+0xd6>
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    d738:	ldrb.w	r8, [r0]
    d73c:	ldr	r1, [pc, #436]	; (d8f4 <dtostrf+0x34c>)
    d73e:	ldr	r2, [pc, #440]	; (d8f8 <dtostrf+0x350>)
		decpt++;
    d740:	movs	r3, #1
    d742:	str	r3, [sp, #4]
    d744:	mov	r9, r3
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    d746:	cmp.w	r8, #52	; 0x34
    d74a:	ite	hi
    d74c:	movhi	r8, r1
    d74e:	movls	r8, r2
		decpt++;
    d750:	mov.w	r3, #4294967295
    d754:	b.n	d682 <dtostrf+0xda>
	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    d756:	subs	r0, r5, r6
	if (pad > 0) {
    d758:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    d75a:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    d75e:	ble.w	d8ea <dtostrf+0x342>
		e += pad;
    d762:	add	r1, r0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    d764:	mov	r2, r4
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    d766:	subs	r0, #1
    d768:	mov.w	ip, #32
    d76c:	strb.w	ip, [r2], #1
    d770:	rsb	r3, r2, #1
    d774:	add	r3, r0
    d776:	add	r3, r4
    d778:	cmp	r3, #0
    d77a:	bgt.n	d76c <dtostrf+0x1c4>
    d77c:	bic.w	r3, r0, r0, asr #31
    d780:	adds	r3, #1
    d782:	add	r3, r4
	}
	if (sign) *p++ = '-';
    d784:	cmp.w	lr, #0
    d788:	bne.n	d6b8 <dtostrf+0x110>
	if (decpt == 0 && precision > 0) {
    d78a:	cmp.w	r9, #0
    d78e:	beq.n	d6c4 <dtostrf+0x11c>
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
    d790:	bge.n	d6d4 <dtostrf+0x12c>
    d792:	cmp	r7, #0
    d794:	beq.n	d6d4 <dtostrf+0x12c>
		*p++ = '0';
    d796:	mov	r2, r3
    d798:	movs	r0, #48	; 0x30
    d79a:	strb.w	r0, [r2], #2
		*p++ = '.';
    d79e:	movs	r7, #46	; 0x2e
    d7a0:	strb	r7, [r3, #1]
    d7a2:	rsb	r3, r9, r2
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
    d7a6:	strb.w	r0, [r2], #1
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
    d7aa:	cmp	r3, r2
    d7ac:	bne.n	d7a6 <dtostrf+0x1fe>
    d7ae:	movs	r2, #0
    d7b0:	str	r2, [sp, #4]
    d7b2:	b.n	d6d4 <dtostrf+0x12c>
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    d7b4:	rsb	r9, r7, #0
    d7b8:	movs	r6, #1
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d7ba:	cmp	r9, r6
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    d7bc:	mov	r0, r6
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    d7be:	it	lt
    d7c0:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d7c2:	cmp.w	r9, #0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    d7c6:	ldr.w	r8, [pc, #304]	; d8f8 <dtostrf+0x350>
		decpt = -precision;
    d7ca:	str.w	r9, [sp, #4]

	// add 1 for decimal point
	if (reqd > decpt) reqd++;

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    d7ce:	beq.w	d69e <dtostrf+0xf6>

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
    d7d2:	bge.w	d6a0 <dtostrf+0xf8>
    d7d6:	cmp	r7, #0
    d7d8:	beq.w	d6a0 <dtostrf+0xf8>
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;

		if (strlen(s) > precision + decpt) {
    d7dc:	add.w	r3, r9, r7
    d7e0:	cmp	r0, r3
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;
    d7e2:	add.w	r6, r7, #2

		if (strlen(s) > precision + decpt) {
    d7e6:	bls.w	d6a0 <dtostrf+0xf8>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d7ea:	cmp	r7, #0
    d7ec:	ble.n	d7fc <dtostrf+0x254>
				val *= 10.0;
    d7ee:	vmov.f32	s15, #36	; 0x41200000  10.0

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d7f2:	subs.w	sl, sl, #1
				val *= 10.0;
    d7f6:	vmul.f32	s16, s16, s15

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    d7fa:	bne.n	d7f2 <dtostrf+0x24a>
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    d7fc:	add	r2, sp, #8
    d7fe:	mov	r0, sl
    d800:	vmov.f32	s0, s16
    d804:	add	r1, sp, #12
    d806:	bl	f814 <fcvtf>

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    d80a:	ldr.w	r9, [sp, #4]
    d80e:	ldr	r2, [sp, #12]
    d810:	adds	r3, r7, #1
    d812:	rsb	r2, r9, r2
    d816:	cmp	r2, r3
    d818:	it	eq
    d81a:	addeq.w	r9, r9, #1
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    d81e:	mov	r8, r0

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    d820:	it	eq
    d822:	streq.w	r9, [sp, #4]
    d826:	b.n	d6a0 <dtostrf+0xf8>
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
    d828:	vcmpe.f32	s0, #0.0
    d82c:	vmrs	APSR_nzcv, fpscr
    d830:	ite	mi
    d832:	movmi	r0, #4
    d834:	movpl	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d836:	cmp	r0, r3
    d838:	bge.n	d8a4 <dtostrf+0x2fc>
		if (width<0) {
    d83a:	cmp	r5, #0
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d83c:	sub.w	r3, r3, r0
		if (width<0) {
    d840:	blt.n	d8b6 <dtostrf+0x30e>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d842:	vmov	r2, s16
    d846:	cmp	r2, #0
    d848:	blt.n	d8ac <dtostrf+0x304>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    d84a:	movs	r2, #78	; 0x4e
    d84c:	movs	r1, #65	; 0x41
    d84e:	strb	r2, [r4, #0]
    d850:	strb	r2, [r4, #2]
    d852:	strb	r1, [r4, #1]
    d854:	adds	r4, #3
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    d856:	cmp	r3, #0
    d858:	beq.n	d8e6 <dtostrf+0x33e>
    d85a:	adds	r0, r4, r3
			*buf++ = ' ';
    d85c:	movs	r3, #32
    d85e:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    d862:	cmp	r4, r0
    d864:	bne.n	d85e <dtostrf+0x2b6>
    d866:	b.n	d628 <dtostrf+0x80>
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
    d868:	adds	r0, r5, r6
		while (pad-- > 0) *p++ = ' ';
    d86a:	negs	r3, r0
    d86c:	cmp	r3, #0
    d86e:	mvn.w	r0, r0
    d872:	ble.w	d722 <dtostrf+0x17a>
    d876:	mov	r2, r1
    d878:	movs	r5, #32
    d87a:	strb.w	r5, [r2], #1
    d87e:	rsb	r3, r2, #1
    d882:	add	r3, r0
    d884:	add	r3, r1
    d886:	cmp	r3, #0
    d888:	bgt.n	d87a <dtostrf+0x2d2>
    d88a:	bic.w	r3, r0, r0, asr #31
    d88e:	adds	r3, #1
    d890:	add	r1, r3
    d892:	b.n	d722 <dtostrf+0x17a>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d894:	movs	r0, #73	; 0x49
    d896:	movs	r1, #78	; 0x4e
    d898:	movs	r2, #70	; 0x46
    d89a:	strb	r0, [r3, #0]
    d89c:	strb	r1, [r3, #1]
    d89e:	strb	r2, [r3, #2]
    d8a0:	adds	r0, r3, #3
    d8a2:	b.n	d628 <dtostrf+0x80>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d8a4:	cmp	r5, #0
    d8a6:	blt.n	d8da <dtostrf+0x332>
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    d8a8:	movs	r3, #0
    d8aa:	b.n	d842 <dtostrf+0x29a>
    d8ac:	mov	r0, r4
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d8ae:	movs	r2, #45	; 0x2d
    d8b0:	strb	r2, [r0, #0]
    d8b2:	adds	r4, r0, #1
    d8b4:	b.n	d84a <dtostrf+0x2a2>
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    d8b6:	cbz	r3, d8da <dtostrf+0x332>
    d8b8:	adds	r0, r2, r3
				*buf++ = ' ';
    d8ba:	movs	r3, #32
    d8bc:	strb.w	r3, [r4], #1
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    d8c0:	cmp	r4, r0
    d8c2:	bne.n	d8bc <dtostrf+0x314>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d8c4:	vmov	r3, s16
    d8c8:	cmp	r3, #0
    d8ca:	blt.n	d8e2 <dtostrf+0x33a>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    d8cc:	movs	r3, #78	; 0x4e
    d8ce:	movs	r2, #65	; 0x41
    d8d0:	strb	r3, [r0, #0]
    d8d2:	strb	r3, [r0, #2]
    d8d4:	strb	r2, [r0, #1]
    d8d6:	adds	r0, #3
    d8d8:	b.n	d628 <dtostrf+0x80>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d8da:	mov	r0, r4
    d8dc:	b.n	d8c4 <dtostrf+0x31c>
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    d8de:	mov	r3, r4
    d8e0:	b.n	d650 <dtostrf+0xa8>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    d8e2:	movs	r3, #0
    d8e4:	b.n	d8ae <dtostrf+0x306>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    d8e6:	mov	r0, r4
    d8e8:	b.n	d628 <dtostrf+0x80>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    d8ea:	mov	r3, r4
    d8ec:	b.n	d6be <dtostrf+0x116>
    d8ee:	nop
    d8f0:	.word	0x7f7fffff
    d8f4:	.word	0x200006a8
    d8f8:	.word	0x200006a4

0000d8fc <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    d8fc:	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    d8fe:	ldr	r3, [pc, #68]	; (d944 <digitalWrite.part.1+0x48>)
    d900:	ldr.w	r2, [r3, r0, lsl #3]
    d904:	ldrb.w	r4, [r2, #640]	; 0x280
    d908:	cbz	r4, d918 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    d90a:	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    d90c:	cbz	r1, d92e <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    d90e:	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d912:	ldr.w	r4, [sp], #4
    d916:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    d918:	add.w	r3, r3, r0, lsl #3
    d91c:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    d91e:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    d920:	cbnz	r1, d938 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    d922:	bic.w	r2, r2, #2
    d926:	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d928:	ldr.w	r4, [sp], #4
    d92c:	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    d92e:	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d932:	ldr.w	r4, [sp], #4
    d936:	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    d938:	orr.w	r2, r2, #3
    d93c:	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    d93e:	ldr.w	r4, [sp], #4
    d942:	bx	lr
    d944:	.word	0x200006ac

0000d948 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    d948:	ldr	r2, [pc, #112]	; (d9bc <pinMode.part.2+0x74>)
    d94a:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    d94e:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    d950:	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    d952:	beq.n	d978 <pinMode.part.2+0x30>
    d954:	cmp	r1, #4
    d956:	beq.n	d990 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    d958:	ldr.w	r0, [r2, r0, lsl #3]
    d95c:	movs	r2, #0
    d95e:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    d962:	cbz	r1, d970 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    d964:	cmp	r1, #2
    d966:	beq.n	d9aa <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    d968:	cmp	r1, #3
    d96a:	beq.n	d9b2 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    d96c:	str	r2, [r3, #0]
    d96e:	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    d970:	mov.w	r2, #256	; 0x100
    d974:	str	r2, [r3, #0]
    d976:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d978:	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d97c:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d980:	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d984:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    d986:	ldr	r2, [r3, #0]
    d988:	bic.w	r2, r2, #32
    d98c:	str	r2, [r3, #0]
    d98e:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d990:	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d994:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    d998:	movs	r0, #1
    d99a:	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    d99e:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    d9a0:	ldr	r2, [r3, #0]
    d9a2:	orr.w	r2, r2, #32
    d9a6:	str	r2, [r3, #0]
    d9a8:	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    d9aa:	movw	r2, #259	; 0x103
    d9ae:	str	r2, [r3, #0]
    d9b0:	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    d9b2:	mov.w	r2, #258	; 0x102
    d9b6:	str	r2, [r3, #0]
    d9b8:	bx	lr
    d9ba:	nop
    d9bc:	.word	0x200006ac

0000d9c0 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    d9c0:	adds	r0, #16
    d9c2:	ldr	r3, [pc, #8]	; (d9cc <attachInterruptVector+0xc>)
    d9c4:	str.w	r1, [r3, r0, lsl #2]
    d9c8:	bx	lr
    d9ca:	nop
    d9cc:	.word	0x20200000

0000d9d0 <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    d9d0:	push	{r4, r5}
	RTC_SR = 0;
    d9d2:	ldr	r3, [pc, #20]	; (d9e8 <rtc_set+0x18>)
	RTC_TPR = 0;
    d9d4:	ldr	r5, [pc, #20]	; (d9ec <rtc_set+0x1c>)
	RTC_TSR = t;
    d9d6:	ldr	r4, [pc, #24]	; (d9f0 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    d9d8:	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    d9da:	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    d9dc:	str	r2, [r3, #0]
	RTC_TPR = 0;
    d9de:	str	r2, [r5, #0]
	RTC_TSR = t;
    d9e0:	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    d9e2:	str	r1, [r3, #0]
}
    d9e4:	pop	{r4, r5}
    d9e6:	bx	lr
    d9e8:	.word	0x4003d014
    d9ec:	.word	0x4003d004
    d9f0:	.word	0x4003d000

0000d9f4 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    d9f4:	cmp	r0, #63	; 0x3f
    d9f6:	bhi.n	d9fc <digitalWrite+0x8>
    d9f8:	b.w	d8fc <digitalWrite.part.1>
    d9fc:	bx	lr
    d9fe:	nop

0000da00 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    da00:	cmp	r0, #63	; 0x3f
    da02:	bhi.n	da08 <pinMode+0x8>
    da04:	b.w	d948 <pinMode.part.2>
    da08:	bx	lr
    da0a:	nop

0000da0c <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    da0c:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    da0e:	ldr	r1, [pc, #48]	; (da40 <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    da10:	ldr	r3, [pc, #48]	; (da44 <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da12:	ldr	r2, [pc, #52]	; (da48 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    da14:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    da16:	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da18:	ldr	r2, [r2, #0]
	__enable_irq();
    da1a:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    da1c:	lsls	r2, r2, #5
    da1e:	bpl.n	da26 <micros+0x1a>
    da20:	cmp	r3, #50	; 0x32
    da22:	it	hi
    da24:	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    da26:	ldr	r1, [pc, #36]	; (da4c <micros+0x40>)
    da28:	rsb	r3, r3, #95744	; 0x17600
    da2c:	mov.w	r2, #1000	; 0x3e8
    da30:	adds	r3, #255	; 0xff
    da32:	umull	r1, r3, r1, r3
    da36:	mul.w	r0, r2, r0
}
    da3a:	add.w	r0, r0, r3, lsr #6
    da3e:	bx	lr
    da40:	.word	0x20005150
    da44:	.word	0xe000e018
    da48:	.word	0xe000ed04
    da4c:	.word	0xaaaaaaab

0000da50 <delay>:

void delay(uint32_t ms)
{
    da50:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    da54:	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    da56:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    da58:	ldr	r7, [pc, #128]	; (dadc <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    da5a:	ldr	r3, [pc, #132]	; (dae0 <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da5c:	ldr	r2, [pc, #132]	; (dae4 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    da5e:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    da60:	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da62:	ldr	r2, [r2, #0]
	__enable_irq();
    da64:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    da66:	lsls	r2, r2, #5
    da68:	bpl.n	da70 <delay+0x20>
    da6a:	cmp	r3, #50	; 0x32
    da6c:	it	hi
    da6e:	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    da70:	cbz	r5, dad8 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    da72:	rsb	r3, r3, #95744	; 0x17600
    da76:	ldr	r6, [pc, #112]	; (dae8 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    da78:	ldr.w	r9, [pc, #100]	; dae0 <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da7c:	ldr.w	r8, [pc, #100]	; dae4 <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    da80:	adds	r3, #255	; 0xff
    da82:	mov.w	r2, #1000	; 0x3e8
    da86:	umull	r1, r3, r6, r3
    da8a:	mul.w	r4, r2, r4
    da8e:	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    da92:	cpsid	i
	current = SYST_CVR;
    da94:	ldr.w	r1, [r9]
	count = systick_millis_count;
    da98:	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    da9a:	ldr.w	lr, [r8]
	__enable_irq();
    da9e:	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    daa0:	rsb	r3, r1, #95744	; 0x17600
    daa4:	adds	r3, #255	; 0xff
    daa6:	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    daaa:	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    daae:	rsb	r3, r4, r3, lsr #6
    dab2:	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    dab6:	beq.n	dabe <delay+0x6e>
    dab8:	cmp	r1, #50	; 0x32
    daba:	it	hi
    dabc:	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    dabe:	mla	r3, r0, r2, r3
    dac2:	cmp.w	r3, #1000	; 0x3e8
    dac6:	bcc.n	dad2 <delay+0x82>
				ms--;
				if (ms == 0) return;
    dac8:	subs	r5, #1
    daca:	beq.n	dad8 <delay+0x88>
				start += 1000;
    dacc:	add.w	r4, r4, #1000	; 0x3e8
    dad0:	b.n	da92 <delay+0x42>
			}
			yield();
    dad2:	bl	e748 <yield>
		}
    dad6:	b.n	da92 <delay+0x42>
    dad8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    dadc:	.word	0x20005150
    dae0:	.word	0xe000e018
    dae4:	.word	0xe000ed04
    dae8:	.word	0xaaaaaaab

0000daec <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    daec:	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    daee:	ldr	r3, [pc, #248]	; (dbe8 <_init_Teensyduino_internal_+0xfc>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    daf0:	ldr	r1, [pc, #248]	; (dbec <_init_Teensyduino_internal_+0x100>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    daf2:	ldr.w	ip, [pc, #280]	; dc0c <_init_Teensyduino_internal_+0x120>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    daf6:	ldr	r6, [pc, #248]	; (dbf0 <_init_Teensyduino_internal_+0x104>)
	FTM0_C2SC = 0x28;
    daf8:	ldr	r2, [pc, #248]	; (dbf4 <_init_Teensyduino_internal_+0x108>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    dafa:	ldr.w	lr, [pc, #276]	; dc10 <_init_Teensyduino_internal_+0x124>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    dafe:	ldr	r5, [pc, #248]	; (dbf8 <_init_Teensyduino_internal_+0x10c>)
	FTM0_C4SC = 0x28;
    db00:	ldr	r4, [pc, #248]	; (dbfc <_init_Teensyduino_internal_+0x110>)
	FTM0_C5SC = 0x28;
    db02:	ldr	r7, [pc, #252]	; (dc00 <_init_Teensyduino_internal_+0x114>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    db04:	mov.w	r0, #134217728	; 0x8000000
    db08:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    db0a:	mov.w	r0, #268435456	; 0x10000000
    db0e:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    db10:	mov.w	r0, #536870912	; 0x20000000
    db14:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    db16:	mov.w	r0, #1073741824	; 0x40000000
    db1a:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    db1c:	mov.w	r0, #2147483648	; 0x80000000
    db20:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    db22:	movs	r0, #0
    db24:	str	r0, [r1, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    db26:	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    db28:	movw	r1, #49151	; 0xbfff
    db2c:	str.w	r1, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    db30:	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    db34:	str	r3, [r6, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    db36:	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    db3a:	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
    db3c:	str	r3, [r5, #0]
	FTM0_C4SC = 0x28;
    db3e:	str	r3, [r4, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    db40:	add.w	r5, r5, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    db44:	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    db46:	add.w	r4, r4, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    db4a:	str	r3, [r6, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    db4c:	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    db50:	str	r3, [r2, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    db52:	add.w	r6, r6, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    db56:	add.w	r2, r2, #528384	; 0x81000
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    db5a:	add.w	lr, lr, #16
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    db5e:	addw	r5, r5, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    db62:	addw	r4, r4, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    db66:	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    db6a:	adds	r2, #16
	FTM3_C5SC = 0x28;
    db6c:	adds	r6, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    db6e:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    db70:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    db72:	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    db76:	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    db78:	str	r3, [r2, #0]
	FTM3_C5SC = 0x28;
    db7a:	str	r3, [r6, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    db7c:	ldr	r6, [pc, #132]	; (dc04 <_init_Teensyduino_internal_+0x118>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    db7e:	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    db80:	str	r3, [r2, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    db82:	movs	r2, #9
    db84:	str	r2, [r6, #0]
	FTM1_CNT = 0;
    db86:	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    db8a:	add.w	r6, r6, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    db8e:	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    db90:	adds	r6, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    db92:	str	r0, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    db94:	str	r1, [r6, #0]
	FTM1_C0SC = 0x28;
    db96:	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    db98:	str	r3, [r6, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    db9a:	str.w	r2, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    db9e:	add.w	r6, r6, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    dba2:	add.w	r7, r7, #520192	; 0x7f000
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    dba6:	addw	r6, r6, #2044	; 0x7fc
	FTM2_MOD = DEFAULT_FTM_MOD;
    dbaa:	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    dbac:	str	r0, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    dbae:	str	r1, [r7, #0]
	FTM2_C0SC = 0x28;
    dbb0:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    dbb2:	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    dbb4:	str.w	r2, [r6, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    dbb8:	adds	r6, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    dbba:	str.w	r0, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    dbbe:	addw	r6, r6, #4092	; 0xffc
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    dbc2:	ldr	r0, [pc, #68]	; (dc08 <_init_Teensyduino_internal_+0x11c>)
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    dbc4:	str	r1, [r6, #0]
	FTM3_C0SC = 0x28;
    dbc6:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    dbc8:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    dbca:	str	r2, [r0, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    dbcc:	bl	ea84 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    dbd0:	movs	r0, #25
    dbd2:	bl	da50 <delay>
	usb_init();
    dbd6:	bl	e684 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    dbda:	movw	r0, #275	; 0x113
}
    dbde:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    dbe2:	b.w	da50 <delay>
    dbe6:	nop
    dbe8:	.word	0xe000e104
    dbec:	.word	0x40038004
    dbf0:	.word	0x40038014
    dbf4:	.word	0x4003801c
    dbf8:	.word	0x40038024
    dbfc:	.word	0x4003802c
    dc00:	.word	0x40038034
    dc04:	.word	0x40038000
    dc08:	.word	0x400b9000
    dc0c:	.word	0x40038008
    dc10:	.word	0x4003800c

0000dc14 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    dc14:	cpsid	i
	avail = usb_buffer_available;
    dc16:	ldr	r0, [pc, #52]	; (dc4c <usb_malloc+0x38>)
    dc18:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    dc1a:	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    dc1e:	cmp	r3, #19
    dc20:	bgt.n	dc44 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    dc22:	mov.w	r1, #2147483648	; 0x80000000
    dc26:	lsrs	r1, r3
    dc28:	bic.w	r2, r2, r1
    dc2c:	str	r2, [r0, #0]
	__enable_irq();
    dc2e:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    dc30:	ldr	r0, [pc, #28]	; (dc50 <usb_malloc+0x3c>)
    dc32:	add.w	r3, r3, r3, lsl #3
    dc36:	lsls	r3, r3, #3
    dc38:	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    dc3a:	movs	r1, #0
    dc3c:	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    dc3e:	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    dc40:	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    dc42:	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    dc44:	cpsie	i
		return NULL;
    dc46:	movs	r0, #0
    dc48:	bx	lr
    dc4a:	nop
    dc4c:	.word	0x20000cd4
    dc50:	.word	0x20001698

0000dc54 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    dc54:	ldr	r3, [pc, #52]	; (dc8c <usb_free+0x38>)
    dc56:	ldr	r2, [pc, #56]	; (dc90 <usb_free+0x3c>)
    dc58:	subs	r3, r0, r3
    dc5a:	umull	r2, r3, r2, r3
    dc5e:	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    dc60:	cmp	r3, #19
    dc62:	bhi.n	dc7e <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    dc64:	ldr	r2, [pc, #44]	; (dc94 <usb_free+0x40>)
    dc66:	ldrb	r2, [r2, #0]
    dc68:	cbnz	r2, dc80 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    dc6a:	cpsid	i
	usb_buffer_available |= mask;
    dc6c:	ldr	r0, [pc, #40]	; (dc98 <usb_free+0x44>)
    dc6e:	mov.w	r1, #2147483648	; 0x80000000
    dc72:	ldr	r2, [r0, #0]
    dc74:	lsr.w	r3, r1, r3
    dc78:	orrs	r2, r3
    dc7a:	str	r2, [r0, #0]
	__enable_irq();
    dc7c:	cpsie	i
    dc7e:	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    dc80:	ldr	r2, [pc, #24]	; (dc9c <usb_free+0x48>)
    dc82:	ldrb	r2, [r2, #0]
    dc84:	cmp	r2, #0
    dc86:	beq.n	dc6a <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    dc88:	b.w	dd08 <usb_rx_memory>
    dc8c:	.word	0x20001698
    dc90:	.word	0x38e38e39
    dc94:	.word	0x20005249
    dc98:	.word	0x20000cd4
    dc9c:	.word	0x20005254

0000dca0 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    dca0:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    dca2:	cmp	r3, #5
    dca4:	bhi.n	dcd0 <usb_rx+0x30>
	__disable_irq();
    dca6:	cpsid	i
	ret = rx_first[endpoint];
    dca8:	ldr	r1, [pc, #40]	; (dcd4 <usb_rx+0x34>)
    dcaa:	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    dcae:	cbz	r0, dccc <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    dcb0:	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    dcb2:	ldr	r4, [pc, #36]	; (dcd8 <usb_rx+0x38>)
    dcb4:	ldrh	r5, [r0, #0]
    dcb6:	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    dcba:	ldr	r6, [r0, #4]
    dcbc:	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    dcc0:	subs	r2, r2, r5
    dcc2:	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    dcc6:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    dcc8:	pop	{r4, r5, r6}
    dcca:	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    dccc:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    dcce:	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    dcd0:	movs	r0, #0
    dcd2:	bx	lr
    dcd4:	.word	0x200051b4
    dcd8:	.word	0x200052d0

0000dcdc <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    dcdc:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    dcde:	cmp	r0, #5
    dce0:	bhi.n	dcfa <usb_tx_packet_count+0x1e>
	__disable_irq();
    dce2:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    dce4:	ldr	r3, [pc, #28]	; (dd04 <usb_tx_packet_count+0x28>)
    dce6:	ldr.w	r3, [r3, r0, lsl #2]
    dcea:	cbz	r3, dcfe <usb_tx_packet_count+0x22>
    dcec:	movs	r0, #0
    dcee:	ldr	r3, [r3, #4]
    dcf0:	adds	r0, #1
    dcf2:	cmp	r3, #0
    dcf4:	bne.n	dcee <usb_tx_packet_count+0x12>
	__enable_irq();
    dcf6:	cpsie	i
	return count;
    dcf8:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    dcfa:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    dcfc:	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    dcfe:	mov	r0, r3
    dd00:	b.n	dcf6 <usb_tx_packet_count+0x1a>
    dd02:	nop
    dd04:	.word	0x20005210

0000dd08 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    dd08:	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    dd0a:	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    dd0c:	ldr	r1, [pc, #104]	; (dd78 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    dd0e:	ldr	r6, [pc, #108]	; (dd7c <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    dd10:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    dd12:	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    dd16:	ldr	r7, [pc, #100]	; (dd7c <usb_rx_memory+0x74>)
    dd18:	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    dd1a:	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    dd1c:	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    dd20:	bpl.n	dd2e <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    dd22:	ldr.w	r4, [r6, r2, lsl #3]
    dd26:	cbz	r4, dd42 <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    dd28:	ldr.w	r2, [r6, r5, lsl #3]
    dd2c:	cbz	r2, dd5e <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    dd2e:	adds	r3, #1
    dd30:	cmp	r3, #7
    dd32:	bne.n	dd12 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    dd34:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    dd36:	ldr	r3, [pc, #72]	; (dd80 <usb_rx_memory+0x78>)
    dd38:	movs	r2, #0
    dd3a:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    dd3c:	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    dd3e:	b.w	dc54 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dd42:	ldr	r4, [pc, #60]	; (dd80 <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    dd44:	ldr	r5, [pc, #60]	; (dd84 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    dd46:	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    dd48:	add.w	r3, r7, r3, lsl #5
    dd4c:	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dd4e:	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    dd50:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    dd52:	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    dd54:	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    dd58:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    dd5a:	pop	{r4, r5, r6, r7}
    dd5c:	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dd5e:	ldr	r2, [pc, #32]	; (dd80 <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    dd60:	ldr	r1, [pc, #36]	; (dd88 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    dd62:	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    dd64:	add.w	r4, r7, r5, lsl #3
    dd68:	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dd6a:	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    dd6c:	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    dd6e:	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    dd70:	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    dd74:	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    dd76:	b.n	dd5a <usb_rx_memory+0x52>
    dd78:	.word	0x2000063c
    dd7c:	.word	0x20001c38
    dd80:	.word	0x20005249
    dd84:	.word	0x00400088
    dd88:	.word	0x004000c8

0000dd8c <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    dd8c:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    dd8e:	cmp	r3, #5
    dd90:	bhi.n	ddce <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    dd92:	ldr	r2, [pc, #108]	; (de00 <usb_tx+0x74>)
    dd94:	lsls	r0, r0, #5
    dd96:	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    dd9a:	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    dd9c:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    dd9e:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    dda0:	ldr	r4, [pc, #96]	; (de04 <usb_tx+0x78>)
    dda2:	ldrb	r2, [r4, r3]
    dda4:	cmp	r2, #3
    dda6:	bhi.n	dde0 <usb_tx+0x54>
    dda8:	tbb	[pc, r2]
    ddac:	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    ddb0:	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    ddb2:	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    ddb4:	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    ddb6:	tst.w	r0, #8
    ddba:	ite	ne
    ddbc:	movne	r3, #200	; 0xc8
    ddbe:	moveq	r3, #136	; 0x88
    ddc0:	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    ddc4:	adds	r1, #8
    ddc6:	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    ddc8:	str	r3, [r0, #0]
	__enable_irq();
    ddca:	cpsie	i
}
    ddcc:	pop	{r4, r5}
    ddce:	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    ddd0:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    ddd2:	movs	r2, #2
		break;
    ddd4:	b.n	ddb2 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    ddd6:	movs	r2, #5
    ddd8:	b.n	ddb2 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    ddda:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    dddc:	movs	r2, #4
		break;
    ddde:	b.n	ddb2 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    dde0:	ldr	r2, [pc, #36]	; (de08 <usb_tx+0x7c>)
    dde2:	ldr.w	r0, [r2, r3, lsl #2]
    dde6:	cbz	r0, ddf8 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    dde8:	ldr	r2, [pc, #32]	; (de0c <usb_tx+0x80>)
    ddea:	ldr.w	r0, [r2, r3, lsl #2]
    ddee:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    ddf0:	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    ddf4:	cpsie	i
		return;
    ddf6:	b.n	ddcc <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    ddf8:	str.w	r1, [r2, r3, lsl #2]
    ddfc:	ldr	r2, [pc, #12]	; (de0c <usb_tx+0x80>)
    ddfe:	b.n	ddf0 <usb_tx+0x64>
    de00:	.word	0x20001c38
    de04:	.word	0x20005258
    de08:	.word	0x20005210
    de0c:	.word	0x20005228

0000de10 <usb_isr>:
}



void usb_isr(void)
{
    de10:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    de14:	ldr.w	fp, [pc, #788]	; e12c <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    de18:	ldr.w	sl, [pc, #788]	; e130 <usb_isr+0x320>
}



void usb_isr(void)
{
    de1c:	sub	sp, #28
    de1e:	b.n	deaa <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    de20:	ldr	r7, [pc, #700]	; (e0e0 <usb_isr+0x2d0>)
    de22:	mov.w	r8, r3, lsr #2
    de26:	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    de2a:	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    de2c:	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    de30:	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    de34:	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    de36:	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    de3a:	and.w	r4, r3, #255	; 0xff
    de3e:	cmp	r3, #0
    de40:	bne.w	e134 <usb_isr+0x324>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    de44:	ldr.w	r3, [r7, r8, lsl #3]
    de48:	lsrs	r3, r3, #16
    de4a:	uxth	r1, r3
    de4c:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    de50:	cmp	r3, #0
    de52:	beq.w	e0cc <usb_isr+0x2bc>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    de56:	ldr	r3, [pc, #652]	; (e0e4 <usb_isr+0x2d4>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    de58:	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    de5c:	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    de60:	ldr.w	r2, [r3, r6, lsl #2]
    de64:	cmp	r2, #0
    de66:	beq.w	e1d0 <usb_isr+0x3c0>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    de6a:	ldr	r5, [pc, #636]	; (e0e8 <usb_isr+0x2d8>)
    de6c:	ldr.w	r3, [r5, r6, lsl #2]
    de70:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    de72:	ldr	r4, [pc, #632]	; (e0ec <usb_isr+0x2dc>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    de74:	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    de78:	ldrh.w	r3, [r4, r6, lsl #1]
    de7c:	add	r1, r3
    de7e:	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    de82:	bl	dc14 <usb_malloc>
					if (packet) {
    de86:	cmp	r0, #0
    de88:	beq.w	e1c2 <usb_isr+0x3b2>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    de8c:	ldr	r2, [pc, #608]	; (e0f0 <usb_isr+0x2e0>)
    de8e:	ldr	r3, [pc, #612]	; (e0f4 <usb_isr+0x2e4>)
    de90:	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    de94:	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    de98:	it	ne
    de9a:	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    de9c:	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    dea0:	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    dea4:	movs	r3, #8
    dea6:	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    deaa:	ldrb.w	r4, [fp]
    deae:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    deb0:	lsls	r0, r4, #29
    deb2:	bpl.n	deec <usb_isr+0xdc>
		if (usb_configuration) {
    deb4:	ldr	r3, [pc, #576]	; (e0f8 <usb_isr+0x2e8>)
    deb6:	ldrb	r3, [r3, #0]
    deb8:	cbz	r3, dee6 <usb_isr+0xd6>
			t = usb_reboot_timer;
    deba:	ldr	r1, [pc, #576]	; (e0fc <usb_isr+0x2ec>)
    debc:	ldrb	r2, [r1, #0]
			if (t) {
    debe:	and.w	r3, r2, #255	; 0xff
    dec2:	cbz	r2, ded0 <usb_isr+0xc0>
				usb_reboot_timer = --t;
    dec4:	subs	r3, #1
    dec6:	uxtb	r3, r3
    dec8:	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    deca:	cmp	r3, #0
    decc:	beq.w	e64c <usb_isr+0x83c>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    ded0:	ldr	r1, [pc, #556]	; (e100 <usb_isr+0x2f0>)
    ded2:	ldrb	r2, [r1, #0]
			if (t) {
    ded4:	and.w	r3, r2, #255	; 0xff
    ded8:	cbz	r2, dee6 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    deda:	subs	r3, #1
    dedc:	uxtb	r3, r3
    dede:	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    dee0:	cmp	r3, #0
    dee2:	beq.w	e1bc <usb_isr+0x3ac>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    dee6:	movs	r3, #4
    dee8:	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    deec:	and.w	r3, r4, #8
    def0:	and.w	r2, r3, #255	; 0xff
    def4:	cmp	r3, #0
    def6:	beq.w	e18e <usb_isr+0x37e>
		uint8_t endpoint;
		stat = USB0_STAT;
    defa:	ldrb.w	r3, [sl]
    defe:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    df00:	lsrs	r6, r3, #4
    df02:	bne.n	de20 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    df04:	lsrs	r0, r3, #2
    df06:	ldr	r7, [pc, #472]	; (e0e0 <usb_isr+0x2d0>)
	pid = BDT_PID(b->desc);
    df08:	ldr.w	r2, [r7, r0, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    df0c:	add.w	r1, r7, r0, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    df10:	ubfx	r2, r2, #2, #4
    df14:	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    df16:	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    df18:	cmp	r2, #12
    df1a:	bhi.w	e0ae <usb_isr+0x29e>
    df1e:	tbh	[pc, r2, lsl #1]
    df22:	.short	0x00ca
    df24:	.word	0x00c600ca
    df28:	.word	0x00c600c6
    df2c:	.word	0x00c600c6
    df30:	.word	0x008b00c6
    df34:	.word	0x00c600c6
    df38:	.word	0x000d00c6
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    df3c:	ldr	r2, [r1, #0]
    df3e:	ldr	r5, [pc, #452]	; (e104 <usb_isr+0x2f4>)
		setup.word2 = *(uint32_t *)(buf + 4);
    df40:	ldr	r1, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    df42:	ldr	r3, [pc, #452]	; (e108 <usb_isr+0x2f8>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    df44:	ldr	r6, [pc, #452]	; (e10c <usb_isr+0x2fc>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    df46:	ldr	r4, [pc, #424]	; (e0f0 <usb_isr+0x2e0>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    df48:	str	r1, [r5, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    df4a:	uxth	r1, r2
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    df4c:	str.w	r4, [r7, r0, lsl #3]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    df50:	str	r2, [r5, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    df52:	movs	r0, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    df54:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    df56:	cmp.w	r1, #2176	; 0x880
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    df5a:	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    df5c:	str	r3, [sp, #4]
    df5e:	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    df60:	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    df62:	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    df64:	beq.w	e5c4 <usb_isr+0x7b4>
    df68:	bls.w	e1d8 <usb_isr+0x3c8>
    df6c:	movw	r4, #8993	; 0x2321
    df70:	cmp	r1, r4
    df72:	beq.w	e5ce <usb_isr+0x7be>
    df76:	bhi.w	e304 <usb_isr+0x4f4>
    df7a:	movw	r4, #8225	; 0x2021
    df7e:	cmp	r1, r4
    df80:	beq.w	e31a <usb_isr+0x50a>
    df84:	movw	r4, #8737	; 0x2221
    df88:	cmp	r1, r4
    df8a:	beq.w	e46c <usb_isr+0x65c>
    df8e:	cmp.w	r1, #2304	; 0x900
    df92:	bne.w	e314 <usb_isr+0x504>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    df96:	ldr	r2, [pc, #352]	; (e0f8 <usb_isr+0x2e8>)
    df98:	ldrb	r1, [r5, #2]
    df9a:	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    df9c:	ldr	r5, [pc, #320]	; (e0e0 <usb_isr+0x2d0>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    df9e:	movs	r4, #4
    dfa0:	b.n	dfa8 <usb_isr+0x198>
    dfa2:	adds	r4, #1
    dfa4:	cmp	r4, #28
    dfa6:	beq.n	dfc2 <usb_isr+0x1b2>
			if (table[i].desc & BDT_OWN) {
    dfa8:	ldr.w	r3, [r7, r4, lsl #3]
    dfac:	lsls	r1, r3, #24
    dfae:	bpl.n	dfa2 <usb_isr+0x192>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    dfb0:	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dfb4:	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    dfb6:	ldr	r0, [r3, #4]
    dfb8:	subs	r0, #8
    dfba:	bl	dc54 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dfbe:	cmp	r4, #28
    dfc0:	bne.n	dfa8 <usb_isr+0x198>
    dfc2:	ldr	r3, [pc, #288]	; (e0e4 <usb_isr+0x2d4>)
    dfc4:	ldr	r2, [pc, #328]	; (e110 <usb_isr+0x300>)
    dfc6:	ldr	r1, [pc, #332]	; (e114 <usb_isr+0x304>)
    dfc8:	ldr	r5, [pc, #284]	; (e0e8 <usb_isr+0x2d8>)
    dfca:	ldr	r4, [pc, #288]	; (e0ec <usb_isr+0x2dc>)
    dfcc:	ldr	r0, [pc, #328]	; (e118 <usb_isr+0x308>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    dfce:	str	r5, [sp, #12]
    dfd0:	str	r4, [sp, #16]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    dfd2:	mov.w	r9, #0
    dfd6:	str	r0, [sp, #8]
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    dfd8:	mov	r8, r1
    dfda:	str	r6, [sp, #20]
    dfdc:	mov	r5, r2
    dfde:	mov	r4, r3
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    dfe0:	ldr	r0, [r4, #0]
			while (p) {
    dfe2:	cbz	r0, dff0 <usb_isr+0x1e0>
				n = p->next;
    dfe4:	ldr	r6, [r0, #4]
				usb_free(p);
    dfe6:	bl	dc54 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    dfea:	mov	r0, r6
    dfec:	cmp	r6, #0
    dfee:	bne.n	dfe4 <usb_isr+0x1d4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    dff0:	movs	r3, #0
    dff2:	str	r3, [r4, #0]
			rx_last[i] = NULL;
    dff4:	ldr	r3, [sp, #12]
			p = tx_first[i];
    dff6:	ldr	r0, [r5, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    dff8:	mov	r2, r3
    dffa:	movs	r3, #0
    dffc:	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    e000:	cbz	r0, e00e <usb_isr+0x1fe>
				n = p->next;
    e002:	ldr	r6, [r0, #4]
				usb_free(p);
    e004:	bl	dc54 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    e008:	mov	r0, r6
    e00a:	cmp	r6, #0
    e00c:	bne.n	e002 <usb_isr+0x1f2>
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    e00e:	ldr	r3, [sp, #8]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    e010:	movs	r2, #0
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    e012:	ldrb	r3, [r3, #0]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    e014:	str	r2, [r5, #0]
			tx_last[i] = NULL;
    e016:	str.w	r2, [r8], #4
			usb_rx_byte_count_data[i] = 0;
    e01a:	ldr	r2, [sp, #16]
    e01c:	mov.w	r1, #0
			switch (tx_state[i]) {
    e020:	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    e022:	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    e026:	cmp	r3, #3
    e028:	bhi.w	e520 <usb_isr+0x710>
    e02c:	tbh	[pc, r3, lsl #1]
    e030:	.word	0x027402c0
    e034:	.word	0x027402c0
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    e038:	ldr	r3, [pc, #204]	; (e108 <usb_isr+0x2f8>)
    e03a:	str	r3, [sp, #4]
    e03c:	ldr	r2, [r3, #0]
		if (data) {
    e03e:	cbz	r2, e09a <usb_isr+0x28a>
			size = ep0_tx_len;
    e040:	ldr	r3, [pc, #216]	; (e11c <usb_isr+0x30c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e042:	ldr	r1, [pc, #220]	; (e120 <usb_isr+0x310>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e044:	ldr	r6, [pc, #196]	; (e10c <usb_isr+0x2fc>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    e046:	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e048:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e04a:	ldrb.w	lr, [r6]
    e04e:	cmp	r0, #64	; 0x40
    e050:	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e052:	eor.w	ip, r4, #1
    e056:	it	cs
    e058:	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e05a:	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e05e:	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e062:	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e066:	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e06a:	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e06e:	ite	eq
    e070:	moveq	r1, #136	; 0x88
    e072:	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e074:	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e076:	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e07a:	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e07e:	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e082:	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e084:	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    e088:	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e08a:	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    e08e:	cbnz	r0, e096 <usb_isr+0x286>
    e090:	cmp	r5, #64	; 0x40
    e092:	it	ne
    e094:	movne	r2, #0
    e096:	ldr	r3, [sp, #4]
    e098:	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    e09a:	ldr	r3, [pc, #104]	; (e104 <usb_isr+0x2f4>)
    e09c:	ldrh	r2, [r3, #0]
    e09e:	cmp.w	r2, #1280	; 0x500
    e0a2:	bne.n	e0ae <usb_isr+0x29e>
			setup.bRequest = 0;
    e0a4:	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    e0a6:	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    e0a8:	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    e0aa:	ldr	r3, [pc, #120]	; (e124 <usb_isr+0x314>)
    e0ac:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    e0ae:	ldr	r2, [pc, #120]	; (e128 <usb_isr+0x318>)
    e0b0:	movs	r3, #1
    e0b2:	strb	r3, [r2, #0]
    e0b4:	b.n	dea4 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    e0b6:	ldr	r2, [pc, #76]	; (e104 <usb_isr+0x2f4>)
    e0b8:	ldrh	r5, [r2, #0]
    e0ba:	movw	r4, #8225	; 0x2021
    e0be:	cmp	r5, r4
    e0c0:	beq.w	e2b8 <usb_isr+0x4a8>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    e0c4:	ldr	r2, [pc, #40]	; (e0f0 <usb_isr+0x2e0>)
    e0c6:	str.w	r2, [r7, r0, lsl #3]
    e0ca:	b.n	e0ae <usb_isr+0x29e>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    e0cc:	ldr	r2, [pc, #32]	; (e0f0 <usb_isr+0x2e0>)
    e0ce:	ldr	r3, [pc, #36]	; (e0f4 <usb_isr+0x2e4>)
    e0d0:	tst.w	r9, #8
    e0d4:	it	ne
    e0d6:	movne	r3, r2
    e0d8:	str.w	r3, [r7, r8, lsl #3]
    e0dc:	b.n	dea4 <usb_isr+0x94>
    e0de:	nop
    e0e0:	.word	0x20001c38
    e0e4:	.word	0x200051b4
    e0e8:	.word	0x20005158
    e0ec:	.word	0x200052d0
    e0f0:	.word	0x004000c8
    e0f4:	.word	0x00400088
    e0f8:	.word	0x20005254
    e0fc:	.word	0x200051cd
    e100:	.word	0x2000513c
    e104:	.word	0x20005240
    e108:	.word	0x20005154
    e10c:	.word	0x200051cc
    e110:	.word	0x20005210
    e114:	.word	0x20005228
    e118:	.word	0x20005258
    e11c:	.word	0x20005170
    e120:	.word	0x20005248
    e124:	.word	0x40072098
    e128:	.word	0x40072094
    e12c:	.word	0x40072080
    e130:	.word	0x40072090
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    e134:	bl	dc54 <usb_free>
				packet = tx_first[endpoint];
    e138:	ldr	r2, [pc, #724]	; (e410 <usb_isr+0x600>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    e13a:	ldr	r1, [pc, #728]	; (e414 <usb_isr+0x604>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    e13c:	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    e140:	cmp	r3, #0
    e142:	beq.w	e29a <usb_isr+0x48a>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    e146:	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    e148:	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    e14a:	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    e14e:	add.w	r2, r3, #8
    e152:	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    e156:	cmp	r4, #3
    e158:	bhi.n	e166 <usb_isr+0x356>
    e15a:	tbb	[pc, r4]
    e15e:	.short	0x0f12
    e160:	.short	0x0215
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    e162:	movs	r2, #4
    e164:	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    e166:	ldrh	r2, [r3, #0]
    e168:	tst.w	r9, #8
    e16c:	ite	eq
    e16e:	moveq	r3, #136	; 0x88
    e170:	movne	r3, #200	; 0xc8
    e172:	orr.w	r3, r3, r2, lsl #16
    e176:	str.w	r3, [r7, r8, lsl #3]
    e17a:	b.n	dea4 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    e17c:	movs	r2, #2
    e17e:	strb	r2, [r1, r6]
						break;
    e180:	b.n	e166 <usb_isr+0x356>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    e182:	movs	r2, #3
    e184:	strb	r2, [r1, r6]
						break;
    e186:	b.n	e166 <usb_isr+0x356>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    e188:	movs	r2, #5
    e18a:	strb	r2, [r1, r6]
						break;
    e18c:	b.n	e166 <usb_isr+0x356>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    e18e:	lsls	r0, r4, #31
    e190:	bmi.w	e322 <usb_isr+0x512>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    e194:	lsls	r1, r4, #24
    e196:	bmi.w	e3be <usb_isr+0x5ae>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    e19a:	lsls	r2, r4, #30
    e19c:	bpl.n	e1ac <usb_isr+0x39c>
		uint8_t err = USB0_ERRSTAT;
    e19e:	ldr	r2, [pc, #632]	; (e418 <usb_isr+0x608>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e1a0:	ldr	r1, [pc, #632]	; (e41c <usb_isr+0x60c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    e1a2:	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e1a4:	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    e1a6:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    e1a8:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e1aa:	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    e1ac:	lsls	r3, r4, #27
    e1ae:	bpl.n	e1b6 <usb_isr+0x3a6>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    e1b0:	ldr	r3, [pc, #616]	; (e41c <usb_isr+0x60c>)
    e1b2:	movs	r2, #16
    e1b4:	strb	r2, [r3, #0]
	}

}
    e1b6:	add	sp, #28
    e1b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    e1bc:	bl	d408 <usb_serial_flush_callback>
    e1c0:	b.n	dee6 <usb_isr+0xd6>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    e1c2:	ldr	r2, [pc, #604]	; (e420 <usb_isr+0x610>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    e1c4:	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    e1c8:	ldrb	r3, [r2, #0]
    e1ca:	adds	r3, #1
    e1cc:	strb	r3, [r2, #0]
    e1ce:	b.n	dea4 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    e1d0:	str.w	r0, [r3, r6, lsl #2]
    e1d4:	ldr	r5, [pc, #588]	; (e424 <usb_isr+0x614>)
    e1d6:	b.n	de72 <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e1d8:	movw	r4, #770	; 0x302
    e1dc:	cmp	r1, r4
    e1de:	beq.w	e5d6 <usb_isr+0x7c6>
    e1e2:	bhi.w	e37c <usb_isr+0x56c>
    e1e6:	cmp	r1, #130	; 0x82
    e1e8:	beq.w	e4f4 <usb_isr+0x6e4>
    e1ec:	cmp.w	r1, #258	; 0x102
    e1f0:	beq.w	e3ec <usb_isr+0x5dc>
    e1f4:	cmp	r1, #128	; 0x80
    e1f6:	bne.w	e314 <usb_isr+0x504>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    e1fa:	ldr	r4, [pc, #556]	; (e428 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		datalen = 2;
    e1fc:	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    e1fe:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    e200:	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e202:	ldrh	r2, [r5, #6]
    e204:	cmp	r2, r0
    e206:	bcs.w	e62c <usb_isr+0x81c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e20a:	ldr	r1, [pc, #544]	; (e42c <usb_isr+0x61c>)
    e20c:	ldrb	r5, [r1, #0]
    e20e:	orr.w	ip, r5, #2
    e212:	add.w	r0, r7, ip, lsl #3
    e216:	cmp	r2, #64	; 0x40
    e218:	mov	lr, r2
    e21a:	mov.w	r3, #1
    e21e:	it	cs
    e220:	movcs.w	lr, #64	; 0x40
    e224:	str	r4, [r0, #4]
    e226:	add.w	r9, r4, lr
    e22a:	rsb	r0, lr, r2
    e22e:	mov.w	r8, lr, lsl #16
    e232:	str	r3, [sp, #8]
    e234:	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e236:	movs	r4, #200	; 0xc8
    e238:	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e23c:	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e240:	str.w	r3, [r7, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
    e244:	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    e246:	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e248:	ldr.w	ip, [pc, #508]	; e448 <usb_isr+0x638>
	ep0_tx_data_toggle ^= 1;
    e24c:	ldr	r3, [pc, #480]	; (e430 <usb_isr+0x620>)
	ep0_tx_bdt_bank ^= 1;
    e24e:	ldr.w	r8, [pc, #476]	; e42c <usb_isr+0x61c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e252:	cmp	r0, #0
    e254:	bne.w	e4ae <usb_isr+0x69e>
    e258:	cmp.w	lr, #64	; 0x40
    e25c:	bne.n	e31a <usb_isr+0x50a>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e25e:	orr.w	r4, r4, #2
    e262:	add.w	r3, r7, r4, lsl #3
    e266:	ldr.w	lr, [pc, #480]	; e448 <usb_isr+0x638>
    e26a:	str.w	r9, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e26e:	cmp	r2, #0
    e270:	bne.w	e4da <usb_isr+0x6ca>
    e274:	lsls	r2, r0, #16
    e276:	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    e27a:	ldrb.w	r3, [sp, #8]
    e27e:	strb	r3, [r6, #0]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e280:	cmp	r0, #64	; 0x40
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e282:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    e284:	add.w	r3, r9, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e288:	str.w	r2, [lr, r4, lsl #3]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e28c:	bne.n	e31a <usb_isr+0x50a>
    e28e:	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    e290:	ldr	r2, [pc, #416]	; (e434 <usb_isr+0x624>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e292:	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    e294:	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e296:	str	r3, [r1, #0]
    e298:	b.n	e31a <usb_isr+0x50a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    e29a:	ldrb	r3, [r1, r6]
    e29c:	cmp	r3, #3
    e29e:	bhi.w	e4e6 <usb_isr+0x6d6>
    e2a2:	add	r2, pc, #4	; (adr r2, e2a8 <usb_isr+0x498>)
    e2a4:	ldr.w	pc, [r2, r3, lsl #2]
    e2a8:	.word	0x0000dea5
    e2ac:	.word	0x0000dea5
    e2b0:	.word	0x0000e377
    e2b4:	.word	0x0000e371
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    e2b8:	ldrh	r2, [r2, #4]
    e2ba:	cbnz	r2, e2d4 <usb_isr+0x4c4>
    e2bc:	ldr	r2, [pc, #376]	; (e438 <usb_isr+0x628>)
    e2be:	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    e2c0:	ldrb.w	r3, [r1], #1
    e2c4:	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    e2c8:	cmp	r5, r1
    e2ca:	bne.n	e2c0 <usb_isr+0x4b0>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e2cc:	ldr	r2, [pc, #364]	; (e43c <usb_isr+0x62c>)
    e2ce:	ldr	r2, [r2, #0]
    e2d0:	cmp	r2, #134	; 0x86
    e2d2:	beq.n	e3d2 <usb_isr+0x5c2>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e2d4:	ldr	r1, [pc, #340]	; (e42c <usb_isr+0x61c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e2d6:	ldr	r6, [pc, #344]	; (e430 <usb_isr+0x620>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e2d8:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e2da:	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e2dc:	orr.w	r5, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e2e0:	eor.w	r4, r4, #1
    e2e4:	strb	r4, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e2e6:	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e2ea:	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e2ec:	mov.w	r4, #0
    e2f0:	str	r4, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e2f2:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e2f6:	ite	eq
    e2f8:	moveq	r1, #136	; 0x88
    e2fa:	movne	r1, #200	; 0xc8
    e2fc:	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    e300:	strb	r2, [r6, #0]
    e302:	b.n	e0c4 <usb_isr+0x2b4>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e304:	movw	r4, #26273	; 0x66a1
    e308:	cmp	r1, r4
    e30a:	beq.n	e314 <usb_isr+0x504>
    e30c:	movw	r4, #26529	; 0x67a1
    e310:	cmp	r1, r4
    e312:	beq.n	e3da <usb_isr+0x5ca>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e314:	ldr	r3, [pc, #296]	; (e440 <usb_isr+0x630>)
    e316:	movs	r2, #15
    e318:	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    e31a:	ldr	r2, [pc, #296]	; (e444 <usb_isr+0x634>)
    e31c:	movs	r3, #1
    e31e:	strb	r3, [r2, #0]
    e320:	b.n	e0ae <usb_isr+0x29e>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e322:	ldr	r1, [pc, #288]	; (e444 <usb_isr+0x634>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e324:	ldr	r3, [pc, #288]	; (e448 <usb_isr+0x638>)
    e326:	ldr	r0, [pc, #292]	; (e44c <usb_isr+0x63c>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e328:	ldr	r6, [pc, #256]	; (e42c <usb_isr+0x61c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e32a:	ldr.w	ip, [pc, #276]	; e440 <usb_isr+0x630>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e32e:	ldr	r5, [pc, #232]	; (e418 <usb_isr+0x608>)
		USB0_ISTAT = 0xFF;
    e330:	ldr.w	lr, [pc, #232]	; e41c <usb_isr+0x60c>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e334:	ldr	r7, [pc, #280]	; (e450 <usb_isr+0x640>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e336:	movs	r4, #2
    e338:	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e33a:	ldr	r4, [pc, #280]	; (e454 <usb_isr+0x644>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e33c:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e33e:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    e340:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    e342:	ldr	r0, [pc, #276]	; (e458 <usb_isr+0x648>)
    e344:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    e346:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    e348:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e34a:	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e34c:	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e34e:	ldr	r4, [pc, #268]	; (e45c <usb_isr+0x64c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e350:	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e354:	ldr	r6, [pc, #264]	; (e460 <usb_isr+0x650>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e356:	movs	r3, #255	; 0xff
    e358:	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e35a:	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e35c:	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    e35e:	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e362:	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e364:	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e366:	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e368:	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    e36a:	add	sp, #28
    e36c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e370:	movs	r3, #1
    e372:	strb	r3, [r1, r6]
						break;
    e374:	b.n	dea4 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    e376:	movs	r3, #0
    e378:	strb	r3, [r1, r6]
						break;
    e37a:	b.n	dea4 <usb_isr+0x94>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e37c:	cmp.w	r1, #1280	; 0x500
    e380:	beq.w	e5ce <usb_isr+0x7be>
    e384:	bcc.n	e314 <usb_isr+0x504>
    e386:	sub.w	r1, r1, #1664	; 0x680
    e38a:	cmp	r1, #1
    e38c:	bhi.n	e314 <usb_isr+0x504>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    e38e:	ldr	r2, [pc, #212]	; (e464 <usb_isr+0x654>)
    e390:	ldr	r4, [r2, #4]
    e392:	cmp	r4, #0
    e394:	beq.n	e314 <usb_isr+0x504>
    e396:	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e398:	ldrh.w	lr, [r5, #4]
    e39c:	b.n	e3a6 <usb_isr+0x596>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    e39e:	adds	r2, #12
			if (list->addr == NULL) break;
    e3a0:	ldr	r4, [r2, #4]
    e3a2:	cmp	r4, #0
    e3a4:	beq.n	e314 <usb_isr+0x504>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e3a6:	ldrh	r3, [r2, #0]
    e3a8:	cmp	r3, r0
    e3aa:	bne.n	e39e <usb_isr+0x58e>
    e3ac:	ldrh	r3, [r2, #2]
    e3ae:	cmp	r3, lr
    e3b0:	bne.n	e39e <usb_isr+0x58e>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    e3b2:	lsrs	r0, r0, #8
    e3b4:	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    e3b6:	ite	eq
    e3b8:	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    e3ba:	ldrhne	r0, [r2, #8]
    e3bc:	b.n	e202 <usb_isr+0x3f2>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e3be:	ldr	r1, [pc, #128]	; (e440 <usb_isr+0x630>)
		USB0_ISTAT = USB_ISTAT_STALL;
    e3c0:	ldr	r3, [pc, #88]	; (e41c <usb_isr+0x60c>)
    e3c2:	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e3c4:	movs	r0, #13
    e3c6:	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    e3c8:	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    e3ca:	lsls	r2, r4, #30
    e3cc:	bpl.w	e1ac <usb_isr+0x39c>
    e3d0:	b.n	e19e <usb_isr+0x38e>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e3d2:	ldr	r2, [pc, #148]	; (e468 <usb_isr+0x658>)
    e3d4:	movs	r1, #15
    e3d6:	strb	r1, [r2, #0]
    e3d8:	b.n	e2d4 <usb_isr+0x4c4>
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e3da:	ldr	r4, [pc, #76]	; (e428 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
    e3dc:	movs	r1, #32
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
		reply_buffer[1] = 0;
    e3de:	strb	r2, [r4, #1]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e3e0:	movs	r2, #4
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
    e3e2:	strb	r0, [r4, #2]
		reply_buffer[3] = 0x20;
    e3e4:	strb	r1, [r4, #3]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e3e6:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
		data = reply_buffer;
		datalen = 4;
    e3e8:	mov	r0, r2
    e3ea:	b.n	e202 <usb_isr+0x3f2>
    e3ec:	ldrh	r1, [r5, #4]
    e3ee:	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    e3f2:	cmp	r1, #6
    e3f4:	bhi.n	e314 <usb_isr+0x504>
    e3f6:	ldrh	r2, [r5, #2]
    e3f8:	cmp	r2, #0
    e3fa:	bne.n	e314 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    e3fc:	ldr	r4, [pc, #64]	; (e440 <usb_isr+0x630>)
    e3fe:	str	r0, [sp, #8]
    e400:	lsls	r1, r1, #2
    e402:	add	r4, r1
    e404:	ldrb	r1, [r4, #0]
    e406:	bic.w	r1, r1, #2
    e40a:	strb	r1, [r4, #0]
    e40c:	b.n	e486 <usb_isr+0x676>
    e40e:	nop
    e410:	.word	0x20005210
    e414:	.word	0x20005258
    e418:	.word	0x40072088
    e41c:	.word	0x40072080
    e420:	.word	0x20005249
    e424:	.word	0x20005158
    e428:	.word	0x2000524c
    e42c:	.word	0x20005248
    e430:	.word	0x200051cc
    e434:	.word	0x20005170
    e438:	.word	0x200052c3
    e43c:	.word	0x200052c4
    e440:	.word	0x400720c0
    e444:	.word	0x40072094
    e448:	.word	0x20001c38
    e44c:	.word	0x00400088
    e450:	.word	0x40072098
    e454:	.word	0x20005174
    e458:	.word	0x200051d0
    e45c:	.word	0x40072084
    e460:	.word	0x4007208c
    e464:	.word	0x20000644
    e468:	.word	0x200051cd
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    e46c:	ldrh	r1, [r5, #4]
    e46e:	cmp	r1, #0
    e470:	bne.w	e5fc <usb_isr+0x7ec>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e474:	ldr	r3, [pc, #472]	; (e650 <usb_isr+0x840>)
    e476:	ldr	r2, [pc, #476]	; (e654 <usb_isr+0x844>)
			usb_cdc_line_rtsdtr = setup.wValue;
    e478:	ldr	r4, [pc, #476]	; (e658 <usb_isr+0x848>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e47a:	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e47c:	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e47e:	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e480:	str	r0, [sp, #8]
    e482:	mov	r2, r1
    e484:	strb	r5, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e486:	movs	r0, #0
    e488:	mov	r9, r0
    e48a:	mov	r8, r0
    e48c:	mov	lr, r0
    e48e:	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e490:	ldr	r1, [pc, #456]	; (e65c <usb_isr+0x84c>)
    e492:	ldrb	r5, [r1, #0]
    e494:	orr.w	ip, r5, #2
    e498:	add.w	r3, r7, ip, lsl #3
    e49c:	str	r3, [sp, #12]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e49e:	ldr	r3, [sp, #8]
    e4a0:	cmp	r3, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4a2:	ldr	r3, [sp, #12]
    e4a4:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4a6:	ite	eq
    e4a8:	moveq	r4, #136	; 0x88
    e4aa:	movne	r4, #200	; 0xc8
    e4ac:	b.n	e238 <usb_isr+0x428>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    e4ae:	cmp	r0, #64	; 0x40
    e4b0:	bls.w	e25e <usb_isr+0x44e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4b4:	orr.w	r4, r4, #2
    e4b8:	add.w	r1, ip, r4, lsl #3
    e4bc:	str.w	r9, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4c0:	cbz	r2, e4e2 <usb_isr+0x6d2>
    e4c2:	ldr	r2, [pc, #412]	; (e660 <usb_isr+0x850>)
	ep0_tx_data_toggle ^= 1;
    e4c4:	ldrb.w	r1, [sp, #8]
    e4c8:	strb	r1, [r3, #0]
	ep0_tx_bdt_bank ^= 1;
    e4ca:	strb.w	r5, [r8]
    e4ce:	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    e4d0:	add.w	r3, r9, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4d4:	str.w	r2, [ip, r4, lsl #3]
    e4d8:	b.n	e290 <usb_isr+0x480>
    e4da:	lsls	r2, r0, #16
    e4dc:	orr.w	r2, r2, #200	; 0xc8
    e4e0:	b.n	e27a <usb_isr+0x46a>
    e4e2:	ldr	r2, [pc, #384]	; (e664 <usb_isr+0x854>)
    e4e4:	b.n	e4c4 <usb_isr+0x6b4>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    e4e6:	tst.w	r9, #8
    e4ea:	ite	eq
    e4ec:	moveq	r3, #2
    e4ee:	movne	r3, #3
    e4f0:	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    e4f2:	b.n	dea4 <usb_isr+0x94>
    e4f4:	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e4f6:	ldr	r3, [pc, #368]	; (e668 <usb_isr+0x858>)
    e4f8:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    e4fc:	cmp	r1, #6
    e4fe:	bhi.w	e316 <usb_isr+0x506>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e502:	ldr	r4, [pc, #360]	; (e66c <usb_isr+0x85c>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e504:	lsls	r1, r1, #2
    e506:	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e508:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    e50a:	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e50c:	ldrb	r2, [r3, #0]
    e50e:	lsls	r3, r2, #30
    e510:	bpl.n	e600 <usb_isr+0x7f0>
    e512:	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    e514:	movs	r0, #2
    e516:	b.n	e202 <usb_isr+0x3f2>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e518:	ldr	r3, [sp, #8]
    e51a:	mov.w	r2, #1
    e51e:	strb	r2, [r3, #0]
    e520:	ldr	r3, [sp, #8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    e522:	add.w	r9, r9, #1
    e526:	adds	r3, #1
    e528:	cmp.w	r9, #6
    e52c:	add.w	r4, r4, #4
    e530:	add.w	r5, r5, #4
    e534:	str	r3, [sp, #8]
    e536:	bne.w	dfe0 <usb_isr+0x1d0>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e53a:	ldr	r3, [pc, #308]	; (e670 <usb_isr+0x860>)
    e53c:	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    e53e:	ldr	r5, [pc, #308]	; (e674 <usb_isr+0x864>)
		cfg = usb_endpoint_config_table;
    e540:	ldr.w	r8, [pc, #316]	; e680 <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e544:	movs	r0, #0
    e546:	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e548:	mov.w	r9, #1
    e54c:	b.n	e56e <usb_isr+0x75e>
    e54e:	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e552:	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    e556:	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e55a:	movs	r3, #0
    e55c:	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    e560:	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e564:	ldr	r3, [pc, #272]	; (e678 <usb_isr+0x868>)
    e566:	cmp	r5, r3
    e568:	add.w	r9, r9, #1
    e56c:	beq.n	e5ba <usb_isr+0x7aa>
			epconf = *cfg++;
    e56e:	ldrb.w	r3, [r8], #1
			*reg = epconf;
    e572:	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    e576:	lsls	r2, r3, #28
    e578:	bpl.n	e54e <usb_isr+0x73e>
				usb_packet_t *p;
				p = usb_malloc();
    e57a:	bl	dc14 <usb_malloc>
				if (p) {
    e57e:	cmp	r0, #0
    e580:	beq.n	e618 <usb_isr+0x808>
					table[index(i, RX, EVEN)].addr = p->buf;
    e582:	add.w	r3, r7, r9, lsl #5
    e586:	mov.w	r4, r9, lsl #2
    e58a:	adds	r0, #8
    e58c:	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    e58e:	ldr	r3, [pc, #212]	; (e664 <usb_isr+0x854>)
    e590:	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    e594:	bl	dc14 <usb_malloc>
				if (p) {
    e598:	cmp	r0, #0
    e59a:	beq.n	e604 <usb_isr+0x7f4>
					table[index(i, RX, ODD)].addr = p->buf;
    e59c:	orr.w	r3, r4, #1
    e5a0:	add.w	r2, r7, r3, lsl #3
    e5a4:	adds	r0, #8
    e5a6:	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    e5a8:	ldr	r2, [pc, #180]	; (e660 <usb_isr+0x850>)
    e5aa:	str.w	r2, [r7, r3, lsl #3]
    e5ae:	b.n	e552 <usb_isr+0x742>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    e5b0:	ldr	r3, [sp, #8]
    e5b2:	mov.w	r2, #0
    e5b6:	strb	r2, [r3, #0]
    e5b8:	b.n	e520 <usb_isr+0x710>
    e5ba:	ldrb	r3, [r6, #0]
    e5bc:	str	r3, [sp, #8]
    e5be:	eor.w	r2, r3, #1
    e5c2:	b.n	e486 <usb_isr+0x676>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    e5c4:	ldr	r2, [pc, #180]	; (e67c <usb_isr+0x86c>)
    e5c6:	ldr	r4, [pc, #164]	; (e66c <usb_isr+0x85c>)
    e5c8:	ldrb	r2, [r2, #0]
    e5ca:	strb	r2, [r4, #0]
    e5cc:	b.n	e202 <usb_isr+0x3f2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e5ce:	movs	r3, #1
    e5d0:	movs	r2, #0
    e5d2:	str	r3, [sp, #8]
    e5d4:	b.n	e486 <usb_isr+0x676>
    e5d6:	ldrh	r1, [r5, #4]
    e5d8:	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    e5dc:	cmp	r1, #6
    e5de:	bhi.w	e314 <usb_isr+0x504>
    e5e2:	ldrh	r2, [r5, #2]
    e5e4:	cmp	r2, #0
    e5e6:	bne.w	e314 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    e5ea:	ldr	r4, [pc, #124]	; (e668 <usb_isr+0x858>)
    e5ec:	str	r0, [sp, #8]
    e5ee:	lsls	r1, r1, #2
    e5f0:	add	r4, r1
    e5f2:	ldrb	r1, [r4, #0]
    e5f4:	orr.w	r1, r1, #2
    e5f8:	strb	r1, [r4, #0]
    e5fa:	b.n	e486 <usb_isr+0x676>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    e5fc:	str	r0, [sp, #8]
    e5fe:	b.n	e486 <usb_isr+0x676>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    e600:	movs	r0, #2
    e602:	b.n	e202 <usb_isr+0x3f2>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    e604:	ldr	r3, [pc, #104]	; (e670 <usb_isr+0x860>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    e606:	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    e60a:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    e60c:	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    e610:	ldr	r2, [pc, #92]	; (e670 <usb_isr+0x860>)
    e612:	adds	r3, #1
    e614:	strb	r3, [r2, #0]
    e616:	b.n	e552 <usb_isr+0x742>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    e618:	ldr	r3, [pc, #84]	; (e670 <usb_isr+0x860>)
    e61a:	ldr	r2, [pc, #84]	; (e670 <usb_isr+0x860>)
    e61c:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    e61e:	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    e622:	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    e624:	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    e628:	strb	r3, [r2, #0]
    e62a:	b.n	e594 <usb_isr+0x784>
    e62c:	cmp	r0, #64	; 0x40
    e62e:	mov	lr, r0
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e630:	mov.w	r3, #1
    e634:	it	cs
    e636:	movcs.w	lr, #64	; 0x40
    e63a:	rsb	r0, lr, r0
    e63e:	mov.w	r8, lr, lsl #16
    e642:	add.w	r9, r4, lr
    e646:	movs	r2, #0
    e648:	str	r3, [sp, #8]
    e64a:	b.n	e490 <usb_isr+0x680>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    e64c:	bkpt	0x0000
    e64e:	nop
    e650:	.word	0x20005150
    e654:	.word	0x200052cc
    e658:	.word	0x2000514c
    e65c:	.word	0x20005248
    e660:	.word	0x004000c8
    e664:	.word	0x00400088
    e668:	.word	0x400720c0
    e66c:	.word	0x2000524c
    e670:	.word	0x20005249
    e674:	.word	0x400720c4
    e678:	.word	0x400720dc
    e67c:	.word	0x20005254
    e680:	.word	0x2000063c

0000e684 <usb_init>:
}



void usb_init(void)
{
    e684:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    e688:	bl	d4e0 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e68c:	movs	r3, #0
    e68e:	ldr	r1, [pc, #140]	; (e71c <usb_init+0x98>)
		table[i].desc = 0;
    e690:	mov	r2, r3
		table[i].addr = 0;
    e692:	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    e696:	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e69a:	adds	r3, #1
    e69c:	cmp	r3, #28
		table[i].desc = 0;
		table[i].addr = 0;
    e69e:	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    e6a0:	mov.w	r4, #0
    e6a4:	ldr	r0, [pc, #116]	; (e71c <usb_init+0x98>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    e6a6:	bne.n	e692 <usb_init+0xe>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e6a8:	ldr	r1, [pc, #116]	; (e720 <usb_init+0x9c>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    e6aa:	ldr	r2, [pc, #120]	; (e724 <usb_init+0xa0>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e6ac:	ldr	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    e6ae:	ldr.w	r8, [pc, #140]	; e73c <usb_init+0xb8>
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    e6b2:	ldr	r7, [pc, #116]	; (e728 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e6b4:	ldr	r5, [pc, #116]	; (e72c <usb_init+0xa8>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    e6b6:	ldr	r6, [pc, #120]	; (e730 <usb_init+0xac>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e6b8:	ldr.w	ip, [pc, #132]	; e740 <usb_init+0xbc>
	USB0_ERRSTAT = 0xFF;
    e6bc:	ldr.w	lr, [pc, #132]	; e744 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    e6c0:	orr.w	r3, r3, #262144	; 0x40000
    e6c4:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    e6c6:	ldr	r3, [r2, #0]
    e6c8:	orr.w	r3, r3, #50331648	; 0x3000000
    e6cc:	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    e6ce:	ubfx	r3, r0, #8, #8
    e6d2:	strb.w	r3, [r8]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    e6d6:	add.w	r1, r1, #172032	; 0x2a000
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    e6da:	ubfx	r3, r0, #16, #8
    e6de:	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e6e0:	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e6e2:	movs	r3, #255	; 0xff

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    e6e4:	adds	r1, #204	; 0xcc
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e6e6:	add.w	r2, r2, #411648	; 0x64800
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    e6ea:	strb	r0, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e6ec:	add.w	r2, r2, #264	; 0x108
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    e6f0:	strb.w	r3, [ip]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e6f4:	ldr	r5, [pc, #60]	; (e734 <usb_init+0xb0>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    e6f6:	strb.w	r3, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e6fa:	ldr	r0, [pc, #60]	; (e738 <usb_init+0xb4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    e6fc:	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    e6fe:	movs	r3, #1
    e700:	strb.w	r3, [r8, #-8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e704:	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    e706:	strb	r4, [r1, #0]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e708:	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e70c:	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    e70e:	strb.w	r3, [r7, #-44]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    e712:	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    e714:	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    e716:	strb	r1, [r2, #0]
    e718:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e71c:	.word	0x20001c38
    e720:	.word	0x40048034
    e724:	.word	0x4000d800
    e728:	.word	0x400720b0
    e72c:	.word	0x400720b4
    e730:	.word	0x40072010
    e734:	.word	0xe000e435
    e738:	.word	0xe000e104
    e73c:	.word	0x4007209c
    e740:	.word	0x40072080
    e744:	.word	0x40072088

0000e748 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    e748:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    e74c:	ldr	r6, [pc, #196]	; (e814 <yield+0xcc>)
    e74e:	ldrb	r3, [r6, #0]
    e750:	cbz	r3, e778 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    e752:	ldr	r7, [pc, #196]	; (e818 <yield+0xd0>)
    e754:	ldrb	r2, [r7, #0]
    e756:	cbnz	r2, e778 <yield+0x30>
	running = 1;
    e758:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    e75a:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    e75c:	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    e75e:	bmi.n	e7ce <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    e760:	lsls	r2, r3, #30
    e762:	bmi.n	e798 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    e764:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    e766:	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    e768:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    e76a:	bpl.n	e778 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    e76c:	ldr	r3, [pc, #172]	; (e81c <yield+0xd4>)
    e76e:	ldr	r2, [r3, #0]
    e770:	cbz	r2, e778 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    e772:	mrs	r2, IPSR
		if (ipsr != 0) return;
    e776:	cbz	r2, e77c <yield+0x34>
    e778:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e77c:	mrs	r1, PRIMASK
		__disable_irq();
    e780:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    e782:	ldr	r0, [r3, #0]
		if (first == nullptr) {
    e784:	cbz	r0, e78e <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    e786:	ldr	r4, [pc, #152]	; (e820 <yield+0xd8>)
    e788:	ldrb	r2, [r4, #0]
    e78a:	cmp	r2, #0
    e78c:	beq.n	e7ec <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e78e:	cmp	r1, #0
    e790:	bne.n	e778 <yield+0x30>
    e792:	cpsie	i
    e794:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    e798:	ldr.w	r8, [pc, #144]	; e82c <yield+0xe4>
    e79c:	ldrb.w	r2, [r8]
    e7a0:	cmp	r2, #0
    e7a2:	beq.n	e764 <yield+0x1c>
    e7a4:	ldr.w	r9, [pc, #136]	; e830 <yield+0xe8>
    e7a8:	movs	r4, #0
    e7aa:	b.n	e7b8 <yield+0x70>
    e7ac:	adds	r4, #1
    e7ae:	ldrb.w	r3, [r8]
    e7b2:	uxtb	r4, r4
    e7b4:	cmp	r3, r4
    e7b6:	bls.n	e7de <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    e7b8:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    e7bc:	ldr	r3, [r5, #0]
    e7be:	mov	r0, r5
    e7c0:	ldr	r3, [r3, #16]
    e7c2:	blx	r3
    e7c4:	cmp	r0, #0
    e7c6:	beq.n	e7ac <yield+0x64>
    e7c8:	ldr	r3, [r5, #16]
    e7ca:	blx	r3
    e7cc:	b.n	e7ac <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    e7ce:	bl	d1f4 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    e7d2:	cbnz	r0, e808 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    e7d4:	ldr	r3, [pc, #76]	; (e824 <yield+0xdc>)
    e7d6:	ldrb	r3, [r3, #0]
    e7d8:	cbnz	r3, e7e2 <yield+0x9a>
    e7da:	ldrb	r3, [r6, #0]
    e7dc:	b.n	e760 <yield+0x18>
    e7de:	ldrb	r3, [r6, #0]
    e7e0:	b.n	e764 <yield+0x1c>
    e7e2:	ldrb	r3, [r6, #0]
    e7e4:	and.w	r3, r3, #254	; 0xfe
    e7e8:	strb	r3, [r6, #0]
    e7ea:	b.n	e760 <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    e7ec:	ldr	r5, [r0, #20]
    e7ee:	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    e7f0:	movs	r3, #1
    e7f2:	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    e7f4:	cbz	r5, e80e <yield+0xc6>
			firstYield->_prev = nullptr;
    e7f6:	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e7f8:	cbnz	r1, e7fc <yield+0xb4>
    e7fa:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    e7fc:	movs	r5, #0
    e7fe:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    e800:	ldr	r3, [r0, #8]
    e802:	blx	r3
		runningFromYield = false;
    e804:	strb	r5, [r4, #0]
    e806:	b.n	e778 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    e808:	bl	ea78 <serialEvent()>
    e80c:	b.n	e7d4 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    e80e:	ldr	r3, [pc, #24]	; (e828 <yield+0xe0>)
    e810:	str	r5, [r3, #0]
    e812:	b.n	e7f8 <yield+0xb0>
    e814:	.word	0x20000cd8
    e818:	.word	0x2000525e
    e81c:	.word	0x2000526c
    e820:	.word	0x20005270
    e824:	.word	0x20000cec
    e828:	.word	0x20005268
    e82c:	.word	0x2000528c
    e830:	.word	0x20005274

0000e834 <EventResponder::triggerEventNotImmediate()>:
uint8_t _serialEvent_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB1_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB2_default __attribute__((weak)) PROGMEM = 0 ;	

void EventResponder::triggerEventNotImmediate()
{
    e834:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e836:	mrs	r2, PRIMASK
		__disable_irq();
    e83a:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    e83c:	ldrb	r3, [r0, #29]
    e83e:	cbnz	r3, e84e <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    e840:	ldrb	r1, [r0, #28]
    e842:	cmp	r1, #1
    e844:	beq.n	e858 <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    e846:	cmp	r1, #3
    e848:	beq.n	e86c <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    e84a:	movs	r3, #1
    e84c:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e84e:	cbnz	r2, e852 <EventResponder::triggerEventNotImmediate()+0x1e>
    e850:	cpsie	i
	}
	enableInterrupts(irq);
}
    e852:	ldr.w	r4, [sp], #4
    e856:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    e858:	ldr	r4, [pc, #68]	; (e8a0 <EventResponder::triggerEventNotImmediate()+0x6c>)
    e85a:	ldr	r1, [r4, #0]
    e85c:	cbz	r1, e888 <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    e85e:	ldr	r1, [pc, #68]	; (e8a4 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    e860:	str	r3, [r0, #20]
				_prev = lastYield;
    e862:	ldr	r3, [r1, #0]
    e864:	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    e866:	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    e868:	str	r0, [r3, #20]
    e86a:	b.n	e84a <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    e86c:	ldr	r4, [pc, #56]	; (e8a8 <EventResponder::triggerEventNotImmediate()+0x74>)
    e86e:	ldr	r1, [r4, #0]
    e870:	cbz	r1, e894 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    e872:	ldr	r1, [pc, #56]	; (e8ac <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    e874:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    e876:	ldr	r3, [r1, #0]
    e878:	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    e87a:	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    e87c:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    e87e:	ldr	r3, [pc, #48]	; (e8b0 <EventResponder::triggerEventNotImmediate()+0x7c>)
    e880:	mov.w	r1, #268435456	; 0x10000000
    e884:	str	r1, [r3, #0]
    e886:	b.n	e84a <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    e888:	ldr	r3, [pc, #24]	; (e8a4 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    e88a:	str	r1, [r0, #20]
				_prev = nullptr;
    e88c:	str	r1, [r0, #24]
				firstYield = this;
    e88e:	str	r0, [r4, #0]
				lastYield = this;
    e890:	str	r0, [r3, #0]
    e892:	b.n	e84a <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    e894:	ldr	r3, [pc, #20]	; (e8ac <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    e896:	str	r1, [r0, #20]
				_prev = nullptr;
    e898:	str	r1, [r0, #24]
				firstInterrupt = this;
    e89a:	str	r0, [r4, #0]
				lastInterrupt = this;
    e89c:	str	r0, [r3, #0]
    e89e:	b.n	e87e <EventResponder::triggerEventNotImmediate()+0x4a>
    e8a0:	.word	0x2000526c
    e8a4:	.word	0x20005268
    e8a8:	.word	0x20005260
    e8ac:	.word	0x20005264
    e8b0:	.word	0xe000ed04

0000e8b4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    e8b4:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e8b6:	mrs	r2, PRIMASK
		__disable_irq();
    e8ba:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    e8bc:	ldr	r4, [pc, #48]	; (e8f0 <EventResponder::runFromInterrupt()+0x3c>)
    e8be:	ldr	r0, [r4, #0]
		if (first) {
    e8c0:	cbz	r0, e8e4 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    e8c2:	ldr	r6, [pc, #48]	; (e8f4 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    e8c4:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    e8c6:	ldr	r3, [r0, #20]
    e8c8:	str	r3, [r4, #0]
			if (firstInterrupt) {
    e8ca:	cbz	r3, e8ea <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    e8cc:	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e8ce:	cbnz	r2, e8d2 <EventResponder::runFromInterrupt()+0x1e>
    e8d0:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    e8d2:	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    e8d4:	ldr	r3, [r0, #8]
    e8d6:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    e8d8:	mrs	r2, PRIMASK
		__disable_irq();
    e8dc:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    e8de:	ldr	r0, [r4, #0]
		if (first) {
    e8e0:	cmp	r0, #0
    e8e2:	bne.n	e8c6 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    e8e4:	cbnz	r2, e8e8 <EventResponder::runFromInterrupt()+0x34>
    e8e6:	cpsie	i
    e8e8:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    e8ea:	str	r3, [r6, #0]
    e8ec:	b.n	e8ce <EventResponder::runFromInterrupt()+0x1a>
    e8ee:	nop
    e8f0:	.word	0x20005260
    e8f4:	.word	0x20005264

0000e8f8 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    e8f8:	b.w	e8b4 <EventResponder::runFromInterrupt()>

0000e8fc <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    e8fc:	ldr	r2, [pc, #8]	; (e908 <systick_isr+0xc>)
    e8fe:	ldr	r3, [r2, #0]
    e900:	adds	r3, #1
    e902:	str	r3, [r2, #0]
    e904:	bx	lr
    e906:	nop
    e908:	.word	0x20005150

0000e90c <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    e90c:	b.w	d210 <usb_serial_flush_input>

0000e910 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    e910:	b.w	d1c4 <usb_serial_peekchar>

0000e914 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    e914:	b.w	d17c <usb_serial_getchar>

0000e918 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    e918:	b.w	d1f4 <usb_serial_available>

0000e91c <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    e91c:	b.w	d3b0 <usb_serial_flush_output>

0000e920 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    e920:	b.w	d368 <usb_serial_write_buffer_free>

0000e924 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    e924:	mov	r0, r1
    e926:	mov	r1, r2
    e928:	b.w	d248 <usb_serial_write>

0000e92c <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    e92c:	mov	r0, r1
    e92e:	b.w	d350 <usb_serial_putchar>
    e932:	nop

0000e934 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    e934:	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
    e936:	mov	r6, r1
    e938:	cbz	r1, e958 <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
    e93a:	cbz	r2, e95c <Print::write(unsigned char const*, unsigned int)+0x28>
    e93c:	mov	r7, r0
    e93e:	mov	r4, r2
    e940:	movs	r5, #0
    e942:	ldr	r3, [r7, #0]
    e944:	ldrb.w	r1, [r6], #1
    e948:	ldr	r3, [r3, #0]
    e94a:	mov	r0, r7
    e94c:	blx	r3
    e94e:	subs	r4, #1
    e950:	add	r5, r0
    e952:	bne.n	e942 <Print::write(unsigned char const*, unsigned int)+0xe>
    e954:	mov	r0, r5
    e956:	pop	{r3, r4, r5, r6, r7, pc}
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    e958:	mov	r0, r1
    e95a:	pop	{r3, r4, r5, r6, r7, pc}
    e95c:	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    e95e:	pop	{r3, r4, r5, r6, r7, pc}

0000e960 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    e960:	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    e962:	ldr	r2, [pc, #24]	; (e97c <Print::println()+0x1c>)
	return write(buf, 2);
    e964:	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    e966:	ldrh	r2, [r2, #0]
	return write(buf, 2);
    e968:	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    e96a:	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    e96c:	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    e96e:	strh.w	r2, [sp, #4]
	return write(buf, 2);
    e972:	movs	r2, #2
    e974:	blx	r3
}
    e976:	add	sp, #12
    e978:	ldr.w	pc, [sp], #4
    e97c:	.word	0x200008d4

0000e980 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    e980:	push	{r4, lr}
	((class Print *)file)->write((uint8_t *)ptr, len);
    e982:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    e984:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    e986:	ldr	r3, [r3, #4]
    e988:	blx	r3
	return len;
}
    e98a:	mov	r0, r4
    e98c:	pop	{r4, pc}
    e98e:	nop

0000e990 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    e990:	push	{r1, r2, r3}
    e992:	push	{lr}
    e994:	sub	sp, #8
    e996:	add	r2, sp, #12
    e998:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    e99c:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    e99e:	bl	11f30 <vdprintf>
#endif
}
    e9a2:	add	sp, #8
    e9a4:	ldr.w	lr, [sp], #4
    e9a8:	add	sp, #12
    e9aa:	bx	lr

0000e9ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    e9ac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e9b0:	sub	sp, #72	; 0x48
    e9b2:	ldrb.w	r6, [sp, #104]	; 0x68
    e9b6:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    e9ba:	cmp	r6, #1
    e9bc:	bls.n	ea5e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xb2>
    e9be:	mov	r4, r2
    e9c0:	mov	r5, r3
	if (n == 0) {
    e9c2:	orrs.w	r3, r4, r5
    e9c6:	mov	r9, r0
    e9c8:	beq.n	ea52 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa6>
    e9ca:	uxtb	r6, r6
    e9cc:	movs	r7, #0
    e9ce:	mov.w	r8, #65	; 0x41
    e9d2:	b.n	e9d8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    e9d4:	uxtb.w	r8, r3
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    e9d8:	mov	r0, r4
    e9da:	mov	r1, r5
    e9dc:	mov	r2, r6
    e9de:	mov	r3, r7
    e9e0:	bl	f490 <__aeabi_uldivmod>
    e9e4:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    e9e6:	cmp	r1, #0
    e9e8:	it	eq
    e9ea:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    e9ec:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
    e9ee:	mov	r0, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    e9f0:	add	r4, sp, #72	; 0x48
    e9f2:	add.w	lr, r3, #48	; 0x30
    e9f6:	add	r4, r8
    e9f8:	itte	cs
    e9fa:	addcs	r3, #55	; 0x37
    e9fc:	uxtbcs.w	lr, r3
    ea00:	uxtbcc.w	lr, lr
			n /= base;
    ea04:	mov	r3, r7
    ea06:	mov	r1, r5
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    ea08:	strb.w	lr, [r4, #-68]
			n /= base;
    ea0c:	mov	r2, r6
    ea0e:	bl	f490 <__aeabi_uldivmod>
    ea12:	mov	r4, r0
    ea14:	mov	r5, r1
			if (n == 0) break;
    ea16:	orrs.w	r3, r4, r5
			i--;
    ea1a:	add.w	r3, r8, #4294967295
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    ea1e:	bne.n	e9d4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x28>
			i--;
		}
	}
	if (sign) {
    ea20:	cmp.w	sl, #0
    ea24:	beq.n	ea38 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    ea26:	add.w	r8, r8, #4294967295
    ea2a:	uxtb.w	r8, r8
		buf[i] = '-';
    ea2e:	add	r3, sp, #72	; 0x48
    ea30:	add	r3, r8
    ea32:	movs	r2, #45	; 0x2d
    ea34:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    ea38:	ldr.w	r3, [r9]
    ea3c:	add	r2, sp, #4
    ea3e:	add.w	r1, r2, r8
    ea42:	ldr	r3, [r3, #4]
    ea44:	mov	r0, r9
    ea46:	rsb	r2, r8, #66	; 0x42
    ea4a:	blx	r3
}
    ea4c:	add	sp, #72	; 0x48
    ea4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    ea52:	movs	r3, #48	; 0x30
    ea54:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    ea58:	mov.w	r8, #65	; 0x41
    ea5c:	b.n	ea20 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x74>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    ea5e:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    ea60:	add	sp, #72	; 0x48
    ea62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ea66:	nop

0000ea68 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    ea68:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    ea6a:	bl	f74 <setup>
	while (1) {
		loop();
    ea6e:	bl	11d0 <loop>
		yield();
    ea72:	bl	e748 <yield>
    ea76:	b.n	ea6e <main+0x6>

0000ea78 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    ea78:	bx	lr
    ea7a:	nop

0000ea7c <operator new(unsigned int)>:
    ea7c:	b.w	f894 <malloc>

0000ea80 <operator delete(void*, unsigned int)>:
    ea80:	b.w	f8a4 <free>

0000ea84 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    ea84:	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    ea86:	ldr	r0, [pc, #164]	; (eb2c <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    ea88:	ldr	r2, [pc, #164]	; (eb30 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    ea8a:	ldr	r3, [pc, #168]	; (eb34 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    ea8c:	ldr	r5, [pc, #168]	; (eb38 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    ea8e:	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    ea90:	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    ea92:	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    ea94:	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    ea96:	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    ea98:	ldr	r4, [pc, #160]	; (eb3c <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    ea9a:	cmp	r3, #8
    ea9c:	beq.n	eb00 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    ea9e:	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    eaa0:	ldr	r0, [pc, #156]	; (eb40 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    eaa2:	ldr	r1, [pc, #160]	; (eb44 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    eaa4:	beq.n	eb16 <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    eaa6:	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    eaa8:	ite	eq
    eaaa:	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    eaac:	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    eaae:	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    eab0:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    eab2:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    eab4:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    eab6:	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    eab8:	ldr	r3, [pc, #140]	; (eb48 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    eaba:	ldr	r1, [pc, #144]	; (eb4c <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    eabc:	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    eabe:	ldr	r2, [pc, #144]	; (eb50 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    eac0:	cbz	r3, eaf2 <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    eac2:	movs	r3, #1
    eac4:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    eac6:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    eac8:	ldr	r3, [pc, #136]	; (eb54 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    eaca:	ldr	r1, [pc, #140]	; (eb58 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    eacc:	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    eace:	ldr	r2, [pc, #140]	; (eb5c <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    ead0:	cmp	r3, #1
    ead2:	bls.n	eb22 <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    ead4:	cmp	r3, #4
    ead6:	bls.n	eaf8 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    ead8:	cmp	r3, #8
    eada:	bls.n	eb1a <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    eadc:	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    eade:	ite	ls
    eae0:	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    eae2:	movhi	r3, #135	; 0x87
    eae4:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    eae6:	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    eae8:	ldr	r3, [pc, #116]	; (eb60 <analog_init+0xdc>)
    eaea:	movs	r2, #1
    eaec:	strb	r2, [r3, #0]
}
    eaee:	pop	{r4, r5}
    eaf0:	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    eaf2:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    eaf4:	str	r3, [r2, #0]
    eaf6:	b.n	eac8 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    eaf8:	movs	r3, #132	; 0x84
    eafa:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    eafc:	str	r3, [r2, #0]
    eafe:	b.n	eae8 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    eb00:	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    eb04:	ldr	r1, [pc, #60]	; (eb44 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    eb06:	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    eb08:	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    eb0a:	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    eb0c:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    eb0e:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    eb10:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    eb12:	str	r3, [r1, #0]
    eb14:	b.n	eab8 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    eb16:	movs	r2, #57	; 0x39
    eb18:	b.n	eb0a <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    eb1a:	movs	r3, #133	; 0x85
    eb1c:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    eb1e:	str	r3, [r2, #0]
    eb20:	b.n	eae8 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    eb22:	movs	r3, #128	; 0x80
    eb24:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    eb26:	str	r3, [r2, #0]
    eb28:	b.n	eae8 <analog_init+0x64>
    eb2a:	nop
    eb2c:	.word	0x40074000
    eb30:	.word	0x40074001
    eb34:	.word	0x20000ced
    eb38:	.word	0x4003b008
    eb3c:	.word	0x4003b00c
    eb40:	.word	0x400bb008
    eb44:	.word	0x400bb00c
    eb48:	.word	0x2000528e
    eb4c:	.word	0x4003b020
    eb50:	.word	0x400bb020
    eb54:	.word	0x20000cee
    eb58:	.word	0x4003b024
    eb5c:	.word	0x400bb024
    eb60:	.word	0x2000528d

0000eb64 <__aeabi_atexit>:
    eb64:	mov	r3, r1
    eb66:	mov	r1, r0
    eb68:	mov	r0, r3
    eb6a:	b.w	f808 <__cxa_atexit>
    eb6e:	nop

0000eb70 <__aeabi_drsub>:
    eb70:	eor.w	r1, r1, #2147483648	; 0x80000000
    eb74:	b.n	eb7c <__adddf3>
    eb76:	nop

0000eb78 <__aeabi_dsub>:
    eb78:	eor.w	r3, r3, #2147483648	; 0x80000000

0000eb7c <__adddf3>:
    eb7c:	push	{r4, r5, lr}
    eb7e:	mov.w	r4, r1, lsl #1
    eb82:	mov.w	r5, r3, lsl #1
    eb86:	teq	r4, r5
    eb8a:	it	eq
    eb8c:	teqeq	r0, r2
    eb90:	itttt	ne
    eb92:	orrsne.w	ip, r4, r0
    eb96:	orrsne.w	ip, r5, r2
    eb9a:	mvnsne.w	ip, r4, asr #21
    eb9e:	mvnsne.w	ip, r5, asr #21
    eba2:	beq.w	ed6a <__adddf3+0x1ee>
    eba6:	mov.w	r4, r4, lsr #21
    ebaa:	rsbs	r5, r4, r5, lsr #21
    ebae:	it	lt
    ebb0:	neglt	r5, r5
    ebb2:	ble.n	ebce <__adddf3+0x52>
    ebb4:	add	r4, r5
    ebb6:	eor.w	r2, r0, r2
    ebba:	eor.w	r3, r1, r3
    ebbe:	eor.w	r0, r2, r0
    ebc2:	eor.w	r1, r3, r1
    ebc6:	eor.w	r2, r0, r2
    ebca:	eor.w	r3, r1, r3
    ebce:	cmp	r5, #54	; 0x36
    ebd0:	it	hi
    ebd2:	pophi	{r4, r5, pc}
    ebd4:	tst.w	r1, #2147483648	; 0x80000000
    ebd8:	mov.w	r1, r1, lsl #12
    ebdc:	mov.w	ip, #1048576	; 0x100000
    ebe0:	orr.w	r1, ip, r1, lsr #12
    ebe4:	beq.n	ebec <__adddf3+0x70>
    ebe6:	negs	r0, r0
    ebe8:	sbc.w	r1, r1, r1, lsl #1
    ebec:	tst.w	r3, #2147483648	; 0x80000000
    ebf0:	mov.w	r3, r3, lsl #12
    ebf4:	orr.w	r3, ip, r3, lsr #12
    ebf8:	beq.n	ec00 <__adddf3+0x84>
    ebfa:	negs	r2, r2
    ebfc:	sbc.w	r3, r3, r3, lsl #1
    ec00:	teq	r4, r5
    ec04:	beq.w	ed56 <__adddf3+0x1da>
    ec08:	sub.w	r4, r4, #1
    ec0c:	rsbs	lr, r5, #32
    ec10:	blt.n	ec2e <__adddf3+0xb2>
    ec12:	lsl.w	ip, r2, lr
    ec16:	lsr.w	r2, r2, r5
    ec1a:	adds	r0, r0, r2
    ec1c:	adc.w	r1, r1, #0
    ec20:	lsl.w	r2, r3, lr
    ec24:	adds	r0, r0, r2
    ec26:	asr.w	r3, r3, r5
    ec2a:	adcs	r1, r3
    ec2c:	b.n	ec4c <__adddf3+0xd0>
    ec2e:	sub.w	r5, r5, #32
    ec32:	add.w	lr, lr, #32
    ec36:	cmp	r2, #1
    ec38:	lsl.w	ip, r3, lr
    ec3c:	it	cs
    ec3e:	orrcs.w	ip, ip, #2
    ec42:	asr.w	r3, r3, r5
    ec46:	adds	r0, r0, r3
    ec48:	adcs.w	r1, r1, r3, asr #31
    ec4c:	and.w	r5, r1, #2147483648	; 0x80000000
    ec50:	bpl.n	ec62 <__adddf3+0xe6>
    ec52:	mov.w	lr, #0
    ec56:	rsbs	ip, ip, #0
    ec5a:	sbcs.w	r0, lr, r0
    ec5e:	sbc.w	r1, lr, r1
    ec62:	cmp.w	r1, #1048576	; 0x100000
    ec66:	bcc.n	eca0 <__adddf3+0x124>
    ec68:	cmp.w	r1, #2097152	; 0x200000
    ec6c:	bcc.n	ec88 <__adddf3+0x10c>
    ec6e:	lsrs	r1, r1, #1
    ec70:	movs.w	r0, r0, rrx
    ec74:	mov.w	ip, ip, rrx
    ec78:	add.w	r4, r4, #1
    ec7c:	mov.w	r2, r4, lsl #21
    ec80:	cmn.w	r2, #4194304	; 0x400000
    ec84:	bcs.w	edbc <__adddf3+0x240>
    ec88:	cmp.w	ip, #2147483648	; 0x80000000
    ec8c:	it	eq
    ec8e:	movseq.w	ip, r0, lsr #1
    ec92:	adcs.w	r0, r0, #0
    ec96:	adc.w	r1, r1, r4, lsl #20
    ec9a:	orr.w	r1, r1, r5
    ec9e:	pop	{r4, r5, pc}
    eca0:	movs.w	ip, ip, lsl #1
    eca4:	adcs	r0, r0
    eca6:	adc.w	r1, r1, r1
    ecaa:	tst.w	r1, #1048576	; 0x100000
    ecae:	sub.w	r4, r4, #1
    ecb2:	bne.n	ec88 <__adddf3+0x10c>
    ecb4:	teq	r1, #0
    ecb8:	itt	eq
    ecba:	moveq	r1, r0
    ecbc:	moveq	r0, #0
    ecbe:	clz	r3, r1
    ecc2:	it	eq
    ecc4:	addeq	r3, #32
    ecc6:	sub.w	r3, r3, #11
    ecca:	subs.w	r2, r3, #32
    ecce:	bge.n	ecea <__adddf3+0x16e>
    ecd0:	adds	r2, #12
    ecd2:	ble.n	ece6 <__adddf3+0x16a>
    ecd4:	add.w	ip, r2, #20
    ecd8:	rsb	r2, r2, #12
    ecdc:	lsl.w	r0, r1, ip
    ece0:	lsr.w	r1, r1, r2
    ece4:	b.n	ed00 <__adddf3+0x184>
    ece6:	add.w	r2, r2, #20
    ecea:	it	le
    ecec:	rsble	ip, r2, #32
    ecf0:	lsl.w	r1, r1, r2
    ecf4:	lsr.w	ip, r0, ip
    ecf8:	itt	le
    ecfa:	orrle.w	r1, r1, ip
    ecfe:	lslle	r0, r2
    ed00:	subs	r4, r4, r3
    ed02:	ittt	ge
    ed04:	addge.w	r1, r1, r4, lsl #20
    ed08:	orrge	r1, r5
    ed0a:	popge	{r4, r5, pc}
    ed0c:	mvn.w	r4, r4
    ed10:	subs	r4, #31
    ed12:	bge.n	ed4e <__adddf3+0x1d2>
    ed14:	adds	r4, #12
    ed16:	bgt.n	ed36 <__adddf3+0x1ba>
    ed18:	add.w	r4, r4, #20
    ed1c:	rsb	r2, r4, #32
    ed20:	lsr.w	r0, r0, r4
    ed24:	lsl.w	r3, r1, r2
    ed28:	orr.w	r0, r0, r3
    ed2c:	lsr.w	r3, r1, r4
    ed30:	orr.w	r1, r5, r3
    ed34:	pop	{r4, r5, pc}
    ed36:	rsb	r4, r4, #12
    ed3a:	rsb	r2, r4, #32
    ed3e:	lsr.w	r0, r0, r2
    ed42:	lsl.w	r3, r1, r4
    ed46:	orr.w	r0, r0, r3
    ed4a:	mov	r1, r5
    ed4c:	pop	{r4, r5, pc}
    ed4e:	lsr.w	r0, r1, r4
    ed52:	mov	r1, r5
    ed54:	pop	{r4, r5, pc}
    ed56:	teq	r4, #0
    ed5a:	eor.w	r3, r3, #1048576	; 0x100000
    ed5e:	itte	eq
    ed60:	eoreq.w	r1, r1, #1048576	; 0x100000
    ed64:	addeq	r4, #1
    ed66:	subne	r5, #1
    ed68:	b.n	ec08 <__adddf3+0x8c>
    ed6a:	mvns.w	ip, r4, asr #21
    ed6e:	it	ne
    ed70:	mvnsne.w	ip, r5, asr #21
    ed74:	beq.n	edca <__adddf3+0x24e>
    ed76:	teq	r4, r5
    ed7a:	it	eq
    ed7c:	teqeq	r0, r2
    ed80:	beq.n	ed8e <__adddf3+0x212>
    ed82:	orrs.w	ip, r4, r0
    ed86:	itt	eq
    ed88:	moveq	r1, r3
    ed8a:	moveq	r0, r2
    ed8c:	pop	{r4, r5, pc}
    ed8e:	teq	r1, r3
    ed92:	ittt	ne
    ed94:	movne	r1, #0
    ed96:	movne	r0, #0
    ed98:	popne	{r4, r5, pc}
    ed9a:	movs.w	ip, r4, lsr #21
    ed9e:	bne.n	edac <__adddf3+0x230>
    eda0:	lsls	r0, r0, #1
    eda2:	adcs	r1, r1
    eda4:	it	cs
    eda6:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    edaa:	pop	{r4, r5, pc}
    edac:	adds.w	r4, r4, #4194304	; 0x400000
    edb0:	itt	cc
    edb2:	addcc.w	r1, r1, #1048576	; 0x100000
    edb6:	popcc	{r4, r5, pc}
    edb8:	and.w	r5, r1, #2147483648	; 0x80000000
    edbc:	orr.w	r1, r5, #2130706432	; 0x7f000000
    edc0:	orr.w	r1, r1, #15728640	; 0xf00000
    edc4:	mov.w	r0, #0
    edc8:	pop	{r4, r5, pc}
    edca:	mvns.w	ip, r4, asr #21
    edce:	itte	ne
    edd0:	movne	r1, r3
    edd2:	movne	r0, r2
    edd4:	mvnseq.w	ip, r5, asr #21
    edd8:	itt	ne
    edda:	movne	r3, r1
    eddc:	movne	r2, r0
    edde:	orrs.w	r4, r0, r1, lsl #12
    ede2:	itte	eq
    ede4:	orrseq.w	r5, r2, r3, lsl #12
    ede8:	teqeq	r1, r3
    edec:	orrne.w	r1, r1, #524288	; 0x80000
    edf0:	pop	{r4, r5, pc}
    edf2:	nop

0000edf4 <__aeabi_ui2d>:
    edf4:	teq	r0, #0
    edf8:	itt	eq
    edfa:	moveq	r1, #0
    edfc:	bxeq	lr
    edfe:	push	{r4, r5, lr}
    ee00:	mov.w	r4, #1024	; 0x400
    ee04:	add.w	r4, r4, #50	; 0x32
    ee08:	mov.w	r5, #0
    ee0c:	mov.w	r1, #0
    ee10:	b.n	ecb4 <__adddf3+0x138>
    ee12:	nop

0000ee14 <__aeabi_i2d>:
    ee14:	teq	r0, #0
    ee18:	itt	eq
    ee1a:	moveq	r1, #0
    ee1c:	bxeq	lr
    ee1e:	push	{r4, r5, lr}
    ee20:	mov.w	r4, #1024	; 0x400
    ee24:	add.w	r4, r4, #50	; 0x32
    ee28:	ands.w	r5, r0, #2147483648	; 0x80000000
    ee2c:	it	mi
    ee2e:	negmi	r0, r0
    ee30:	mov.w	r1, #0
    ee34:	b.n	ecb4 <__adddf3+0x138>
    ee36:	nop

0000ee38 <__aeabi_f2d>:
    ee38:	lsls	r2, r0, #1
    ee3a:	mov.w	r1, r2, asr #3
    ee3e:	mov.w	r1, r1, rrx
    ee42:	mov.w	r0, r2, lsl #28
    ee46:	itttt	ne
    ee48:	andsne.w	r3, r2, #4278190080	; 0xff000000
    ee4c:	teqne	r3, #4278190080	; 0xff000000
    ee50:	eorne.w	r1, r1, #939524096	; 0x38000000
    ee54:	bxne	lr
    ee56:	teq	r2, #0
    ee5a:	ite	ne
    ee5c:	teqne	r3, #4278190080	; 0xff000000
    ee60:	bxeq	lr
    ee62:	push	{r4, r5, lr}
    ee64:	mov.w	r4, #896	; 0x380
    ee68:	and.w	r5, r1, #2147483648	; 0x80000000
    ee6c:	bic.w	r1, r1, #2147483648	; 0x80000000
    ee70:	b.n	ecb4 <__adddf3+0x138>
    ee72:	nop

0000ee74 <__aeabi_ul2d>:
    ee74:	orrs.w	r2, r0, r1
    ee78:	it	eq
    ee7a:	bxeq	lr
    ee7c:	push	{r4, r5, lr}
    ee7e:	mov.w	r5, #0
    ee82:	b.n	ee9a <__aeabi_l2d+0x16>

0000ee84 <__aeabi_l2d>:
    ee84:	orrs.w	r2, r0, r1
    ee88:	it	eq
    ee8a:	bxeq	lr
    ee8c:	push	{r4, r5, lr}
    ee8e:	ands.w	r5, r1, #2147483648	; 0x80000000
    ee92:	bpl.n	ee9a <__aeabi_l2d+0x16>
    ee94:	negs	r0, r0
    ee96:	sbc.w	r1, r1, r1, lsl #1
    ee9a:	mov.w	r4, #1024	; 0x400
    ee9e:	add.w	r4, r4, #50	; 0x32
    eea2:	movs.w	ip, r1, lsr #22
    eea6:	beq.w	ec62 <__adddf3+0xe6>
    eeaa:	mov.w	r2, #3
    eeae:	movs.w	ip, ip, lsr #3
    eeb2:	it	ne
    eeb4:	addne	r2, #3
    eeb6:	movs.w	ip, ip, lsr #3
    eeba:	it	ne
    eebc:	addne	r2, #3
    eebe:	add.w	r2, r2, ip, lsr #3
    eec2:	rsb	r3, r2, #32
    eec6:	lsl.w	ip, r0, r3
    eeca:	lsr.w	r0, r0, r2
    eece:	lsl.w	lr, r1, r3
    eed2:	orr.w	r0, r0, lr
    eed6:	lsr.w	r1, r1, r2
    eeda:	add	r4, r2
    eedc:	b.n	ec62 <__adddf3+0xe6>
    eede:	nop

0000eee0 <__aeabi_dmul>:
    eee0:	push	{r4, r5, r6, lr}
    eee2:	mov.w	ip, #255	; 0xff
    eee6:	orr.w	ip, ip, #1792	; 0x700
    eeea:	ands.w	r4, ip, r1, lsr #20
    eeee:	ittte	ne
    eef0:	andsne.w	r5, ip, r3, lsr #20
    eef4:	teqne	r4, ip
    eef8:	teqne	r5, ip
    eefc:	bleq	f0bc <__aeabi_dmul+0x1dc>
    ef00:	add	r4, r5
    ef02:	eor.w	r6, r1, r3
    ef06:	bic.w	r1, r1, ip, lsl #21
    ef0a:	bic.w	r3, r3, ip, lsl #21
    ef0e:	orrs.w	r5, r0, r1, lsl #12
    ef12:	it	ne
    ef14:	orrsne.w	r5, r2, r3, lsl #12
    ef18:	orr.w	r1, r1, #1048576	; 0x100000
    ef1c:	orr.w	r3, r3, #1048576	; 0x100000
    ef20:	beq.n	ef94 <__aeabi_dmul+0xb4>
    ef22:	umull	ip, lr, r0, r2
    ef26:	mov.w	r5, #0
    ef2a:	umlal	lr, r5, r1, r2
    ef2e:	and.w	r2, r6, #2147483648	; 0x80000000
    ef32:	umlal	lr, r5, r0, r3
    ef36:	mov.w	r6, #0
    ef3a:	umlal	r5, r6, r1, r3
    ef3e:	teq	ip, #0
    ef42:	it	ne
    ef44:	orrne.w	lr, lr, #1
    ef48:	sub.w	r4, r4, #255	; 0xff
    ef4c:	cmp.w	r6, #512	; 0x200
    ef50:	sbc.w	r4, r4, #768	; 0x300
    ef54:	bcs.n	ef60 <__aeabi_dmul+0x80>
    ef56:	movs.w	lr, lr, lsl #1
    ef5a:	adcs	r5, r5
    ef5c:	adc.w	r6, r6, r6
    ef60:	orr.w	r1, r2, r6, lsl #11
    ef64:	orr.w	r1, r1, r5, lsr #21
    ef68:	mov.w	r0, r5, lsl #11
    ef6c:	orr.w	r0, r0, lr, lsr #21
    ef70:	mov.w	lr, lr, lsl #11
    ef74:	subs.w	ip, r4, #253	; 0xfd
    ef78:	it	hi
    ef7a:	cmphi.w	ip, #1792	; 0x700
    ef7e:	bhi.n	efbe <__aeabi_dmul+0xde>
    ef80:	cmp.w	lr, #2147483648	; 0x80000000
    ef84:	it	eq
    ef86:	movseq.w	lr, r0, lsr #1
    ef8a:	adcs.w	r0, r0, #0
    ef8e:	adc.w	r1, r1, r4, lsl #20
    ef92:	pop	{r4, r5, r6, pc}
    ef94:	and.w	r6, r6, #2147483648	; 0x80000000
    ef98:	orr.w	r1, r6, r1
    ef9c:	orr.w	r0, r0, r2
    efa0:	eor.w	r1, r1, r3
    efa4:	subs.w	r4, r4, ip, lsr #1
    efa8:	ittt	gt
    efaa:	rsbsgt	r5, r4, ip
    efae:	orrgt.w	r1, r1, r4, lsl #20
    efb2:	popgt	{r4, r5, r6, pc}
    efb4:	orr.w	r1, r1, #1048576	; 0x100000
    efb8:	mov.w	lr, #0
    efbc:	subs	r4, #1
    efbe:	bgt.w	f118 <__aeabi_dmul+0x238>
    efc2:	cmn.w	r4, #54	; 0x36
    efc6:	ittt	le
    efc8:	movle	r0, #0
    efca:	andle.w	r1, r1, #2147483648	; 0x80000000
    efce:	pople	{r4, r5, r6, pc}
    efd0:	rsb	r4, r4, #0
    efd4:	subs	r4, #32
    efd6:	bge.n	f044 <__aeabi_dmul+0x164>
    efd8:	adds	r4, #12
    efda:	bgt.n	f014 <__aeabi_dmul+0x134>
    efdc:	add.w	r4, r4, #20
    efe0:	rsb	r5, r4, #32
    efe4:	lsl.w	r3, r0, r5
    efe8:	lsr.w	r0, r0, r4
    efec:	lsl.w	r2, r1, r5
    eff0:	orr.w	r0, r0, r2
    eff4:	and.w	r2, r1, #2147483648	; 0x80000000
    eff8:	bic.w	r1, r1, #2147483648	; 0x80000000
    effc:	adds.w	r0, r0, r3, lsr #31
    f000:	lsr.w	r6, r1, r4
    f004:	adc.w	r1, r2, r6
    f008:	orrs.w	lr, lr, r3, lsl #1
    f00c:	it	eq
    f00e:	biceq.w	r0, r0, r3, lsr #31
    f012:	pop	{r4, r5, r6, pc}
    f014:	rsb	r4, r4, #12
    f018:	rsb	r5, r4, #32
    f01c:	lsl.w	r3, r0, r4
    f020:	lsr.w	r0, r0, r5
    f024:	lsl.w	r2, r1, r4
    f028:	orr.w	r0, r0, r2
    f02c:	and.w	r1, r1, #2147483648	; 0x80000000
    f030:	adds.w	r0, r0, r3, lsr #31
    f034:	adc.w	r1, r1, #0
    f038:	orrs.w	lr, lr, r3, lsl #1
    f03c:	it	eq
    f03e:	biceq.w	r0, r0, r3, lsr #31
    f042:	pop	{r4, r5, r6, pc}
    f044:	rsb	r5, r4, #32
    f048:	lsl.w	r2, r0, r5
    f04c:	orr.w	lr, lr, r2
    f050:	lsr.w	r3, r0, r4
    f054:	lsl.w	r2, r1, r5
    f058:	orr.w	r3, r3, r2
    f05c:	lsr.w	r0, r1, r4
    f060:	and.w	r1, r1, #2147483648	; 0x80000000
    f064:	lsr.w	r2, r1, r4
    f068:	bic.w	r0, r0, r2
    f06c:	add.w	r0, r0, r3, lsr #31
    f070:	orrs.w	lr, lr, r3, lsl #1
    f074:	it	eq
    f076:	biceq.w	r0, r0, r3, lsr #31
    f07a:	pop	{r4, r5, r6, pc}
    f07c:	teq	r4, #0
    f080:	bne.n	f0a2 <__aeabi_dmul+0x1c2>
    f082:	and.w	r6, r1, #2147483648	; 0x80000000
    f086:	lsls	r0, r0, #1
    f088:	adc.w	r1, r1, r1
    f08c:	tst.w	r1, #1048576	; 0x100000
    f090:	it	eq
    f092:	subeq	r4, #1
    f094:	beq.n	f086 <__aeabi_dmul+0x1a6>
    f096:	orr.w	r1, r1, r6
    f09a:	teq	r5, #0
    f09e:	it	ne
    f0a0:	bxne	lr
    f0a2:	and.w	r6, r3, #2147483648	; 0x80000000
    f0a6:	lsls	r2, r2, #1
    f0a8:	adc.w	r3, r3, r3
    f0ac:	tst.w	r3, #1048576	; 0x100000
    f0b0:	it	eq
    f0b2:	subeq	r5, #1
    f0b4:	beq.n	f0a6 <__aeabi_dmul+0x1c6>
    f0b6:	orr.w	r3, r3, r6
    f0ba:	bx	lr
    f0bc:	teq	r4, ip
    f0c0:	and.w	r5, ip, r3, lsr #20
    f0c4:	it	ne
    f0c6:	teqne	r5, ip
    f0ca:	beq.n	f0e6 <__aeabi_dmul+0x206>
    f0cc:	orrs.w	r6, r0, r1, lsl #1
    f0d0:	it	ne
    f0d2:	orrsne.w	r6, r2, r3, lsl #1
    f0d6:	bne.n	f07c <__aeabi_dmul+0x19c>
    f0d8:	eor.w	r1, r1, r3
    f0dc:	and.w	r1, r1, #2147483648	; 0x80000000
    f0e0:	mov.w	r0, #0
    f0e4:	pop	{r4, r5, r6, pc}
    f0e6:	orrs.w	r6, r0, r1, lsl #1
    f0ea:	itte	eq
    f0ec:	moveq	r0, r2
    f0ee:	moveq	r1, r3
    f0f0:	orrsne.w	r6, r2, r3, lsl #1
    f0f4:	beq.n	f12a <__aeabi_dmul+0x24a>
    f0f6:	teq	r4, ip
    f0fa:	bne.n	f102 <__aeabi_dmul+0x222>
    f0fc:	orrs.w	r6, r0, r1, lsl #12
    f100:	bne.n	f12a <__aeabi_dmul+0x24a>
    f102:	teq	r5, ip
    f106:	bne.n	f114 <__aeabi_dmul+0x234>
    f108:	orrs.w	r6, r2, r3, lsl #12
    f10c:	itt	ne
    f10e:	movne	r0, r2
    f110:	movne	r1, r3
    f112:	bne.n	f12a <__aeabi_dmul+0x24a>
    f114:	eor.w	r1, r1, r3
    f118:	and.w	r1, r1, #2147483648	; 0x80000000
    f11c:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f120:	orr.w	r1, r1, #15728640	; 0xf00000
    f124:	mov.w	r0, #0
    f128:	pop	{r4, r5, r6, pc}
    f12a:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f12e:	orr.w	r1, r1, #16252928	; 0xf80000
    f132:	pop	{r4, r5, r6, pc}

0000f134 <__aeabi_ddiv>:
    f134:	push	{r4, r5, r6, lr}
    f136:	mov.w	ip, #255	; 0xff
    f13a:	orr.w	ip, ip, #1792	; 0x700
    f13e:	ands.w	r4, ip, r1, lsr #20
    f142:	ittte	ne
    f144:	andsne.w	r5, ip, r3, lsr #20
    f148:	teqne	r4, ip
    f14c:	teqne	r5, ip
    f150:	bleq	f2a2 <__aeabi_ddiv+0x16e>
    f154:	sub.w	r4, r4, r5
    f158:	eor.w	lr, r1, r3
    f15c:	orrs.w	r5, r2, r3, lsl #12
    f160:	mov.w	r1, r1, lsl #12
    f164:	beq.w	f278 <__aeabi_ddiv+0x144>
    f168:	mov.w	r3, r3, lsl #12
    f16c:	mov.w	r5, #268435456	; 0x10000000
    f170:	orr.w	r3, r5, r3, lsr #4
    f174:	orr.w	r3, r3, r2, lsr #24
    f178:	mov.w	r2, r2, lsl #8
    f17c:	orr.w	r5, r5, r1, lsr #4
    f180:	orr.w	r5, r5, r0, lsr #24
    f184:	mov.w	r6, r0, lsl #8
    f188:	and.w	r1, lr, #2147483648	; 0x80000000
    f18c:	cmp	r5, r3
    f18e:	it	eq
    f190:	cmpeq	r6, r2
    f192:	adc.w	r4, r4, #253	; 0xfd
    f196:	add.w	r4, r4, #768	; 0x300
    f19a:	bcs.n	f1a2 <__aeabi_ddiv+0x6e>
    f19c:	lsrs	r3, r3, #1
    f19e:	mov.w	r2, r2, rrx
    f1a2:	subs	r6, r6, r2
    f1a4:	sbc.w	r5, r5, r3
    f1a8:	lsrs	r3, r3, #1
    f1aa:	mov.w	r2, r2, rrx
    f1ae:	mov.w	r0, #1048576	; 0x100000
    f1b2:	mov.w	ip, #524288	; 0x80000
    f1b6:	subs.w	lr, r6, r2
    f1ba:	sbcs.w	lr, r5, r3
    f1be:	ittt	cs
    f1c0:	subcs	r6, r6, r2
    f1c2:	movcs	r5, lr
    f1c4:	orrcs.w	r0, r0, ip
    f1c8:	lsrs	r3, r3, #1
    f1ca:	mov.w	r2, r2, rrx
    f1ce:	subs.w	lr, r6, r2
    f1d2:	sbcs.w	lr, r5, r3
    f1d6:	ittt	cs
    f1d8:	subcs	r6, r6, r2
    f1da:	movcs	r5, lr
    f1dc:	orrcs.w	r0, r0, ip, lsr #1
    f1e0:	lsrs	r3, r3, #1
    f1e2:	mov.w	r2, r2, rrx
    f1e6:	subs.w	lr, r6, r2
    f1ea:	sbcs.w	lr, r5, r3
    f1ee:	ittt	cs
    f1f0:	subcs	r6, r6, r2
    f1f2:	movcs	r5, lr
    f1f4:	orrcs.w	r0, r0, ip, lsr #2
    f1f8:	lsrs	r3, r3, #1
    f1fa:	mov.w	r2, r2, rrx
    f1fe:	subs.w	lr, r6, r2
    f202:	sbcs.w	lr, r5, r3
    f206:	ittt	cs
    f208:	subcs	r6, r6, r2
    f20a:	movcs	r5, lr
    f20c:	orrcs.w	r0, r0, ip, lsr #3
    f210:	orrs.w	lr, r5, r6
    f214:	beq.n	f248 <__aeabi_ddiv+0x114>
    f216:	mov.w	r5, r5, lsl #4
    f21a:	orr.w	r5, r5, r6, lsr #28
    f21e:	mov.w	r6, r6, lsl #4
    f222:	mov.w	r3, r3, lsl #3
    f226:	orr.w	r3, r3, r2, lsr #29
    f22a:	mov.w	r2, r2, lsl #3
    f22e:	movs.w	ip, ip, lsr #4
    f232:	bne.n	f1b6 <__aeabi_ddiv+0x82>
    f234:	tst.w	r1, #1048576	; 0x100000
    f238:	bne.n	f252 <__aeabi_ddiv+0x11e>
    f23a:	orr.w	r1, r1, r0
    f23e:	mov.w	r0, #0
    f242:	mov.w	ip, #2147483648	; 0x80000000
    f246:	b.n	f1b6 <__aeabi_ddiv+0x82>
    f248:	tst.w	r1, #1048576	; 0x100000
    f24c:	itt	eq
    f24e:	orreq	r1, r0
    f250:	moveq	r0, #0
    f252:	subs.w	ip, r4, #253	; 0xfd
    f256:	it	hi
    f258:	cmphi.w	ip, #1792	; 0x700
    f25c:	bhi.w	efbe <__aeabi_dmul+0xde>
    f260:	subs.w	ip, r5, r3
    f264:	itt	eq
    f266:	subseq.w	ip, r6, r2
    f26a:	movseq.w	ip, r0, lsr #1
    f26e:	adcs.w	r0, r0, #0
    f272:	adc.w	r1, r1, r4, lsl #20
    f276:	pop	{r4, r5, r6, pc}
    f278:	and.w	lr, lr, #2147483648	; 0x80000000
    f27c:	orr.w	r1, lr, r1, lsr #12
    f280:	adds.w	r4, r4, ip, lsr #1
    f284:	ittt	gt
    f286:	rsbsgt	r5, r4, ip
    f28a:	orrgt.w	r1, r1, r4, lsl #20
    f28e:	popgt	{r4, r5, r6, pc}
    f290:	orr.w	r1, r1, #1048576	; 0x100000
    f294:	mov.w	lr, #0
    f298:	subs	r4, #1
    f29a:	b.n	efbe <__aeabi_dmul+0xde>
    f29c:	orr.w	lr, r5, r6
    f2a0:	b.n	efbe <__aeabi_dmul+0xde>
    f2a2:	and.w	r5, ip, r3, lsr #20
    f2a6:	teq	r4, ip
    f2aa:	it	eq
    f2ac:	teqeq	r5, ip
    f2b0:	beq.w	f12a <__aeabi_dmul+0x24a>
    f2b4:	teq	r4, ip
    f2b8:	bne.n	f2d0 <__aeabi_ddiv+0x19c>
    f2ba:	orrs.w	r4, r0, r1, lsl #12
    f2be:	bne.w	f12a <__aeabi_dmul+0x24a>
    f2c2:	teq	r5, ip
    f2c6:	bne.w	f114 <__aeabi_dmul+0x234>
    f2ca:	mov	r0, r2
    f2cc:	mov	r1, r3
    f2ce:	b.n	f12a <__aeabi_dmul+0x24a>
    f2d0:	teq	r5, ip
    f2d4:	bne.n	f2e4 <__aeabi_ddiv+0x1b0>
    f2d6:	orrs.w	r5, r2, r3, lsl #12
    f2da:	beq.w	f0d8 <__aeabi_dmul+0x1f8>
    f2de:	mov	r0, r2
    f2e0:	mov	r1, r3
    f2e2:	b.n	f12a <__aeabi_dmul+0x24a>
    f2e4:	orrs.w	r6, r0, r1, lsl #1
    f2e8:	it	ne
    f2ea:	orrsne.w	r6, r2, r3, lsl #1
    f2ee:	bne.w	f07c <__aeabi_dmul+0x19c>
    f2f2:	orrs.w	r4, r0, r1, lsl #1
    f2f6:	bne.w	f114 <__aeabi_dmul+0x234>
    f2fa:	orrs.w	r5, r2, r3, lsl #1
    f2fe:	bne.w	f0d8 <__aeabi_dmul+0x1f8>
    f302:	b.n	f12a <__aeabi_dmul+0x24a>

0000f304 <__gedf2>:
    f304:	mov.w	ip, #4294967295
    f308:	b.n	f318 <__cmpdf2+0x4>
    f30a:	nop

0000f30c <__ledf2>:
    f30c:	mov.w	ip, #1
    f310:	b.n	f318 <__cmpdf2+0x4>
    f312:	nop

0000f314 <__cmpdf2>:
    f314:	mov.w	ip, #1
    f318:	str.w	ip, [sp, #-4]!
    f31c:	mov.w	ip, r1, lsl #1
    f320:	mvns.w	ip, ip, asr #21
    f324:	mov.w	ip, r3, lsl #1
    f328:	it	ne
    f32a:	mvnsne.w	ip, ip, asr #21
    f32e:	beq.n	f368 <__cmpdf2+0x54>
    f330:	add	sp, #4
    f332:	orrs.w	ip, r0, r1, lsl #1
    f336:	ite	eq
    f338:	orrseq.w	ip, r2, r3, lsl #1
    f33c:	teqne	r1, r3
    f340:	ittt	eq
    f342:	teqeq	r0, r2
    f346:	moveq	r0, #0
    f348:	bxeq	lr
    f34a:	cmn.w	r0, #0
    f34e:	teq	r1, r3
    f352:	it	pl
    f354:	cmppl	r1, r3
    f356:	it	eq
    f358:	cmpeq	r0, r2
    f35a:	ite	cs
    f35c:	asrcs	r0, r3, #31
    f35e:	mvncc.w	r0, r3, asr #31
    f362:	orr.w	r0, r0, #1
    f366:	bx	lr
    f368:	mov.w	ip, r1, lsl #1
    f36c:	mvns.w	ip, ip, asr #21
    f370:	bne.n	f378 <__cmpdf2+0x64>
    f372:	orrs.w	ip, r0, r1, lsl #12
    f376:	bne.n	f388 <__cmpdf2+0x74>
    f378:	mov.w	ip, r3, lsl #1
    f37c:	mvns.w	ip, ip, asr #21
    f380:	bne.n	f330 <__cmpdf2+0x1c>
    f382:	orrs.w	ip, r2, r3, lsl #12
    f386:	beq.n	f330 <__cmpdf2+0x1c>
    f388:	ldr.w	r0, [sp], #4
    f38c:	bx	lr
    f38e:	nop

0000f390 <__aeabi_cdrcmple>:
    f390:	mov	ip, r0
    f392:	mov	r0, r2
    f394:	mov	r2, ip
    f396:	mov	ip, r1
    f398:	mov	r1, r3
    f39a:	mov	r3, ip
    f39c:	b.n	f3a0 <__aeabi_cdcmpeq>
    f39e:	nop

0000f3a0 <__aeabi_cdcmpeq>:
    f3a0:	push	{r0, lr}
    f3a2:	bl	f314 <__cmpdf2>
    f3a6:	cmp	r0, #0
    f3a8:	it	mi
    f3aa:	cmnmi.w	r0, #0
    f3ae:	pop	{r0, pc}

0000f3b0 <__aeabi_dcmpeq>:
    f3b0:	str.w	lr, [sp, #-8]!
    f3b4:	bl	f3a0 <__aeabi_cdcmpeq>
    f3b8:	ite	eq
    f3ba:	moveq	r0, #1
    f3bc:	movne	r0, #0
    f3be:	ldr.w	pc, [sp], #8
    f3c2:	nop

0000f3c4 <__aeabi_dcmplt>:
    f3c4:	str.w	lr, [sp, #-8]!
    f3c8:	bl	f3a0 <__aeabi_cdcmpeq>
    f3cc:	ite	cc
    f3ce:	movcc	r0, #1
    f3d0:	movcs	r0, #0
    f3d2:	ldr.w	pc, [sp], #8
    f3d6:	nop

0000f3d8 <__aeabi_dcmple>:
    f3d8:	str.w	lr, [sp, #-8]!
    f3dc:	bl	f3a0 <__aeabi_cdcmpeq>
    f3e0:	ite	ls
    f3e2:	movls	r0, #1
    f3e4:	movhi	r0, #0
    f3e6:	ldr.w	pc, [sp], #8
    f3ea:	nop

0000f3ec <__aeabi_dcmpge>:
    f3ec:	str.w	lr, [sp, #-8]!
    f3f0:	bl	f390 <__aeabi_cdrcmple>
    f3f4:	ite	ls
    f3f6:	movls	r0, #1
    f3f8:	movhi	r0, #0
    f3fa:	ldr.w	pc, [sp], #8
    f3fe:	nop

0000f400 <__aeabi_dcmpgt>:
    f400:	str.w	lr, [sp, #-8]!
    f404:	bl	f390 <__aeabi_cdrcmple>
    f408:	ite	cc
    f40a:	movcc	r0, #1
    f40c:	movcs	r0, #0
    f40e:	ldr.w	pc, [sp], #8
    f412:	nop

0000f414 <__aeabi_dcmpun>:
    f414:	mov.w	ip, r1, lsl #1
    f418:	mvns.w	ip, ip, asr #21
    f41c:	bne.n	f424 <__aeabi_dcmpun+0x10>
    f41e:	orrs.w	ip, r0, r1, lsl #12
    f422:	bne.n	f43a <__aeabi_dcmpun+0x26>
    f424:	mov.w	ip, r3, lsl #1
    f428:	mvns.w	ip, ip, asr #21
    f42c:	bne.n	f434 <__aeabi_dcmpun+0x20>
    f42e:	orrs.w	ip, r2, r3, lsl #12
    f432:	bne.n	f43a <__aeabi_dcmpun+0x26>
    f434:	mov.w	r0, #0
    f438:	bx	lr
    f43a:	mov.w	r0, #1
    f43e:	bx	lr

0000f440 <__aeabi_d2iz>:
    f440:	mov.w	r2, r1, lsl #1
    f444:	adds.w	r2, r2, #2097152	; 0x200000
    f448:	bcs.n	f476 <__aeabi_d2iz+0x36>
    f44a:	bpl.n	f470 <__aeabi_d2iz+0x30>
    f44c:	mvn.w	r3, #992	; 0x3e0
    f450:	subs.w	r2, r3, r2, asr #21
    f454:	bls.n	f47c <__aeabi_d2iz+0x3c>
    f456:	mov.w	r3, r1, lsl #11
    f45a:	orr.w	r3, r3, #2147483648	; 0x80000000
    f45e:	orr.w	r3, r3, r0, lsr #21
    f462:	tst.w	r1, #2147483648	; 0x80000000
    f466:	lsr.w	r0, r3, r2
    f46a:	it	ne
    f46c:	negne	r0, r0
    f46e:	bx	lr
    f470:	mov.w	r0, #0
    f474:	bx	lr
    f476:	orrs.w	r0, r0, r1, lsl #12
    f47a:	bne.n	f488 <__aeabi_d2iz+0x48>
    f47c:	ands.w	r0, r1, #2147483648	; 0x80000000
    f480:	it	eq
    f482:	mvneq.w	r0, #2147483648	; 0x80000000
    f486:	bx	lr
    f488:	mov.w	r0, #0
    f48c:	bx	lr
    f48e:	nop

0000f490 <__aeabi_uldivmod>:
    f490:	cbnz	r3, f4a8 <__aeabi_uldivmod+0x18>
    f492:	cbnz	r2, f4a8 <__aeabi_uldivmod+0x18>
    f494:	cmp	r1, #0
    f496:	it	eq
    f498:	cmpeq	r0, #0
    f49a:	itt	ne
    f49c:	movne.w	r1, #4294967295
    f4a0:	movne.w	r0, #4294967295
    f4a4:	b.w	f7a4 <__aeabi_idiv0>
    f4a8:	sub.w	ip, sp, #8
    f4ac:	strd	ip, lr, [sp, #-16]!
    f4b0:	bl	f4c0 <__udivmoddi4>
    f4b4:	ldr.w	lr, [sp, #4]
    f4b8:	ldrd	r2, r3, [sp, #8]
    f4bc:	add	sp, #16
    f4be:	bx	lr

0000f4c0 <__udivmoddi4>:
    f4c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f4c4:	mov	ip, r1
    f4c6:	mov	r6, r1
    f4c8:	mov	r4, r0
    f4ca:	ldr	r5, [sp, #32]
    f4cc:	cmp	r3, #0
    f4ce:	bne.n	f572 <__udivmoddi4+0xb2>
    f4d0:	cmp	r2, r1
    f4d2:	mov	r7, r2
    f4d4:	bls.n	f5b0 <__udivmoddi4+0xf0>
    f4d6:	clz	lr, r2
    f4da:	cmp.w	lr, #0
    f4de:	beq.n	f4f8 <__udivmoddi4+0x38>
    f4e0:	rsb	r4, lr, #32
    f4e4:	lsr.w	r4, r0, r4
    f4e8:	lsl.w	r6, r1, lr
    f4ec:	orr.w	ip, r4, r6
    f4f0:	lsl.w	r7, r2, lr
    f4f4:	lsl.w	r4, r0, lr
    f4f8:	mov.w	r9, r7, lsr #16
    f4fc:	lsrs	r2, r4, #16
    f4fe:	udiv	r0, ip, r9
    f502:	uxth.w	r8, r7
    f506:	mls	r6, r9, r0, ip
    f50a:	orr.w	r6, r2, r6, lsl #16
    f50e:	mul.w	r3, r0, r8
    f512:	cmp	r3, r6
    f514:	bls.n	f52a <__udivmoddi4+0x6a>
    f516:	adds	r6, r6, r7
    f518:	add.w	r2, r0, #4294967295
    f51c:	bcs.w	f764 <__udivmoddi4+0x2a4>
    f520:	cmp	r3, r6
    f522:	bls.w	f764 <__udivmoddi4+0x2a4>
    f526:	subs	r0, #2
    f528:	add	r6, r7
    f52a:	subs	r6, r6, r3
    f52c:	uxth	r2, r4
    f52e:	udiv	r3, r6, r9
    f532:	mls	r6, r9, r3, r6
    f536:	orr.w	r4, r2, r6, lsl #16
    f53a:	mul.w	r8, r3, r8
    f53e:	cmp	r8, r4
    f540:	bls.n	f556 <__udivmoddi4+0x96>
    f542:	adds	r4, r4, r7
    f544:	add.w	r2, r3, #4294967295
    f548:	bcs.w	f760 <__udivmoddi4+0x2a0>
    f54c:	cmp	r8, r4
    f54e:	bls.w	f760 <__udivmoddi4+0x2a0>
    f552:	subs	r3, #2
    f554:	add	r4, r7
    f556:	rsb	r4, r8, r4
    f55a:	orr.w	r0, r3, r0, lsl #16
    f55e:	movs	r1, #0
    f560:	cmp	r5, #0
    f562:	beq.n	f62a <__udivmoddi4+0x16a>
    f564:	lsr.w	r4, r4, lr
    f568:	movs	r3, #0
    f56a:	str	r4, [r5, #0]
    f56c:	str	r3, [r5, #4]
    f56e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f572:	cmp	r3, r1
    f574:	bls.n	f586 <__udivmoddi4+0xc6>
    f576:	cmp	r5, #0
    f578:	beq.n	f626 <__udivmoddi4+0x166>
    f57a:	movs	r1, #0
    f57c:	stmia.w	r5, {r0, r6}
    f580:	mov	r0, r1
    f582:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f586:	clz	r1, r3
    f58a:	cmp	r1, #0
    f58c:	bne.w	f6b0 <__udivmoddi4+0x1f0>
    f590:	cmp	r3, r6
    f592:	bcc.n	f59a <__udivmoddi4+0xda>
    f594:	cmp	r2, r0
    f596:	bhi.w	f78a <__udivmoddi4+0x2ca>
    f59a:	subs	r4, r0, r2
    f59c:	sbc.w	r6, r6, r3
    f5a0:	movs	r0, #1
    f5a2:	mov	ip, r6
    f5a4:	cmp	r5, #0
    f5a6:	beq.n	f62a <__udivmoddi4+0x16a>
    f5a8:	stmia.w	r5, {r4, ip}
    f5ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f5b0:	cbnz	r2, f5b8 <__udivmoddi4+0xf8>
    f5b2:	movs	r7, #1
    f5b4:	udiv	r7, r7, r2
    f5b8:	clz	lr, r7
    f5bc:	cmp.w	lr, #0
    f5c0:	bne.n	f62e <__udivmoddi4+0x16e>
    f5c2:	subs	r3, r6, r7
    f5c4:	mov.w	r8, r7, lsr #16
    f5c8:	uxth.w	ip, r7
    f5cc:	movs	r1, #1
    f5ce:	udiv	r0, r3, r8
    f5d2:	lsrs	r2, r4, #16
    f5d4:	mls	r6, r8, r0, r3
    f5d8:	orr.w	r6, r2, r6, lsl #16
    f5dc:	mul.w	r3, ip, r0
    f5e0:	cmp	r3, r6
    f5e2:	bls.n	f5f4 <__udivmoddi4+0x134>
    f5e4:	adds	r6, r6, r7
    f5e6:	add.w	r2, r0, #4294967295
    f5ea:	bcs.n	f5f2 <__udivmoddi4+0x132>
    f5ec:	cmp	r3, r6
    f5ee:	bhi.w	f78e <__udivmoddi4+0x2ce>
    f5f2:	mov	r0, r2
    f5f4:	subs	r6, r6, r3
    f5f6:	uxth	r2, r4
    f5f8:	udiv	r3, r6, r8
    f5fc:	mls	r6, r8, r3, r6
    f600:	orr.w	r4, r2, r6, lsl #16
    f604:	mul.w	ip, ip, r3
    f608:	cmp	ip, r4
    f60a:	bls.n	f61c <__udivmoddi4+0x15c>
    f60c:	adds	r4, r4, r7
    f60e:	add.w	r2, r3, #4294967295
    f612:	bcs.n	f61a <__udivmoddi4+0x15a>
    f614:	cmp	ip, r4
    f616:	bhi.w	f784 <__udivmoddi4+0x2c4>
    f61a:	mov	r3, r2
    f61c:	rsb	r4, ip, r4
    f620:	orr.w	r0, r3, r0, lsl #16
    f624:	b.n	f560 <__udivmoddi4+0xa0>
    f626:	mov	r1, r5
    f628:	mov	r0, r5
    f62a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f62e:	rsb	r1, lr, #32
    f632:	lsl.w	r3, r6, lr
    f636:	lsl.w	r7, r7, lr
    f63a:	lsr.w	r9, r0, r1
    f63e:	mov.w	r8, r7, lsr #16
    f642:	lsrs	r6, r1
    f644:	orr.w	r9, r9, r3
    f648:	udiv	sl, r6, r8
    f64c:	mov.w	r4, r9, lsr #16
    f650:	mls	r6, r8, sl, r6
    f654:	uxth.w	ip, r7
    f658:	orr.w	r3, r4, r6, lsl #16
    f65c:	mul.w	r2, sl, ip
    f660:	cmp	r2, r3
    f662:	lsl.w	r4, r0, lr
    f666:	bls.n	f67e <__udivmoddi4+0x1be>
    f668:	adds	r3, r3, r7
    f66a:	add.w	r1, sl, #4294967295
    f66e:	bcs.w	f780 <__udivmoddi4+0x2c0>
    f672:	cmp	r2, r3
    f674:	bls.w	f780 <__udivmoddi4+0x2c0>
    f678:	sub.w	sl, sl, #2
    f67c:	add	r3, r7
    f67e:	subs	r3, r3, r2
    f680:	uxth.w	r9, r9
    f684:	udiv	r1, r3, r8
    f688:	mls	r3, r8, r1, r3
    f68c:	orr.w	r3, r9, r3, lsl #16
    f690:	mul.w	r6, r1, ip
    f694:	cmp	r6, r3
    f696:	bls.n	f6a8 <__udivmoddi4+0x1e8>
    f698:	adds	r3, r3, r7
    f69a:	add.w	r2, r1, #4294967295
    f69e:	bcs.n	f778 <__udivmoddi4+0x2b8>
    f6a0:	cmp	r6, r3
    f6a2:	bls.n	f778 <__udivmoddi4+0x2b8>
    f6a4:	subs	r1, #2
    f6a6:	add	r3, r7
    f6a8:	subs	r3, r3, r6
    f6aa:	orr.w	r1, r1, sl, lsl #16
    f6ae:	b.n	f5ce <__udivmoddi4+0x10e>
    f6b0:	rsb	lr, r1, #32
    f6b4:	lsr.w	r4, r2, lr
    f6b8:	lsls	r3, r1
    f6ba:	orrs	r3, r4
    f6bc:	lsr.w	r7, r0, lr
    f6c0:	lsl.w	r4, r6, r1
    f6c4:	mov.w	ip, r3, lsr #16
    f6c8:	lsr.w	r6, r6, lr
    f6cc:	orrs	r4, r7
    f6ce:	udiv	r9, r6, ip
    f6d2:	lsrs	r7, r4, #16
    f6d4:	mls	r6, ip, r9, r6
    f6d8:	uxth.w	r8, r3
    f6dc:	orr.w	r6, r7, r6, lsl #16
    f6e0:	mul.w	r7, r9, r8
    f6e4:	cmp	r7, r6
    f6e6:	lsl.w	r2, r2, r1
    f6ea:	lsl.w	sl, r0, r1
    f6ee:	bls.n	f702 <__udivmoddi4+0x242>
    f6f0:	adds	r6, r6, r3
    f6f2:	add.w	r0, r9, #4294967295
    f6f6:	bcs.n	f77c <__udivmoddi4+0x2bc>
    f6f8:	cmp	r7, r6
    f6fa:	bls.n	f77c <__udivmoddi4+0x2bc>
    f6fc:	sub.w	r9, r9, #2
    f700:	add	r6, r3
    f702:	subs	r6, r6, r7
    f704:	uxth	r0, r4
    f706:	udiv	r4, r6, ip
    f70a:	mls	r6, ip, r4, r6
    f70e:	orr.w	r7, r0, r6, lsl #16
    f712:	mul.w	r8, r4, r8
    f716:	cmp	r8, r7
    f718:	bls.n	f72a <__udivmoddi4+0x26a>
    f71a:	adds	r7, r7, r3
    f71c:	add.w	r0, r4, #4294967295
    f720:	bcs.n	f774 <__udivmoddi4+0x2b4>
    f722:	cmp	r8, r7
    f724:	bls.n	f774 <__udivmoddi4+0x2b4>
    f726:	subs	r4, #2
    f728:	add	r7, r3
    f72a:	orr.w	r0, r4, r9, lsl #16
    f72e:	rsb	r7, r8, r7
    f732:	umull	r8, r9, r0, r2
    f736:	cmp	r7, r9
    f738:	mov	r4, r8
    f73a:	mov	r6, r9
    f73c:	bcc.n	f768 <__udivmoddi4+0x2a8>
    f73e:	beq.n	f794 <__udivmoddi4+0x2d4>
    f740:	cbz	r5, f79c <__udivmoddi4+0x2dc>
    f742:	subs.w	r3, sl, r4
    f746:	sbc.w	r7, r7, r6
    f74a:	lsl.w	lr, r7, lr
    f74e:	lsrs	r3, r1
    f750:	lsrs	r7, r1
    f752:	orr.w	r3, lr, r3
    f756:	stmia.w	r5, {r3, r7}
    f75a:	movs	r1, #0
    f75c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f760:	mov	r3, r2
    f762:	b.n	f556 <__udivmoddi4+0x96>
    f764:	mov	r0, r2
    f766:	b.n	f52a <__udivmoddi4+0x6a>
    f768:	subs.w	r4, r8, r2
    f76c:	sbc.w	r6, r9, r3
    f770:	subs	r0, #1
    f772:	b.n	f740 <__udivmoddi4+0x280>
    f774:	mov	r4, r0
    f776:	b.n	f72a <__udivmoddi4+0x26a>
    f778:	mov	r1, r2
    f77a:	b.n	f6a8 <__udivmoddi4+0x1e8>
    f77c:	mov	r9, r0
    f77e:	b.n	f702 <__udivmoddi4+0x242>
    f780:	mov	sl, r1
    f782:	b.n	f67e <__udivmoddi4+0x1be>
    f784:	subs	r3, #2
    f786:	add	r4, r7
    f788:	b.n	f61c <__udivmoddi4+0x15c>
    f78a:	mov	r0, r1
    f78c:	b.n	f5a4 <__udivmoddi4+0xe4>
    f78e:	subs	r0, #2
    f790:	add	r6, r7
    f792:	b.n	f5f4 <__udivmoddi4+0x134>
    f794:	cmp	sl, r8
    f796:	bcc.n	f768 <__udivmoddi4+0x2a8>
    f798:	mov	r6, r7
    f79a:	b.n	f740 <__udivmoddi4+0x280>
    f79c:	mov	r1, r5
    f79e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f7a2:	nop

0000f7a4 <__aeabi_idiv0>:
    f7a4:	bx	lr
    f7a6:	nop

0000f7a8 <_calloc_r>:
    f7a8:	push	{r4, lr}
    f7aa:	mul.w	r1, r2, r1
    f7ae:	bl	f8b4 <_malloc_r>
    f7b2:	mov	r4, r0
    f7b4:	cbz	r0, f7ee <_calloc_r+0x46>
    f7b6:	ldr.w	r2, [r0, #-4]
    f7ba:	bic.w	r2, r2, #3
    f7be:	subs	r2, #4
    f7c0:	cmp	r2, #36	; 0x24
    f7c2:	bhi.n	f7f6 <_calloc_r+0x4e>
    f7c4:	cmp	r2, #19
    f7c6:	bls.n	f7f2 <_calloc_r+0x4a>
    f7c8:	movs	r3, #0
    f7ca:	cmp	r2, #27
    f7cc:	str	r3, [r0, #0]
    f7ce:	str	r3, [r0, #4]
    f7d0:	bls.n	f800 <_calloc_r+0x58>
    f7d2:	cmp	r2, #36	; 0x24
    f7d4:	str	r3, [r0, #8]
    f7d6:	str	r3, [r0, #12]
    f7d8:	iteee	ne
    f7da:	addne.w	r2, r0, #16
    f7de:	streq	r3, [r0, #16]
    f7e0:	streq	r3, [r0, #20]
    f7e2:	addeq.w	r2, r0, #24
    f7e6:	movs	r3, #0
    f7e8:	str	r3, [r2, #0]
    f7ea:	str	r3, [r2, #4]
    f7ec:	str	r3, [r2, #8]
    f7ee:	mov	r0, r4
    f7f0:	pop	{r4, pc}
    f7f2:	mov	r2, r0
    f7f4:	b.n	f7e6 <_calloc_r+0x3e>
    f7f6:	movs	r1, #0
    f7f8:	bl	1001c <memset>
    f7fc:	mov	r0, r4
    f7fe:	pop	{r4, pc}
    f800:	add.w	r2, r0, #8
    f804:	b.n	f7e6 <_calloc_r+0x3e>
    f806:	nop

0000f808 <__cxa_atexit>:
    f808:	mov	r3, r2
    f80a:	mov	r2, r1
    f80c:	mov	r1, r0
    f80e:	movs	r0, #2
    f810:	b.w	11f90 <__register_exitproc>

0000f814 <fcvtf>:
    f814:	push	{r4, r5, r6, lr}
    f816:	mov	r4, r0
    f818:	vmov	r0, s0
    f81c:	mov	r5, r1
    f81e:	mov	r6, r2
    f820:	bl	ee38 <__aeabi_f2d>
    f824:	mov	r2, r6
    f826:	vmov	d0, r0, r1
    f82a:	movs	r3, #0
    f82c:	mov	r1, r5
    f82e:	mov	r0, r4
    f830:	ldmia.w	sp!, {r4, r5, r6, lr}
    f834:	b.w	12f94 <fcvtbuf>

0000f838 <__errno>:
    f838:	ldr	r3, [pc, #4]	; (f840 <__errno+0x8>)
    f83a:	ldr	r0, [r3, #0]
    f83c:	bx	lr
    f83e:	nop
    f840:	.word	0x20001118

0000f844 <__libc_init_array>:
    f844:	push	{r4, r5, r6, lr}
    f846:	ldr	r6, [pc, #60]	; (f884 <__libc_init_array+0x40>)
    f848:	ldr	r5, [pc, #60]	; (f888 <__libc_init_array+0x44>)
    f84a:	subs	r6, r6, r5
    f84c:	asrs	r6, r6, #2
    f84e:	it	ne
    f850:	movne	r4, #0
    f852:	beq.n	f860 <__libc_init_array+0x1c>
    f854:	adds	r4, #1
    f856:	ldr.w	r3, [r5], #4
    f85a:	blx	r3
    f85c:	cmp	r6, r4
    f85e:	bne.n	f854 <__libc_init_array+0x10>
    f860:	ldr	r6, [pc, #40]	; (f88c <__libc_init_array+0x48>)
    f862:	ldr	r5, [pc, #44]	; (f890 <__libc_init_array+0x4c>)
    f864:	subs	r6, r6, r5
    f866:	bl	13aa0 <___init_veneer>
    f86a:	asrs	r6, r6, #2
    f86c:	it	ne
    f86e:	movne	r4, #0
    f870:	beq.n	f880 <__libc_init_array+0x3c>
    f872:	adds	r4, #1
    f874:	ldr.w	r3, [r5], #4
    f878:	blx	r3
    f87a:	cmp	r6, r4
    f87c:	bne.n	f872 <__libc_init_array+0x2e>
    f87e:	pop	{r4, r5, r6, pc}
    f880:	pop	{r4, r5, r6, pc}
    f882:	nop
    f884:	.word	0x60001620
    f888:	.word	0x60001620
    f88c:	.word	0x6000162c
    f890:	.word	0x60001620

0000f894 <malloc>:
    f894:	ldr	r3, [pc, #8]	; (f8a0 <malloc+0xc>)
    f896:	mov	r1, r0
    f898:	ldr	r0, [r3, #0]
    f89a:	b.w	f8b4 <_malloc_r>
    f89e:	nop
    f8a0:	.word	0x20001118

0000f8a4 <free>:
    f8a4:	ldr	r3, [pc, #8]	; (f8b0 <free+0xc>)
    f8a6:	mov	r1, r0
    f8a8:	ldr	r0, [r3, #0]
    f8aa:	b.w	13130 <_free_r>
    f8ae:	nop
    f8b0:	.word	0x20001118

0000f8b4 <_malloc_r>:
    f8b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f8b8:	add.w	r5, r1, #11
    f8bc:	cmp	r5, #22
    f8be:	sub	sp, #12
    f8c0:	mov	r6, r0
    f8c2:	bls.w	fa04 <_malloc_r+0x150>
    f8c6:	bics.w	r5, r5, #7
    f8ca:	bmi.w	fa4c <_malloc_r+0x198>
    f8ce:	cmp	r1, r5
    f8d0:	bhi.w	fa4c <_malloc_r+0x198>
    f8d4:	bl	100b8 <__malloc_lock>
    f8d8:	cmp.w	r5, #504	; 0x1f8
    f8dc:	bcc.w	fe18 <_malloc_r+0x564>
    f8e0:	lsrs	r3, r5, #9
    f8e2:	beq.w	fa5a <_malloc_r+0x1a6>
    f8e6:	cmp	r3, #4
    f8e8:	bhi.w	fbf2 <_malloc_r+0x33e>
    f8ec:	lsrs	r0, r5, #6
    f8ee:	add.w	lr, r0, #57	; 0x39
    f8f2:	mov.w	r3, lr, lsl #1
    f8f6:	adds	r0, #56	; 0x38
    f8f8:	ldr	r7, [pc, #784]	; (fc0c <_malloc_r+0x358>)
    f8fa:	add.w	r3, r7, r3, lsl #2
    f8fe:	sub.w	r1, r3, #8
    f902:	ldr	r4, [r3, #4]
    f904:	cmp	r1, r4
    f906:	bne.n	f918 <_malloc_r+0x64>
    f908:	b.n	fa64 <_malloc_r+0x1b0>
    f90a:	cmp	r2, #0
    f90c:	bge.w	fa68 <_malloc_r+0x1b4>
    f910:	ldr	r4, [r4, #12]
    f912:	cmp	r1, r4
    f914:	beq.w	fa64 <_malloc_r+0x1b0>
    f918:	ldr	r3, [r4, #4]
    f91a:	bic.w	r3, r3, #3
    f91e:	subs	r2, r3, r5
    f920:	cmp	r2, #15
    f922:	ble.n	f90a <_malloc_r+0x56>
    f924:	ldr	r1, [pc, #740]	; (fc0c <_malloc_r+0x358>)
    f926:	ldr	r4, [r7, #16]
    f928:	add.w	lr, r1, #8
    f92c:	cmp	r4, lr
    f92e:	beq.w	fc98 <_malloc_r+0x3e4>
    f932:	ldr	r3, [r4, #4]
    f934:	bic.w	r3, r3, #3
    f938:	subs	r2, r3, r5
    f93a:	cmp	r2, #15
    f93c:	bgt.w	fc72 <_malloc_r+0x3be>
    f940:	cmp	r2, #0
    f942:	str.w	lr, [r1, #20]
    f946:	str.w	lr, [r1, #16]
    f94a:	bge.w	fa8a <_malloc_r+0x1d6>
    f94e:	cmp.w	r3, #512	; 0x200
    f952:	bcs.w	fc24 <_malloc_r+0x370>
    f956:	lsrs	r3, r3, #3
    f958:	add.w	ip, r3, #1
    f95c:	movs	r2, #1
    f95e:	asrs	r3, r3, #2
    f960:	lsl.w	r3, r2, r3
    f964:	ldr	r2, [r1, #4]
    f966:	ldr.w	r8, [r1, ip, lsl #3]
    f96a:	str.w	r8, [r4, #8]
    f96e:	add.w	r9, r1, ip, lsl #3
    f972:	orrs	r2, r3
    f974:	sub.w	r3, r9, #8
    f978:	str	r3, [r4, #12]
    f97a:	str	r2, [r1, #4]
    f97c:	str.w	r4, [r1, ip, lsl #3]
    f980:	str.w	r4, [r8, #12]
    f984:	asrs	r3, r0, #2
    f986:	movs	r4, #1
    f988:	lsls	r4, r3
    f98a:	cmp	r4, r2
    f98c:	bhi.w	faa4 <_malloc_r+0x1f0>
    f990:	tst	r4, r2
    f992:	bne.n	f9a2 <_malloc_r+0xee>
    f994:	bic.w	r0, r0, #3
    f998:	lsls	r4, r4, #1
    f99a:	tst	r4, r2
    f99c:	add.w	r0, r0, #4
    f9a0:	beq.n	f998 <_malloc_r+0xe4>
    f9a2:	add.w	r9, r7, r0, lsl #3
    f9a6:	mov	ip, r9
    f9a8:	mov	r8, r0
    f9aa:	ldr.w	r1, [ip, #12]
    f9ae:	cmp	ip, r1
    f9b0:	bne.n	f9c2 <_malloc_r+0x10e>
    f9b2:	b.n	fc9c <_malloc_r+0x3e8>
    f9b4:	cmp	r2, #0
    f9b6:	bge.w	fcbc <_malloc_r+0x408>
    f9ba:	ldr	r1, [r1, #12]
    f9bc:	cmp	ip, r1
    f9be:	beq.w	fc9c <_malloc_r+0x3e8>
    f9c2:	ldr	r3, [r1, #4]
    f9c4:	bic.w	r3, r3, #3
    f9c8:	subs	r2, r3, r5
    f9ca:	cmp	r2, #15
    f9cc:	ble.n	f9b4 <_malloc_r+0x100>
    f9ce:	mov	r4, r1
    f9d0:	ldr.w	ip, [r1, #12]
    f9d4:	ldr.w	r8, [r4, #8]!
    f9d8:	adds	r3, r1, r5
    f9da:	orr.w	r5, r5, #1
    f9de:	str	r5, [r1, #4]
    f9e0:	orr.w	r1, r2, #1
    f9e4:	str.w	ip, [r8, #12]
    f9e8:	mov	r0, r6
    f9ea:	str.w	r8, [ip, #8]
    f9ee:	str	r3, [r7, #20]
    f9f0:	str	r3, [r7, #16]
    f9f2:	str.w	lr, [r3, #12]
    f9f6:	str.w	lr, [r3, #8]
    f9fa:	str	r1, [r3, #4]
    f9fc:	str	r2, [r3, r2]
    f9fe:	bl	100bc <__malloc_unlock>
    fa02:	b.n	fa44 <_malloc_r+0x190>
    fa04:	cmp	r1, #16
    fa06:	bhi.n	fa4c <_malloc_r+0x198>
    fa08:	bl	100b8 <__malloc_lock>
    fa0c:	movs	r5, #16
    fa0e:	movs	r3, #6
    fa10:	movs	r0, #2
    fa12:	ldr	r7, [pc, #504]	; (fc0c <_malloc_r+0x358>)
    fa14:	add.w	r3, r7, r3, lsl #2
    fa18:	sub.w	r2, r3, #8
    fa1c:	ldr	r4, [r3, #4]
    fa1e:	cmp	r4, r2
    fa20:	beq.w	fcae <_malloc_r+0x3fa>
    fa24:	ldr	r3, [r4, #4]
    fa26:	ldr	r1, [r4, #12]
    fa28:	ldr	r5, [r4, #8]
    fa2a:	bic.w	r3, r3, #3
    fa2e:	add	r3, r4
    fa30:	mov	r0, r6
    fa32:	ldr	r2, [r3, #4]
    fa34:	str	r1, [r5, #12]
    fa36:	orr.w	r2, r2, #1
    fa3a:	str	r5, [r1, #8]
    fa3c:	str	r2, [r3, #4]
    fa3e:	bl	100bc <__malloc_unlock>
    fa42:	adds	r4, #8
    fa44:	mov	r0, r4
    fa46:	add	sp, #12
    fa48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa4c:	movs	r4, #0
    fa4e:	movs	r3, #12
    fa50:	mov	r0, r4
    fa52:	str	r3, [r6, #0]
    fa54:	add	sp, #12
    fa56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa5a:	movs	r3, #128	; 0x80
    fa5c:	mov.w	lr, #64	; 0x40
    fa60:	movs	r0, #63	; 0x3f
    fa62:	b.n	f8f8 <_malloc_r+0x44>
    fa64:	mov	r0, lr
    fa66:	b.n	f924 <_malloc_r+0x70>
    fa68:	add	r3, r4
    fa6a:	ldr	r1, [r4, #12]
    fa6c:	ldr	r2, [r3, #4]
    fa6e:	ldr	r5, [r4, #8]
    fa70:	orr.w	r2, r2, #1
    fa74:	str	r1, [r5, #12]
    fa76:	mov	r0, r6
    fa78:	str	r5, [r1, #8]
    fa7a:	str	r2, [r3, #4]
    fa7c:	bl	100bc <__malloc_unlock>
    fa80:	adds	r4, #8
    fa82:	mov	r0, r4
    fa84:	add	sp, #12
    fa86:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa8a:	add	r3, r4
    fa8c:	mov	r0, r6
    fa8e:	ldr	r2, [r3, #4]
    fa90:	orr.w	r2, r2, #1
    fa94:	str	r2, [r3, #4]
    fa96:	bl	100bc <__malloc_unlock>
    fa9a:	adds	r4, #8
    fa9c:	mov	r0, r4
    fa9e:	add	sp, #12
    faa0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    faa4:	ldr	r4, [r7, #8]
    faa6:	ldr	r3, [r4, #4]
    faa8:	bic.w	r8, r3, #3
    faac:	cmp	r8, r5
    faae:	bcc.n	faba <_malloc_r+0x206>
    fab0:	rsb	r3, r5, r8
    fab4:	cmp	r3, #15
    fab6:	bgt.w	fbd2 <_malloc_r+0x31e>
    faba:	ldr	r3, [pc, #340]	; (fc10 <_malloc_r+0x35c>)
    fabc:	ldr.w	r9, [pc, #352]	; fc20 <_malloc_r+0x36c>
    fac0:	ldr	r2, [r3, #0]
    fac2:	ldr.w	r3, [r9]
    fac6:	adds	r3, #1
    fac8:	add	r2, r5
    faca:	add.w	sl, r4, r8
    face:	beq.w	fd92 <_malloc_r+0x4de>
    fad2:	add.w	r2, r2, #4096	; 0x1000
    fad6:	adds	r2, #15
    fad8:	bic.w	r2, r2, #4080	; 0xff0
    fadc:	bic.w	r2, r2, #15
    fae0:	mov	r1, r2
    fae2:	mov	r0, r6
    fae4:	str	r2, [sp, #4]
    fae6:	bl	104a0 <_sbrk_r>
    faea:	cmp.w	r0, #4294967295
    faee:	mov	fp, r0
    faf0:	ldr	r2, [sp, #4]
    faf2:	beq.w	fda6 <_malloc_r+0x4f2>
    faf6:	cmp	sl, r0
    faf8:	bhi.w	fcf4 <_malloc_r+0x440>
    fafc:	ldr	r3, [pc, #276]	; (fc14 <_malloc_r+0x360>)
    fafe:	ldr	r1, [r3, #0]
    fb00:	cmp	sl, fp
    fb02:	add	r1, r2
    fb04:	str	r1, [r3, #0]
    fb06:	beq.w	fdb0 <_malloc_r+0x4fc>
    fb0a:	ldr.w	r0, [r9]
    fb0e:	ldr.w	lr, [pc, #272]	; fc20 <_malloc_r+0x36c>
    fb12:	adds	r0, #1
    fb14:	ittet	ne
    fb16:	rsbne	sl, sl, fp
    fb1a:	addne	r1, sl
    fb1c:	streq.w	fp, [lr]
    fb20:	strne	r1, [r3, #0]
    fb22:	ands.w	r1, fp, #7
    fb26:	beq.w	fd58 <_malloc_r+0x4a4>
    fb2a:	rsb	r0, r1, #8
    fb2e:	rsb	r1, r1, #4096	; 0x1000
    fb32:	add	fp, r0
    fb34:	adds	r1, #8
    fb36:	add	r2, fp
    fb38:	ubfx	r2, r2, #0, #12
    fb3c:	rsb	r9, r2, r1
    fb40:	mov	r1, r9
    fb42:	mov	r0, r6
    fb44:	str	r3, [sp, #4]
    fb46:	bl	104a0 <_sbrk_r>
    fb4a:	adds	r3, r0, #1
    fb4c:	ldr	r3, [sp, #4]
    fb4e:	beq.w	fdd0 <_malloc_r+0x51c>
    fb52:	rsb	r2, fp, r0
    fb56:	add	r2, r9
    fb58:	orr.w	r2, r2, #1
    fb5c:	ldr	r1, [r3, #0]
    fb5e:	str.w	fp, [r7, #8]
    fb62:	add	r1, r9
    fb64:	cmp	r4, r7
    fb66:	str.w	r2, [fp, #4]
    fb6a:	str	r1, [r3, #0]
    fb6c:	ldr.w	r9, [pc, #164]	; fc14 <_malloc_r+0x360>
    fb70:	beq.n	fba0 <_malloc_r+0x2ec>
    fb72:	cmp.w	r8, #15
    fb76:	bls.w	fd74 <_malloc_r+0x4c0>
    fb7a:	ldr	r2, [r4, #4]
    fb7c:	sub.w	r3, r8, #12
    fb80:	bic.w	r3, r3, #7
    fb84:	adds	r0, r4, r3
    fb86:	and.w	r2, r2, #1
    fb8a:	mov.w	lr, #5
    fb8e:	orrs	r2, r3
    fb90:	cmp	r3, #15
    fb92:	str	r2, [r4, #4]
    fb94:	str.w	lr, [r0, #4]
    fb98:	str.w	lr, [r0, #8]
    fb9c:	bhi.w	fdd8 <_malloc_r+0x524>
    fba0:	ldr	r3, [pc, #116]	; (fc18 <_malloc_r+0x364>)
    fba2:	ldr	r4, [r7, #8]
    fba4:	ldr	r2, [r3, #0]
    fba6:	cmp	r1, r2
    fba8:	it	hi
    fbaa:	strhi	r1, [r3, #0]
    fbac:	ldr	r3, [pc, #108]	; (fc1c <_malloc_r+0x368>)
    fbae:	ldr	r2, [r3, #0]
    fbb0:	cmp	r1, r2
    fbb2:	ldr	r2, [r4, #4]
    fbb4:	it	hi
    fbb6:	strhi	r1, [r3, #0]
    fbb8:	bic.w	r2, r2, #3
    fbbc:	cmp	r5, r2
    fbbe:	sub.w	r3, r2, r5
    fbc2:	bhi.n	fbc8 <_malloc_r+0x314>
    fbc4:	cmp	r3, #15
    fbc6:	bgt.n	fbd2 <_malloc_r+0x31e>
    fbc8:	mov	r0, r6
    fbca:	bl	100bc <__malloc_unlock>
    fbce:	movs	r4, #0
    fbd0:	b.n	fa44 <_malloc_r+0x190>
    fbd2:	adds	r2, r4, r5
    fbd4:	orr.w	r3, r3, #1
    fbd8:	orr.w	r5, r5, #1
    fbdc:	str	r5, [r4, #4]
    fbde:	mov	r0, r6
    fbe0:	str	r2, [r7, #8]
    fbe2:	str	r3, [r2, #4]
    fbe4:	bl	100bc <__malloc_unlock>
    fbe8:	adds	r4, #8
    fbea:	mov	r0, r4
    fbec:	add	sp, #12
    fbee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fbf2:	cmp	r3, #20
    fbf4:	bls.n	fcda <_malloc_r+0x426>
    fbf6:	cmp	r3, #84	; 0x54
    fbf8:	bhi.w	fd44 <_malloc_r+0x490>
    fbfc:	lsrs	r0, r5, #12
    fbfe:	add.w	lr, r0, #111	; 0x6f
    fc02:	mov.w	r3, lr, lsl #1
    fc06:	adds	r0, #110	; 0x6e
    fc08:	b.n	f8f8 <_malloc_r+0x44>
    fc0a:	nop
    fc0c:	.word	0x20001288
    fc10:	.word	0x20005298
    fc14:	.word	0x2000529c
    fc18:	.word	0x20005294
    fc1c:	.word	0x20005290
    fc20:	.word	0x20001694
    fc24:	lsrs	r2, r3, #9
    fc26:	cmp	r2, #4
    fc28:	bls.n	fce8 <_malloc_r+0x434>
    fc2a:	cmp	r2, #20
    fc2c:	bhi.w	fd96 <_malloc_r+0x4e2>
    fc30:	add.w	r1, r2, #92	; 0x5c
    fc34:	lsls	r1, r1, #1
    fc36:	adds	r2, #91	; 0x5b
    fc38:	add.w	ip, r7, r1, lsl #2
    fc3c:	ldr.w	r1, [r7, r1, lsl #2]
    fc40:	ldr.w	r8, [pc, #476]	; fe20 <_malloc_r+0x56c>
    fc44:	sub.w	ip, ip, #8
    fc48:	cmp	ip, r1
    fc4a:	beq.w	fd5e <_malloc_r+0x4aa>
    fc4e:	ldr	r2, [r1, #4]
    fc50:	bic.w	r2, r2, #3
    fc54:	cmp	r3, r2
    fc56:	bcs.n	fc5e <_malloc_r+0x3aa>
    fc58:	ldr	r1, [r1, #8]
    fc5a:	cmp	ip, r1
    fc5c:	bne.n	fc4e <_malloc_r+0x39a>
    fc5e:	ldr.w	ip, [r1, #12]
    fc62:	ldr	r2, [r7, #4]
    fc64:	str.w	ip, [r4, #12]
    fc68:	str	r1, [r4, #8]
    fc6a:	str.w	r4, [ip, #8]
    fc6e:	str	r4, [r1, #12]
    fc70:	b.n	f984 <_malloc_r+0xd0>
    fc72:	adds	r3, r4, r5
    fc74:	orr.w	r7, r2, #1
    fc78:	orr.w	r5, r5, #1
    fc7c:	str	r5, [r4, #4]
    fc7e:	mov	r0, r6
    fc80:	str	r3, [r1, #20]
    fc82:	str	r3, [r1, #16]
    fc84:	str.w	lr, [r3, #12]
    fc88:	str.w	lr, [r3, #8]
    fc8c:	str	r7, [r3, #4]
    fc8e:	str	r2, [r3, r2]
    fc90:	adds	r4, #8
    fc92:	bl	100bc <__malloc_unlock>
    fc96:	b.n	fa44 <_malloc_r+0x190>
    fc98:	ldr	r2, [r1, #4]
    fc9a:	b.n	f984 <_malloc_r+0xd0>
    fc9c:	add.w	r8, r8, #1
    fca0:	tst.w	r8, #3
    fca4:	add.w	ip, ip, #8
    fca8:	bne.w	f9aa <_malloc_r+0xf6>
    fcac:	b.n	fd10 <_malloc_r+0x45c>
    fcae:	ldr	r4, [r3, #12]
    fcb0:	cmp	r3, r4
    fcb2:	it	eq
    fcb4:	addeq	r0, #2
    fcb6:	beq.w	f924 <_malloc_r+0x70>
    fcba:	b.n	fa24 <_malloc_r+0x170>
    fcbc:	add	r3, r1
    fcbe:	mov	r4, r1
    fcc0:	ldr	r2, [r3, #4]
    fcc2:	ldr	r1, [r1, #12]
    fcc4:	ldr.w	r5, [r4, #8]!
    fcc8:	orr.w	r2, r2, #1
    fccc:	str	r2, [r3, #4]
    fcce:	mov	r0, r6
    fcd0:	str	r1, [r5, #12]
    fcd2:	str	r5, [r1, #8]
    fcd4:	bl	100bc <__malloc_unlock>
    fcd8:	b.n	fa44 <_malloc_r+0x190>
    fcda:	add.w	lr, r3, #92	; 0x5c
    fcde:	add.w	r0, r3, #91	; 0x5b
    fce2:	mov.w	r3, lr, lsl #1
    fce6:	b.n	f8f8 <_malloc_r+0x44>
    fce8:	lsrs	r2, r3, #6
    fcea:	add.w	r1, r2, #57	; 0x39
    fcee:	lsls	r1, r1, #1
    fcf0:	adds	r2, #56	; 0x38
    fcf2:	b.n	fc38 <_malloc_r+0x384>
    fcf4:	cmp	r4, r7
    fcf6:	ldr	r3, [pc, #296]	; (fe20 <_malloc_r+0x56c>)
    fcf8:	beq.w	fafc <_malloc_r+0x248>
    fcfc:	ldr	r4, [r3, #8]
    fcfe:	ldr	r2, [r4, #4]
    fd00:	bic.w	r2, r2, #3
    fd04:	b.n	fbbc <_malloc_r+0x308>
    fd06:	ldr.w	r3, [r9], #-8
    fd0a:	cmp	r9, r3
    fd0c:	bne.w	fe14 <_malloc_r+0x560>
    fd10:	tst.w	r0, #3
    fd14:	add.w	r0, r0, #4294967295
    fd18:	bne.n	fd06 <_malloc_r+0x452>
    fd1a:	ldr	r3, [r7, #4]
    fd1c:	bic.w	r3, r3, r4
    fd20:	str	r3, [r7, #4]
    fd22:	lsls	r4, r4, #1
    fd24:	cmp	r4, r3
    fd26:	bhi.w	faa4 <_malloc_r+0x1f0>
    fd2a:	cmp	r4, #0
    fd2c:	beq.w	faa4 <_malloc_r+0x1f0>
    fd30:	tst	r4, r3
    fd32:	mov	r0, r8
    fd34:	bne.w	f9a2 <_malloc_r+0xee>
    fd38:	lsls	r4, r4, #1
    fd3a:	tst	r4, r3
    fd3c:	add.w	r0, r0, #4
    fd40:	beq.n	fd38 <_malloc_r+0x484>
    fd42:	b.n	f9a2 <_malloc_r+0xee>
    fd44:	cmp.w	r3, #340	; 0x154
    fd48:	bhi.n	fd7c <_malloc_r+0x4c8>
    fd4a:	lsrs	r0, r5, #15
    fd4c:	add.w	lr, r0, #120	; 0x78
    fd50:	mov.w	r3, lr, lsl #1
    fd54:	adds	r0, #119	; 0x77
    fd56:	b.n	f8f8 <_malloc_r+0x44>
    fd58:	mov.w	r1, #4096	; 0x1000
    fd5c:	b.n	fb36 <_malloc_r+0x282>
    fd5e:	movs	r1, #1
    fd60:	ldr.w	r3, [r8, #4]
    fd64:	asrs	r2, r2, #2
    fd66:	lsl.w	r2, r1, r2
    fd6a:	orrs	r2, r3
    fd6c:	str.w	r2, [r8, #4]
    fd70:	mov	r1, ip
    fd72:	b.n	fc64 <_malloc_r+0x3b0>
    fd74:	movs	r3, #1
    fd76:	str.w	r3, [fp, #4]
    fd7a:	b.n	fbc8 <_malloc_r+0x314>
    fd7c:	movw	r2, #1364	; 0x554
    fd80:	cmp	r3, r2
    fd82:	bhi.n	fdc6 <_malloc_r+0x512>
    fd84:	lsrs	r0, r5, #18
    fd86:	add.w	lr, r0, #125	; 0x7d
    fd8a:	mov.w	r3, lr, lsl #1
    fd8e:	adds	r0, #124	; 0x7c
    fd90:	b.n	f8f8 <_malloc_r+0x44>
    fd92:	adds	r2, #16
    fd94:	b.n	fae0 <_malloc_r+0x22c>
    fd96:	cmp	r2, #84	; 0x54
    fd98:	bhi.n	fde8 <_malloc_r+0x534>
    fd9a:	lsrs	r2, r3, #12
    fd9c:	add.w	r1, r2, #111	; 0x6f
    fda0:	lsls	r1, r1, #1
    fda2:	adds	r2, #110	; 0x6e
    fda4:	b.n	fc38 <_malloc_r+0x384>
    fda6:	ldr	r4, [r7, #8]
    fda8:	ldr	r2, [r4, #4]
    fdaa:	bic.w	r2, r2, #3
    fdae:	b.n	fbbc <_malloc_r+0x308>
    fdb0:	ubfx	r0, sl, #0, #12
    fdb4:	cmp	r0, #0
    fdb6:	bne.w	fb0a <_malloc_r+0x256>
    fdba:	add	r2, r8
    fdbc:	ldr	r3, [r7, #8]
    fdbe:	orr.w	r2, r2, #1
    fdc2:	str	r2, [r3, #4]
    fdc4:	b.n	fba0 <_malloc_r+0x2ec>
    fdc6:	movs	r3, #254	; 0xfe
    fdc8:	mov.w	lr, #127	; 0x7f
    fdcc:	movs	r0, #126	; 0x7e
    fdce:	b.n	f8f8 <_malloc_r+0x44>
    fdd0:	movs	r2, #1
    fdd2:	mov.w	r9, #0
    fdd6:	b.n	fb5c <_malloc_r+0x2a8>
    fdd8:	add.w	r1, r4, #8
    fddc:	mov	r0, r6
    fdde:	bl	13130 <_free_r>
    fde2:	ldr.w	r1, [r9]
    fde6:	b.n	fba0 <_malloc_r+0x2ec>
    fde8:	cmp.w	r2, #340	; 0x154
    fdec:	bhi.n	fdfa <_malloc_r+0x546>
    fdee:	lsrs	r2, r3, #15
    fdf0:	add.w	r1, r2, #120	; 0x78
    fdf4:	lsls	r1, r1, #1
    fdf6:	adds	r2, #119	; 0x77
    fdf8:	b.n	fc38 <_malloc_r+0x384>
    fdfa:	movw	r1, #1364	; 0x554
    fdfe:	cmp	r2, r1
    fe00:	bhi.n	fe0e <_malloc_r+0x55a>
    fe02:	lsrs	r2, r3, #18
    fe04:	add.w	r1, r2, #125	; 0x7d
    fe08:	lsls	r1, r1, #1
    fe0a:	adds	r2, #124	; 0x7c
    fe0c:	b.n	fc38 <_malloc_r+0x384>
    fe0e:	movs	r1, #254	; 0xfe
    fe10:	movs	r2, #126	; 0x7e
    fe12:	b.n	fc38 <_malloc_r+0x384>
    fe14:	ldr	r3, [r7, #4]
    fe16:	b.n	fd22 <_malloc_r+0x46e>
    fe18:	lsrs	r0, r5, #3
    fe1a:	adds	r3, r0, #1
    fe1c:	lsls	r3, r3, #1
    fe1e:	b.n	fa12 <_malloc_r+0x15e>
    fe20:	.word	0x20001288

0000fe24 <__ascii_mbtowc>:
    fe24:	sub	sp, #8
    fe26:	cbz	r1, fe3c <__ascii_mbtowc+0x18>
    fe28:	cbz	r2, fe42 <__ascii_mbtowc+0x1e>
    fe2a:	cbz	r3, fe48 <__ascii_mbtowc+0x24>
    fe2c:	ldrb	r3, [r2, #0]
    fe2e:	str	r3, [r1, #0]
    fe30:	ldrb	r2, [r2, #0]
    fe32:	adds	r0, r2, #0
    fe34:	it	ne
    fe36:	movne	r0, #1
    fe38:	add	sp, #8
    fe3a:	bx	lr
    fe3c:	add	r1, sp, #4
    fe3e:	cmp	r2, #0
    fe40:	bne.n	fe2a <__ascii_mbtowc+0x6>
    fe42:	mov	r0, r2
    fe44:	add	sp, #8
    fe46:	bx	lr
    fe48:	mvn.w	r0, #1
    fe4c:	b.n	fe38 <__ascii_mbtowc+0x14>
    fe4e:	nop

0000fe50 <memchr>:
    fe50:	and.w	r1, r1, #255	; 0xff
    fe54:	cmp	r2, #16
    fe56:	blt.n	feb0 <memchr+0x60>
    fe58:	tst.w	r0, #7
    fe5c:	beq.n	fe70 <memchr+0x20>
    fe5e:	ldrb.w	r3, [r0], #1
    fe62:	subs	r2, #1
    fe64:	cmp	r3, r1
    fe66:	beq.n	fec4 <memchr+0x74>
    fe68:	tst.w	r0, #7
    fe6c:	cbz	r2, fec0 <memchr+0x70>
    fe6e:	bne.n	fe5e <memchr+0xe>
    fe70:	push	{r4, r5, r6, r7}
    fe72:	orr.w	r1, r1, r1, lsl #8
    fe76:	orr.w	r1, r1, r1, lsl #16
    fe7a:	bic.w	r4, r2, #7
    fe7e:	mvns.w	r7, #0
    fe82:	movs	r3, #0
    fe84:	ldrd	r5, r6, [r0], #8
    fe88:	subs	r4, #8
    fe8a:	eor.w	r5, r5, r1
    fe8e:	eor.w	r6, r6, r1
    fe92:	uadd8	r5, r5, r7
    fe96:	sel	r5, r3, r7
    fe9a:	uadd8	r6, r6, r7
    fe9e:	sel	r6, r5, r7
    fea2:	cbnz	r6, fec8 <memchr+0x78>
    fea4:	bne.n	fe84 <memchr+0x34>
    fea6:	pop	{r4, r5, r6, r7}
    fea8:	and.w	r1, r1, #255	; 0xff
    feac:	and.w	r2, r2, #7
    feb0:	cbz	r2, fec0 <memchr+0x70>
    feb2:	ldrb.w	r3, [r0], #1
    feb6:	subs	r2, #1
    feb8:	eor.w	r3, r3, r1
    febc:	cbz	r3, fec4 <memchr+0x74>
    febe:	bne.n	feb2 <memchr+0x62>
    fec0:	movs	r0, #0
    fec2:	bx	lr
    fec4:	subs	r0, #1
    fec6:	bx	lr
    fec8:	cmp	r5, #0
    feca:	itte	eq
    fecc:	moveq	r5, r6
    fece:	subeq	r0, #3
    fed0:	subne	r0, #7
    fed2:	tst.w	r5, #1
    fed6:	bne.n	fee8 <memchr+0x98>
    fed8:	adds	r0, #1
    feda:	tst.w	r5, #256	; 0x100
    fede:	ittt	eq
    fee0:	addeq	r0, #1
    fee2:	tsteq.w	r5, #98304	; 0x18000
    fee6:	addeq	r0, #1
    fee8:	pop	{r4, r5, r6, r7}
    feea:	subs	r0, #1
    feec:	bx	lr
    feee:	nop

0000fef0 <memcmp>:
    fef0:	cmp	r2, #3
    fef2:	push	{r4, r5, r6}
    fef4:	bls.n	ff44 <memcmp+0x54>
    fef6:	orr.w	r3, r0, r1
    fefa:	lsls	r3, r3, #30
    fefc:	beq.n	ff22 <memcmp+0x32>
    fefe:	ldrb	r4, [r0, #0]
    ff00:	ldrb	r5, [r1, #0]
    ff02:	cmp	r4, r5
    ff04:	bne.n	ff4c <memcmp+0x5c>
    ff06:	add	r2, r0
    ff08:	adds	r3, r0, #1
    ff0a:	b.n	ff18 <memcmp+0x28>
    ff0c:	ldrb.w	r4, [r3], #1
    ff10:	ldrb.w	r5, [r1, #1]!
    ff14:	cmp	r4, r5
    ff16:	bne.n	ff4c <memcmp+0x5c>
    ff18:	cmp	r3, r2
    ff1a:	bne.n	ff0c <memcmp+0x1c>
    ff1c:	movs	r0, #0
    ff1e:	pop	{r4, r5, r6}
    ff20:	bx	lr
    ff22:	mov	r4, r1
    ff24:	mov	r3, r0
    ff26:	ldr	r6, [r3, #0]
    ff28:	ldr	r5, [r4, #0]
    ff2a:	cmp	r6, r5
    ff2c:	mov	r0, r3
    ff2e:	mov	r1, r4
    ff30:	add.w	r3, r3, #4
    ff34:	add.w	r4, r4, #4
    ff38:	bne.n	fefe <memcmp+0xe>
    ff3a:	subs	r2, #4
    ff3c:	cmp	r2, #3
    ff3e:	mov	r0, r3
    ff40:	mov	r1, r4
    ff42:	bhi.n	ff26 <memcmp+0x36>
    ff44:	cmp	r2, #0
    ff46:	bne.n	fefe <memcmp+0xe>
    ff48:	mov	r0, r2
    ff4a:	b.n	ff1e <memcmp+0x2e>
    ff4c:	subs	r0, r4, r5
    ff4e:	pop	{r4, r5, r6}
    ff50:	bx	lr
    ff52:	nop

0000ff54 <memmove>:
    ff54:	cmp	r0, r1
    ff56:	push	{r4, r5, r6, r7, lr}
    ff58:	bls.n	ff76 <memmove+0x22>
    ff5a:	adds	r3, r1, r2
    ff5c:	cmp	r0, r3
    ff5e:	bcs.n	ff76 <memmove+0x22>
    ff60:	adds	r1, r0, r2
    ff62:	cmp	r2, #0
    ff64:	beq.n	1000a <memmove+0xb6>
    ff66:	subs	r2, r3, r2
    ff68:	ldrb.w	r4, [r3, #-1]!
    ff6c:	strb.w	r4, [r1, #-1]!
    ff70:	cmp	r3, r2
    ff72:	bne.n	ff68 <memmove+0x14>
    ff74:	pop	{r4, r5, r6, r7, pc}
    ff76:	cmp	r2, #15
    ff78:	bls.n	1000c <memmove+0xb8>
    ff7a:	orr.w	r3, r1, r0
    ff7e:	lsls	r3, r3, #30
    ff80:	bne.n	10010 <memmove+0xbc>
    ff82:	add.w	r4, r0, #16
    ff86:	add.w	r3, r1, #16
    ff8a:	mov	r5, r2
    ff8c:	ldr.w	r6, [r3, #-16]
    ff90:	str.w	r6, [r4, #-16]
    ff94:	ldr.w	r6, [r3, #-12]
    ff98:	str.w	r6, [r4, #-12]
    ff9c:	ldr.w	r6, [r3, #-8]
    ffa0:	str.w	r6, [r4, #-8]
    ffa4:	subs	r5, #16
    ffa6:	ldr.w	r6, [r3, #-4]
    ffaa:	str.w	r6, [r4, #-4]
    ffae:	cmp	r5, #15
    ffb0:	add.w	r3, r3, #16
    ffb4:	add.w	r4, r4, #16
    ffb8:	bhi.n	ff8c <memmove+0x38>
    ffba:	sub.w	r3, r2, #16
    ffbe:	bic.w	r3, r3, #15
    ffc2:	and.w	lr, r2, #15
    ffc6:	adds	r3, #16
    ffc8:	cmp.w	lr, #3
    ffcc:	add	r1, r3
    ffce:	add	r3, r0
    ffd0:	bls.n	10016 <memmove+0xc2>
    ffd2:	subs	r6, r3, #4
    ffd4:	mov	r5, r1
    ffd6:	mov	r4, lr
    ffd8:	subs	r4, #4
    ffda:	ldr.w	r7, [r5], #4
    ffde:	str.w	r7, [r6, #4]!
    ffe2:	cmp	r4, #3
    ffe4:	bhi.n	ffd8 <memmove+0x84>
    ffe6:	sub.w	r4, lr, #4
    ffea:	bic.w	r4, r4, #3
    ffee:	adds	r4, #4
    fff0:	add	r3, r4
    fff2:	add	r1, r4
    fff4:	and.w	r2, r2, #3
    fff8:	cbz	r2, 10014 <memmove+0xc0>
    fffa:	subs	r3, #1
    fffc:	add	r2, r1
    fffe:	ldrb.w	r4, [r1], #1
   10002:	strb.w	r4, [r3, #1]!
   10006:	cmp	r2, r1
   10008:	bne.n	fffe <memmove+0xaa>
   1000a:	pop	{r4, r5, r6, r7, pc}
   1000c:	mov	r3, r0
   1000e:	b.n	fff8 <memmove+0xa4>
   10010:	mov	r3, r0
   10012:	b.n	fffa <memmove+0xa6>
   10014:	pop	{r4, r5, r6, r7, pc}
   10016:	mov	r2, lr
   10018:	b.n	fff8 <memmove+0xa4>
   1001a:	nop

0001001c <memset>:
   1001c:	push	{r4, r5, r6}
   1001e:	lsls	r4, r0, #30
   10020:	beq.n	100b0 <memset+0x94>
   10022:	subs	r4, r2, #1
   10024:	cmp	r2, #0
   10026:	beq.n	100ac <memset+0x90>
   10028:	uxtb	r5, r1
   1002a:	mov	r3, r0
   1002c:	b.n	10034 <memset+0x18>
   1002e:	subs	r2, r4, #1
   10030:	cbz	r4, 100ac <memset+0x90>
   10032:	mov	r4, r2
   10034:	strb.w	r5, [r3], #1
   10038:	lsls	r2, r3, #30
   1003a:	bne.n	1002e <memset+0x12>
   1003c:	cmp	r4, #3
   1003e:	bls.n	1009e <memset+0x82>
   10040:	uxtb	r5, r1
   10042:	orr.w	r5, r5, r5, lsl #8
   10046:	cmp	r4, #15
   10048:	orr.w	r5, r5, r5, lsl #16
   1004c:	bls.n	10082 <memset+0x66>
   1004e:	add.w	r2, r3, #16
   10052:	mov	r6, r4
   10054:	subs	r6, #16
   10056:	cmp	r6, #15
   10058:	str.w	r5, [r2, #-16]
   1005c:	str.w	r5, [r2, #-12]
   10060:	str.w	r5, [r2, #-8]
   10064:	str.w	r5, [r2, #-4]
   10068:	add.w	r2, r2, #16
   1006c:	bhi.n	10054 <memset+0x38>
   1006e:	sub.w	r2, r4, #16
   10072:	bic.w	r2, r2, #15
   10076:	and.w	r4, r4, #15
   1007a:	adds	r2, #16
   1007c:	cmp	r4, #3
   1007e:	add	r3, r2
   10080:	bls.n	1009e <memset+0x82>
   10082:	mov	r6, r3
   10084:	mov	r2, r4
   10086:	subs	r2, #4
   10088:	cmp	r2, #3
   1008a:	str.w	r5, [r6], #4
   1008e:	bhi.n	10086 <memset+0x6a>
   10090:	subs	r2, r4, #4
   10092:	bic.w	r2, r2, #3
   10096:	adds	r2, #4
   10098:	add	r3, r2
   1009a:	and.w	r4, r4, #3
   1009e:	cbz	r4, 100ac <memset+0x90>
   100a0:	uxtb	r1, r1
   100a2:	add	r4, r3
   100a4:	strb.w	r1, [r3], #1
   100a8:	cmp	r3, r4
   100aa:	bne.n	100a4 <memset+0x88>
   100ac:	pop	{r4, r5, r6}
   100ae:	bx	lr
   100b0:	mov	r4, r2
   100b2:	mov	r3, r0
   100b4:	b.n	1003c <memset+0x20>
   100b6:	nop

000100b8 <__malloc_lock>:
   100b8:	bx	lr
   100ba:	nop

000100bc <__malloc_unlock>:
   100bc:	bx	lr
   100be:	nop

000100c0 <_realloc_r>:
   100c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   100c4:	mov	r7, r2
   100c6:	sub	sp, #12
   100c8:	cmp	r1, #0
   100ca:	beq.w	10250 <_realloc_r+0x190>
   100ce:	mov	r6, r1
   100d0:	mov	r9, r0
   100d2:	add.w	r5, r7, #11
   100d6:	bl	100b8 <__malloc_lock>
   100da:	ldr.w	lr, [r6, #-4]
   100de:	cmp	r5, #22
   100e0:	bic.w	r4, lr, #3
   100e4:	sub.w	r8, r6, #8
   100e8:	bhi.n	1016c <_realloc_r+0xac>
   100ea:	movs	r2, #16
   100ec:	mov	r5, r2
   100ee:	cmp	r7, r5
   100f0:	bhi.n	10176 <_realloc_r+0xb6>
   100f2:	cmp	r4, r2
   100f4:	bge.n	101e2 <_realloc_r+0x122>
   100f6:	ldr	r3, [pc, #804]	; (1041c <_realloc_r+0x35c>)
   100f8:	ldr	r1, [r3, #8]
   100fa:	add.w	r0, r8, r4
   100fe:	cmp	r0, r1
   10100:	ldr	r1, [r0, #4]
   10102:	beq.w	102b8 <_realloc_r+0x1f8>
   10106:	bic.w	r3, r1, #1
   1010a:	add	r3, r0
   1010c:	ldr	r3, [r3, #4]
   1010e:	lsls	r3, r3, #31
   10110:	bpl.n	1020e <_realloc_r+0x14e>
   10112:	tst.w	lr, #1
   10116:	beq.n	10184 <_realloc_r+0xc4>
   10118:	mov	r1, r7
   1011a:	mov	r0, r9
   1011c:	bl	f8b4 <_malloc_r>
   10120:	mov	r7, r0
   10122:	cbz	r0, 1015e <_realloc_r+0x9e>
   10124:	ldr.w	r3, [r6, #-4]
   10128:	bic.w	r3, r3, #1
   1012c:	add	r3, r8
   1012e:	sub.w	r2, r0, #8
   10132:	cmp	r2, r3
   10134:	beq.w	103c0 <_realloc_r+0x300>
   10138:	subs	r2, r4, #4
   1013a:	cmp	r2, #36	; 0x24
   1013c:	bhi.w	103a2 <_realloc_r+0x2e2>
   10140:	cmp	r2, #19
   10142:	bhi.w	1034e <_realloc_r+0x28e>
   10146:	mov	r3, r0
   10148:	mov	r2, r6
   1014a:	ldr	r1, [r2, #0]
   1014c:	str	r1, [r3, #0]
   1014e:	ldr	r1, [r2, #4]
   10150:	str	r1, [r3, #4]
   10152:	ldr	r2, [r2, #8]
   10154:	str	r2, [r3, #8]
   10156:	mov	r1, r6
   10158:	mov	r0, r9
   1015a:	bl	13130 <_free_r>
   1015e:	mov	r0, r9
   10160:	bl	100bc <__malloc_unlock>
   10164:	mov	r0, r7
   10166:	add	sp, #12
   10168:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1016c:	bic.w	r5, r5, #7
   10170:	cmp	r5, #0
   10172:	mov	r2, r5
   10174:	bge.n	100ee <_realloc_r+0x2e>
   10176:	movs	r3, #12
   10178:	movs	r0, #0
   1017a:	str.w	r3, [r9]
   1017e:	add	sp, #12
   10180:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10184:	ldr.w	r3, [r6, #-8]
   10188:	rsb	sl, r3, r8
   1018c:	ldr.w	r3, [sl, #4]
   10190:	bic.w	ip, r3, #3
   10194:	add.w	r3, r4, ip
   10198:	cmp	r3, r2
   1019a:	blt.n	10118 <_realloc_r+0x58>
   1019c:	mov	r7, sl
   1019e:	ldr.w	r1, [sl, #12]
   101a2:	ldr.w	r0, [r7, #8]!
   101a6:	subs	r2, r4, #4
   101a8:	cmp	r2, #36	; 0x24
   101aa:	str	r1, [r0, #12]
   101ac:	str	r0, [r1, #8]
   101ae:	bhi.w	103e0 <_realloc_r+0x320>
   101b2:	cmp	r2, #19
   101b4:	bls.w	103dc <_realloc_r+0x31c>
   101b8:	ldr	r1, [r6, #0]
   101ba:	str.w	r1, [sl, #8]
   101be:	ldr	r1, [r6, #4]
   101c0:	str.w	r1, [sl, #12]
   101c4:	cmp	r2, #27
   101c6:	bhi.w	10420 <_realloc_r+0x360>
   101ca:	adds	r6, #8
   101cc:	add.w	r2, sl, #16
   101d0:	ldr	r1, [r6, #0]
   101d2:	str	r1, [r2, #0]
   101d4:	ldr	r1, [r6, #4]
   101d6:	str	r1, [r2, #4]
   101d8:	ldr	r1, [r6, #8]
   101da:	str	r1, [r2, #8]
   101dc:	mov	r6, r7
   101de:	mov	r4, r3
   101e0:	mov	r8, sl
   101e2:	subs	r3, r4, r5
   101e4:	cmp	r3, #15
   101e6:	bhi.n	10224 <_realloc_r+0x164>
   101e8:	ldr.w	r3, [r8, #4]
   101ec:	and.w	r3, r3, #1
   101f0:	orrs	r3, r4
   101f2:	add	r4, r8
   101f4:	str.w	r3, [r8, #4]
   101f8:	ldr	r3, [r4, #4]
   101fa:	orr.w	r3, r3, #1
   101fe:	str	r3, [r4, #4]
   10200:	mov	r0, r9
   10202:	bl	100bc <__malloc_unlock>
   10206:	mov	r0, r6
   10208:	add	sp, #12
   1020a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1020e:	bic.w	r1, r1, #3
   10212:	add	r1, r4
   10214:	cmp	r1, r2
   10216:	blt.n	1025c <_realloc_r+0x19c>
   10218:	ldr	r3, [r0, #12]
   1021a:	ldr	r2, [r0, #8]
   1021c:	mov	r4, r1
   1021e:	str	r3, [r2, #12]
   10220:	str	r2, [r3, #8]
   10222:	b.n	101e2 <_realloc_r+0x122>
   10224:	ldr.w	r2, [r8, #4]
   10228:	add.w	r1, r8, r5
   1022c:	and.w	r2, r2, #1
   10230:	orrs	r5, r2
   10232:	orr.w	r2, r3, #1
   10236:	add	r3, r1
   10238:	str.w	r5, [r8, #4]
   1023c:	str	r2, [r1, #4]
   1023e:	ldr	r2, [r3, #4]
   10240:	orr.w	r2, r2, #1
   10244:	adds	r1, #8
   10246:	str	r2, [r3, #4]
   10248:	mov	r0, r9
   1024a:	bl	13130 <_free_r>
   1024e:	b.n	10200 <_realloc_r+0x140>
   10250:	mov	r1, r2
   10252:	add	sp, #12
   10254:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10258:	b.w	f8b4 <_malloc_r>
   1025c:	tst.w	lr, #1
   10260:	bne.w	10118 <_realloc_r+0x58>
   10264:	ldr.w	r3, [r6, #-8]
   10268:	rsb	sl, r3, r8
   1026c:	ldr.w	r3, [sl, #4]
   10270:	bic.w	ip, r3, #3
   10274:	add.w	lr, r1, ip
   10278:	cmp	lr, r2
   1027a:	blt.n	10194 <_realloc_r+0xd4>
   1027c:	ldr	r3, [r0, #12]
   1027e:	ldr	r2, [r0, #8]
   10280:	mov	r7, sl
   10282:	str	r3, [r2, #12]
   10284:	str	r2, [r3, #8]
   10286:	ldr.w	r1, [r7, #8]!
   1028a:	ldr.w	r3, [sl, #12]
   1028e:	str	r3, [r1, #12]
   10290:	subs	r2, r4, #4
   10292:	cmp	r2, #36	; 0x24
   10294:	str	r1, [r3, #8]
   10296:	bhi.w	103cc <_realloc_r+0x30c>
   1029a:	cmp	r2, #19
   1029c:	bls.n	10364 <_realloc_r+0x2a4>
   1029e:	ldr	r3, [r6, #0]
   102a0:	str.w	r3, [sl, #8]
   102a4:	ldr	r3, [r6, #4]
   102a6:	str.w	r3, [sl, #12]
   102aa:	cmp	r2, #27
   102ac:	bhi.w	103f0 <_realloc_r+0x330>
   102b0:	adds	r6, #8
   102b2:	add.w	r3, sl, #16
   102b6:	b.n	10366 <_realloc_r+0x2a6>
   102b8:	bic.w	fp, r1, #3
   102bc:	add	fp, r4
   102be:	add.w	r0, r5, #16
   102c2:	cmp	fp, r0
   102c4:	bge.n	1037a <_realloc_r+0x2ba>
   102c6:	tst.w	lr, #1
   102ca:	bne.w	10118 <_realloc_r+0x58>
   102ce:	ldr.w	r1, [r6, #-8]
   102d2:	rsb	sl, r1, r8
   102d6:	ldr.w	r1, [sl, #4]
   102da:	bic.w	ip, r1, #3
   102de:	add	fp, ip
   102e0:	cmp	r0, fp
   102e2:	bgt.w	10194 <_realloc_r+0xd4>
   102e6:	mov	r7, sl
   102e8:	ldr.w	r1, [sl, #12]
   102ec:	ldr.w	r0, [r7, #8]!
   102f0:	subs	r2, r4, #4
   102f2:	cmp	r2, #36	; 0x24
   102f4:	str	r1, [r0, #12]
   102f6:	str	r0, [r1, #8]
   102f8:	bhi.w	10464 <_realloc_r+0x3a4>
   102fc:	cmp	r2, #19
   102fe:	bls.w	1044c <_realloc_r+0x38c>
   10302:	ldr	r1, [r6, #0]
   10304:	str.w	r1, [sl, #8]
   10308:	ldr	r1, [r6, #4]
   1030a:	str.w	r1, [sl, #12]
   1030e:	cmp	r2, #27
   10310:	bhi.w	10472 <_realloc_r+0x3b2>
   10314:	adds	r6, #8
   10316:	add.w	r2, sl, #16
   1031a:	ldr	r1, [r6, #0]
   1031c:	str	r1, [r2, #0]
   1031e:	ldr	r1, [r6, #4]
   10320:	str	r1, [r2, #4]
   10322:	ldr	r1, [r6, #8]
   10324:	str	r1, [r2, #8]
   10326:	add.w	r1, sl, r5
   1032a:	rsb	r2, r5, fp
   1032e:	orr.w	r2, r2, #1
   10332:	str	r1, [r3, #8]
   10334:	str	r2, [r1, #4]
   10336:	ldr.w	r3, [sl, #4]
   1033a:	and.w	r3, r3, #1
   1033e:	orrs	r5, r3
   10340:	mov	r0, r9
   10342:	str.w	r5, [sl, #4]
   10346:	bl	100bc <__malloc_unlock>
   1034a:	mov	r0, r7
   1034c:	b.n	10208 <_realloc_r+0x148>
   1034e:	ldr	r3, [r6, #0]
   10350:	str	r3, [r0, #0]
   10352:	ldr	r3, [r6, #4]
   10354:	str	r3, [r0, #4]
   10356:	cmp	r2, #27
   10358:	bhi.n	103aa <_realloc_r+0x2ea>
   1035a:	add.w	r3, r0, #8
   1035e:	add.w	r2, r6, #8
   10362:	b.n	1014a <_realloc_r+0x8a>
   10364:	mov	r3, r7
   10366:	ldr	r2, [r6, #0]
   10368:	str	r2, [r3, #0]
   1036a:	ldr	r2, [r6, #4]
   1036c:	str	r2, [r3, #4]
   1036e:	ldr	r2, [r6, #8]
   10370:	str	r2, [r3, #8]
   10372:	mov	r6, r7
   10374:	mov	r4, lr
   10376:	mov	r8, sl
   10378:	b.n	101e2 <_realloc_r+0x122>
   1037a:	add.w	r1, r8, r5
   1037e:	rsb	fp, r5, fp
   10382:	orr.w	r2, fp, #1
   10386:	str	r1, [r3, #8]
   10388:	str	r2, [r1, #4]
   1038a:	ldr.w	r3, [r6, #-4]
   1038e:	and.w	r3, r3, #1
   10392:	orrs	r5, r3
   10394:	mov	r0, r9
   10396:	str.w	r5, [r6, #-4]
   1039a:	bl	100bc <__malloc_unlock>
   1039e:	mov	r0, r6
   103a0:	b.n	10208 <_realloc_r+0x148>
   103a2:	mov	r1, r6
   103a4:	bl	ff54 <memmove>
   103a8:	b.n	10156 <_realloc_r+0x96>
   103aa:	ldr	r3, [r6, #8]
   103ac:	str	r3, [r0, #8]
   103ae:	ldr	r3, [r6, #12]
   103b0:	str	r3, [r0, #12]
   103b2:	cmp	r2, #36	; 0x24
   103b4:	beq.n	10408 <_realloc_r+0x348>
   103b6:	add.w	r3, r0, #16
   103ba:	add.w	r2, r6, #16
   103be:	b.n	1014a <_realloc_r+0x8a>
   103c0:	ldr.w	r3, [r0, #-4]
   103c4:	bic.w	r3, r3, #3
   103c8:	add	r4, r3
   103ca:	b.n	101e2 <_realloc_r+0x122>
   103cc:	mov	r1, r6
   103ce:	mov	r0, r7
   103d0:	mov	r4, lr
   103d2:	mov	r8, sl
   103d4:	bl	ff54 <memmove>
   103d8:	mov	r6, r7
   103da:	b.n	101e2 <_realloc_r+0x122>
   103dc:	mov	r2, r7
   103de:	b.n	101d0 <_realloc_r+0x110>
   103e0:	mov	r1, r6
   103e2:	mov	r0, r7
   103e4:	mov	r4, r3
   103e6:	mov	r8, sl
   103e8:	bl	ff54 <memmove>
   103ec:	mov	r6, r7
   103ee:	b.n	101e2 <_realloc_r+0x122>
   103f0:	ldr	r3, [r6, #8]
   103f2:	str.w	r3, [sl, #16]
   103f6:	ldr	r3, [r6, #12]
   103f8:	str.w	r3, [sl, #20]
   103fc:	cmp	r2, #36	; 0x24
   103fe:	beq.n	10438 <_realloc_r+0x378>
   10400:	adds	r6, #16
   10402:	add.w	r3, sl, #24
   10406:	b.n	10366 <_realloc_r+0x2a6>
   10408:	ldr	r3, [r6, #16]
   1040a:	str	r3, [r0, #16]
   1040c:	ldr	r3, [r6, #20]
   1040e:	str	r3, [r0, #20]
   10410:	add.w	r2, r6, #24
   10414:	add.w	r3, r0, #24
   10418:	b.n	1014a <_realloc_r+0x8a>
   1041a:	nop
   1041c:	.word	0x20001288
   10420:	ldr	r1, [r6, #8]
   10422:	str.w	r1, [sl, #16]
   10426:	ldr	r1, [r6, #12]
   10428:	str.w	r1, [sl, #20]
   1042c:	cmp	r2, #36	; 0x24
   1042e:	beq.n	10450 <_realloc_r+0x390>
   10430:	adds	r6, #16
   10432:	add.w	r2, sl, #24
   10436:	b.n	101d0 <_realloc_r+0x110>
   10438:	ldr	r3, [r6, #16]
   1043a:	str.w	r3, [sl, #24]
   1043e:	ldr	r3, [r6, #20]
   10440:	str.w	r3, [sl, #28]
   10444:	adds	r6, #24
   10446:	add.w	r3, sl, #32
   1044a:	b.n	10366 <_realloc_r+0x2a6>
   1044c:	mov	r2, r7
   1044e:	b.n	1031a <_realloc_r+0x25a>
   10450:	ldr	r2, [r6, #16]
   10452:	str.w	r2, [sl, #24]
   10456:	ldr	r2, [r6, #20]
   10458:	str.w	r2, [sl, #28]
   1045c:	adds	r6, #24
   1045e:	add.w	r2, sl, #32
   10462:	b.n	101d0 <_realloc_r+0x110>
   10464:	mov	r1, r6
   10466:	mov	r0, r7
   10468:	str	r3, [sp, #4]
   1046a:	bl	ff54 <memmove>
   1046e:	ldr	r3, [sp, #4]
   10470:	b.n	10326 <_realloc_r+0x266>
   10472:	ldr	r1, [r6, #8]
   10474:	str.w	r1, [sl, #16]
   10478:	ldr	r1, [r6, #12]
   1047a:	str.w	r1, [sl, #20]
   1047e:	cmp	r2, #36	; 0x24
   10480:	beq.n	1048a <_realloc_r+0x3ca>
   10482:	adds	r6, #16
   10484:	add.w	r2, sl, #24
   10488:	b.n	1031a <_realloc_r+0x25a>
   1048a:	ldr	r2, [r6, #16]
   1048c:	str.w	r2, [sl, #24]
   10490:	ldr	r2, [r6, #20]
   10492:	str.w	r2, [sl, #28]
   10496:	adds	r6, #24
   10498:	add.w	r2, sl, #32
   1049c:	b.n	1031a <_realloc_r+0x25a>
   1049e:	nop

000104a0 <_sbrk_r>:
   104a0:	push	{r3, r4, r5, lr}
   104a2:	ldr	r4, [pc, #28]	; (104c0 <_sbrk_r+0x20>)
   104a4:	movs	r3, #0
   104a6:	mov	r5, r0
   104a8:	mov	r0, r1
   104aa:	str	r3, [r4, #0]
   104ac:	bl	d4b0 <_sbrk>
   104b0:	adds	r3, r0, #1
   104b2:	beq.n	104b6 <_sbrk_r+0x16>
   104b4:	pop	{r3, r4, r5, pc}
   104b6:	ldr	r3, [r4, #0]
   104b8:	cmp	r3, #0
   104ba:	beq.n	104b4 <_sbrk_r+0x14>
   104bc:	str	r3, [r5, #0]
   104be:	pop	{r3, r4, r5, pc}
   104c0:	.word	0x200052dc

000104c4 <sprintf>:
   104c4:	push	{r1, r2, r3}
   104c6:	push	{r4, r5, r6, r7, lr}
   104c8:	sub	sp, #112	; 0x70
   104ca:	add	r3, sp, #132	; 0x84
   104cc:	ldr	r1, [pc, #60]	; (1050c <sprintf+0x48>)
   104ce:	ldr.w	r2, [r3], #4
   104d2:	str	r3, [sp, #4]
   104d4:	mov	r5, r0
   104d6:	mvn.w	r4, #2147483648	; 0x80000000
   104da:	ldr	r0, [r1, #0]
   104dc:	str	r5, [sp, #8]
   104de:	mov.w	r7, #520	; 0x208
   104e2:	movw	r6, #65535	; 0xffff
   104e6:	add	r1, sp, #8
   104e8:	str	r5, [sp, #24]
   104ea:	strh.w	r7, [sp, #20]
   104ee:	str	r4, [sp, #16]
   104f0:	str	r4, [sp, #28]
   104f2:	strh.w	r6, [sp, #22]
   104f6:	bl	10800 <_svfprintf_r>
   104fa:	ldr	r3, [sp, #8]
   104fc:	movs	r2, #0
   104fe:	strb	r2, [r3, #0]
   10500:	add	sp, #112	; 0x70
   10502:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   10506:	add	sp, #12
   10508:	bx	lr
   1050a:	nop
   1050c:	.word	0x20001118

00010510 <strcpy>:
   10510:	eor.w	r2, r0, r1
   10514:	mov	ip, r0
   10516:	tst.w	r2, #3
   1051a:	bne.n	105bc <strcpy+0xac>
   1051c:	tst.w	r1, #3
   10520:	bne.n	10588 <strcpy+0x78>
   10522:	str.w	r4, [sp, #-4]!
   10526:	tst.w	r1, #4
   1052a:	ldr.w	r3, [r1], #4
   1052e:	beq.n	10548 <strcpy+0x38>
   10530:	sub.w	r2, r3, #16843009	; 0x1010101
   10534:	bics	r2, r3
   10536:	tst.w	r2, #2155905152	; 0x80808080
   1053a:	itt	eq
   1053c:	streq.w	r3, [ip], #4
   10540:	ldreq.w	r3, [r1], #4
   10544:	bne.n	10574 <strcpy+0x64>
   10546:	nop
   10548:	ldr.w	r4, [r1], #4
   1054c:	sub.w	r2, r3, #16843009	; 0x1010101
   10550:	bics	r2, r3
   10552:	tst.w	r2, #2155905152	; 0x80808080
   10556:	sub.w	r2, r4, #16843009	; 0x1010101
   1055a:	bne.n	10574 <strcpy+0x64>
   1055c:	str.w	r3, [ip], #4
   10560:	bics	r2, r4
   10562:	tst.w	r2, #2155905152	; 0x80808080
   10566:	itt	eq
   10568:	ldreq.w	r3, [r1], #4
   1056c:	streq.w	r4, [ip], #4
   10570:	beq.n	10548 <strcpy+0x38>
   10572:	mov	r3, r4
   10574:	strb.w	r3, [ip], #1
   10578:	tst.w	r3, #255	; 0xff
   1057c:	mov.w	r3, r3, ror #8
   10580:	bne.n	10574 <strcpy+0x64>
   10582:	ldr.w	r4, [sp], #4
   10586:	bx	lr
   10588:	tst.w	r1, #1
   1058c:	beq.n	1059c <strcpy+0x8c>
   1058e:	ldrb.w	r2, [r1], #1
   10592:	strb.w	r2, [ip], #1
   10596:	cmp	r2, #0
   10598:	it	eq
   1059a:	bxeq	lr
   1059c:	tst.w	r1, #2
   105a0:	beq.n	10522 <strcpy+0x12>
   105a2:	ldrh.w	r2, [r1], #2
   105a6:	tst.w	r2, #255	; 0xff
   105aa:	itet	ne
   105ac:	strhne.w	r2, [ip], #2
   105b0:	strbeq.w	r2, [ip]
   105b4:	tstne.w	r2, #65280	; 0xff00
   105b8:	bne.n	10522 <strcpy+0x12>
   105ba:	bx	lr
   105bc:	ldrb.w	r2, [r1], #1
   105c0:	strb.w	r2, [ip], #1
   105c4:	cmp	r2, #0
   105c6:	bne.n	105bc <strcpy+0xac>
   105c8:	bx	lr
   105ca:	nop

000105cc <strlcat>:
   105cc:	push	{r4, r5, r6, lr}
   105ce:	cbz	r2, 1060e <strlcat+0x42>
   105d0:	ldrb	r6, [r0, #0]
   105d2:	cbz	r6, 1061a <strlcat+0x4e>
   105d4:	adds	r3, r0, #1
   105d6:	adds	r6, r0, r2
   105d8:	b.n	105e0 <strlcat+0x14>
   105da:	ldrb	r5, [r3, #0]
   105dc:	adds	r3, #1
   105de:	cbz	r5, 105e6 <strlcat+0x1a>
   105e0:	cmp	r6, r3
   105e2:	mov	r4, r3
   105e4:	bne.n	105da <strlcat+0xe>
   105e6:	subs	r6, r4, r0
   105e8:	subs	r2, r2, r6
   105ea:	beq.n	10610 <strlcat+0x44>
   105ec:	ldrb	r3, [r1, #0]
   105ee:	mov	r5, r1
   105f0:	cbz	r3, 10606 <strlcat+0x3a>
   105f2:	cmp	r2, #1
   105f4:	beq.n	105fc <strlcat+0x30>
   105f6:	strb	r3, [r4, #0]
   105f8:	subs	r2, #1
   105fa:	adds	r4, #1
   105fc:	ldrb.w	r3, [r5, #1]!
   10600:	cmp	r3, #0
   10602:	bne.n	105f2 <strlcat+0x26>
   10604:	subs	r3, r5, r1
   10606:	movs	r2, #0
   10608:	strb	r2, [r4, #0]
   1060a:	adds	r0, r6, r3
   1060c:	pop	{r4, r5, r6, pc}
   1060e:	mov	r6, r2
   10610:	mov	r0, r1
   10612:	bl	10680 <strlen>
   10616:	add	r0, r6
   10618:	pop	{r4, r5, r6, pc}
   1061a:	mov	r4, r0
   1061c:	b.n	105ec <strlcat+0x20>
   1061e:	nop

00010620 <strlcpy>:
   10620:	push	{r4}
   10622:	mov	r3, r1
   10624:	cbz	r2, 1063a <strlcpy+0x1a>
   10626:	b.n	10632 <strlcpy+0x12>
   10628:	ldrb.w	r4, [r3], #1
   1062c:	strb.w	r4, [r0], #1
   10630:	cbz	r4, 10642 <strlcpy+0x22>
   10632:	subs	r2, #1
   10634:	bne.n	10628 <strlcpy+0x8>
   10636:	movs	r2, #0
   10638:	strb	r2, [r0, #0]
   1063a:	ldrb.w	r2, [r3], #1
   1063e:	cmp	r2, #0
   10640:	bne.n	1063a <strlcpy+0x1a>
   10642:	subs	r0, r3, r1
   10644:	subs	r0, #1
   10646:	ldr.w	r4, [sp], #4
   1064a:	bx	lr
	...

00010680 <strlen>:
   10680:	pld	[r0]
   10684:	strd	r4, r5, [sp, #-8]!
   10688:	bic.w	r1, r0, #7
   1068c:	mvn.w	ip, #0
   10690:	ands.w	r4, r0, #7
   10694:	pld	[r1, #32]
   10698:	bne.w	1072e <strlen+0xae>
   1069c:	mov.w	r4, #0
   106a0:	mvn.w	r0, #7
   106a4:	ldrd	r2, r3, [r1]
   106a8:	pld	[r1, #64]	; 0x40
   106ac:	add.w	r0, r0, #8
   106b0:	uadd8	r2, r2, ip
   106b4:	sel	r2, r4, ip
   106b8:	uadd8	r3, r3, ip
   106bc:	sel	r3, r2, ip
   106c0:	cbnz	r3, 10716 <strlen+0x96>
   106c2:	ldrd	r2, r3, [r1, #8]
   106c6:	uadd8	r2, r2, ip
   106ca:	add.w	r0, r0, #8
   106ce:	sel	r2, r4, ip
   106d2:	uadd8	r3, r3, ip
   106d6:	sel	r3, r2, ip
   106da:	cbnz	r3, 10716 <strlen+0x96>
   106dc:	ldrd	r2, r3, [r1, #16]
   106e0:	uadd8	r2, r2, ip
   106e4:	add.w	r0, r0, #8
   106e8:	sel	r2, r4, ip
   106ec:	uadd8	r3, r3, ip
   106f0:	sel	r3, r2, ip
   106f4:	cbnz	r3, 10716 <strlen+0x96>
   106f6:	ldrd	r2, r3, [r1, #24]
   106fa:	add.w	r1, r1, #32
   106fe:	uadd8	r2, r2, ip
   10702:	add.w	r0, r0, #8
   10706:	sel	r2, r4, ip
   1070a:	uadd8	r3, r3, ip
   1070e:	sel	r3, r2, ip
   10712:	cmp	r3, #0
   10714:	beq.n	106a4 <strlen+0x24>
   10716:	cmp	r2, #0
   10718:	itt	eq
   1071a:	addeq	r0, #4
   1071c:	moveq	r2, r3
   1071e:	rev	r2, r2
   10720:	clz	r2, r2
   10724:	ldrd	r4, r5, [sp], #8
   10728:	add.w	r0, r0, r2, lsr #3
   1072c:	bx	lr
   1072e:	ldrd	r2, r3, [r1]
   10732:	and.w	r5, r4, #3
   10736:	rsb	r0, r4, #0
   1073a:	mov.w	r5, r5, lsl #3
   1073e:	tst.w	r4, #4
   10742:	pld	[r1, #64]	; 0x40
   10746:	lsl.w	r5, ip, r5
   1074a:	orn	r2, r2, r5
   1074e:	itt	ne
   10750:	ornne	r3, r3, r5
   10754:	movne	r2, ip
   10756:	mov.w	r4, #0
   1075a:	b.n	106b0 <strlen+0x30>

0001075c <strncmp>:
   1075c:	cmp	r2, #0
   1075e:	beq.n	107e4 <strncmp+0x88>
   10760:	orr.w	r3, r0, r1
   10764:	ands.w	r3, r3, #3
   10768:	push	{r4, r5, r6, r7}
   1076a:	bne.n	107b8 <strncmp+0x5c>
   1076c:	cmp	r2, #3
   1076e:	bls.n	107b8 <strncmp+0x5c>
   10770:	ldr	r4, [r0, #0]
   10772:	ldr	r5, [r1, #0]
   10774:	cmp	r4, r5
   10776:	bne.n	107b8 <strncmp+0x5c>
   10778:	subs	r2, #4
   1077a:	beq.n	107e8 <strncmp+0x8c>
   1077c:	sub.w	r5, r4, #16843009	; 0x1010101
   10780:	bic.w	r4, r5, r4
   10784:	tst.w	r4, #2155905152	; 0x80808080
   10788:	bne.n	107ee <strncmp+0x92>
   1078a:	adds	r7, r0, #4
   1078c:	adds	r5, r1, #4
   1078e:	b.n	107ac <strncmp+0x50>
   10790:	ldr.w	r3, [r7], #4
   10794:	ldr	r6, [r1, #0]
   10796:	sub.w	r4, r3, #16843009	; 0x1010101
   1079a:	cmp	r3, r6
   1079c:	bic.w	r4, r4, r3
   107a0:	bne.n	107b8 <strncmp+0x5c>
   107a2:	subs	r2, #4
   107a4:	beq.n	107e8 <strncmp+0x8c>
   107a6:	tst.w	r4, #2155905152	; 0x80808080
   107aa:	bne.n	107f4 <strncmp+0x98>
   107ac:	cmp	r2, #3
   107ae:	mov	r1, r5
   107b0:	mov	r0, r7
   107b2:	add.w	r5, r5, #4
   107b6:	bhi.n	10790 <strncmp+0x34>
   107b8:	ldrb	r3, [r0, #0]
   107ba:	ldrb	r4, [r1, #0]
   107bc:	cmp	r4, r3
   107be:	add.w	r2, r2, #4294967295
   107c2:	bne.n	107de <strncmp+0x82>
   107c4:	cbz	r2, 107e8 <strncmp+0x8c>
   107c6:	cbnz	r4, 107ce <strncmp+0x72>
   107c8:	b.n	107f8 <strncmp+0x9c>
   107ca:	cbz	r2, 107e8 <strncmp+0x8c>
   107cc:	cbz	r3, 107ee <strncmp+0x92>
   107ce:	ldrb.w	r3, [r0, #1]!
   107d2:	ldrb.w	r4, [r1, #1]!
   107d6:	cmp	r3, r4
   107d8:	add.w	r2, r2, #4294967295
   107dc:	beq.n	107ca <strncmp+0x6e>
   107de:	subs	r0, r3, r4
   107e0:	pop	{r4, r5, r6, r7}
   107e2:	bx	lr
   107e4:	mov	r0, r2
   107e6:	bx	lr
   107e8:	mov	r0, r2
   107ea:	pop	{r4, r5, r6, r7}
   107ec:	bx	lr
   107ee:	mov	r0, r3
   107f0:	pop	{r4, r5, r6, r7}
   107f2:	bx	lr
   107f4:	movs	r0, #0
   107f6:	b.n	107e0 <strncmp+0x84>
   107f8:	mov	r0, r4
   107fa:	b.n	107e0 <strncmp+0x84>
   107fc:	movs	r0, r0
	...

00010800 <_svfprintf_r>:
   10800:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10804:	sub	sp, #260	; 0x104
   10806:	mov	r4, r1
   10808:	str	r1, [sp, #20]
   1080a:	mov	r5, r2
   1080c:	str	r3, [sp, #40]	; 0x28
   1080e:	str	r0, [sp, #24]
   10810:	bl	13300 <_localeconv_r>
   10814:	ldr	r3, [r0, #0]
   10816:	str	r3, [sp, #76]	; 0x4c
   10818:	mov	r0, r3
   1081a:	bl	10680 <strlen>
   1081e:	ldrh	r3, [r4, #12]
   10820:	str	r0, [sp, #72]	; 0x48
   10822:	lsls	r6, r3, #24
   10824:	bpl.n	1082e <_svfprintf_r+0x2e>
   10826:	ldr	r3, [r4, #16]
   10828:	cmp	r3, #0
   1082a:	beq.w	11a90 <_svfprintf_r+0x1290>
   1082e:	vldr	d7, [pc, #664]	; 10ac8 <_svfprintf_r+0x2c8>
   10832:	movs	r3, #0
   10834:	vstr	d7, [sp, #64]	; 0x40
   10838:	str	r3, [sp, #56]	; 0x38
   1083a:	str	r3, [sp, #148]	; 0x94
   1083c:	str	r3, [sp, #144]	; 0x90
   1083e:	str	r3, [sp, #84]	; 0x54
   10840:	str	r3, [sp, #28]
   10842:	ldr.w	sl, [pc, #656]	; 10ad4 <_svfprintf_r+0x2d4>
   10846:	add	r3, sp, #192	; 0xc0
   10848:	str	r3, [sp, #140]	; 0x8c
   1084a:	mov	r9, r3
   1084c:	mov	r8, r5
   1084e:	ldrb.w	r3, [r8]
   10852:	mov	r4, r8
   10854:	cbz	r3, 10892 <_svfprintf_r+0x92>
   10856:	cmp	r3, #37	; 0x25
   10858:	bne.n	10860 <_svfprintf_r+0x60>
   1085a:	b.n	10892 <_svfprintf_r+0x92>
   1085c:	cmp	r3, #37	; 0x25
   1085e:	beq.n	10868 <_svfprintf_r+0x68>
   10860:	ldrb.w	r3, [r4, #1]!
   10864:	cmp	r3, #0
   10866:	bne.n	1085c <_svfprintf_r+0x5c>
   10868:	rsb	r5, r8, r4
   1086c:	cbz	r5, 10892 <_svfprintf_r+0x92>
   1086e:	ldr	r3, [sp, #144]	; 0x90
   10870:	ldr	r2, [sp, #148]	; 0x94
   10872:	str.w	r8, [r9]
   10876:	adds	r3, #1
   10878:	add	r2, r5
   1087a:	cmp	r3, #7
   1087c:	str.w	r5, [r9, #4]
   10880:	str	r2, [sp, #148]	; 0x94
   10882:	str	r3, [sp, #144]	; 0x90
   10884:	bgt.w	109d4 <_svfprintf_r+0x1d4>
   10888:	add.w	r9, r9, #8
   1088c:	ldr	r3, [sp, #28]
   1088e:	add	r3, r5
   10890:	str	r3, [sp, #28]
   10892:	ldrb	r3, [r4, #0]
   10894:	cmp	r3, #0
   10896:	beq.w	109e6 <_svfprintf_r+0x1e6>
   1089a:	movs	r3, #0
   1089c:	mov	r2, r3
   1089e:	strb.w	r3, [sp, #111]	; 0x6f
   108a2:	mov	r1, r3
   108a4:	str	r3, [sp, #32]
   108a6:	str	r3, [sp, #12]
   108a8:	mov.w	fp, #4294967295
   108ac:	ldrb	r3, [r4, #1]
   108ae:	add.w	r8, r4, #1
   108b2:	mov	r5, fp
   108b4:	add.w	r8, r8, #1
   108b8:	sub.w	r0, r3, #32
   108bc:	cmp	r0, #88	; 0x58
   108be:	bhi.w	1112a <_svfprintf_r+0x92a>
   108c2:	tbh	[pc, r0, lsl #1]
   108c6:	.short	0x03a0
   108c8:	.word	0x04320432
   108cc:	.word	0x043203a8
   108d0:	.word	0x04320432
   108d4:	.word	0x04320432
   108d8:	.word	0x03af0432
   108dc:	.word	0x043203bd
   108e0:	.word	0x00e2005d
   108e4:	.word	0x01090432
   108e8:	.word	0x01100110
   108ec:	.word	0x01100110
   108f0:	.word	0x01100110
   108f4:	.word	0x01100110
   108f8:	.word	0x04320110
   108fc:	.word	0x04320432
   10900:	.word	0x04320432
   10904:	.word	0x04320432
   10908:	.word	0x04320432
   1090c:	.word	0x01200432
   10910:	.word	0x04320286
   10914:	.word	0x04320286
   10918:	.word	0x04320432
   1091c:	.word	0x02d40432
   10920:	.word	0x04320432
   10924:	.word	0x043202e5
   10928:	.word	0x04320432
   1092c:	.word	0x04320432
   10930:	.word	0x0432030f
   10934:	.word	0x033d0432
   10938:	.word	0x04320432
   1093c:	.word	0x04320432
   10940:	.word	0x04320432
   10944:	.word	0x04320432
   10948:	.word	0x04320432
   1094c:	.word	0x0391037e
   10950:	.word	0x02860286
   10954:	.word	0x03990286
   10958:	.word	0x04320391
   1095c:	.word	0x04070432
   10960:	.word	0x04120432
   10964:	.word	0x006400a3
   10968:	.word	0x043203c2
   1096c:	.word	0x043203c9
   10970:	.word	0x043203ea
   10974:	.word	0x03f20432
   10978:	ldr	r0, [sp, #32]
   1097a:	str	r3, [sp, #40]	; 0x28
   1097c:	negs	r0, r0
   1097e:	str	r0, [sp, #32]
   10980:	ldr	r3, [sp, #12]
   10982:	orr.w	r3, r3, #4
   10986:	str	r3, [sp, #12]
   10988:	ldrb.w	r3, [r8]
   1098c:	b.n	108b4 <_svfprintf_r+0xb4>
   1098e:	ldr	r0, [sp, #40]	; 0x28
   10990:	mov	fp, r5
   10992:	movs	r1, #0
   10994:	ldr	r4, [r0, #0]
   10996:	strb.w	r1, [sp, #111]	; 0x6f
   1099a:	adds	r7, r0, #4
   1099c:	ldr	r0, [sp, #12]
   1099e:	movs	r3, #48	; 0x30
   109a0:	movs	r2, #120	; 0x78
   109a2:	cmp	fp, r1
   109a4:	strb.w	r3, [sp, #112]	; 0x70
   109a8:	mov.w	r5, #0
   109ac:	strb.w	r2, [sp, #113]	; 0x71
   109b0:	orr.w	r3, r0, #2
   109b4:	blt.w	11164 <_svfprintf_r+0x964>
   109b8:	bic.w	r3, r0, #128	; 0x80
   109bc:	orr.w	r3, r3, #2
   109c0:	str	r3, [sp, #12]
   109c2:	orrs.w	r3, r4, r5
   109c6:	str	r7, [sp, #40]	; 0x28
   109c8:	beq.w	11110 <_svfprintf_r+0x910>
   109cc:	mov	r7, r1
   109ce:	str	r2, [sp, #52]	; 0x34
   109d0:	ldr	r0, [pc, #252]	; (10ad0 <_svfprintf_r+0x2d0>)
   109d2:	b.n	10fa2 <_svfprintf_r+0x7a2>
   109d4:	add	r2, sp, #140	; 0x8c
   109d6:	ldr	r1, [sp, #20]
   109d8:	ldr	r0, [sp, #24]
   109da:	bl	13940 <__ssprint_r>
   109de:	cbnz	r0, 109f4 <_svfprintf_r+0x1f4>
   109e0:	add.w	r9, sp, #192	; 0xc0
   109e4:	b.n	1088c <_svfprintf_r+0x8c>
   109e6:	ldr	r3, [sp, #148]	; 0x94
   109e8:	cbz	r3, 109f4 <_svfprintf_r+0x1f4>
   109ea:	ldr	r0, [sp, #24]
   109ec:	ldr	r1, [sp, #20]
   109ee:	add	r2, sp, #140	; 0x8c
   109f0:	bl	13940 <__ssprint_r>
   109f4:	ldr	r3, [sp, #20]
   109f6:	ldrh	r3, [r3, #12]
   109f8:	tst.w	r3, #64	; 0x40
   109fc:	ldr	r3, [sp, #28]
   109fe:	it	ne
   10a00:	movne.w	r3, #4294967295
   10a04:	mov	r0, r3
   10a06:	add	sp, #260	; 0x104
   10a08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10a0c:	str	r3, [sp, #52]	; 0x34
   10a0e:	mov	fp, r5
   10a10:	cmp	r2, #0
   10a12:	bne.w	11e7c <_svfprintf_r+0x167c>
   10a16:	ldr	r2, [sp, #12]
   10a18:	ands.w	r3, r2, #32
   10a1c:	beq.w	10eac <_svfprintf_r+0x6ac>
   10a20:	ldr	r7, [sp, #40]	; 0x28
   10a22:	adds	r7, #7
   10a24:	bic.w	r3, r7, #7
   10a28:	movs	r7, #0
   10a2a:	add.w	r1, r3, #8
   10a2e:	cmp	fp, r7
   10a30:	str	r1, [sp, #40]	; 0x28
   10a32:	ldrd	r4, r5, [r3]
   10a36:	strb.w	r7, [sp, #111]	; 0x6f
   10a3a:	blt.w	11902 <_svfprintf_r+0x1102>
   10a3e:	bic.w	r3, r2, #128	; 0x80
   10a42:	str	r3, [sp, #12]
   10a44:	orrs.w	r3, r4, r5
   10a48:	beq.w	11154 <_svfprintf_r+0x954>
   10a4c:	add	r6, sp, #192	; 0xc0
   10a4e:	lsrs	r2, r4, #3
   10a50:	orr.w	r2, r2, r5, lsl #29
   10a54:	lsrs	r1, r5, #3
   10a56:	and.w	r3, r4, #7
   10a5a:	mov	r5, r1
   10a5c:	mov	r4, r2
   10a5e:	adds	r3, #48	; 0x30
   10a60:	orrs.w	r2, r4, r5
   10a64:	strb.w	r3, [r6, #-1]!
   10a68:	bne.n	10a4e <_svfprintf_r+0x24e>
   10a6a:	ldr	r2, [sp, #12]
   10a6c:	lsls	r1, r2, #31
   10a6e:	bpl.w	10b90 <_svfprintf_r+0x390>
   10a72:	cmp	r3, #48	; 0x30
   10a74:	beq.w	10b90 <_svfprintf_r+0x390>
   10a78:	movs	r2, #48	; 0x30
   10a7a:	subs	r3, r6, #1
   10a7c:	strb.w	r2, [r6, #-1]
   10a80:	add	r2, sp, #192	; 0xc0
   10a82:	subs	r2, r2, r3
   10a84:	str	r2, [sp, #36]	; 0x24
   10a86:	mov	r6, r3
   10a88:	b.n	10b96 <_svfprintf_r+0x396>
   10a8a:	ldrb.w	r3, [r8]
   10a8e:	cmp	r3, #42	; 0x2a
   10a90:	add.w	r4, r8, #1
   10a94:	beq.w	11e60 <_svfprintf_r+0x1660>
   10a98:	sub.w	r0, r3, #48	; 0x30
   10a9c:	cmp	r0, #9
   10a9e:	it	ls
   10aa0:	movls	r5, #0
   10aa2:	bhi.w	11db2 <_svfprintf_r+0x15b2>
   10aa6:	ldrb.w	r3, [r4], #1
   10aaa:	add.w	r5, r5, r5, lsl #2
   10aae:	add.w	r5, r0, r5, lsl #1
   10ab2:	sub.w	r0, r3, #48	; 0x30
   10ab6:	cmp	r0, #9
   10ab8:	bls.n	10aa6 <_svfprintf_r+0x2a6>
   10aba:	orr.w	r5, r5, r5, asr #31
   10abe:	mov	r8, r4
   10ac0:	b.n	108b8 <_svfprintf_r+0xb8>
   10ac2:	nop
   10ac4:	nop.w
	...
   10ad0:	.word	0x20000920
   10ad4:	.word	0x200008ec
   10ad8:	ldr	r3, [sp, #12]
   10ada:	orr.w	r3, r3, #128	; 0x80
   10ade:	str	r3, [sp, #12]
   10ae0:	ldrb.w	r3, [r8]
   10ae4:	b.n	108b4 <_svfprintf_r+0xb4>
   10ae6:	sub.w	r0, r3, #48	; 0x30
   10aea:	movs	r3, #0
   10aec:	mov	r4, r3
   10aee:	ldrb.w	r3, [r8], #1
   10af2:	add.w	r4, r4, r4, lsl #2
   10af6:	add.w	r4, r0, r4, lsl #1
   10afa:	sub.w	r0, r3, #48	; 0x30
   10afe:	cmp	r0, #9
   10b00:	bls.n	10aee <_svfprintf_r+0x2ee>
   10b02:	str	r4, [sp, #32]
   10b04:	b.n	108b8 <_svfprintf_r+0xb8>
   10b06:	str	r3, [sp, #52]	; 0x34
   10b08:	mov	fp, r5
   10b0a:	cmp	r2, #0
   10b0c:	bne.w	11e98 <_svfprintf_r+0x1698>
   10b10:	ldr	r3, [sp, #12]
   10b12:	orr.w	r3, r3, #16
   10b16:	str	r3, [sp, #12]
   10b18:	ldr	r3, [sp, #12]
   10b1a:	lsls	r4, r3, #26
   10b1c:	bpl.w	1158e <_svfprintf_r+0xd8e>
   10b20:	ldr	r7, [sp, #40]	; 0x28
   10b22:	adds	r7, #7
   10b24:	bic.w	r7, r7, #7
   10b28:	ldrd	r2, r3, [r7]
   10b2c:	add.w	r1, r7, #8
   10b30:	str	r1, [sp, #40]	; 0x28
   10b32:	mov	r4, r2
   10b34:	mov	r5, r3
   10b36:	cmp	r2, #0
   10b38:	sbcs.w	r3, r3, #0
   10b3c:	blt.w	11604 <_svfprintf_r+0xe04>
   10b40:	cmp.w	fp, #0
   10b44:	ldrb.w	r7, [sp, #111]	; 0x6f
   10b48:	blt.w	115ca <_svfprintf_r+0xdca>
   10b4c:	ldr	r3, [sp, #12]
   10b4e:	bic.w	r3, r3, #128	; 0x80
   10b52:	str	r3, [sp, #12]
   10b54:	orrs.w	r3, r4, r5
   10b58:	beq.w	10f2c <_svfprintf_r+0x72c>
   10b5c:	cmp	r5, #0
   10b5e:	it	eq
   10b60:	cmpeq	r4, #10
   10b62:	bcc.w	10f36 <_svfprintf_r+0x736>
   10b66:	add	r6, sp, #192	; 0xc0
   10b68:	mov	r0, r4
   10b6a:	mov	r1, r5
   10b6c:	movs	r2, #10
   10b6e:	movs	r3, #0
   10b70:	bl	f490 <__aeabi_uldivmod>
   10b74:	adds	r2, #48	; 0x30
   10b76:	strb.w	r2, [r6, #-1]!
   10b7a:	mov	r0, r4
   10b7c:	mov	r1, r5
   10b7e:	movs	r3, #0
   10b80:	movs	r2, #10
   10b82:	bl	f490 <__aeabi_uldivmod>
   10b86:	mov	r4, r0
   10b88:	mov	r5, r1
   10b8a:	orrs.w	r3, r4, r5
   10b8e:	bne.n	10b68 <_svfprintf_r+0x368>
   10b90:	add	r3, sp, #192	; 0xc0
   10b92:	subs	r3, r3, r6
   10b94:	str	r3, [sp, #36]	; 0x24
   10b96:	ldr	r3, [sp, #36]	; 0x24
   10b98:	cmp	r3, fp
   10b9a:	it	lt
   10b9c:	movlt	r3, fp
   10b9e:	str	r3, [sp, #16]
   10ba0:	movs	r3, #0
   10ba2:	str	r3, [sp, #60]	; 0x3c
   10ba4:	cbz	r7, 10bac <_svfprintf_r+0x3ac>
   10ba6:	ldr	r3, [sp, #16]
   10ba8:	adds	r3, #1
   10baa:	str	r3, [sp, #16]
   10bac:	ldr	r3, [sp, #12]
   10bae:	ands.w	r3, r3, #2
   10bb2:	str	r3, [sp, #44]	; 0x2c
   10bb4:	beq.n	10bbc <_svfprintf_r+0x3bc>
   10bb6:	ldr	r3, [sp, #16]
   10bb8:	adds	r3, #2
   10bba:	str	r3, [sp, #16]
   10bbc:	ldr	r3, [sp, #12]
   10bbe:	ands.w	r3, r3, #132	; 0x84
   10bc2:	str	r3, [sp, #48]	; 0x30
   10bc4:	bne.w	1117e <_svfprintf_r+0x97e>
   10bc8:	ldr	r3, [sp, #32]
   10bca:	ldr	r2, [sp, #16]
   10bcc:	subs	r5, r3, r2
   10bce:	cmp	r5, #0
   10bd0:	ble.w	1117e <_svfprintf_r+0x97e>
   10bd4:	cmp	r5, #16
   10bd6:	ldr	r1, [sp, #148]	; 0x94
   10bd8:	ldr	r2, [sp, #144]	; 0x90
   10bda:	ldr	r7, [pc, #672]	; (10e7c <_svfprintf_r+0x67c>)
   10bdc:	ble.n	10c2e <_svfprintf_r+0x42e>
   10bde:	str	r6, [sp, #80]	; 0x50
   10be0:	mov	r0, r9
   10be2:	movs	r4, #16
   10be4:	mov	r9, r7
   10be6:	ldr	r6, [sp, #20]
   10be8:	mov	r7, r5
   10bea:	ldr	r5, [sp, #24]
   10bec:	b.n	10bf8 <_svfprintf_r+0x3f8>
   10bee:	subs	r7, #16
   10bf0:	cmp	r7, #16
   10bf2:	add.w	r0, r0, #8
   10bf6:	ble.n	10c26 <_svfprintf_r+0x426>
   10bf8:	adds	r2, #1
   10bfa:	ldr	r3, [pc, #640]	; (10e7c <_svfprintf_r+0x67c>)
   10bfc:	str	r2, [sp, #144]	; 0x90
   10bfe:	adds	r1, #16
   10c00:	cmp	r2, #7
   10c02:	str	r1, [sp, #148]	; 0x94
   10c04:	stmia.w	r0, {r3, r4}
   10c08:	ble.n	10bee <_svfprintf_r+0x3ee>
   10c0a:	add	r2, sp, #140	; 0x8c
   10c0c:	mov	r1, r6
   10c0e:	mov	r0, r5
   10c10:	bl	13940 <__ssprint_r>
   10c14:	cmp	r0, #0
   10c16:	bne.w	109f4 <_svfprintf_r+0x1f4>
   10c1a:	subs	r7, #16
   10c1c:	cmp	r7, #16
   10c1e:	ldr	r1, [sp, #148]	; 0x94
   10c20:	ldr	r2, [sp, #144]	; 0x90
   10c22:	add	r0, sp, #192	; 0xc0
   10c24:	bgt.n	10bf8 <_svfprintf_r+0x3f8>
   10c26:	ldr	r6, [sp, #80]	; 0x50
   10c28:	mov	r5, r7
   10c2a:	mov	r7, r9
   10c2c:	mov	r9, r0
   10c2e:	adds	r2, #1
   10c30:	adds	r4, r5, r1
   10c32:	cmp	r2, #7
   10c34:	str	r4, [sp, #148]	; 0x94
   10c36:	str	r2, [sp, #144]	; 0x90
   10c38:	str.w	r7, [r9]
   10c3c:	str.w	r5, [r9, #4]
   10c40:	bgt.w	1149e <_svfprintf_r+0xc9e>
   10c44:	ldrb.w	r7, [sp, #111]	; 0x6f
   10c48:	add.w	r9, r9, #8
   10c4c:	cbz	r7, 10c6c <_svfprintf_r+0x46c>
   10c4e:	ldr	r3, [sp, #144]	; 0x90
   10c50:	adds	r3, #1
   10c52:	adds	r4, #1
   10c54:	add.w	r1, sp, #111	; 0x6f
   10c58:	movs	r2, #1
   10c5a:	cmp	r3, #7
   10c5c:	str	r4, [sp, #148]	; 0x94
   10c5e:	str	r3, [sp, #144]	; 0x90
   10c60:	stmia.w	r9, {r1, r2}
   10c64:	bgt.w	113b2 <_svfprintf_r+0xbb2>
   10c68:	add.w	r9, r9, #8
   10c6c:	ldr	r3, [sp, #44]	; 0x2c
   10c6e:	cbz	r3, 10c8c <_svfprintf_r+0x48c>
   10c70:	ldr	r3, [sp, #144]	; 0x90
   10c72:	adds	r3, #1
   10c74:	adds	r4, #2
   10c76:	add	r1, sp, #112	; 0x70
   10c78:	movs	r2, #2
   10c7a:	cmp	r3, #7
   10c7c:	str	r4, [sp, #148]	; 0x94
   10c7e:	str	r3, [sp, #144]	; 0x90
   10c80:	stmia.w	r9, {r1, r2}
   10c84:	bgt.w	113ca <_svfprintf_r+0xbca>
   10c88:	add.w	r9, r9, #8
   10c8c:	ldr	r3, [sp, #48]	; 0x30
   10c8e:	cmp	r3, #128	; 0x80
   10c90:	beq.w	11256 <_svfprintf_r+0xa56>
   10c94:	ldr	r3, [sp, #36]	; 0x24
   10c96:	rsb	r7, r3, fp
   10c9a:	cmp	r7, #0
   10c9c:	ble.n	10d06 <_svfprintf_r+0x506>
   10c9e:	ldr	r2, [pc, #480]	; (10e80 <_svfprintf_r+0x680>)
   10ca0:	ldr	r3, [sp, #144]	; 0x90
   10ca2:	str	r2, [sp, #44]	; 0x2c
   10ca4:	cmp	r7, #16
   10ca6:	ble.n	10cee <_svfprintf_r+0x4ee>
   10ca8:	mov	r2, r4
   10caa:	mov.w	fp, #16
   10cae:	ldr	r5, [sp, #24]
   10cb0:	ldr	r4, [sp, #20]
   10cb2:	b.n	10cbe <_svfprintf_r+0x4be>
   10cb4:	subs	r7, #16
   10cb6:	cmp	r7, #16
   10cb8:	add.w	r9, r9, #8
   10cbc:	ble.n	10cec <_svfprintf_r+0x4ec>
   10cbe:	adds	r3, #1
   10cc0:	adds	r2, #16
   10cc2:	cmp	r3, #7
   10cc4:	str	r2, [sp, #148]	; 0x94
   10cc6:	str	r3, [sp, #144]	; 0x90
   10cc8:	stmia.w	r9, {sl, fp}
   10ccc:	ble.n	10cb4 <_svfprintf_r+0x4b4>
   10cce:	add	r2, sp, #140	; 0x8c
   10cd0:	mov	r1, r4
   10cd2:	mov	r0, r5
   10cd4:	bl	13940 <__ssprint_r>
   10cd8:	cmp	r0, #0
   10cda:	bne.w	109f4 <_svfprintf_r+0x1f4>
   10cde:	subs	r7, #16
   10ce0:	cmp	r7, #16
   10ce2:	ldr	r2, [sp, #148]	; 0x94
   10ce4:	ldr	r3, [sp, #144]	; 0x90
   10ce6:	add.w	r9, sp, #192	; 0xc0
   10cea:	bgt.n	10cbe <_svfprintf_r+0x4be>
   10cec:	mov	r4, r2
   10cee:	adds	r3, #1
   10cf0:	ldr	r2, [sp, #44]	; 0x2c
   10cf2:	str	r3, [sp, #144]	; 0x90
   10cf4:	add	r4, r7
   10cf6:	cmp	r3, #7
   10cf8:	str	r4, [sp, #148]	; 0x94
   10cfa:	stmia.w	r9, {r2, r7}
   10cfe:	bgt.w	1139a <_svfprintf_r+0xb9a>
   10d02:	add.w	r9, r9, #8
   10d06:	ldr	r3, [sp, #12]
   10d08:	lsls	r2, r3, #23
   10d0a:	bmi.w	11182 <_svfprintf_r+0x982>
   10d0e:	ldr	r3, [sp, #144]	; 0x90
   10d10:	ldr	r1, [sp, #36]	; 0x24
   10d12:	str.w	r6, [r9]
   10d16:	adds	r3, #1
   10d18:	add	r4, r1
   10d1a:	cmp	r3, #7
   10d1c:	str	r4, [sp, #148]	; 0x94
   10d1e:	str.w	r1, [r9, #4]
   10d22:	str	r3, [sp, #144]	; 0x90
   10d24:	bgt.w	1136e <_svfprintf_r+0xb6e>
   10d28:	add.w	r9, r9, #8
   10d2c:	ldr	r3, [sp, #12]
   10d2e:	lsls	r1, r3, #29
   10d30:	bpl.n	10db2 <_svfprintf_r+0x5b2>
   10d32:	ldr	r3, [sp, #32]
   10d34:	ldr	r2, [sp, #16]
   10d36:	subs	r5, r3, r2
   10d38:	cmp	r5, #0
   10d3a:	ble.n	10db2 <_svfprintf_r+0x5b2>
   10d3c:	cmp	r5, #16
   10d3e:	ldr	r3, [sp, #144]	; 0x90
   10d40:	ldr	r7, [pc, #312]	; (10e7c <_svfprintf_r+0x67c>)
   10d42:	ble.n	10d8c <_svfprintf_r+0x58c>
   10d44:	mov	r2, r4
   10d46:	movs	r6, #16
   10d48:	ldr.w	fp, [sp, #24]
   10d4c:	ldr	r4, [sp, #20]
   10d4e:	b.n	10d5a <_svfprintf_r+0x55a>
   10d50:	subs	r5, #16
   10d52:	cmp	r5, #16
   10d54:	add.w	r9, r9, #8
   10d58:	ble.n	10d8a <_svfprintf_r+0x58a>
   10d5a:	adds	r3, #1
   10d5c:	ldr	r1, [pc, #284]	; (10e7c <_svfprintf_r+0x67c>)
   10d5e:	str	r3, [sp, #144]	; 0x90
   10d60:	adds	r2, #16
   10d62:	cmp	r3, #7
   10d64:	str	r2, [sp, #148]	; 0x94
   10d66:	stmia.w	r9, {r1, r6}
   10d6a:	ble.n	10d50 <_svfprintf_r+0x550>
   10d6c:	add	r2, sp, #140	; 0x8c
   10d6e:	mov	r1, r4
   10d70:	mov	r0, fp
   10d72:	bl	13940 <__ssprint_r>
   10d76:	cmp	r0, #0
   10d78:	bne.w	109f4 <_svfprintf_r+0x1f4>
   10d7c:	subs	r5, #16
   10d7e:	cmp	r5, #16
   10d80:	ldr	r2, [sp, #148]	; 0x94
   10d82:	ldr	r3, [sp, #144]	; 0x90
   10d84:	add.w	r9, sp, #192	; 0xc0
   10d88:	bgt.n	10d5a <_svfprintf_r+0x55a>
   10d8a:	mov	r4, r2
   10d8c:	adds	r3, #1
   10d8e:	add	r4, r5
   10d90:	cmp	r3, #7
   10d92:	str	r4, [sp, #148]	; 0x94
   10d94:	str	r3, [sp, #144]	; 0x90
   10d96:	str.w	r7, [r9]
   10d9a:	str.w	r5, [r9, #4]
   10d9e:	ble.n	10db2 <_svfprintf_r+0x5b2>
   10da0:	add	r2, sp, #140	; 0x8c
   10da2:	ldr	r1, [sp, #20]
   10da4:	ldr	r0, [sp, #24]
   10da6:	bl	13940 <__ssprint_r>
   10daa:	cmp	r0, #0
   10dac:	bne.w	109f4 <_svfprintf_r+0x1f4>
   10db0:	ldr	r4, [sp, #148]	; 0x94
   10db2:	ldr	r3, [sp, #28]
   10db4:	ldr	r2, [sp, #32]
   10db6:	ldr	r1, [sp, #16]
   10db8:	cmp	r2, r1
   10dba:	ite	ge
   10dbc:	addge	r3, r3, r2
   10dbe:	addlt	r3, r3, r1
   10dc0:	str	r3, [sp, #28]
   10dc2:	cmp	r4, #0
   10dc4:	bne.w	11386 <_svfprintf_r+0xb86>
   10dc8:	movs	r3, #0
   10dca:	str	r3, [sp, #144]	; 0x90
   10dcc:	add.w	r9, sp, #192	; 0xc0
   10dd0:	b.n	1084e <_svfprintf_r+0x4e>
   10dd2:	str	r3, [sp, #52]	; 0x34
   10dd4:	mov	fp, r5
   10dd6:	cmp	r2, #0
   10dd8:	bne.w	11ea0 <_svfprintf_r+0x16a0>
   10ddc:	ldr	r3, [sp, #12]
   10dde:	ldr	r7, [sp, #40]	; 0x28
   10de0:	lsls	r2, r3, #28
   10de2:	add.w	r7, r7, #7
   10de6:	bpl.w	118d2 <_svfprintf_r+0x10d2>
   10dea:	bic.w	r3, r7, #7
   10dee:	vldr	d7, [r3]
   10df2:	vstr	d7, [sp, #64]	; 0x40
   10df6:	add.w	r2, r3, #8
   10dfa:	str	r2, [sp, #40]	; 0x28
   10dfc:	ldrd	r1, r2, [sp, #64]	; 0x40
   10e00:	bic.w	r3, r2, #2147483648	; 0x80000000
   10e04:	str	r1, [sp, #88]	; 0x58
   10e06:	str	r3, [sp, #92]	; 0x5c
   10e08:	ldrd	r4, r5, [sp, #88]	; 0x58
   10e0c:	mov.w	r2, #4294967295
   10e10:	mov	r0, r4
   10e12:	mov	r1, r5
   10e14:	ldr	r3, [pc, #108]	; (10e84 <_svfprintf_r+0x684>)
   10e16:	bl	f414 <__aeabi_dcmpun>
   10e1a:	cmp	r0, #0
   10e1c:	bne.w	117d4 <_svfprintf_r+0xfd4>
   10e20:	mov.w	r2, #4294967295
   10e24:	ldr	r3, [pc, #92]	; (10e84 <_svfprintf_r+0x684>)
   10e26:	mov	r0, r4
   10e28:	mov	r1, r5
   10e2a:	bl	f3d8 <__aeabi_dcmple>
   10e2e:	cmp	r0, #0
   10e30:	bne.w	117d4 <_svfprintf_r+0xfd4>
   10e34:	movs	r2, #0
   10e36:	movs	r3, #0
   10e38:	ldrd	r0, r1, [sp, #64]	; 0x40
   10e3c:	bl	f3c4 <__aeabi_dcmplt>
   10e40:	cmp	r0, #0
   10e42:	bne.w	11cea <_svfprintf_r+0x14ea>
   10e46:	ldrb.w	r7, [sp, #111]	; 0x6f
   10e4a:	ldr	r6, [pc, #60]	; (10e88 <_svfprintf_r+0x688>)
   10e4c:	ldr	r3, [pc, #60]	; (10e8c <_svfprintf_r+0x68c>)
   10e4e:	ldr	r1, [sp, #12]
   10e50:	bic.w	r1, r1, #128	; 0x80
   10e54:	str	r1, [sp, #12]
   10e56:	ldr	r1, [sp, #52]	; 0x34
   10e58:	movs	r2, #3
   10e5a:	mov.w	fp, #0
   10e5e:	str	r2, [sp, #16]
   10e60:	cmp	r1, #71	; 0x47
   10e62:	it	le
   10e64:	movle	r6, r3
   10e66:	str	r2, [sp, #36]	; 0x24
   10e68:	str.w	fp, [sp, #60]	; 0x3c
   10e6c:	b.n	10ba4 <_svfprintf_r+0x3a4>
   10e6e:	ldr	r3, [sp, #12]
   10e70:	orr.w	r3, r3, #8
   10e74:	str	r3, [sp, #12]
   10e76:	ldrb.w	r3, [r8]
   10e7a:	b.n	108b4 <_svfprintf_r+0xb4>
   10e7c:	.word	0x2000093c
   10e80:	.word	0x200008ec
   10e84:	.word	0x7fefffff
   10e88:	.word	0x20000900
   10e8c:	.word	0x200008fc
   10e90:	str	r3, [sp, #52]	; 0x34
   10e92:	mov	fp, r5
   10e94:	cmp	r2, #0
   10e96:	bne.w	11eb8 <_svfprintf_r+0x16b8>
   10e9a:	ldr	r3, [sp, #12]
   10e9c:	orr.w	r3, r3, #16
   10ea0:	str	r3, [sp, #12]
   10ea2:	ldr	r2, [sp, #12]
   10ea4:	ands.w	r3, r2, #32
   10ea8:	bne.w	10a20 <_svfprintf_r+0x220>
   10eac:	ldr	r1, [sp, #12]
   10eae:	ands.w	r2, r1, #16
   10eb2:	beq.w	1176c <_svfprintf_r+0xf6c>
   10eb6:	ldr	r0, [sp, #40]	; 0x28
   10eb8:	strb.w	r3, [sp, #111]	; 0x6f
   10ebc:	cmp.w	fp, #0
   10ec0:	ldr	r4, [r0, #0]
   10ec2:	add.w	r7, r0, #4
   10ec6:	mov.w	r5, #0
   10eca:	blt.w	11900 <_svfprintf_r+0x1100>
   10ece:	mov	r2, r1
   10ed0:	bic.w	r2, r2, #128	; 0x80
   10ed4:	str	r2, [sp, #12]
   10ed6:	orrs.w	r2, r4, r5
   10eda:	str	r7, [sp, #40]	; 0x28
   10edc:	beq.w	11154 <_svfprintf_r+0x954>
   10ee0:	mov	r7, r3
   10ee2:	b.n	10a4c <_svfprintf_r+0x24c>
   10ee4:	str	r3, [sp, #52]	; 0x34
   10ee6:	mov	fp, r5
   10ee8:	cmp	r2, #0
   10eea:	bne.w	11eb0 <_svfprintf_r+0x16b0>
   10eee:	ldr	r3, [sp, #12]
   10ef0:	orr.w	r3, r3, #16
   10ef4:	str	r3, [sp, #12]
   10ef6:	ldr	r2, [sp, #12]
   10ef8:	ands.w	r3, r2, #32
   10efc:	beq.w	11558 <_svfprintf_r+0xd58>
   10f00:	ldr	r7, [sp, #40]	; 0x28
   10f02:	adds	r7, #7
   10f04:	bic.w	r3, r7, #7
   10f08:	movs	r7, #0
   10f0a:	add.w	r1, r3, #8
   10f0e:	cmp	fp, r7
   10f10:	str	r1, [sp, #40]	; 0x28
   10f12:	ldrd	r4, r5, [r3]
   10f16:	strb.w	r7, [sp, #111]	; 0x6f
   10f1a:	blt.w	115ca <_svfprintf_r+0xdca>
   10f1e:	bic.w	r3, r2, #128	; 0x80
   10f22:	str	r3, [sp, #12]
   10f24:	orrs.w	r3, r4, r5
   10f28:	bne.w	10b5c <_svfprintf_r+0x35c>
   10f2c:	cmp.w	fp, #0
   10f30:	beq.w	1111e <_svfprintf_r+0x91e>
   10f34:	movs	r4, #0
   10f36:	add	r6, sp, #256	; 0x100
   10f38:	adds	r4, #48	; 0x30
   10f3a:	strb.w	r4, [r6, #-65]!
   10f3e:	b.n	10b90 <_svfprintf_r+0x390>
   10f40:	str	r3, [sp, #52]	; 0x34
   10f42:	mov	fp, r5
   10f44:	cmp	r2, #0
   10f46:	bne.w	11ea8 <_svfprintf_r+0x16a8>
   10f4a:	ldr	r3, [sp, #12]
   10f4c:	ldr	r0, [pc, #700]	; (1120c <_svfprintf_r+0xa0c>)
   10f4e:	lsls	r5, r3, #26
   10f50:	bpl.w	110be <_svfprintf_r+0x8be>
   10f54:	ldr	r7, [sp, #40]	; 0x28
   10f56:	adds	r7, #7
   10f58:	bic.w	r3, r7, #7
   10f5c:	ldrd	r4, r5, [r3]
   10f60:	add.w	r2, r3, #8
   10f64:	str	r2, [sp, #40]	; 0x28
   10f66:	ldr	r2, [sp, #12]
   10f68:	ands.w	r7, r2, #1
   10f6c:	beq.w	113e2 <_svfprintf_r+0xbe2>
   10f70:	orrs.w	r3, r4, r5
   10f74:	beq.w	1197c <_svfprintf_r+0x117c>
   10f78:	ldrb.w	r2, [sp, #52]	; 0x34
   10f7c:	strb.w	r2, [sp, #113]	; 0x71
   10f80:	movs	r7, #0
   10f82:	ldr	r2, [sp, #12]
   10f84:	strb.w	r7, [sp, #111]	; 0x6f
   10f88:	movs	r3, #48	; 0x30
   10f8a:	cmp	fp, r7
   10f8c:	strb.w	r3, [sp, #112]	; 0x70
   10f90:	orr.w	r3, r2, #2
   10f94:	blt.w	11cf4 <_svfprintf_r+0x14f4>
   10f98:	bic.w	r3, r2, #128	; 0x80
   10f9c:	orr.w	r3, r3, #2
   10fa0:	str	r3, [sp, #12]
   10fa2:	add	r6, sp, #192	; 0xc0
   10fa4:	lsrs	r3, r4, #4
   10fa6:	and.w	r1, r4, #15
   10faa:	orr.w	r3, r3, r5, lsl #28
   10fae:	lsrs	r2, r5, #4
   10fb0:	mov	r4, r3
   10fb2:	mov	r5, r2
   10fb4:	ldrb	r3, [r0, r1]
   10fb6:	strb.w	r3, [r6, #-1]!
   10fba:	orrs.w	r3, r4, r5
   10fbe:	bne.n	10fa4 <_svfprintf_r+0x7a4>
   10fc0:	b.n	10b90 <_svfprintf_r+0x390>
   10fc2:	ldr	r1, [sp, #40]	; 0x28
   10fc4:	str	r3, [sp, #52]	; 0x34
   10fc6:	ldr	r2, [r1, #0]
   10fc8:	strb.w	r2, [sp, #152]	; 0x98
   10fcc:	movs	r3, #0
   10fce:	mov	r2, r1
   10fd0:	mov	r7, r3
   10fd2:	strb.w	r3, [sp, #111]	; 0x6f
   10fd6:	adds	r2, #4
   10fd8:	movs	r3, #1
   10fda:	str	r3, [sp, #16]
   10fdc:	mov	fp, r7
   10fde:	str	r7, [sp, #60]	; 0x3c
   10fe0:	str	r2, [sp, #40]	; 0x28
   10fe2:	str	r3, [sp, #36]	; 0x24
   10fe4:	add	r6, sp, #152	; 0x98
   10fe6:	b.n	10bac <_svfprintf_r+0x3ac>
   10fe8:	str	r3, [sp, #52]	; 0x34
   10fea:	mov	fp, r5
   10fec:	cmp	r2, #0
   10fee:	beq.w	10b18 <_svfprintf_r+0x318>
   10ff2:	strb.w	r1, [sp, #111]	; 0x6f
   10ff6:	b.n	10b18 <_svfprintf_r+0x318>
   10ff8:	ldr	r3, [sp, #12]
   10ffa:	orr.w	r3, r3, #64	; 0x40
   10ffe:	str	r3, [sp, #12]
   11000:	ldrb.w	r3, [r8]
   11004:	b.n	108b4 <_svfprintf_r+0xb4>
   11006:	ldrb.w	r3, [r8]
   1100a:	cmp	r1, #0
   1100c:	bne.w	108b4 <_svfprintf_r+0xb4>
   11010:	movs	r2, #1
   11012:	movs	r1, #32
   11014:	b.n	108b4 <_svfprintf_r+0xb4>
   11016:	ldr	r3, [sp, #12]
   11018:	orr.w	r3, r3, #1
   1101c:	str	r3, [sp, #12]
   1101e:	ldrb.w	r3, [r8]
   11022:	b.n	108b4 <_svfprintf_r+0xb4>
   11024:	ldr	r4, [sp, #40]	; 0x28
   11026:	ldr	r3, [r4, #0]
   11028:	str	r3, [sp, #32]
   1102a:	mov	r0, r3
   1102c:	cmp	r0, #0
   1102e:	mov	r3, r4
   11030:	add.w	r3, r3, #4
   11034:	blt.w	10978 <_svfprintf_r+0x178>
   11038:	str	r3, [sp, #40]	; 0x28
   1103a:	ldrb.w	r3, [r8]
   1103e:	b.n	108b4 <_svfprintf_r+0xb4>
   11040:	ldrb.w	r3, [r8]
   11044:	movs	r2, #1
   11046:	movs	r1, #43	; 0x2b
   11048:	b.n	108b4 <_svfprintf_r+0xb4>
   1104a:	ldr	r3, [sp, #12]
   1104c:	orr.w	r3, r3, #32
   11050:	str	r3, [sp, #12]
   11052:	ldrb.w	r3, [r8]
   11056:	b.n	108b4 <_svfprintf_r+0xb4>
   11058:	ldr	r2, [sp, #40]	; 0x28
   1105a:	str	r3, [sp, #52]	; 0x34
   1105c:	ldr	r6, [r2, #0]
   1105e:	movs	r4, #0
   11060:	strb.w	r4, [sp, #111]	; 0x6f
   11064:	adds	r7, r2, #4
   11066:	cmp	r6, #0
   11068:	beq.w	11ca4 <_svfprintf_r+0x14a4>
   1106c:	cmp	r5, #0
   1106e:	blt.w	11b34 <_svfprintf_r+0x1334>
   11072:	mov	r2, r5
   11074:	mov	r1, r4
   11076:	mov	r0, r6
   11078:	bl	fe50 <memchr>
   1107c:	cmp	r0, #0
   1107e:	beq.w	11d48 <_svfprintf_r+0x1548>
   11082:	subs	r3, r0, r6
   11084:	str	r3, [sp, #36]	; 0x24
   11086:	mov	fp, r4
   11088:	bic.w	r3, r3, r3, asr #31
   1108c:	str	r7, [sp, #40]	; 0x28
   1108e:	str	r3, [sp, #16]
   11090:	str.w	fp, [sp, #60]	; 0x3c
   11094:	ldrb.w	r7, [sp, #111]	; 0x6f
   11098:	b.n	10ba4 <_svfprintf_r+0x3a4>
   1109a:	str	r3, [sp, #52]	; 0x34
   1109c:	mov	fp, r5
   1109e:	cmp	r2, #0
   110a0:	beq.w	10ef6 <_svfprintf_r+0x6f6>
   110a4:	strb.w	r1, [sp, #111]	; 0x6f
   110a8:	b.n	10ef6 <_svfprintf_r+0x6f6>
   110aa:	str	r3, [sp, #52]	; 0x34
   110ac:	mov	fp, r5
   110ae:	cmp	r2, #0
   110b0:	bne.w	11ed0 <_svfprintf_r+0x16d0>
   110b4:	ldr	r3, [sp, #12]
   110b6:	ldr	r0, [pc, #344]	; (11210 <_svfprintf_r+0xa10>)
   110b8:	lsls	r5, r3, #26
   110ba:	bmi.w	10f54 <_svfprintf_r+0x754>
   110be:	ldr	r3, [sp, #12]
   110c0:	lsls	r4, r3, #27
   110c2:	bpl.w	11942 <_svfprintf_r+0x1142>
   110c6:	ldr	r2, [sp, #40]	; 0x28
   110c8:	mov	r3, r2
   110ca:	adds	r3, #4
   110cc:	ldr	r4, [r2, #0]
   110ce:	str	r3, [sp, #40]	; 0x28
   110d0:	movs	r5, #0
   110d2:	b.n	10f66 <_svfprintf_r+0x766>
   110d4:	ldrb.w	r3, [r8]
   110d8:	cmp	r3, #108	; 0x6c
   110da:	beq.w	11a62 <_svfprintf_r+0x1262>
   110de:	ldr	r0, [sp, #12]
   110e0:	orr.w	r0, r0, #16
   110e4:	str	r0, [sp, #12]
   110e6:	b.w	108b4 <_svfprintf_r+0xb4>
   110ea:	cmp	r2, #0
   110ec:	bne.w	11ec8 <_svfprintf_r+0x16c8>
   110f0:	ldr	r3, [sp, #12]
   110f2:	lsls	r3, r3, #26
   110f4:	bpl.w	117a6 <_svfprintf_r+0xfa6>
   110f8:	ldr	r2, [sp, #40]	; 0x28
   110fa:	ldr	r1, [sp, #28]
   110fc:	ldr	r3, [r2, #0]
   110fe:	asrs	r5, r1, #31
   11100:	mov	r0, r1
   11102:	adds	r2, #4
   11104:	mov	r1, r5
   11106:	str	r2, [sp, #40]	; 0x28
   11108:	strd	r0, r1, [r3]
   1110c:	b.w	1084e <_svfprintf_r+0x4e>
   11110:	ldr	r0, [pc, #252]	; (11210 <_svfprintf_r+0xa10>)
   11112:	str	r2, [sp, #52]	; 0x34
   11114:	cmp.w	fp, #0
   11118:	bne.w	11404 <_svfprintf_r+0xc04>
   1111c:	mov	r7, fp
   1111e:	mov.w	fp, #0
   11122:	str.w	fp, [sp, #36]	; 0x24
   11126:	add	r6, sp, #192	; 0xc0
   11128:	b.n	10b96 <_svfprintf_r+0x396>
   1112a:	str	r3, [sp, #52]	; 0x34
   1112c:	cmp	r2, #0
   1112e:	bne.w	11ec0 <_svfprintf_r+0x16c0>
   11132:	ldr	r2, [sp, #52]	; 0x34
   11134:	cmp	r2, #0
   11136:	beq.w	109e6 <_svfprintf_r+0x1e6>
   1113a:	movs	r3, #0
   1113c:	movs	r1, #1
   1113e:	mov	r7, r3
   11140:	str	r1, [sp, #16]
   11142:	strb.w	r2, [sp, #152]	; 0x98
   11146:	strb.w	r3, [sp, #111]	; 0x6f
   1114a:	mov	fp, r3
   1114c:	str	r3, [sp, #60]	; 0x3c
   1114e:	str	r1, [sp, #36]	; 0x24
   11150:	add	r6, sp, #152	; 0x98
   11152:	b.n	10bac <_svfprintf_r+0x3ac>
   11154:	cmp.w	fp, #0
   11158:	beq.w	11d78 <_svfprintf_r+0x1578>
   1115c:	movs	r7, #0
   1115e:	movs	r4, #0
   11160:	movs	r5, #0
   11162:	b.n	10a4c <_svfprintf_r+0x24c>
   11164:	ldr	r0, [pc, #168]	; (11210 <_svfprintf_r+0xa10>)
   11166:	str	r3, [sp, #12]
   11168:	str	r2, [sp, #52]	; 0x34
   1116a:	orrs.w	r3, r4, r5
   1116e:	str	r7, [sp, #40]	; 0x28
   11170:	mov.w	r7, #0
   11174:	bne.w	10fa2 <_svfprintf_r+0x7a2>
   11178:	movs	r4, #0
   1117a:	movs	r5, #0
   1117c:	b.n	10fa2 <_svfprintf_r+0x7a2>
   1117e:	ldr	r4, [sp, #148]	; 0x94
   11180:	b.n	10c4c <_svfprintf_r+0x44c>
   11182:	ldr	r3, [sp, #52]	; 0x34
   11184:	cmp	r3, #101	; 0x65
   11186:	ble.w	112de <_svfprintf_r+0xade>
   1118a:	movs	r2, #0
   1118c:	movs	r3, #0
   1118e:	ldrd	r0, r1, [sp, #64]	; 0x40
   11192:	bl	f3b0 <__aeabi_dcmpeq>
   11196:	cmp	r0, #0
   11198:	beq.w	11408 <_svfprintf_r+0xc08>
   1119c:	ldr	r3, [sp, #144]	; 0x90
   1119e:	ldr	r2, [pc, #116]	; (11214 <_svfprintf_r+0xa14>)
   111a0:	str.w	r2, [r9]
   111a4:	adds	r3, #1
   111a6:	adds	r4, #1
   111a8:	movs	r2, #1
   111aa:	cmp	r3, #7
   111ac:	str	r4, [sp, #148]	; 0x94
   111ae:	str	r3, [sp, #144]	; 0x90
   111b0:	str.w	r2, [r9, #4]
   111b4:	bgt.w	11994 <_svfprintf_r+0x1194>
   111b8:	add.w	r9, r9, #8
   111bc:	ldr	r3, [sp, #116]	; 0x74
   111be:	ldr	r2, [sp, #56]	; 0x38
   111c0:	cmp	r3, r2
   111c2:	blt.n	111cc <_svfprintf_r+0x9cc>
   111c4:	ldr	r3, [sp, #12]
   111c6:	lsls	r3, r3, #31
   111c8:	bpl.w	10d2c <_svfprintf_r+0x52c>
   111cc:	ldr	r3, [sp, #144]	; 0x90
   111ce:	ldr	r1, [sp, #72]	; 0x48
   111d0:	ldr	r2, [sp, #76]	; 0x4c
   111d2:	str.w	r2, [r9]
   111d6:	adds	r3, #1
   111d8:	add	r4, r1
   111da:	cmp	r3, #7
   111dc:	str	r4, [sp, #148]	; 0x94
   111de:	str.w	r1, [r9, #4]
   111e2:	str	r3, [sp, #144]	; 0x90
   111e4:	bgt.w	11a76 <_svfprintf_r+0x1276>
   111e8:	add.w	r9, r9, #8
   111ec:	ldr	r3, [sp, #56]	; 0x38
   111ee:	subs	r5, r3, #1
   111f0:	cmp	r5, #0
   111f2:	ble.w	10d2c <_svfprintf_r+0x52c>
   111f6:	ldr	r2, [pc, #32]	; (11218 <_svfprintf_r+0xa18>)
   111f8:	ldr	r3, [sp, #144]	; 0x90
   111fa:	str	r2, [sp, #44]	; 0x2c
   111fc:	cmp	r5, #16
   111fe:	ble.w	115d4 <_svfprintf_r+0xdd4>
   11202:	movs	r6, #16
   11204:	ldr	r7, [sp, #24]
   11206:	ldr.w	fp, [sp, #20]
   1120a:	b.n	11228 <_svfprintf_r+0xa28>
   1120c:	.word	0x2000090c
   11210:	.word	0x20000920
   11214:	.word	0x200006a4
   11218:	.word	0x200008ec
   1121c:	add.w	r9, r9, #8
   11220:	subs	r5, #16
   11222:	cmp	r5, #16
   11224:	ble.w	115d4 <_svfprintf_r+0xdd4>
   11228:	adds	r3, #1
   1122a:	adds	r4, #16
   1122c:	cmp	r3, #7
   1122e:	str	r4, [sp, #148]	; 0x94
   11230:	str	r3, [sp, #144]	; 0x90
   11232:	str.w	sl, [r9]
   11236:	str.w	r6, [r9, #4]
   1123a:	ble.n	1121c <_svfprintf_r+0xa1c>
   1123c:	add	r2, sp, #140	; 0x8c
   1123e:	mov	r1, fp
   11240:	mov	r0, r7
   11242:	bl	13940 <__ssprint_r>
   11246:	cmp	r0, #0
   11248:	bne.w	109f4 <_svfprintf_r+0x1f4>
   1124c:	ldr	r4, [sp, #148]	; 0x94
   1124e:	ldr	r3, [sp, #144]	; 0x90
   11250:	add.w	r9, sp, #192	; 0xc0
   11254:	b.n	11220 <_svfprintf_r+0xa20>
   11256:	ldr	r3, [sp, #32]
   11258:	ldr	r2, [sp, #16]
   1125a:	subs	r7, r3, r2
   1125c:	cmp	r7, #0
   1125e:	ble.w	10c94 <_svfprintf_r+0x494>
   11262:	ldr	r2, [pc, #752]	; (11554 <_svfprintf_r+0xd54>)
   11264:	ldr	r3, [sp, #144]	; 0x90
   11266:	str	r2, [sp, #44]	; 0x2c
   11268:	cmp	r7, #16
   1126a:	ble.n	112c4 <_svfprintf_r+0xac4>
   1126c:	mov	r2, r9
   1126e:	mov	r1, r4
   11270:	mov	r9, r7
   11272:	movs	r5, #16
   11274:	mov	r7, r6
   11276:	ldr	r4, [sp, #24]
   11278:	ldr	r6, [sp, #20]
   1127a:	b.n	1128a <_svfprintf_r+0xa8a>
   1127c:	sub.w	r9, r9, #16
   11280:	cmp.w	r9, #16
   11284:	add.w	r2, r2, #8
   11288:	ble.n	112bc <_svfprintf_r+0xabc>
   1128a:	adds	r3, #1
   1128c:	adds	r1, #16
   1128e:	cmp	r3, #7
   11290:	str	r1, [sp, #148]	; 0x94
   11292:	str	r3, [sp, #144]	; 0x90
   11294:	str.w	sl, [r2]
   11298:	str	r5, [r2, #4]
   1129a:	ble.n	1127c <_svfprintf_r+0xa7c>
   1129c:	add	r2, sp, #140	; 0x8c
   1129e:	mov	r1, r6
   112a0:	mov	r0, r4
   112a2:	bl	13940 <__ssprint_r>
   112a6:	cmp	r0, #0
   112a8:	bne.w	109f4 <_svfprintf_r+0x1f4>
   112ac:	sub.w	r9, r9, #16
   112b0:	cmp.w	r9, #16
   112b4:	ldr	r1, [sp, #148]	; 0x94
   112b6:	ldr	r3, [sp, #144]	; 0x90
   112b8:	add	r2, sp, #192	; 0xc0
   112ba:	bgt.n	1128a <_svfprintf_r+0xa8a>
   112bc:	mov	r6, r7
   112be:	mov	r4, r1
   112c0:	mov	r7, r9
   112c2:	mov	r9, r2
   112c4:	adds	r3, #1
   112c6:	ldr	r2, [sp, #44]	; 0x2c
   112c8:	str	r3, [sp, #144]	; 0x90
   112ca:	add	r4, r7
   112cc:	cmp	r3, #7
   112ce:	str	r4, [sp, #148]	; 0x94
   112d0:	stmia.w	r9, {r2, r7}
   112d4:	bgt.w	11752 <_svfprintf_r+0xf52>
   112d8:	add.w	r9, r9, #8
   112dc:	b.n	10c94 <_svfprintf_r+0x494>
   112de:	ldr	r3, [sp, #56]	; 0x38
   112e0:	ldr	r5, [sp, #144]	; 0x90
   112e2:	cmp	r3, #1
   112e4:	ble.w	116fc <_svfprintf_r+0xefc>
   112e8:	adds	r5, #1
   112ea:	adds	r4, #1
   112ec:	movs	r3, #1
   112ee:	cmp	r5, #7
   112f0:	str	r4, [sp, #148]	; 0x94
   112f2:	str	r5, [sp, #144]	; 0x90
   112f4:	str.w	r6, [r9]
   112f8:	str.w	r3, [r9, #4]
   112fc:	bgt.w	1171e <_svfprintf_r+0xf1e>
   11300:	add.w	r9, r9, #8
   11304:	ldr	r2, [sp, #72]	; 0x48
   11306:	ldr	r3, [sp, #76]	; 0x4c
   11308:	str.w	r3, [r9]
   1130c:	adds	r5, #1
   1130e:	add	r4, r2
   11310:	cmp	r5, #7
   11312:	str	r4, [sp, #148]	; 0x94
   11314:	str	r5, [sp, #144]	; 0x90
   11316:	str.w	r2, [r9, #4]
   1131a:	bgt.w	11738 <_svfprintf_r+0xf38>
   1131e:	add.w	r9, r9, #8
   11322:	movs	r3, #0
   11324:	movs	r2, #0
   11326:	ldrd	r0, r1, [sp, #64]	; 0x40
   1132a:	bl	f3b0 <__aeabi_dcmpeq>
   1132e:	ldr	r3, [sp, #56]	; 0x38
   11330:	cmp	r0, #0
   11332:	bne.w	114bc <_svfprintf_r+0xcbc>
   11336:	subs	r3, #1
   11338:	adds	r5, #1
   1133a:	adds	r6, #1
   1133c:	add	r4, r3
   1133e:	cmp	r5, #7
   11340:	str	r5, [sp, #144]	; 0x90
   11342:	str	r4, [sp, #148]	; 0x94
   11344:	str.w	r6, [r9]
   11348:	str.w	r3, [r9, #4]
   1134c:	bgt.w	1153a <_svfprintf_r+0xd3a>
   11350:	add.w	r9, r9, #8
   11354:	ldr	r2, [sp, #84]	; 0x54
   11356:	str.w	r2, [r9, #4]
   1135a:	adds	r5, #1
   1135c:	add	r4, r2
   1135e:	add	r3, sp, #124	; 0x7c
   11360:	cmp	r5, #7
   11362:	str	r4, [sp, #148]	; 0x94
   11364:	str	r5, [sp, #144]	; 0x90
   11366:	str.w	r3, [r9]
   1136a:	ble.w	10d28 <_svfprintf_r+0x528>
   1136e:	add	r2, sp, #140	; 0x8c
   11370:	ldr	r1, [sp, #20]
   11372:	ldr	r0, [sp, #24]
   11374:	bl	13940 <__ssprint_r>
   11378:	cmp	r0, #0
   1137a:	bne.w	109f4 <_svfprintf_r+0x1f4>
   1137e:	ldr	r4, [sp, #148]	; 0x94
   11380:	add.w	r9, sp, #192	; 0xc0
   11384:	b.n	10d2c <_svfprintf_r+0x52c>
   11386:	add	r2, sp, #140	; 0x8c
   11388:	ldr	r1, [sp, #20]
   1138a:	ldr	r0, [sp, #24]
   1138c:	bl	13940 <__ssprint_r>
   11390:	cmp	r0, #0
   11392:	beq.w	10dc8 <_svfprintf_r+0x5c8>
   11396:	b.w	109f4 <_svfprintf_r+0x1f4>
   1139a:	add	r2, sp, #140	; 0x8c
   1139c:	ldr	r1, [sp, #20]
   1139e:	ldr	r0, [sp, #24]
   113a0:	bl	13940 <__ssprint_r>
   113a4:	cmp	r0, #0
   113a6:	bne.w	109f4 <_svfprintf_r+0x1f4>
   113aa:	ldr	r4, [sp, #148]	; 0x94
   113ac:	add.w	r9, sp, #192	; 0xc0
   113b0:	b.n	10d06 <_svfprintf_r+0x506>
   113b2:	add	r2, sp, #140	; 0x8c
   113b4:	ldr	r1, [sp, #20]
   113b6:	ldr	r0, [sp, #24]
   113b8:	bl	13940 <__ssprint_r>
   113bc:	cmp	r0, #0
   113be:	bne.w	109f4 <_svfprintf_r+0x1f4>
   113c2:	ldr	r4, [sp, #148]	; 0x94
   113c4:	add.w	r9, sp, #192	; 0xc0
   113c8:	b.n	10c6c <_svfprintf_r+0x46c>
   113ca:	add	r2, sp, #140	; 0x8c
   113cc:	ldr	r1, [sp, #20]
   113ce:	ldr	r0, [sp, #24]
   113d0:	bl	13940 <__ssprint_r>
   113d4:	cmp	r0, #0
   113d6:	bne.w	109f4 <_svfprintf_r+0x1f4>
   113da:	ldr	r4, [sp, #148]	; 0x94
   113dc:	add.w	r9, sp, #192	; 0xc0
   113e0:	b.n	10c8c <_svfprintf_r+0x48c>
   113e2:	cmp.w	fp, #0
   113e6:	strb.w	r7, [sp, #111]	; 0x6f
   113ea:	blt.w	119ac <_svfprintf_r+0x11ac>
   113ee:	bic.w	r3, r2, #128	; 0x80
   113f2:	str	r3, [sp, #12]
   113f4:	orrs.w	r3, r4, r5
   113f8:	bne.w	10fa2 <_svfprintf_r+0x7a2>
   113fc:	cmp.w	fp, #0
   11400:	beq.w	1111c <_svfprintf_r+0x91c>
   11404:	movs	r7, #0
   11406:	b.n	11178 <_svfprintf_r+0x978>
   11408:	ldr	r5, [sp, #116]	; 0x74
   1140a:	cmp	r5, #0
   1140c:	ble.w	119b2 <_svfprintf_r+0x11b2>
   11410:	ldr	r3, [sp, #60]	; 0x3c
   11412:	ldr	r2, [sp, #56]	; 0x38
   11414:	cmp	r3, r2
   11416:	it	ge
   11418:	movge	r3, r2
   1141a:	cmp	r3, #0
   1141c:	mov	r5, r3
   1141e:	ble.n	1143c <_svfprintf_r+0xc3c>
   11420:	ldr	r3, [sp, #144]	; 0x90
   11422:	str.w	r6, [r9]
   11426:	adds	r3, #1
   11428:	add	r4, r5
   1142a:	cmp	r3, #7
   1142c:	str	r4, [sp, #148]	; 0x94
   1142e:	str.w	r5, [r9, #4]
   11432:	str	r3, [sp, #144]	; 0x90
   11434:	bgt.w	11b8a <_svfprintf_r+0x138a>
   11438:	add.w	r9, r9, #8
   1143c:	ldr	r3, [sp, #60]	; 0x3c
   1143e:	cmp	r5, #0
   11440:	it	ge
   11442:	subge	r3, r3, r5
   11444:	cmp	r3, #0
   11446:	mov	r5, r3
   11448:	ble.w	1163c <_svfprintf_r+0xe3c>
   1144c:	ldr	r2, [pc, #260]	; (11554 <_svfprintf_r+0xd54>)
   1144e:	ldr	r3, [sp, #144]	; 0x90
   11450:	str	r2, [sp, #44]	; 0x2c
   11452:	cmp	r5, #16
   11454:	ble.w	1195e <_svfprintf_r+0x115e>
   11458:	mov	r2, r4
   1145a:	movs	r7, #16
   1145c:	ldr.w	fp, [sp, #24]
   11460:	ldr	r4, [sp, #20]
   11462:	b.n	11470 <_svfprintf_r+0xc70>
   11464:	add.w	r9, r9, #8
   11468:	subs	r5, #16
   1146a:	cmp	r5, #16
   1146c:	ble.w	1195c <_svfprintf_r+0x115c>
   11470:	adds	r3, #1
   11472:	adds	r2, #16
   11474:	cmp	r3, #7
   11476:	str	r2, [sp, #148]	; 0x94
   11478:	str	r3, [sp, #144]	; 0x90
   1147a:	str.w	sl, [r9]
   1147e:	str.w	r7, [r9, #4]
   11482:	ble.n	11464 <_svfprintf_r+0xc64>
   11484:	add	r2, sp, #140	; 0x8c
   11486:	mov	r1, r4
   11488:	mov	r0, fp
   1148a:	bl	13940 <__ssprint_r>
   1148e:	cmp	r0, #0
   11490:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11494:	ldr	r2, [sp, #148]	; 0x94
   11496:	ldr	r3, [sp, #144]	; 0x90
   11498:	add.w	r9, sp, #192	; 0xc0
   1149c:	b.n	11468 <_svfprintf_r+0xc68>
   1149e:	add	r2, sp, #140	; 0x8c
   114a0:	ldr	r1, [sp, #20]
   114a2:	ldr	r0, [sp, #24]
   114a4:	bl	13940 <__ssprint_r>
   114a8:	cmp	r0, #0
   114aa:	bne.w	109f4 <_svfprintf_r+0x1f4>
   114ae:	ldrb.w	r7, [sp, #111]	; 0x6f
   114b2:	ldr	r4, [sp, #148]	; 0x94
   114b4:	add.w	r9, sp, #192	; 0xc0
   114b8:	b.w	10c4c <_svfprintf_r+0x44c>
   114bc:	subs	r6, r3, #1
   114be:	cmp	r6, #0
   114c0:	ble.w	11354 <_svfprintf_r+0xb54>
   114c4:	ldr	r3, [pc, #140]	; (11554 <_svfprintf_r+0xd54>)
   114c6:	str	r3, [sp, #44]	; 0x2c
   114c8:	cmp	r6, #16
   114ca:	ble.n	11526 <_svfprintf_r+0xd26>
   114cc:	str.w	r8, [sp, #36]	; 0x24
   114d0:	movs	r7, #16
   114d2:	mov	r8, r6
   114d4:	ldr.w	fp, [sp, #24]
   114d8:	ldr	r6, [sp, #20]
   114da:	b.n	114ea <_svfprintf_r+0xcea>
   114dc:	sub.w	r8, r8, #16
   114e0:	cmp.w	r8, #16
   114e4:	add.w	r9, r9, #8
   114e8:	ble.n	11520 <_svfprintf_r+0xd20>
   114ea:	adds	r5, #1
   114ec:	adds	r4, #16
   114ee:	cmp	r5, #7
   114f0:	str	r4, [sp, #148]	; 0x94
   114f2:	str	r5, [sp, #144]	; 0x90
   114f4:	str.w	sl, [r9]
   114f8:	str.w	r7, [r9, #4]
   114fc:	ble.n	114dc <_svfprintf_r+0xcdc>
   114fe:	add	r2, sp, #140	; 0x8c
   11500:	mov	r1, r6
   11502:	mov	r0, fp
   11504:	bl	13940 <__ssprint_r>
   11508:	cmp	r0, #0
   1150a:	bne.w	109f4 <_svfprintf_r+0x1f4>
   1150e:	sub.w	r8, r8, #16
   11512:	cmp.w	r8, #16
   11516:	ldr	r4, [sp, #148]	; 0x94
   11518:	ldr	r5, [sp, #144]	; 0x90
   1151a:	add.w	r9, sp, #192	; 0xc0
   1151e:	bgt.n	114ea <_svfprintf_r+0xcea>
   11520:	mov	r6, r8
   11522:	ldr.w	r8, [sp, #36]	; 0x24
   11526:	ldr	r3, [sp, #44]	; 0x2c
   11528:	adds	r5, #1
   1152a:	add	r4, r6
   1152c:	cmp	r5, #7
   1152e:	str	r4, [sp, #148]	; 0x94
   11530:	str	r5, [sp, #144]	; 0x90
   11532:	stmia.w	r9, {r3, r6}
   11536:	ble.w	11350 <_svfprintf_r+0xb50>
   1153a:	add	r2, sp, #140	; 0x8c
   1153c:	ldr	r1, [sp, #20]
   1153e:	ldr	r0, [sp, #24]
   11540:	bl	13940 <__ssprint_r>
   11544:	cmp	r0, #0
   11546:	bne.w	109f4 <_svfprintf_r+0x1f4>
   1154a:	ldr	r4, [sp, #148]	; 0x94
   1154c:	ldr	r5, [sp, #144]	; 0x90
   1154e:	add.w	r9, sp, #192	; 0xc0
   11552:	b.n	11354 <_svfprintf_r+0xb54>
   11554:	.word	0x200008ec
   11558:	ldr	r1, [sp, #12]
   1155a:	ands.w	r2, r1, #16
   1155e:	beq.w	11908 <_svfprintf_r+0x1108>
   11562:	ldr	r0, [sp, #40]	; 0x28
   11564:	strb.w	r3, [sp, #111]	; 0x6f
   11568:	cmp.w	fp, #0
   1156c:	ldr	r4, [r0, #0]
   1156e:	add.w	r7, r0, #4
   11572:	mov.w	r5, #0
   11576:	blt.n	115c6 <_svfprintf_r+0xdc6>
   11578:	mov	r2, r1
   1157a:	bic.w	r2, r2, #128	; 0x80
   1157e:	str	r2, [sp, #12]
   11580:	orrs.w	r2, r4, r5
   11584:	str	r7, [sp, #40]	; 0x28
   11586:	mov	r7, r3
   11588:	bne.w	10b5c <_svfprintf_r+0x35c>
   1158c:	b.n	10f2c <_svfprintf_r+0x72c>
   1158e:	ldr	r3, [sp, #12]
   11590:	lsls	r0, r3, #27
   11592:	bmi.n	115ea <_svfprintf_r+0xdea>
   11594:	ldr	r3, [sp, #12]
   11596:	lsls	r1, r3, #25
   11598:	bpl.n	115ea <_svfprintf_r+0xdea>
   1159a:	ldr	r1, [sp, #40]	; 0x28
   1159c:	ldrsh.w	r4, [r1]
   115a0:	adds	r1, #4
   115a2:	asrs	r5, r4, #31
   115a4:	mov	r2, r4
   115a6:	mov	r3, r5
   115a8:	str	r1, [sp, #40]	; 0x28
   115aa:	b.w	10b36 <_svfprintf_r+0x336>
   115ae:	ldr	r1, [sp, #40]	; 0x28
   115b0:	strb.w	r3, [sp, #111]	; 0x6f
   115b4:	cmp.w	fp, #0
   115b8:	ldr	r4, [r1, #0]
   115ba:	add.w	r7, r1, #4
   115be:	mov.w	r5, #0
   115c2:	bge.w	11a5e <_svfprintf_r+0x125e>
   115c6:	str	r7, [sp, #40]	; 0x28
   115c8:	mov	r7, r3
   115ca:	orrs.w	r3, r4, r5
   115ce:	bne.w	10b5c <_svfprintf_r+0x35c>
   115d2:	b.n	10f36 <_svfprintf_r+0x736>
   115d4:	adds	r3, #1
   115d6:	ldr	r2, [sp, #44]	; 0x2c
   115d8:	str	r3, [sp, #144]	; 0x90
   115da:	add	r4, r5
   115dc:	cmp	r3, #7
   115de:	str	r4, [sp, #148]	; 0x94
   115e0:	stmia.w	r9, {r2, r5}
   115e4:	ble.w	10d28 <_svfprintf_r+0x528>
   115e8:	b.n	1136e <_svfprintf_r+0xb6e>
   115ea:	ldr	r2, [sp, #40]	; 0x28
   115ec:	ldr	r4, [r2, #0]
   115ee:	mov	r3, r2
   115f0:	adds	r3, #4
   115f2:	asrs	r5, r4, #31
   115f4:	mov	r2, r4
   115f6:	str	r3, [sp, #40]	; 0x28
   115f8:	cmp	r2, #0
   115fa:	mov	r3, r5
   115fc:	sbcs.w	r3, r3, #0
   11600:	bge.w	10b40 <_svfprintf_r+0x340>
   11604:	negs	r4, r4
   11606:	mov.w	r7, #45	; 0x2d
   1160a:	sbc.w	r5, r5, r5, lsl #1
   1160e:	cmp.w	fp, #0
   11612:	strb.w	r7, [sp, #111]	; 0x6f
   11616:	blt.w	10b5c <_svfprintf_r+0x35c>
   1161a:	ldr	r3, [sp, #12]
   1161c:	bic.w	r3, r3, #128	; 0x80
   11620:	str	r3, [sp, #12]
   11622:	b.w	10b5c <_svfprintf_r+0x35c>
   11626:	add	r2, sp, #140	; 0x8c
   11628:	ldr	r1, [sp, #20]
   1162a:	ldr	r0, [sp, #24]
   1162c:	bl	13940 <__ssprint_r>
   11630:	cmp	r0, #0
   11632:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11636:	ldr	r4, [sp, #148]	; 0x94
   11638:	add.w	r9, sp, #192	; 0xc0
   1163c:	ldr	r2, [sp, #60]	; 0x3c
   1163e:	ldr	r3, [sp, #116]	; 0x74
   11640:	add	r2, r6
   11642:	mov	r7, r2
   11644:	ldr	r2, [sp, #56]	; 0x38
   11646:	cmp	r3, r2
   11648:	blt.n	116da <_svfprintf_r+0xeda>
   1164a:	ldr	r2, [sp, #12]
   1164c:	lsls	r5, r2, #31
   1164e:	bmi.n	116da <_svfprintf_r+0xeda>
   11650:	ldr	r1, [sp, #56]	; 0x38
   11652:	add	r6, r1
   11654:	subs	r5, r6, r7
   11656:	subs	r3, r1, r3
   11658:	cmp	r5, r3
   1165a:	it	ge
   1165c:	movge	r5, r3
   1165e:	cmp	r5, #0
   11660:	mov	r6, r5
   11662:	ble.n	11680 <_svfprintf_r+0xe80>
   11664:	ldr	r2, [sp, #144]	; 0x90
   11666:	str.w	r7, [r9]
   1166a:	adds	r2, #1
   1166c:	add	r4, r5
   1166e:	cmp	r2, #7
   11670:	str	r4, [sp, #148]	; 0x94
   11672:	str.w	r5, [r9, #4]
   11676:	str	r2, [sp, #144]	; 0x90
   11678:	bgt.w	11c78 <_svfprintf_r+0x1478>
   1167c:	add.w	r9, r9, #8
   11680:	cmp	r6, #0
   11682:	ite	ge
   11684:	subge	r5, r3, r6
   11686:	movlt	r5, r3
   11688:	cmp	r5, #0
   1168a:	ble.w	10d2c <_svfprintf_r+0x52c>
   1168e:	ldr	r2, [pc, #744]	; (11978 <_svfprintf_r+0x1178>)
   11690:	ldr	r3, [sp, #144]	; 0x90
   11692:	str	r2, [sp, #44]	; 0x2c
   11694:	cmp	r5, #16
   11696:	ble.n	115d4 <_svfprintf_r+0xdd4>
   11698:	movs	r6, #16
   1169a:	ldr	r7, [sp, #24]
   1169c:	ldr.w	fp, [sp, #20]
   116a0:	b.n	116ac <_svfprintf_r+0xeac>
   116a2:	add.w	r9, r9, #8
   116a6:	subs	r5, #16
   116a8:	cmp	r5, #16
   116aa:	ble.n	115d4 <_svfprintf_r+0xdd4>
   116ac:	adds	r3, #1
   116ae:	adds	r4, #16
   116b0:	cmp	r3, #7
   116b2:	str	r4, [sp, #148]	; 0x94
   116b4:	str	r3, [sp, #144]	; 0x90
   116b6:	str.w	sl, [r9]
   116ba:	str.w	r6, [r9, #4]
   116be:	ble.n	116a2 <_svfprintf_r+0xea2>
   116c0:	add	r2, sp, #140	; 0x8c
   116c2:	mov	r1, fp
   116c4:	mov	r0, r7
   116c6:	bl	13940 <__ssprint_r>
   116ca:	cmp	r0, #0
   116cc:	bne.w	109f4 <_svfprintf_r+0x1f4>
   116d0:	ldr	r4, [sp, #148]	; 0x94
   116d2:	ldr	r3, [sp, #144]	; 0x90
   116d4:	add.w	r9, sp, #192	; 0xc0
   116d8:	b.n	116a6 <_svfprintf_r+0xea6>
   116da:	ldr	r2, [sp, #144]	; 0x90
   116dc:	ldr	r0, [sp, #72]	; 0x48
   116de:	ldr	r1, [sp, #76]	; 0x4c
   116e0:	str.w	r1, [r9]
   116e4:	adds	r2, #1
   116e6:	add	r4, r0
   116e8:	cmp	r2, #7
   116ea:	str	r4, [sp, #148]	; 0x94
   116ec:	str.w	r0, [r9, #4]
   116f0:	str	r2, [sp, #144]	; 0x90
   116f2:	bgt.w	11c5e <_svfprintf_r+0x145e>
   116f6:	add.w	r9, r9, #8
   116fa:	b.n	11650 <_svfprintf_r+0xe50>
   116fc:	ldr	r3, [sp, #12]
   116fe:	lsls	r0, r3, #31
   11700:	bmi.w	112e8 <_svfprintf_r+0xae8>
   11704:	adds	r5, #1
   11706:	adds	r4, #1
   11708:	movs	r3, #1
   1170a:	cmp	r5, #7
   1170c:	str	r4, [sp, #148]	; 0x94
   1170e:	str	r5, [sp, #144]	; 0x90
   11710:	str.w	r6, [r9]
   11714:	str.w	r3, [r9, #4]
   11718:	ble.w	11350 <_svfprintf_r+0xb50>
   1171c:	b.n	1153a <_svfprintf_r+0xd3a>
   1171e:	add	r2, sp, #140	; 0x8c
   11720:	ldr	r1, [sp, #20]
   11722:	ldr	r0, [sp, #24]
   11724:	bl	13940 <__ssprint_r>
   11728:	cmp	r0, #0
   1172a:	bne.w	109f4 <_svfprintf_r+0x1f4>
   1172e:	ldr	r4, [sp, #148]	; 0x94
   11730:	ldr	r5, [sp, #144]	; 0x90
   11732:	add.w	r9, sp, #192	; 0xc0
   11736:	b.n	11304 <_svfprintf_r+0xb04>
   11738:	add	r2, sp, #140	; 0x8c
   1173a:	ldr	r1, [sp, #20]
   1173c:	ldr	r0, [sp, #24]
   1173e:	bl	13940 <__ssprint_r>
   11742:	cmp	r0, #0
   11744:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11748:	ldr	r4, [sp, #148]	; 0x94
   1174a:	ldr	r5, [sp, #144]	; 0x90
   1174c:	add.w	r9, sp, #192	; 0xc0
   11750:	b.n	11322 <_svfprintf_r+0xb22>
   11752:	add	r2, sp, #140	; 0x8c
   11754:	ldr	r1, [sp, #20]
   11756:	ldr	r0, [sp, #24]
   11758:	bl	13940 <__ssprint_r>
   1175c:	cmp	r0, #0
   1175e:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11762:	ldr	r4, [sp, #148]	; 0x94
   11764:	add.w	r9, sp, #192	; 0xc0
   11768:	b.w	10c94 <_svfprintf_r+0x494>
   1176c:	ldr	r1, [sp, #12]
   1176e:	ands.w	r3, r1, #64	; 0x40
   11772:	beq.w	118e8 <_svfprintf_r+0x10e8>
   11776:	ldr	r0, [sp, #40]	; 0x28
   11778:	strb.w	r2, [sp, #111]	; 0x6f
   1177c:	mov	r3, r0
   1177e:	cmp.w	fp, #0
   11782:	add.w	r3, r3, #4
   11786:	ldrh	r4, [r0, #0]
   11788:	mov.w	r5, #0
   1178c:	blt.w	11b10 <_svfprintf_r+0x1310>
   11790:	bic.w	r1, r1, #128	; 0x80
   11794:	str	r1, [sp, #12]
   11796:	orrs.w	r1, r4, r5
   1179a:	str	r3, [sp, #40]	; 0x28
   1179c:	beq.w	11154 <_svfprintf_r+0x954>
   117a0:	mov	r7, r2
   117a2:	b.w	10a4c <_svfprintf_r+0x24c>
   117a6:	ldr	r3, [sp, #12]
   117a8:	lsls	r7, r3, #27
   117aa:	bmi.n	117c4 <_svfprintf_r+0xfc4>
   117ac:	ldr	r3, [sp, #12]
   117ae:	lsls	r6, r3, #25
   117b0:	bpl.n	117c4 <_svfprintf_r+0xfc4>
   117b2:	ldr	r2, [sp, #40]	; 0x28
   117b4:	ldr	r3, [r2, #0]
   117b6:	adds	r2, #4
   117b8:	str	r2, [sp, #40]	; 0x28
   117ba:	ldrh.w	r2, [sp, #28]
   117be:	strh	r2, [r3, #0]
   117c0:	b.w	1084e <_svfprintf_r+0x4e>
   117c4:	ldr	r2, [sp, #40]	; 0x28
   117c6:	ldr	r3, [r2, #0]
   117c8:	adds	r2, #4
   117ca:	str	r2, [sp, #40]	; 0x28
   117cc:	ldr	r2, [sp, #28]
   117ce:	str	r2, [r3, #0]
   117d0:	b.w	1084e <_svfprintf_r+0x4e>
   117d4:	ldrd	r0, r1, [sp, #64]	; 0x40
   117d8:	mov	r2, r0
   117da:	mov	r3, r1
   117dc:	bl	f414 <__aeabi_dcmpun>
   117e0:	cmp	r0, #0
   117e2:	bne.w	11de0 <_svfprintf_r+0x15e0>
   117e6:	ldr	r3, [sp, #52]	; 0x34
   117e8:	cmp.w	fp, #4294967295
   117ec:	bic.w	r7, r3, #32
   117f0:	beq.w	11cc2 <_svfprintf_r+0x14c2>
   117f4:	cmp	r7, #71	; 0x47
   117f6:	beq.w	11afe <_svfprintf_r+0x12fe>
   117fa:	ldr	r3, [sp, #68]	; 0x44
   117fc:	ldr	r2, [sp, #12]
   117fe:	cmp	r3, #0
   11800:	orr.w	r2, r2, #256	; 0x100
   11804:	str	r2, [sp, #44]	; 0x2c
   11806:	blt.w	11cfa <_svfprintf_r+0x14fa>
   1180a:	vldr	d7, [sp, #64]	; 0x40
   1180e:	vstr	d7, [sp, #96]	; 0x60
   11812:	movs	r3, #0
   11814:	str	r3, [sp, #16]
   11816:	ldr	r3, [sp, #52]	; 0x34
   11818:	cmp	r3, #102	; 0x66
   1181a:	beq.w	11cc8 <_svfprintf_r+0x14c8>
   1181e:	cmp	r3, #70	; 0x46
   11820:	beq.w	11aae <_svfprintf_r+0x12ae>
   11824:	cmp	r7, #69	; 0x45
   11826:	ite	eq
   11828:	addeq.w	r5, fp, #1
   1182c:	movne	r5, fp
   1182e:	add	r2, sp, #132	; 0x84
   11830:	add	r3, sp, #120	; 0x78
   11832:	str	r2, [sp, #4]
   11834:	str	r3, [sp, #0]
   11836:	mov	r2, r5
   11838:	add	r3, sp, #116	; 0x74
   1183a:	movs	r1, #2
   1183c:	vldr	d0, [sp, #96]	; 0x60
   11840:	ldr	r0, [sp, #24]
   11842:	bl	12160 <_dtoa_r>
   11846:	ldr	r3, [sp, #52]	; 0x34
   11848:	cmp	r3, #103	; 0x67
   1184a:	mov	r6, r0
   1184c:	bne.w	11d26 <_svfprintf_r+0x1526>
   11850:	ldr	r3, [sp, #12]
   11852:	lsls	r2, r3, #31
   11854:	bpl.w	11dca <_svfprintf_r+0x15ca>
   11858:	adds	r4, r6, r5
   1185a:	movs	r2, #0
   1185c:	movs	r3, #0
   1185e:	ldrd	r0, r1, [sp, #96]	; 0x60
   11862:	bl	f3b0 <__aeabi_dcmpeq>
   11866:	cmp	r0, #0
   11868:	bne.w	11b86 <_svfprintf_r+0x1386>
   1186c:	ldr	r3, [sp, #132]	; 0x84
   1186e:	cmp	r4, r3
   11870:	bls.n	11880 <_svfprintf_r+0x1080>
   11872:	movs	r1, #48	; 0x30
   11874:	adds	r2, r3, #1
   11876:	str	r2, [sp, #132]	; 0x84
   11878:	strb	r1, [r3, #0]
   1187a:	ldr	r3, [sp, #132]	; 0x84
   1187c:	cmp	r4, r3
   1187e:	bhi.n	11874 <_svfprintf_r+0x1074>
   11880:	subs	r3, r3, r6
   11882:	cmp	r7, #71	; 0x47
   11884:	str	r3, [sp, #56]	; 0x38
   11886:	beq.w	11b78 <_svfprintf_r+0x1378>
   1188a:	ldr	r3, [sp, #52]	; 0x34
   1188c:	cmp	r3, #101	; 0x65
   1188e:	ble.w	11d44 <_svfprintf_r+0x1544>
   11892:	ldr	r3, [sp, #52]	; 0x34
   11894:	cmp	r3, #102	; 0x66
   11896:	ldr	r3, [sp, #116]	; 0x74
   11898:	str	r3, [sp, #60]	; 0x3c
   1189a:	beq.w	11d5e <_svfprintf_r+0x155e>
   1189e:	ldr	r2, [sp, #60]	; 0x3c
   118a0:	ldr	r1, [sp, #56]	; 0x38
   118a2:	cmp	r2, r1
   118a4:	blt.w	11d0c <_svfprintf_r+0x150c>
   118a8:	ldr	r3, [sp, #12]
   118aa:	lsls	r1, r3, #31
   118ac:	bmi.w	11dce <_svfprintf_r+0x15ce>
   118b0:	bic.w	r3, r2, r2, asr #31
   118b4:	str	r2, [sp, #36]	; 0x24
   118b6:	movs	r2, #103	; 0x67
   118b8:	str	r2, [sp, #52]	; 0x34
   118ba:	ldr	r2, [sp, #16]
   118bc:	cmp	r2, #0
   118be:	bne.w	11b20 <_svfprintf_r+0x1320>
   118c2:	str	r3, [sp, #16]
   118c4:	ldr	r3, [sp, #44]	; 0x2c
   118c6:	str	r3, [sp, #12]
   118c8:	mov	fp, r2
   118ca:	ldrb.w	r7, [sp, #111]	; 0x6f
   118ce:	b.w	10ba4 <_svfprintf_r+0x3a4>
   118d2:	bic.w	r7, r7, #7
   118d6:	vldr	d7, [r7]
   118da:	add.w	r3, r7, #8
   118de:	vstr	d7, [sp, #64]	; 0x40
   118e2:	str	r3, [sp, #40]	; 0x28
   118e4:	b.w	10dfc <_svfprintf_r+0x5fc>
   118e8:	ldr	r1, [sp, #40]	; 0x28
   118ea:	strb.w	r3, [sp, #111]	; 0x6f
   118ee:	cmp.w	fp, #0
   118f2:	ldr	r4, [r1, #0]
   118f4:	add.w	r7, r1, #4
   118f8:	mov.w	r5, #0
   118fc:	bge.w	11a58 <_svfprintf_r+0x1258>
   11900:	str	r7, [sp, #40]	; 0x28
   11902:	movs	r7, #0
   11904:	b.w	10a4c <_svfprintf_r+0x24c>
   11908:	ldr	r1, [sp, #12]
   1190a:	ands.w	r3, r1, #64	; 0x40
   1190e:	beq.w	115ae <_svfprintf_r+0xdae>
   11912:	ldr	r0, [sp, #40]	; 0x28
   11914:	strb.w	r2, [sp, #111]	; 0x6f
   11918:	mov	r3, r0
   1191a:	cmp.w	fp, #0
   1191e:	add.w	r3, r3, #4
   11922:	ldrh	r4, [r0, #0]
   11924:	mov.w	r5, #0
   11928:	blt.w	11b0a <_svfprintf_r+0x130a>
   1192c:	bic.w	r1, r1, #128	; 0x80
   11930:	str	r1, [sp, #12]
   11932:	orrs.w	r1, r4, r5
   11936:	str	r3, [sp, #40]	; 0x28
   11938:	mov	r7, r2
   1193a:	bne.w	10b5c <_svfprintf_r+0x35c>
   1193e:	b.w	10f2c <_svfprintf_r+0x72c>
   11942:	ldr	r3, [sp, #12]
   11944:	ldr	r2, [sp, #40]	; 0x28
   11946:	tst.w	r3, #64	; 0x40
   1194a:	mov	r3, r2
   1194c:	beq.w	11b14 <_svfprintf_r+0x1314>
   11950:	adds	r3, #4
   11952:	ldrh	r4, [r2, #0]
   11954:	str	r3, [sp, #40]	; 0x28
   11956:	movs	r5, #0
   11958:	b.w	10f66 <_svfprintf_r+0x766>
   1195c:	mov	r4, r2
   1195e:	adds	r3, #1
   11960:	ldr	r2, [sp, #44]	; 0x2c
   11962:	str	r3, [sp, #144]	; 0x90
   11964:	add	r4, r5
   11966:	cmp	r3, #7
   11968:	str	r4, [sp, #148]	; 0x94
   1196a:	stmia.w	r9, {r2, r5}
   1196e:	bgt.w	11626 <_svfprintf_r+0xe26>
   11972:	add.w	r9, r9, #8
   11976:	b.n	1163c <_svfprintf_r+0xe3c>
   11978:	.word	0x200008ec
   1197c:	movs	r7, #0
   1197e:	cmp	fp, r7
   11980:	strb.w	r7, [sp, #111]	; 0x6f
   11984:	blt.w	11178 <_svfprintf_r+0x978>
   11988:	ldr	r3, [sp, #12]
   1198a:	bic.w	r3, r3, #128	; 0x80
   1198e:	str	r3, [sp, #12]
   11990:	b.w	11114 <_svfprintf_r+0x914>
   11994:	add	r2, sp, #140	; 0x8c
   11996:	ldr	r1, [sp, #20]
   11998:	ldr	r0, [sp, #24]
   1199a:	bl	13940 <__ssprint_r>
   1199e:	cmp	r0, #0
   119a0:	bne.w	109f4 <_svfprintf_r+0x1f4>
   119a4:	ldr	r4, [sp, #148]	; 0x94
   119a6:	add.w	r9, sp, #192	; 0xc0
   119aa:	b.n	111bc <_svfprintf_r+0x9bc>
   119ac:	ldr	r7, [sp, #40]	; 0x28
   119ae:	b.w	1116a <_svfprintf_r+0x96a>
   119b2:	ldr	r3, [sp, #144]	; 0x90
   119b4:	ldr	r2, [pc, #736]	; (11c98 <_svfprintf_r+0x1498>)
   119b6:	str.w	r2, [r9]
   119ba:	adds	r3, #1
   119bc:	adds	r4, #1
   119be:	movs	r2, #1
   119c0:	cmp	r3, #7
   119c2:	str	r4, [sp, #148]	; 0x94
   119c4:	str	r3, [sp, #144]	; 0x90
   119c6:	str.w	r2, [r9, #4]
   119ca:	bgt.w	11ae4 <_svfprintf_r+0x12e4>
   119ce:	add.w	r9, r9, #8
   119d2:	cbnz	r5, 119e0 <_svfprintf_r+0x11e0>
   119d4:	ldr	r3, [sp, #56]	; 0x38
   119d6:	cbnz	r3, 119e0 <_svfprintf_r+0x11e0>
   119d8:	ldr	r3, [sp, #12]
   119da:	lsls	r7, r3, #31
   119dc:	bpl.w	10d2c <_svfprintf_r+0x52c>
   119e0:	ldr	r3, [sp, #144]	; 0x90
   119e2:	ldr	r1, [sp, #72]	; 0x48
   119e4:	ldr	r2, [sp, #76]	; 0x4c
   119e6:	str.w	r2, [r9]
   119ea:	adds	r3, #1
   119ec:	add	r4, r1
   119ee:	cmp	r3, #7
   119f0:	str	r4, [sp, #148]	; 0x94
   119f2:	str.w	r1, [r9, #4]
   119f6:	str	r3, [sp, #144]	; 0x90
   119f8:	bgt.w	11d96 <_svfprintf_r+0x1596>
   119fc:	add.w	r9, r9, #8
   11a00:	negs	r5, r5
   11a02:	cmp	r5, #0
   11a04:	ble.w	11b5c <_svfprintf_r+0x135c>
   11a08:	ldr	r2, [pc, #656]	; (11c9c <_svfprintf_r+0x149c>)
   11a0a:	str	r2, [sp, #44]	; 0x2c
   11a0c:	cmp	r5, #16
   11a0e:	ble.w	11ba4 <_svfprintf_r+0x13a4>
   11a12:	mov	r2, r4
   11a14:	movs	r7, #16
   11a16:	ldr.w	fp, [sp, #24]
   11a1a:	ldr	r4, [sp, #20]
   11a1c:	b.n	11a2a <_svfprintf_r+0x122a>
   11a1e:	add.w	r9, r9, #8
   11a22:	subs	r5, #16
   11a24:	cmp	r5, #16
   11a26:	ble.w	11ba2 <_svfprintf_r+0x13a2>
   11a2a:	adds	r3, #1
   11a2c:	adds	r2, #16
   11a2e:	cmp	r3, #7
   11a30:	str	r2, [sp, #148]	; 0x94
   11a32:	str	r3, [sp, #144]	; 0x90
   11a34:	str.w	sl, [r9]
   11a38:	str.w	r7, [r9, #4]
   11a3c:	ble.n	11a1e <_svfprintf_r+0x121e>
   11a3e:	add	r2, sp, #140	; 0x8c
   11a40:	mov	r1, r4
   11a42:	mov	r0, fp
   11a44:	bl	13940 <__ssprint_r>
   11a48:	cmp	r0, #0
   11a4a:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11a4e:	ldr	r2, [sp, #148]	; 0x94
   11a50:	ldr	r3, [sp, #144]	; 0x90
   11a52:	add.w	r9, sp, #192	; 0xc0
   11a56:	b.n	11a22 <_svfprintf_r+0x1222>
   11a58:	ldr	r2, [sp, #12]
   11a5a:	b.w	10ed0 <_svfprintf_r+0x6d0>
   11a5e:	ldr	r2, [sp, #12]
   11a60:	b.n	1157a <_svfprintf_r+0xd7a>
   11a62:	ldr	r3, [sp, #12]
   11a64:	orr.w	r3, r3, #32
   11a68:	str	r3, [sp, #12]
   11a6a:	add.w	r8, r8, #1
   11a6e:	ldrb.w	r3, [r8]
   11a72:	b.w	108b4 <_svfprintf_r+0xb4>
   11a76:	add	r2, sp, #140	; 0x8c
   11a78:	ldr	r1, [sp, #20]
   11a7a:	ldr	r0, [sp, #24]
   11a7c:	bl	13940 <__ssprint_r>
   11a80:	cmp	r0, #0
   11a82:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11a86:	ldr	r4, [sp, #148]	; 0x94
   11a88:	add.w	r9, sp, #192	; 0xc0
   11a8c:	b.w	111ec <_svfprintf_r+0x9ec>
   11a90:	movs	r1, #64	; 0x40
   11a92:	ldr	r0, [sp, #24]
   11a94:	bl	f8b4 <_malloc_r>
   11a98:	ldr	r2, [sp, #20]
   11a9a:	str	r0, [r2, #0]
   11a9c:	str	r0, [r2, #16]
   11a9e:	cmp	r0, #0
   11aa0:	beq.w	11e8a <_svfprintf_r+0x168a>
   11aa4:	ldr	r2, [sp, #20]
   11aa6:	movs	r3, #64	; 0x40
   11aa8:	str	r3, [r2, #20]
   11aaa:	b.w	1082e <_svfprintf_r+0x2e>
   11aae:	add	r2, sp, #132	; 0x84
   11ab0:	add	r3, sp, #120	; 0x78
   11ab2:	str	r2, [sp, #4]
   11ab4:	str	r3, [sp, #0]
   11ab6:	mov	r2, fp
   11ab8:	add	r3, sp, #116	; 0x74
   11aba:	movs	r1, #3
   11abc:	vldr	d0, [sp, #96]	; 0x60
   11ac0:	ldr	r0, [sp, #24]
   11ac2:	bl	12160 <_dtoa_r>
   11ac6:	mov	r5, fp
   11ac8:	mov	r6, r0
   11aca:	ldr	r3, [sp, #52]	; 0x34
   11acc:	cmp	r3, #70	; 0x46
   11ace:	add.w	r4, r6, r5
   11ad2:	bne.w	1185a <_svfprintf_r+0x105a>
   11ad6:	ldrb	r3, [r6, #0]
   11ad8:	cmp	r3, #48	; 0x30
   11ada:	beq.w	11dec <_svfprintf_r+0x15ec>
   11ade:	ldr	r5, [sp, #116]	; 0x74
   11ae0:	add	r4, r5
   11ae2:	b.n	1185a <_svfprintf_r+0x105a>
   11ae4:	add	r2, sp, #140	; 0x8c
   11ae6:	ldr	r1, [sp, #20]
   11ae8:	ldr	r0, [sp, #24]
   11aea:	bl	13940 <__ssprint_r>
   11aee:	cmp	r0, #0
   11af0:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11af4:	ldr	r5, [sp, #116]	; 0x74
   11af6:	ldr	r4, [sp, #148]	; 0x94
   11af8:	add.w	r9, sp, #192	; 0xc0
   11afc:	b.n	119d2 <_svfprintf_r+0x11d2>
   11afe:	cmp.w	fp, #0
   11b02:	it	eq
   11b04:	moveq.w	fp, #1
   11b08:	b.n	117fa <_svfprintf_r+0xffa>
   11b0a:	str	r3, [sp, #40]	; 0x28
   11b0c:	mov	r7, r2
   11b0e:	b.n	115ca <_svfprintf_r+0xdca>
   11b10:	str	r3, [sp, #40]	; 0x28
   11b12:	b.n	11902 <_svfprintf_r+0x1102>
   11b14:	adds	r3, #4
   11b16:	ldr	r4, [r2, #0]
   11b18:	str	r3, [sp, #40]	; 0x28
   11b1a:	movs	r5, #0
   11b1c:	b.w	10f66 <_svfprintf_r+0x766>
   11b20:	movs	r7, #45	; 0x2d
   11b22:	str	r3, [sp, #16]
   11b24:	ldr	r3, [sp, #44]	; 0x2c
   11b26:	str	r3, [sp, #12]
   11b28:	strb.w	r7, [sp, #111]	; 0x6f
   11b2c:	mov.w	fp, #0
   11b30:	b.w	10ba6 <_svfprintf_r+0x3a6>
   11b34:	mov	r0, r6
   11b36:	bl	10680 <strlen>
   11b3a:	mov	fp, r4
   11b3c:	mov	r3, r0
   11b3e:	str	r0, [sp, #36]	; 0x24
   11b40:	b.w	11088 <_svfprintf_r+0x888>
   11b44:	add	r2, sp, #140	; 0x8c
   11b46:	ldr	r1, [sp, #20]
   11b48:	ldr	r0, [sp, #24]
   11b4a:	bl	13940 <__ssprint_r>
   11b4e:	cmp	r0, #0
   11b50:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11b54:	ldr	r4, [sp, #148]	; 0x94
   11b56:	ldr	r3, [sp, #144]	; 0x90
   11b58:	add.w	r9, sp, #192	; 0xc0
   11b5c:	ldr	r1, [sp, #56]	; 0x38
   11b5e:	str.w	r6, [r9]
   11b62:	adds	r3, #1
   11b64:	add	r4, r1
   11b66:	cmp	r3, #7
   11b68:	str	r4, [sp, #148]	; 0x94
   11b6a:	str	r3, [sp, #144]	; 0x90
   11b6c:	str.w	r1, [r9, #4]
   11b70:	ble.w	10d28 <_svfprintf_r+0x528>
   11b74:	b.w	1136e <_svfprintf_r+0xb6e>
   11b78:	ldr	r3, [sp, #116]	; 0x74
   11b7a:	adds	r5, r3, #3
   11b7c:	blt.n	11bbc <_svfprintf_r+0x13bc>
   11b7e:	cmp	fp, r3
   11b80:	blt.n	11bbc <_svfprintf_r+0x13bc>
   11b82:	str	r3, [sp, #60]	; 0x3c
   11b84:	b.n	1189e <_svfprintf_r+0x109e>
   11b86:	mov	r3, r4
   11b88:	b.n	11880 <_svfprintf_r+0x1080>
   11b8a:	add	r2, sp, #140	; 0x8c
   11b8c:	ldr	r1, [sp, #20]
   11b8e:	ldr	r0, [sp, #24]
   11b90:	bl	13940 <__ssprint_r>
   11b94:	cmp	r0, #0
   11b96:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11b9a:	ldr	r4, [sp, #148]	; 0x94
   11b9c:	add.w	r9, sp, #192	; 0xc0
   11ba0:	b.n	1143c <_svfprintf_r+0xc3c>
   11ba2:	mov	r4, r2
   11ba4:	adds	r3, #1
   11ba6:	ldr	r2, [sp, #44]	; 0x2c
   11ba8:	str	r3, [sp, #144]	; 0x90
   11baa:	add	r4, r5
   11bac:	cmp	r3, #7
   11bae:	str	r4, [sp, #148]	; 0x94
   11bb0:	stmia.w	r9, {r2, r5}
   11bb4:	bgt.n	11b44 <_svfprintf_r+0x1344>
   11bb6:	add.w	r9, r9, #8
   11bba:	b.n	11b5c <_svfprintf_r+0x135c>
   11bbc:	ldr	r2, [sp, #52]	; 0x34
   11bbe:	subs	r2, #2
   11bc0:	str	r2, [sp, #52]	; 0x34
   11bc2:	subs	r3, #1
   11bc4:	cmp	r3, #0
   11bc6:	ldrb.w	r2, [sp, #52]	; 0x34
   11bca:	str	r3, [sp, #116]	; 0x74
   11bcc:	it	lt
   11bce:	neglt	r3, r3
   11bd0:	strb.w	r2, [sp, #124]	; 0x7c
   11bd4:	ite	lt
   11bd6:	movlt	r2, #45	; 0x2d
   11bd8:	movge	r2, #43	; 0x2b
   11bda:	cmp	r3, #9
   11bdc:	strb.w	r2, [sp, #125]	; 0x7d
   11be0:	ble.w	11dba <_svfprintf_r+0x15ba>
   11be4:	add.w	r0, sp, #139	; 0x8b
   11be8:	mov	r4, r0
   11bea:	ldr	r2, [pc, #180]	; (11ca0 <_svfprintf_r+0x14a0>)
   11bec:	smull	r2, r1, r2, r3
   11bf0:	asrs	r2, r3, #31
   11bf2:	rsb	r2, r2, r1, asr #2
   11bf6:	add.w	r1, r2, r2, lsl #2
   11bfa:	sub.w	r3, r3, r1, lsl #1
   11bfe:	add.w	r1, r3, #48	; 0x30
   11c02:	cmp	r2, #9
   11c04:	mov	r3, r2
   11c06:	strb.w	r1, [r4, #-1]!
   11c0a:	bgt.n	11bea <_svfprintf_r+0x13ea>
   11c0c:	mov	r1, r4
   11c0e:	adds	r3, #48	; 0x30
   11c10:	uxtb	r2, r3
   11c12:	strb.w	r2, [r1, #-1]!
   11c16:	cmp	r0, r1
   11c18:	bls.w	11e84 <_svfprintf_r+0x1684>
   11c1c:	add.w	r1, sp, #126	; 0x7e
   11c20:	mov	r3, r4
   11c22:	b.n	11c28 <_svfprintf_r+0x1428>
   11c24:	ldrb.w	r2, [r3], #1
   11c28:	strb.w	r2, [r1], #1
   11c2c:	cmp	r0, r3
   11c2e:	bne.n	11c24 <_svfprintf_r+0x1424>
   11c30:	adds	r3, r0, #1
   11c32:	subs	r3, r3, r4
   11c34:	add.w	r2, sp, #126	; 0x7e
   11c38:	add	r3, r2
   11c3a:	add	r2, sp, #124	; 0x7c
   11c3c:	subs	r3, r3, r2
   11c3e:	ldr	r2, [sp, #56]	; 0x38
   11c40:	str	r3, [sp, #84]	; 0x54
   11c42:	cmp	r2, #1
   11c44:	add	r3, r2
   11c46:	str	r3, [sp, #36]	; 0x24
   11c48:	ble.w	11e1a <_svfprintf_r+0x161a>
   11c4c:	ldr	r3, [sp, #36]	; 0x24
   11c4e:	ldr	r2, [sp, #72]	; 0x48
   11c50:	add	r3, r2
   11c52:	movs	r2, #0
   11c54:	str	r3, [sp, #36]	; 0x24
   11c56:	str	r2, [sp, #60]	; 0x3c
   11c58:	bic.w	r3, r3, r3, asr #31
   11c5c:	b.n	118ba <_svfprintf_r+0x10ba>
   11c5e:	add	r2, sp, #140	; 0x8c
   11c60:	ldr	r1, [sp, #20]
   11c62:	ldr	r0, [sp, #24]
   11c64:	bl	13940 <__ssprint_r>
   11c68:	cmp	r0, #0
   11c6a:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11c6e:	ldr	r3, [sp, #116]	; 0x74
   11c70:	ldr	r4, [sp, #148]	; 0x94
   11c72:	add.w	r9, sp, #192	; 0xc0
   11c76:	b.n	11650 <_svfprintf_r+0xe50>
   11c78:	add	r2, sp, #140	; 0x8c
   11c7a:	ldr	r1, [sp, #20]
   11c7c:	ldr	r0, [sp, #24]
   11c7e:	bl	13940 <__ssprint_r>
   11c82:	cmp	r0, #0
   11c84:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11c88:	ldr	r3, [sp, #116]	; 0x74
   11c8a:	ldr	r2, [sp, #56]	; 0x38
   11c8c:	ldr	r4, [sp, #148]	; 0x94
   11c8e:	subs	r3, r2, r3
   11c90:	add.w	r9, sp, #192	; 0xc0
   11c94:	b.n	11680 <_svfprintf_r+0xe80>
   11c96:	nop
   11c98:	.word	0x200006a4
   11c9c:	.word	0x200008ec
   11ca0:	.word	0x66666667
   11ca4:	cmp	r5, #6
   11ca6:	mov	r3, r5
   11ca8:	it	cs
   11caa:	movcs	r3, #6
   11cac:	str	r3, [sp, #36]	; 0x24
   11cae:	bic.w	r3, r3, r3, asr #31
   11cb2:	mov	fp, r6
   11cb4:	str	r7, [sp, #40]	; 0x28
   11cb6:	str	r6, [sp, #60]	; 0x3c
   11cb8:	mov	r7, r6
   11cba:	str	r3, [sp, #16]
   11cbc:	ldr	r6, [pc, #536]	; (11ed8 <_svfprintf_r+0x16d8>)
   11cbe:	b.w	10ba4 <_svfprintf_r+0x3a4>
   11cc2:	mov.w	fp, #6
   11cc6:	b.n	117fa <_svfprintf_r+0xffa>
   11cc8:	add	r2, sp, #132	; 0x84
   11cca:	add	r3, sp, #120	; 0x78
   11ccc:	str	r2, [sp, #4]
   11cce:	str	r3, [sp, #0]
   11cd0:	mov	r2, fp
   11cd2:	add	r3, sp, #116	; 0x74
   11cd4:	movs	r1, #3
   11cd6:	vldr	d0, [sp, #96]	; 0x60
   11cda:	ldr	r0, [sp, #24]
   11cdc:	bl	12160 <_dtoa_r>
   11ce0:	mov	r5, fp
   11ce2:	mov	r6, r0
   11ce4:	add.w	r4, r0, fp
   11ce8:	b.n	11ad6 <_svfprintf_r+0x12d6>
   11cea:	movs	r7, #45	; 0x2d
   11cec:	strb.w	r7, [sp, #111]	; 0x6f
   11cf0:	b.w	10e4a <_svfprintf_r+0x64a>
   11cf4:	str	r3, [sp, #12]
   11cf6:	b.w	10fa2 <_svfprintf_r+0x7a2>
   11cfa:	ldrd	r1, r2, [sp, #64]	; 0x40
   11cfe:	add.w	r3, r2, #2147483648	; 0x80000000
   11d02:	str	r3, [sp, #100]	; 0x64
   11d04:	movs	r3, #45	; 0x2d
   11d06:	str	r1, [sp, #96]	; 0x60
   11d08:	str	r3, [sp, #16]
   11d0a:	b.n	11816 <_svfprintf_r+0x1016>
   11d0c:	ldr	r2, [sp, #72]	; 0x48
   11d0e:	ldr	r3, [sp, #56]	; 0x38
   11d10:	add	r3, r2
   11d12:	ldr	r2, [sp, #60]	; 0x3c
   11d14:	str	r3, [sp, #36]	; 0x24
   11d16:	cmp	r2, #0
   11d18:	ble.w	11e2e <_svfprintf_r+0x162e>
   11d1c:	movs	r2, #103	; 0x67
   11d1e:	bic.w	r3, r3, r3, asr #31
   11d22:	str	r2, [sp, #52]	; 0x34
   11d24:	b.n	118ba <_svfprintf_r+0x10ba>
   11d26:	ldr	r3, [sp, #52]	; 0x34
   11d28:	cmp	r3, #71	; 0x47
   11d2a:	bne.w	11858 <_svfprintf_r+0x1058>
   11d2e:	ldr	r3, [sp, #12]
   11d30:	lsls	r3, r3, #31
   11d32:	bmi.w	11aca <_svfprintf_r+0x12ca>
   11d36:	ldr	r3, [sp, #132]	; 0x84
   11d38:	cmp	r7, #71	; 0x47
   11d3a:	sub.w	r3, r3, r6
   11d3e:	str	r3, [sp, #56]	; 0x38
   11d40:	beq.w	11b78 <_svfprintf_r+0x1378>
   11d44:	ldr	r3, [sp, #116]	; 0x74
   11d46:	b.n	11bc2 <_svfprintf_r+0x13c2>
   11d48:	bic.w	r3, r5, r5, asr #31
   11d4c:	str	r7, [sp, #40]	; 0x28
   11d4e:	str	r3, [sp, #16]
   11d50:	str	r5, [sp, #36]	; 0x24
   11d52:	mov	fp, r0
   11d54:	str	r0, [sp, #60]	; 0x3c
   11d56:	ldrb.w	r7, [sp, #111]	; 0x6f
   11d5a:	b.w	10ba4 <_svfprintf_r+0x3a4>
   11d5e:	cmp	r3, #0
   11d60:	ble.n	11e3e <_svfprintf_r+0x163e>
   11d62:	cmp.w	fp, #0
   11d66:	bne.n	11e08 <_svfprintf_r+0x1608>
   11d68:	ldr	r2, [sp, #12]
   11d6a:	lsls	r4, r2, #31
   11d6c:	bmi.n	11e08 <_svfprintf_r+0x1608>
   11d6e:	mov	r2, r3
   11d70:	str	r2, [sp, #36]	; 0x24
   11d72:	bic.w	r3, r3, r3, asr #31
   11d76:	b.n	118ba <_svfprintf_r+0x10ba>
   11d78:	ldr	r3, [sp, #12]
   11d7a:	lsls	r3, r3, #31
   11d7c:	mov	r7, fp
   11d7e:	bpl.n	11d8c <_svfprintf_r+0x158c>
   11d80:	add	r6, sp, #256	; 0x100
   11d82:	movs	r3, #48	; 0x30
   11d84:	strb.w	r3, [r6, #-65]!
   11d88:	b.w	10b90 <_svfprintf_r+0x390>
   11d8c:	str.w	fp, [sp, #36]	; 0x24
   11d90:	add	r6, sp, #192	; 0xc0
   11d92:	b.w	10b96 <_svfprintf_r+0x396>
   11d96:	add	r2, sp, #140	; 0x8c
   11d98:	ldr	r1, [sp, #20]
   11d9a:	ldr	r0, [sp, #24]
   11d9c:	bl	13940 <__ssprint_r>
   11da0:	cmp	r0, #0
   11da2:	bne.w	109f4 <_svfprintf_r+0x1f4>
   11da6:	ldr	r5, [sp, #116]	; 0x74
   11da8:	ldr	r4, [sp, #148]	; 0x94
   11daa:	ldr	r3, [sp, #144]	; 0x90
   11dac:	add.w	r9, sp, #192	; 0xc0
   11db0:	b.n	11a00 <_svfprintf_r+0x1200>
   11db2:	mov	r8, r4
   11db4:	movs	r5, #0
   11db6:	b.w	108b8 <_svfprintf_r+0xb8>
   11dba:	adds	r3, #48	; 0x30
   11dbc:	movs	r2, #48	; 0x30
   11dbe:	strb.w	r3, [sp, #127]	; 0x7f
   11dc2:	strb.w	r2, [sp, #126]	; 0x7e
   11dc6:	add	r3, sp, #128	; 0x80
   11dc8:	b.n	11c3a <_svfprintf_r+0x143a>
   11dca:	ldr	r3, [sp, #132]	; 0x84
   11dcc:	b.n	11880 <_svfprintf_r+0x1080>
   11dce:	ldr	r2, [sp, #72]	; 0x48
   11dd0:	ldr	r3, [sp, #60]	; 0x3c
   11dd2:	add	r3, r2
   11dd4:	movs	r2, #103	; 0x67
   11dd6:	str	r3, [sp, #36]	; 0x24
   11dd8:	str	r2, [sp, #52]	; 0x34
   11dda:	bic.w	r3, r3, r3, asr #31
   11dde:	b.n	118ba <_svfprintf_r+0x10ba>
   11de0:	ldr	r6, [pc, #248]	; (11edc <_svfprintf_r+0x16dc>)
   11de2:	ldr	r3, [pc, #252]	; (11ee0 <_svfprintf_r+0x16e0>)
   11de4:	ldrb.w	r7, [sp, #111]	; 0x6f
   11de8:	b.w	10e4e <_svfprintf_r+0x64e>
   11dec:	movs	r2, #0
   11dee:	movs	r3, #0
   11df0:	ldrd	r0, r1, [sp, #96]	; 0x60
   11df4:	bl	f3b0 <__aeabi_dcmpeq>
   11df8:	cmp	r0, #0
   11dfa:	bne.w	11ade <_svfprintf_r+0x12de>
   11dfe:	rsb	r5, r5, #1
   11e02:	str	r5, [sp, #116]	; 0x74
   11e04:	add	r4, r5
   11e06:	b.n	1185a <_svfprintf_r+0x105a>
   11e08:	ldr	r3, [sp, #60]	; 0x3c
   11e0a:	ldr	r2, [sp, #72]	; 0x48
   11e0c:	adds	r5, r3, r2
   11e0e:	add.w	r3, r5, fp
   11e12:	str	r3, [sp, #36]	; 0x24
   11e14:	bic.w	r3, r3, r3, asr #31
   11e18:	b.n	118ba <_svfprintf_r+0x10ba>
   11e1a:	ldr	r3, [sp, #12]
   11e1c:	ands.w	r3, r3, #1
   11e20:	bne.w	11c4c <_svfprintf_r+0x144c>
   11e24:	str	r3, [sp, #60]	; 0x3c
   11e26:	ldr	r3, [sp, #36]	; 0x24
   11e28:	bic.w	r3, r3, r3, asr #31
   11e2c:	b.n	118ba <_svfprintf_r+0x10ba>
   11e2e:	ldr	r3, [sp, #60]	; 0x3c
   11e30:	ldr	r2, [sp, #36]	; 0x24
   11e32:	rsb	r3, r3, #1
   11e36:	add	r2, r3
   11e38:	mov	r3, r2
   11e3a:	str	r2, [sp, #36]	; 0x24
   11e3c:	b.n	11d1c <_svfprintf_r+0x151c>
   11e3e:	cmp.w	fp, #0
   11e42:	bne.n	11e4a <_svfprintf_r+0x164a>
   11e44:	ldr	r3, [sp, #12]
   11e46:	lsls	r0, r3, #31
   11e48:	bpl.n	11e5a <_svfprintf_r+0x165a>
   11e4a:	ldr	r3, [sp, #72]	; 0x48
   11e4c:	adds	r5, r3, #1
   11e4e:	add.w	r3, r5, fp
   11e52:	str	r3, [sp, #36]	; 0x24
   11e54:	bic.w	r3, r3, r3, asr #31
   11e58:	b.n	118ba <_svfprintf_r+0x10ba>
   11e5a:	movs	r3, #1
   11e5c:	str	r3, [sp, #36]	; 0x24
   11e5e:	b.n	118ba <_svfprintf_r+0x10ba>
   11e60:	ldr	r0, [sp, #40]	; 0x28
   11e62:	ldrb.w	r3, [r8, #1]
   11e66:	ldr	r5, [r0, #0]
   11e68:	adds	r0, #4
   11e6a:	cmp	r5, #0
   11e6c:	str	r0, [sp, #40]	; 0x28
   11e6e:	mov	r8, r4
   11e70:	bge.w	108b4 <_svfprintf_r+0xb4>
   11e74:	mov.w	r5, #4294967295
   11e78:	b.w	108b4 <_svfprintf_r+0xb4>
   11e7c:	strb.w	r1, [sp, #111]	; 0x6f
   11e80:	b.w	10a16 <_svfprintf_r+0x216>
   11e84:	add.w	r3, sp, #126	; 0x7e
   11e88:	b.n	11c3a <_svfprintf_r+0x143a>
   11e8a:	ldr	r2, [sp, #24]
   11e8c:	movs	r3, #12
   11e8e:	str	r3, [r2, #0]
   11e90:	mov.w	r0, #4294967295
   11e94:	b.w	10a06 <_svfprintf_r+0x206>
   11e98:	strb.w	r1, [sp, #111]	; 0x6f
   11e9c:	b.w	10b10 <_svfprintf_r+0x310>
   11ea0:	strb.w	r1, [sp, #111]	; 0x6f
   11ea4:	b.w	10ddc <_svfprintf_r+0x5dc>
   11ea8:	strb.w	r1, [sp, #111]	; 0x6f
   11eac:	b.w	10f4a <_svfprintf_r+0x74a>
   11eb0:	strb.w	r1, [sp, #111]	; 0x6f
   11eb4:	b.w	10eee <_svfprintf_r+0x6ee>
   11eb8:	strb.w	r1, [sp, #111]	; 0x6f
   11ebc:	b.w	10e9a <_svfprintf_r+0x69a>
   11ec0:	strb.w	r1, [sp, #111]	; 0x6f
   11ec4:	b.w	11132 <_svfprintf_r+0x932>
   11ec8:	strb.w	r1, [sp, #111]	; 0x6f
   11ecc:	b.w	110f0 <_svfprintf_r+0x8f0>
   11ed0:	strb.w	r1, [sp, #111]	; 0x6f
   11ed4:	b.w	110b4 <_svfprintf_r+0x8b4>
   11ed8:	.word	0x20000934
   11edc:	.word	0x20000908
   11ee0:	.word	0x20000904

00011ee4 <_vdprintf_r>:
   11ee4:	push	{r4, r5, r6, r7, lr}
   11ee6:	sub.w	sp, sp, #532	; 0x214
   11eea:	add	r5, sp, #16
   11eec:	str	r3, [sp, #0]
   11eee:	mov	r7, r1
   11ef0:	mov	r3, r2
   11ef2:	mov.w	r4, #512	; 0x200
   11ef6:	add	r2, sp, #12
   11ef8:	mov	r1, r5
   11efa:	str	r4, [sp, #12]
   11efc:	mov	r6, r0
   11efe:	bl	13a40 <_vasnprintf_r>
   11f02:	cbz	r0, 11f28 <_vdprintf_r+0x44>
   11f04:	mov	r4, r0
   11f06:	mov	r2, r0
   11f08:	mov	r1, r7
   11f0a:	ldr	r3, [sp, #12]
   11f0c:	mov	r0, r6
   11f0e:	bl	11f64 <_write_r>
   11f12:	cmp	r4, r5
   11f14:	str	r0, [sp, #12]
   11f16:	beq.n	11f22 <_vdprintf_r+0x3e>
   11f18:	mov	r0, r6
   11f1a:	mov	r1, r4
   11f1c:	bl	13130 <_free_r>
   11f20:	ldr	r0, [sp, #12]
   11f22:	add.w	sp, sp, #532	; 0x214
   11f26:	pop	{r4, r5, r6, r7, pc}
   11f28:	mov.w	r0, #4294967295
   11f2c:	b.n	11f22 <_vdprintf_r+0x3e>
   11f2e:	nop

00011f30 <vdprintf>:
   11f30:	push	{r4}
   11f32:	ldr	r4, [pc, #16]	; (11f44 <vdprintf+0x14>)
   11f34:	mov	r3, r2
   11f36:	mov	r2, r1
   11f38:	mov	r1, r0
   11f3a:	ldr	r0, [r4, #0]
   11f3c:	ldr.w	r4, [sp], #4
   11f40:	b.w	11ee4 <_vdprintf_r>
   11f44:	.word	0x20001118

00011f48 <__ascii_wctomb>:
   11f48:	cbz	r1, 11f54 <__ascii_wctomb+0xc>
   11f4a:	cmp	r2, #255	; 0xff
   11f4c:	bhi.n	11f58 <__ascii_wctomb+0x10>
   11f4e:	strb	r2, [r1, #0]
   11f50:	movs	r0, #1
   11f52:	bx	lr
   11f54:	mov	r0, r1
   11f56:	bx	lr
   11f58:	movs	r3, #138	; 0x8a
   11f5a:	str	r3, [r0, #0]
   11f5c:	mov.w	r0, #4294967295
   11f60:	bx	lr
   11f62:	nop

00011f64 <_write_r>:
   11f64:	push	{r4, r5, r6, lr}
   11f66:	mov	r5, r1
   11f68:	ldr	r4, [pc, #32]	; (11f8c <_write_r+0x28>)
   11f6a:	mov	r1, r2
   11f6c:	mov	r6, r0
   11f6e:	mov	r2, r3
   11f70:	mov	r0, r5
   11f72:	movs	r3, #0
   11f74:	str	r3, [r4, #0]
   11f76:	bl	e980 <_write>
   11f7a:	adds	r3, r0, #1
   11f7c:	beq.n	11f80 <_write_r+0x1c>
   11f7e:	pop	{r4, r5, r6, pc}
   11f80:	ldr	r3, [r4, #0]
   11f82:	cmp	r3, #0
   11f84:	beq.n	11f7e <_write_r+0x1a>
   11f86:	str	r3, [r6, #0]
   11f88:	pop	{r4, r5, r6, pc}
   11f8a:	nop
   11f8c:	.word	0x200052dc

00011f90 <__register_exitproc>:
   11f90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11f94:	ldr	r4, [pc, #148]	; (1202c <__register_exitproc+0x9c>)
   11f96:	ldr	r5, [r4, #0]
   11f98:	ldr.w	r4, [r5, #328]	; 0x148
   11f9c:	mov	r6, r0
   11f9e:	mov	r8, r1
   11fa0:	mov	sl, r2
   11fa2:	mov	r9, r3
   11fa4:	cbz	r4, 12018 <__register_exitproc+0x88>
   11fa6:	ldr	r0, [r4, #4]
   11fa8:	cmp	r0, #31
   11faa:	bgt.n	11fdc <__register_exitproc+0x4c>
   11fac:	adds	r3, r0, #1
   11fae:	cbz	r6, 11fce <__register_exitproc+0x3e>
   11fb0:	add.w	r5, r4, r0, lsl #2
   11fb4:	movs	r2, #1
   11fb6:	str.w	sl, [r5, #136]	; 0x88
   11fba:	ldr.w	r1, [r4, #392]	; 0x188
   11fbe:	lsls	r2, r0
   11fc0:	orrs	r1, r2
   11fc2:	cmp	r6, #2
   11fc4:	str.w	r1, [r4, #392]	; 0x188
   11fc8:	str.w	r9, [r5, #264]	; 0x108
   11fcc:	beq.n	1200c <__register_exitproc+0x7c>
   11fce:	adds	r0, #2
   11fd0:	str	r3, [r4, #4]
   11fd2:	str.w	r8, [r4, r0, lsl #2]
   11fd6:	movs	r0, #0
   11fd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11fdc:	ldr	r3, [pc, #80]	; (12030 <__register_exitproc+0xa0>)
   11fde:	cbz	r3, 12022 <__register_exitproc+0x92>
   11fe0:	mov.w	r0, #400	; 0x190
   11fe4:	bl	f894 <malloc>
   11fe8:	mov	r4, r0
   11fea:	cbz	r0, 12022 <__register_exitproc+0x92>
   11fec:	ldr.w	r3, [r5, #328]	; 0x148
   11ff0:	movs	r7, #0
   11ff2:	stmia.w	r0, {r3, r7}
   11ff6:	str.w	r4, [r5, #328]	; 0x148
   11ffa:	mov	r0, r7
   11ffc:	movs	r3, #1
   11ffe:	str.w	r7, [r4, #392]	; 0x188
   12002:	str.w	r7, [r4, #396]	; 0x18c
   12006:	cmp	r6, #0
   12008:	beq.n	11fce <__register_exitproc+0x3e>
   1200a:	b.n	11fb0 <__register_exitproc+0x20>
   1200c:	ldr.w	r1, [r4, #396]	; 0x18c
   12010:	orrs	r2, r1
   12012:	str.w	r2, [r4, #396]	; 0x18c
   12016:	b.n	11fce <__register_exitproc+0x3e>
   12018:	add.w	r4, r5, #332	; 0x14c
   1201c:	str.w	r4, [r5, #328]	; 0x148
   12020:	b.n	11fa6 <__register_exitproc+0x16>
   12022:	mov.w	r0, #4294967295
   12026:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1202a:	nop
   1202c:	.word	0x200008d8
   12030:	.word	0x0000f895

00012034 <quorem>:
   12034:	ldr	r2, [r0, #16]
   12036:	ldr	r3, [r1, #16]
   12038:	cmp	r3, r2
   1203a:	bgt.w	12158 <quorem+0x124>
   1203e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12042:	add.w	r8, r3, #4294967295
   12046:	add.w	r7, r1, #20
   1204a:	add.w	fp, r0, #20
   1204e:	ldr.w	r2, [r7, r8, lsl #2]
   12052:	ldr.w	r3, [fp, r8, lsl #2]
   12056:	mov.w	r4, r8, lsl #2
   1205a:	sub	sp, #12
   1205c:	adds	r2, #1
   1205e:	udiv	r9, r3, r2
   12062:	add.w	r3, fp, r4
   12066:	str	r4, [sp, #0]
   12068:	add.w	sl, r7, r4
   1206c:	str	r3, [sp, #4]
   1206e:	cmp.w	r9, #0
   12072:	beq.n	120e8 <quorem+0xb4>
   12074:	movs	r5, #0
   12076:	mov	ip, r7
   12078:	mov	lr, fp
   1207a:	mov	r3, r5
   1207c:	ldr.w	r6, [ip], #4
   12080:	ldr.w	r2, [lr]
   12084:	uxth	r4, r6
   12086:	mla	r5, r9, r4, r5
   1208a:	lsrs	r6, r6, #16
   1208c:	lsrs	r4, r5, #16
   1208e:	mla	r4, r9, r6, r4
   12092:	uxth	r5, r5
   12094:	subs	r3, r3, r5
   12096:	uxth	r6, r4
   12098:	uxtah	r3, r3, r2
   1209c:	rsb	r6, r6, r2, lsr #16
   120a0:	add.w	r6, r6, r3, asr #16
   120a4:	uxth	r3, r3
   120a6:	orr.w	r3, r3, r6, lsl #16
   120aa:	cmp	sl, ip
   120ac:	str.w	r3, [lr], #4
   120b0:	mov.w	r5, r4, lsr #16
   120b4:	mov.w	r3, r6, asr #16
   120b8:	bcs.n	1207c <quorem+0x48>
   120ba:	ldr	r3, [sp, #0]
   120bc:	ldr.w	r3, [fp, r3]
   120c0:	cbnz	r3, 120e8 <quorem+0xb4>
   120c2:	ldr	r4, [sp, #4]
   120c4:	subs	r3, r4, #4
   120c6:	cmp	fp, r3
   120c8:	bcs.n	120e4 <quorem+0xb0>
   120ca:	ldr.w	r3, [r4, #-4]
   120ce:	cbnz	r3, 120e4 <quorem+0xb0>
   120d0:	sub.w	r3, r4, #8
   120d4:	b.n	120dc <quorem+0xa8>
   120d6:	ldr	r2, [r3, #0]
   120d8:	subs	r3, #4
   120da:	cbnz	r2, 120e4 <quorem+0xb0>
   120dc:	cmp	fp, r3
   120de:	add.w	r8, r8, #4294967295
   120e2:	bcc.n	120d6 <quorem+0xa2>
   120e4:	str.w	r8, [r0, #16]
   120e8:	mov	r4, r0
   120ea:	bl	1372c <__mcmp>
   120ee:	cmp	r0, #0
   120f0:	blt.n	12150 <quorem+0x11c>
   120f2:	add.w	r9, r9, #1
   120f6:	mov	r5, fp
   120f8:	movs	r3, #0
   120fa:	ldr.w	r1, [r7], #4
   120fe:	ldr	r0, [r5, #0]
   12100:	uxth	r2, r1
   12102:	subs	r2, r3, r2
   12104:	lsrs	r1, r1, #16
   12106:	uxtah	r2, r2, r0
   1210a:	rsb	r3, r1, r0, lsr #16
   1210e:	add.w	r3, r3, r2, asr #16
   12112:	uxth	r1, r2
   12114:	orr.w	r1, r1, r3, lsl #16
   12118:	cmp	sl, r7
   1211a:	str.w	r1, [r5], #4
   1211e:	mov.w	r3, r3, asr #16
   12122:	bcs.n	120fa <quorem+0xc6>
   12124:	ldr.w	r2, [fp, r8, lsl #2]
   12128:	add.w	r3, fp, r8, lsl #2
   1212c:	cbnz	r2, 12150 <quorem+0x11c>
   1212e:	subs	r2, r3, #4
   12130:	cmp	fp, r2
   12132:	bcs.n	1214c <quorem+0x118>
   12134:	ldr.w	r2, [r3, #-4]
   12138:	cbnz	r2, 1214c <quorem+0x118>
   1213a:	subs	r3, #8
   1213c:	b.n	12144 <quorem+0x110>
   1213e:	ldr	r2, [r3, #0]
   12140:	subs	r3, #4
   12142:	cbnz	r2, 1214c <quorem+0x118>
   12144:	cmp	fp, r3
   12146:	add.w	r8, r8, #4294967295
   1214a:	bcc.n	1213e <quorem+0x10a>
   1214c:	str.w	r8, [r4, #16]
   12150:	mov	r0, r9
   12152:	add	sp, #12
   12154:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12158:	movs	r0, #0
   1215a:	bx	lr
   1215c:	movs	r0, r0
	...

00012160 <_dtoa_r>:
   12160:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12164:	vmov	r6, r7, d0
   12168:	sub	sp, #108	; 0x6c
   1216a:	ldr	r4, [r0, #64]	; 0x40
   1216c:	ldr	r5, [sp, #144]	; 0x90
   1216e:	str	r1, [sp, #0]
   12170:	mov	r9, r0
   12172:	str	r2, [sp, #20]
   12174:	str	r3, [sp, #12]
   12176:	vmov	sl, s0
   1217a:	mov	fp, r7
   1217c:	cbz	r4, 12194 <_dtoa_r+0x34>
   1217e:	ldr	r2, [r0, #68]	; 0x44
   12180:	str	r2, [r4, #4]
   12182:	movs	r3, #1
   12184:	lsls	r3, r2
   12186:	str	r3, [r4, #8]
   12188:	mov	r1, r4
   1218a:	bl	13368 <_Bfree>
   1218e:	movs	r3, #0
   12190:	str.w	r3, [r9, #64]	; 0x40
   12194:	cmp.w	fp, #0
   12198:	mov	r4, fp
   1219a:	blt.n	12206 <_dtoa_r+0xa6>
   1219c:	movs	r3, #0
   1219e:	str	r3, [r5, #0]
   121a0:	ldr	r3, [pc, #644]	; (12428 <_dtoa_r+0x2c8>)
   121a2:	mov	r2, r3
   121a4:	ands	r3, r4
   121a6:	cmp	r3, r2
   121a8:	beq.n	121d8 <_dtoa_r+0x78>
   121aa:	movs	r2, #0
   121ac:	movs	r3, #0
   121ae:	mov	r0, sl
   121b0:	mov	r1, fp
   121b2:	bl	f3b0 <__aeabi_dcmpeq>
   121b6:	mov	r6, sl
   121b8:	mov	r7, fp
   121ba:	mov	r8, r0
   121bc:	cbz	r0, 12212 <_dtoa_r+0xb2>
   121be:	ldr	r2, [sp, #12]
   121c0:	movs	r3, #1
   121c2:	str	r3, [r2, #0]
   121c4:	ldr	r3, [sp, #148]	; 0x94
   121c6:	cmp	r3, #0
   121c8:	beq.w	12348 <_dtoa_r+0x1e8>
   121cc:	ldr	r0, [pc, #604]	; (1242c <_dtoa_r+0x2cc>)
   121ce:	str	r0, [r3, #0]
   121d0:	subs	r0, #1
   121d2:	add	sp, #108	; 0x6c
   121d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   121d8:	ldr	r2, [sp, #12]
   121da:	movw	r3, #9999	; 0x270f
   121de:	str	r3, [r2, #0]
   121e0:	cmp.w	sl, #0
   121e4:	beq.w	1231c <_dtoa_r+0x1bc>
   121e8:	ldr	r0, [pc, #580]	; (12430 <_dtoa_r+0x2d0>)
   121ea:	ldr	r3, [sp, #148]	; 0x94
   121ec:	cmp	r3, #0
   121ee:	beq.n	121d2 <_dtoa_r+0x72>
   121f0:	ldrb	r3, [r0, #3]
   121f2:	cmp	r3, #0
   121f4:	beq.w	1234c <_dtoa_r+0x1ec>
   121f8:	add.w	r3, r0, #8
   121fc:	ldr	r2, [sp, #148]	; 0x94
   121fe:	str	r3, [r2, #0]
   12200:	add	sp, #108	; 0x6c
   12202:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12206:	movs	r3, #1
   12208:	bic.w	r4, fp, #2147483648	; 0x80000000
   1220c:	str	r3, [r5, #0]
   1220e:	mov	fp, r4
   12210:	b.n	121a0 <_dtoa_r+0x40>
   12212:	add	r2, sp, #96	; 0x60
   12214:	add	r1, sp, #100	; 0x64
   12216:	vmov	d0, r6, r7
   1221a:	mov	r0, r9
   1221c:	bl	13884 <__d2b>
   12220:	lsrs	r5, r4, #20
   12222:	str	r0, [sp, #40]	; 0x28
   12224:	bne.w	1232e <_dtoa_r+0x1ce>
   12228:	ldr	r5, [sp, #96]	; 0x60
   1222a:	ldr	r6, [sp, #100]	; 0x64
   1222c:	add	r6, r5
   1222e:	addw	r3, r6, #1074	; 0x432
   12232:	cmp	r3, #32
   12234:	ble.w	12748 <_dtoa_r+0x5e8>
   12238:	rsb	r3, r3, #64	; 0x40
   1223c:	addw	r0, r6, #1042	; 0x412
   12240:	lsls	r4, r3
   12242:	lsr.w	r0, sl, r0
   12246:	orrs	r0, r4
   12248:	bl	edf4 <__aeabi_ui2d>
   1224c:	movs	r3, #1
   1224e:	subs	r4, r6, #1
   12250:	sub.w	r1, r1, #32505856	; 0x1f00000
   12254:	str	r3, [sp, #60]	; 0x3c
   12256:	movs	r2, #0
   12258:	ldr	r3, [pc, #472]	; (12434 <_dtoa_r+0x2d4>)
   1225a:	bl	eb78 <__aeabi_dsub>
   1225e:	add	r3, pc, #432	; (adr r3, 12410 <_dtoa_r+0x2b0>)
   12260:	ldrd	r2, r3, [r3]
   12264:	bl	eee0 <__aeabi_dmul>
   12268:	add	r3, pc, #428	; (adr r3, 12418 <_dtoa_r+0x2b8>)
   1226a:	ldrd	r2, r3, [r3]
   1226e:	bl	eb7c <__adddf3>
   12272:	mov	r6, r0
   12274:	mov	r0, r4
   12276:	mov	r7, r1
   12278:	bl	ee14 <__aeabi_i2d>
   1227c:	add	r3, pc, #416	; (adr r3, 12420 <_dtoa_r+0x2c0>)
   1227e:	ldrd	r2, r3, [r3]
   12282:	bl	eee0 <__aeabi_dmul>
   12286:	mov	r2, r0
   12288:	mov	r3, r1
   1228a:	mov	r0, r6
   1228c:	mov	r1, r7
   1228e:	bl	eb7c <__adddf3>
   12292:	mov	r6, r0
   12294:	mov	r7, r1
   12296:	bl	f440 <__aeabi_d2iz>
   1229a:	movs	r2, #0
   1229c:	str	r0, [sp, #16]
   1229e:	movs	r3, #0
   122a0:	mov	r0, r6
   122a2:	mov	r1, r7
   122a4:	bl	f3c4 <__aeabi_dcmplt>
   122a8:	cmp	r0, #0
   122aa:	bne.w	126fe <_dtoa_r+0x59e>
   122ae:	ldr	r6, [sp, #16]
   122b0:	cmp	r6, #22
   122b2:	bhi.w	126f8 <_dtoa_r+0x598>
   122b6:	ldr	r3, [pc, #384]	; (12438 <_dtoa_r+0x2d8>)
   122b8:	add.w	r3, r3, r6, lsl #3
   122bc:	ldrd	r0, r1, [r3]
   122c0:	mov	r2, sl
   122c2:	mov	r3, fp
   122c4:	bl	f400 <__aeabi_dcmpgt>
   122c8:	cmp	r0, #0
   122ca:	beq.w	12752 <_dtoa_r+0x5f2>
   122ce:	subs	r3, r6, #1
   122d0:	str	r3, [sp, #16]
   122d2:	movs	r3, #0
   122d4:	str	r3, [sp, #52]	; 0x34
   122d6:	subs	r5, r5, r4
   122d8:	subs.w	r8, r5, #1
   122dc:	bmi.w	12734 <_dtoa_r+0x5d4>
   122e0:	movs	r3, #0
   122e2:	str	r3, [sp, #28]
   122e4:	ldr	r3, [sp, #16]
   122e6:	cmp	r3, #0
   122e8:	blt.w	12722 <_dtoa_r+0x5c2>
   122ec:	add	r8, r3
   122ee:	str	r3, [sp, #48]	; 0x30
   122f0:	movs	r3, #0
   122f2:	str	r3, [sp, #24]
   122f4:	ldr	r3, [sp, #0]
   122f6:	cmp	r3, #9
   122f8:	bhi.n	12350 <_dtoa_r+0x1f0>
   122fa:	cmp	r3, #5
   122fc:	ble.w	12f88 <_dtoa_r+0xe28>
   12300:	subs	r3, #4
   12302:	str	r3, [sp, #0]
   12304:	movs	r6, #0
   12306:	ldr	r3, [sp, #0]
   12308:	subs	r3, #2
   1230a:	cmp	r3, #3
   1230c:	bhi.w	12f56 <_dtoa_r+0xdf6>
   12310:	tbh	[pc, r3, lsl #1]
   12314:	.word	0x0224032b
   12318:	.word	0x04500336
   1231c:	ldr	r3, [pc, #272]	; (12430 <_dtoa_r+0x2d0>)
   1231e:	ldr	r2, [pc, #284]	; (1243c <_dtoa_r+0x2dc>)
   12320:	ubfx	r0, r4, #0, #20
   12324:	cmp	r0, #0
   12326:	ite	ne
   12328:	movne	r0, r3
   1232a:	moveq	r0, r2
   1232c:	b.n	121ea <_dtoa_r+0x8a>
   1232e:	ubfx	r3, fp, #0, #20
   12332:	orr.w	r1, r3, #1069547520	; 0x3fc00000
   12336:	subw	r4, r5, #1023	; 0x3ff
   1233a:	mov	r0, sl
   1233c:	str.w	r8, [sp, #60]	; 0x3c
   12340:	orr.w	r1, r1, #3145728	; 0x300000
   12344:	ldr	r5, [sp, #96]	; 0x60
   12346:	b.n	12256 <_dtoa_r+0xf6>
   12348:	ldr	r0, [pc, #244]	; (12440 <_dtoa_r+0x2e0>)
   1234a:	b.n	121d2 <_dtoa_r+0x72>
   1234c:	adds	r3, r0, #3
   1234e:	b.n	121fc <_dtoa_r+0x9c>
   12350:	movs	r1, #0
   12352:	str.w	r1, [r9, #68]	; 0x44
   12356:	mov	r0, r9
   12358:	mov	r4, r1
   1235a:	str	r1, [sp, #0]
   1235c:	bl	1331c <_Balloc>
   12360:	mov.w	r3, #4294967295
   12364:	str	r3, [sp, #32]
   12366:	str	r3, [sp, #56]	; 0x38
   12368:	movs	r3, #1
   1236a:	str	r0, [sp, #36]	; 0x24
   1236c:	str.w	r0, [r9, #64]	; 0x40
   12370:	str	r4, [sp, #20]
   12372:	str	r3, [sp, #44]	; 0x2c
   12374:	ldr	r3, [sp, #100]	; 0x64
   12376:	cmp	r3, #0
   12378:	blt.w	1251c <_dtoa_r+0x3bc>
   1237c:	ldr	r2, [sp, #16]
   1237e:	cmp	r2, #14
   12380:	bgt.w	1251c <_dtoa_r+0x3bc>
   12384:	ldr	r3, [pc, #176]	; (12438 <_dtoa_r+0x2d8>)
   12386:	add.w	r3, r3, r2, lsl #3
   1238a:	vldr	d7, [r3]
   1238e:	ldr	r3, [sp, #20]
   12390:	cmp	r3, #0
   12392:	vstr	d7, [sp]
   12396:	blt.w	12996 <_dtoa_r+0x836>
   1239a:	mov	r6, sl
   1239c:	mov	r7, fp
   1239e:	ldrd	sl, fp, [sp]
   123a2:	mov	r0, r6
   123a4:	mov	r2, sl
   123a6:	mov	r3, fp
   123a8:	mov	r1, r7
   123aa:	bl	f134 <__aeabi_ddiv>
   123ae:	bl	f440 <__aeabi_d2iz>
   123b2:	mov	r4, r0
   123b4:	bl	ee14 <__aeabi_i2d>
   123b8:	mov	r2, sl
   123ba:	mov	r3, fp
   123bc:	bl	eee0 <__aeabi_dmul>
   123c0:	mov	r3, r1
   123c2:	mov	r2, r0
   123c4:	mov	r1, r7
   123c6:	mov	r0, r6
   123c8:	bl	eb78 <__aeabi_dsub>
   123cc:	ldr	r5, [sp, #36]	; 0x24
   123ce:	add.w	r3, r4, #48	; 0x30
   123d2:	strb	r3, [r5, #0]
   123d4:	ldr	r3, [sp, #32]
   123d6:	cmp	r3, #1
   123d8:	mov	r6, r0
   123da:	mov	r7, r1
   123dc:	add.w	r5, r5, #1
   123e0:	beq.n	124a6 <_dtoa_r+0x346>
   123e2:	movs	r2, #0
   123e4:	ldr	r3, [pc, #92]	; (12444 <_dtoa_r+0x2e4>)
   123e6:	bl	eee0 <__aeabi_dmul>
   123ea:	movs	r2, #0
   123ec:	movs	r3, #0
   123ee:	mov	r6, r0
   123f0:	mov	r7, r1
   123f2:	bl	f3b0 <__aeabi_dcmpeq>
   123f6:	cmp	r0, #0
   123f8:	bne.n	124f6 <_dtoa_r+0x396>
   123fa:	str.w	r9, [sp, #20]
   123fe:	ldr.w	sl, [sp, #32]
   12402:	ldr.w	fp, [sp, #36]	; 0x24
   12406:	ldrd	r8, r9, [sp]
   1240a:	b.n	1245e <_dtoa_r+0x2fe>
   1240c:	nop.w
   12410:	.word	0x636f4361
   12414:	.word	0x3fd287a7
   12418:	.word	0x8b60c8b3
   1241c:	.word	0x3fc68a28
   12420:	.word	0x509f79fb
   12424:	.word	0x3fd34413
   12428:	.word	0x7ff00000
   1242c:	.word	0x200006a5
   12430:	.word	0x20000a5c
   12434:	.word	0x3ff80000
   12438:	.word	0x20000a60
   1243c:	.word	0x20000a50
   12440:	.word	0x200006a4
   12444:	.word	0x40240000
   12448:	bl	eee0 <__aeabi_dmul>
   1244c:	movs	r2, #0
   1244e:	movs	r3, #0
   12450:	mov	r6, r0
   12452:	mov	r7, r1
   12454:	bl	f3b0 <__aeabi_dcmpeq>
   12458:	cmp	r0, #0
   1245a:	bne.w	12bba <_dtoa_r+0xa5a>
   1245e:	mov	r2, r8
   12460:	mov	r3, r9
   12462:	mov	r0, r6
   12464:	mov	r1, r7
   12466:	bl	f134 <__aeabi_ddiv>
   1246a:	bl	f440 <__aeabi_d2iz>
   1246e:	mov	r4, r0
   12470:	bl	ee14 <__aeabi_i2d>
   12474:	mov	r2, r8
   12476:	mov	r3, r9
   12478:	bl	eee0 <__aeabi_dmul>
   1247c:	mov	r2, r0
   1247e:	mov	r3, r1
   12480:	mov	r0, r6
   12482:	mov	r1, r7
   12484:	bl	eb78 <__aeabi_dsub>
   12488:	add.w	lr, r4, #48	; 0x30
   1248c:	strb.w	lr, [r5], #1
   12490:	rsb	lr, fp, r5
   12494:	cmp	lr, sl
   12496:	mov	r6, r0
   12498:	mov	r7, r1
   1249a:	mov.w	r2, #0
   1249e:	ldr	r3, [pc, #696]	; (12758 <_dtoa_r+0x5f8>)
   124a0:	bne.n	12448 <_dtoa_r+0x2e8>
   124a2:	ldr.w	r9, [sp, #20]
   124a6:	mov	r2, r6
   124a8:	mov	r3, r7
   124aa:	mov	r0, r6
   124ac:	mov	r1, r7
   124ae:	bl	eb7c <__adddf3>
   124b2:	mov	r6, r0
   124b4:	mov	r7, r1
   124b6:	mov	r2, r0
   124b8:	mov	r3, r1
   124ba:	ldrd	r0, r1, [sp]
   124be:	bl	f3c4 <__aeabi_dcmplt>
   124c2:	cbnz	r0, 124d6 <_dtoa_r+0x376>
   124c4:	mov	r2, r6
   124c6:	mov	r3, r7
   124c8:	ldrd	r0, r1, [sp]
   124cc:	bl	f3b0 <__aeabi_dcmpeq>
   124d0:	cbz	r0, 124f6 <_dtoa_r+0x396>
   124d2:	lsls	r3, r4, #31
   124d4:	bpl.n	124f6 <_dtoa_r+0x396>
   124d6:	ldrb.w	r4, [r5, #-1]
   124da:	ldr	r2, [sp, #36]	; 0x24
   124dc:	subs	r3, r5, #1
   124de:	b.n	124ea <_dtoa_r+0x38a>
   124e0:	cmp	r2, r3
   124e2:	beq.w	12cde <_dtoa_r+0xb7e>
   124e6:	ldrb.w	r4, [r3, #-1]!
   124ea:	cmp	r4, #57	; 0x39
   124ec:	add.w	r5, r3, #1
   124f0:	beq.n	124e0 <_dtoa_r+0x380>
   124f2:	adds	r4, #1
   124f4:	strb	r4, [r3, #0]
   124f6:	ldr	r1, [sp, #40]	; 0x28
   124f8:	mov	r0, r9
   124fa:	bl	13368 <_Bfree>
   124fe:	movs	r2, #0
   12500:	ldr	r3, [sp, #16]
   12502:	strb	r2, [r5, #0]
   12504:	ldr	r2, [sp, #12]
   12506:	adds	r3, #1
   12508:	str	r3, [r2, #0]
   1250a:	ldr	r3, [sp, #148]	; 0x94
   1250c:	cmp	r3, #0
   1250e:	beq.w	12c48 <_dtoa_r+0xae8>
   12512:	ldr	r0, [sp, #36]	; 0x24
   12514:	str	r5, [r3, #0]
   12516:	add	sp, #108	; 0x6c
   12518:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1251c:	ldr	r2, [sp, #44]	; 0x2c
   1251e:	cmp	r2, #0
   12520:	beq.w	12740 <_dtoa_r+0x5e0>
   12524:	ldr	r2, [sp, #0]
   12526:	cmp	r2, #1
   12528:	ble.w	129da <_dtoa_r+0x87a>
   1252c:	ldr	r3, [sp, #32]
   1252e:	ldr	r2, [sp, #24]
   12530:	subs	r7, r3, #1
   12532:	cmp	r2, r7
   12534:	blt.w	12c4e <_dtoa_r+0xaee>
   12538:	subs	r7, r2, r7
   1253a:	ldr	r3, [sp, #32]
   1253c:	cmp	r3, #0
   1253e:	blt.w	12e42 <_dtoa_r+0xce2>
   12542:	ldr	r5, [sp, #28]
   12544:	ldr	r3, [sp, #32]
   12546:	ldr	r2, [sp, #28]
   12548:	movs	r1, #1
   1254a:	add	r2, r3
   1254c:	mov	r0, r9
   1254e:	str	r2, [sp, #28]
   12550:	add	r8, r3
   12552:	bl	13498 <__i2b>
   12556:	mov	r6, r0
   12558:	cbz	r5, 12574 <_dtoa_r+0x414>
   1255a:	cmp.w	r8, #0
   1255e:	ble.n	12574 <_dtoa_r+0x414>
   12560:	cmp	r5, r8
   12562:	ldr	r2, [sp, #28]
   12564:	mov	r3, r5
   12566:	it	ge
   12568:	movge	r3, r8
   1256a:	subs	r2, r2, r3
   1256c:	str	r2, [sp, #28]
   1256e:	subs	r5, r5, r3
   12570:	rsb	r8, r3, r8
   12574:	ldr	r3, [sp, #24]
   12576:	cmp	r3, #0
   12578:	ble.w	12b66 <_dtoa_r+0xa06>
   1257c:	ldr	r2, [sp, #44]	; 0x2c
   1257e:	cmp	r2, #0
   12580:	beq.w	12988 <_dtoa_r+0x828>
   12584:	cmp	r7, #0
   12586:	beq.w	12988 <_dtoa_r+0x828>
   1258a:	mov	r1, r6
   1258c:	mov	r2, r7
   1258e:	mov	r0, r9
   12590:	bl	135dc <__pow5mult>
   12594:	ldr	r2, [sp, #40]	; 0x28
   12596:	mov	r1, r0
   12598:	mov	r6, r0
   1259a:	mov	r0, r9
   1259c:	bl	134ac <__multiply>
   125a0:	ldr	r1, [sp, #40]	; 0x28
   125a2:	mov	r4, r0
   125a4:	mov	r0, r9
   125a6:	bl	13368 <_Bfree>
   125aa:	ldr	r3, [sp, #24]
   125ac:	subs	r3, r3, r7
   125ae:	str	r3, [sp, #24]
   125b0:	bne.w	12986 <_dtoa_r+0x826>
   125b4:	movs	r1, #1
   125b6:	mov	r0, r9
   125b8:	bl	13498 <__i2b>
   125bc:	ldr	r3, [sp, #48]	; 0x30
   125be:	str	r0, [sp, #24]
   125c0:	cmp	r3, #0
   125c2:	beq.w	129f0 <_dtoa_r+0x890>
   125c6:	mov	r1, r0
   125c8:	mov	r2, r3
   125ca:	mov	r0, r9
   125cc:	bl	135dc <__pow5mult>
   125d0:	ldr	r3, [sp, #0]
   125d2:	str	r0, [sp, #24]
   125d4:	cmp	r3, #1
   125d6:	ble.w	12bc0 <_dtoa_r+0xa60>
   125da:	movs	r7, #0
   125dc:	ldr	r2, [sp, #24]
   125de:	ldr	r3, [r2, #16]
   125e0:	add.w	r3, r2, r3, lsl #2
   125e4:	ldr	r0, [r3, #16]
   125e6:	bl	133fc <__hi0bits>
   125ea:	rsb	r0, r0, #32
   125ee:	add	r0, r8
   125f0:	ands.w	r0, r0, #31
   125f4:	beq.w	129ec <_dtoa_r+0x88c>
   125f8:	rsb	r3, r0, #32
   125fc:	cmp	r3, #4
   125fe:	ble.w	12f7c <_dtoa_r+0xe1c>
   12602:	rsb	r0, r0, #28
   12606:	ldr	r3, [sp, #28]
   12608:	add	r3, r0
   1260a:	str	r3, [sp, #28]
   1260c:	add	r5, r0
   1260e:	add	r8, r0
   12610:	ldr	r3, [sp, #28]
   12612:	cmp	r3, #0
   12614:	ble.n	12622 <_dtoa_r+0x4c2>
   12616:	mov	r1, r4
   12618:	mov	r2, r3
   1261a:	mov	r0, r9
   1261c:	bl	1367c <__lshift>
   12620:	mov	r4, r0
   12622:	cmp.w	r8, #0
   12626:	ble.n	12634 <_dtoa_r+0x4d4>
   12628:	mov	r2, r8
   1262a:	ldr	r1, [sp, #24]
   1262c:	mov	r0, r9
   1262e:	bl	1367c <__lshift>
   12632:	str	r0, [sp, #24]
   12634:	ldr	r3, [sp, #52]	; 0x34
   12636:	cmp	r3, #0
   12638:	bne.w	12b30 <_dtoa_r+0x9d0>
   1263c:	ldr	r3, [sp, #32]
   1263e:	cmp	r3, #0
   12640:	ble.w	12b6a <_dtoa_r+0xa0a>
   12644:	ldr	r3, [sp, #44]	; 0x2c
   12646:	cmp	r3, #0
   12648:	bne.w	12a34 <_dtoa_r+0x8d4>
   1264c:	ldr.w	fp, [sp, #36]	; 0x24
   12650:	ldr	r7, [sp, #32]
   12652:	ldr.w	r8, [sp, #24]
   12656:	mov	r5, fp
   12658:	b.n	12660 <_dtoa_r+0x500>
   1265a:	bl	1337c <__multadd>
   1265e:	mov	r4, r0
   12660:	mov	r1, r8
   12662:	mov	r0, r4
   12664:	bl	12034 <quorem>
   12668:	add.w	sl, r0, #48	; 0x30
   1266c:	strb.w	sl, [r5], #1
   12670:	rsb	r3, fp, r5
   12674:	cmp	r3, r7
   12676:	mov.w	r2, #10
   1267a:	mov.w	r3, #0
   1267e:	mov	r1, r4
   12680:	mov	r0, r9
   12682:	blt.n	1265a <_dtoa_r+0x4fa>
   12684:	ldr	r3, [sp, #36]	; 0x24
   12686:	ldr	r2, [sp, #32]
   12688:	cmp	r2, #1
   1268a:	ite	ge
   1268c:	addge	r3, r3, r2
   1268e:	addlt	r3, #1
   12690:	mov	r5, r3
   12692:	mov.w	fp, #0
   12696:	mov	r1, r4
   12698:	movs	r2, #1
   1269a:	mov	r0, r9
   1269c:	bl	1367c <__lshift>
   126a0:	ldr	r1, [sp, #24]
   126a2:	str	r0, [sp, #40]	; 0x28
   126a4:	bl	1372c <__mcmp>
   126a8:	cmp	r0, #0
   126aa:	ble.w	12cb8 <_dtoa_r+0xb58>
   126ae:	ldrb.w	r2, [r5, #-1]
   126b2:	ldr	r1, [sp, #36]	; 0x24
   126b4:	subs	r3, r5, #1
   126b6:	b.n	126c2 <_dtoa_r+0x562>
   126b8:	cmp	r3, r1
   126ba:	beq.w	12ba6 <_dtoa_r+0xa46>
   126be:	ldrb.w	r2, [r3, #-1]!
   126c2:	cmp	r2, #57	; 0x39
   126c4:	add.w	r5, r3, #1
   126c8:	beq.n	126b8 <_dtoa_r+0x558>
   126ca:	adds	r2, #1
   126cc:	strb	r2, [r3, #0]
   126ce:	ldr	r1, [sp, #24]
   126d0:	mov	r0, r9
   126d2:	bl	13368 <_Bfree>
   126d6:	cmp	r6, #0
   126d8:	beq.w	124f6 <_dtoa_r+0x396>
   126dc:	cmp.w	fp, #0
   126e0:	beq.n	126ee <_dtoa_r+0x58e>
   126e2:	cmp	fp, r6
   126e4:	beq.n	126ee <_dtoa_r+0x58e>
   126e6:	mov	r1, fp
   126e8:	mov	r0, r9
   126ea:	bl	13368 <_Bfree>
   126ee:	mov	r1, r6
   126f0:	mov	r0, r9
   126f2:	bl	13368 <_Bfree>
   126f6:	b.n	124f6 <_dtoa_r+0x396>
   126f8:	movs	r3, #1
   126fa:	str	r3, [sp, #52]	; 0x34
   126fc:	b.n	122d6 <_dtoa_r+0x176>
   126fe:	ldr.w	r8, [sp, #16]
   12702:	mov	r0, r8
   12704:	bl	ee14 <__aeabi_i2d>
   12708:	mov	r2, r0
   1270a:	mov	r3, r1
   1270c:	mov	r0, r6
   1270e:	mov	r1, r7
   12710:	bl	f3b0 <__aeabi_dcmpeq>
   12714:	cmp	r0, #0
   12716:	bne.w	122ae <_dtoa_r+0x14e>
   1271a:	add.w	r3, r8, #4294967295
   1271e:	str	r3, [sp, #16]
   12720:	b.n	122ae <_dtoa_r+0x14e>
   12722:	ldr	r2, [sp, #28]
   12724:	ldr	r3, [sp, #16]
   12726:	subs	r2, r2, r3
   12728:	negs	r3, r3
   1272a:	str	r3, [sp, #24]
   1272c:	movs	r3, #0
   1272e:	str	r2, [sp, #28]
   12730:	str	r3, [sp, #48]	; 0x30
   12732:	b.n	122f4 <_dtoa_r+0x194>
   12734:	rsb	r3, r8, #0
   12738:	str	r3, [sp, #28]
   1273a:	mov.w	r8, #0
   1273e:	b.n	122e4 <_dtoa_r+0x184>
   12740:	ldr	r7, [sp, #24]
   12742:	ldr	r5, [sp, #28]
   12744:	ldr	r6, [sp, #44]	; 0x2c
   12746:	b.n	12558 <_dtoa_r+0x3f8>
   12748:	rsb	r4, r3, #32
   1274c:	lsl.w	r0, sl, r4
   12750:	b.n	12248 <_dtoa_r+0xe8>
   12752:	str	r0, [sp, #52]	; 0x34
   12754:	b.n	122d6 <_dtoa_r+0x176>
   12756:	nop
   12758:	.word	0x40240000
   1275c:	movs	r3, #0
   1275e:	str	r3, [sp, #44]	; 0x2c
   12760:	ldr	r3, [sp, #16]
   12762:	ldr	r2, [sp, #20]
   12764:	add	r3, r2
   12766:	str	r3, [sp, #56]	; 0x38
   12768:	adds	r3, #1
   1276a:	cmp	r3, #0
   1276c:	str	r3, [sp, #32]
   1276e:	ble.w	12c6c <_dtoa_r+0xb0c>
   12772:	ldr	r4, [sp, #32]
   12774:	mov	r5, r4
   12776:	movs	r1, #0
   12778:	cmp	r5, #23
   1277a:	str.w	r1, [r9, #68]	; 0x44
   1277e:	bls.n	12798 <_dtoa_r+0x638>
   12780:	movs	r2, #1
   12782:	movs	r3, #4
   12784:	lsls	r3, r3, #1
   12786:	add.w	r0, r3, #20
   1278a:	cmp	r0, r5
   1278c:	mov	r1, r2
   1278e:	add.w	r2, r2, #1
   12792:	bls.n	12784 <_dtoa_r+0x624>
   12794:	str.w	r1, [r9, #68]	; 0x44
   12798:	mov	r0, r9
   1279a:	bl	1331c <_Balloc>
   1279e:	cmp	r4, #14
   127a0:	str	r0, [sp, #36]	; 0x24
   127a2:	str.w	r0, [r9, #64]	; 0x40
   127a6:	bhi.w	12374 <_dtoa_r+0x214>
   127aa:	cmp	r6, #0
   127ac:	beq.w	12374 <_dtoa_r+0x214>
   127b0:	ldr	r1, [sp, #16]
   127b2:	cmp	r1, #0
   127b4:	strd	sl, fp, [sp, #64]	; 0x40
   127b8:	ble.w	12cf0 <_dtoa_r+0xb90>
   127bc:	ldr	r3, [pc, #576]	; (12a00 <_dtoa_r+0x8a0>)
   127be:	and.w	r2, r1, #15
   127c2:	asrs	r6, r1, #4
   127c4:	add.w	r3, r3, r2, lsl #3
   127c8:	lsls	r0, r6, #27
   127ca:	ldrd	r4, r5, [r3]
   127ce:	bpl.w	12c5e <_dtoa_r+0xafe>
   127d2:	ldr	r3, [pc, #560]	; (12a04 <_dtoa_r+0x8a4>)
   127d4:	mov	r0, sl
   127d6:	mov	r1, fp
   127d8:	ldrd	r2, r3, [r3, #32]
   127dc:	bl	f134 <__aeabi_ddiv>
   127e0:	strd	r0, r1, [sp, #72]	; 0x48
   127e4:	and.w	r6, r6, #15
   127e8:	mov.w	sl, #3
   127ec:	cbz	r6, 12810 <_dtoa_r+0x6b0>
   127ee:	ldr	r7, [pc, #532]	; (12a04 <_dtoa_r+0x8a4>)
   127f0:	lsls	r1, r6, #31
   127f2:	bpl.n	12808 <_dtoa_r+0x6a8>
   127f4:	mov	r0, r4
   127f6:	mov	r1, r5
   127f8:	ldrd	r2, r3, [r7]
   127fc:	bl	eee0 <__aeabi_dmul>
   12800:	add.w	sl, sl, #1
   12804:	mov	r4, r0
   12806:	mov	r5, r1
   12808:	asrs	r6, r6, #1
   1280a:	add.w	r7, r7, #8
   1280e:	bne.n	127f0 <_dtoa_r+0x690>
   12810:	mov	r2, r4
   12812:	mov	r3, r5
   12814:	ldrd	r0, r1, [sp, #72]	; 0x48
   12818:	bl	f134 <__aeabi_ddiv>
   1281c:	mov	r6, r0
   1281e:	mov	r7, r1
   12820:	ldr	r3, [sp, #52]	; 0x34
   12822:	cbz	r3, 12836 <_dtoa_r+0x6d6>
   12824:	movs	r2, #0
   12826:	ldr	r3, [pc, #480]	; (12a08 <_dtoa_r+0x8a8>)
   12828:	mov	r0, r6
   1282a:	mov	r1, r7
   1282c:	bl	f3c4 <__aeabi_dcmplt>
   12830:	cmp	r0, #0
   12832:	bne.w	12e6a <_dtoa_r+0xd0a>
   12836:	mov	r0, sl
   12838:	bl	ee14 <__aeabi_i2d>
   1283c:	mov	r2, r6
   1283e:	mov	r3, r7
   12840:	bl	eee0 <__aeabi_dmul>
   12844:	ldr	r3, [pc, #452]	; (12a0c <_dtoa_r+0x8ac>)
   12846:	movs	r2, #0
   12848:	bl	eb7c <__adddf3>
   1284c:	ldr	r3, [sp, #32]
   1284e:	mov	r4, r0
   12850:	sub.w	r5, r1, #54525952	; 0x3400000
   12854:	cmp	r3, #0
   12856:	beq.w	12c10 <_dtoa_r+0xab0>
   1285a:	ldr	r3, [sp, #16]
   1285c:	str	r3, [sp, #88]	; 0x58
   1285e:	ldr	r3, [sp, #32]
   12860:	str	r3, [sp, #72]	; 0x48
   12862:	ldr	r3, [sp, #44]	; 0x2c
   12864:	cmp	r3, #0
   12866:	beq.w	12d92 <_dtoa_r+0xc32>
   1286a:	ldr	r2, [sp, #72]	; 0x48
   1286c:	ldr	r3, [pc, #400]	; (12a00 <_dtoa_r+0x8a0>)
   1286e:	ldr	r1, [pc, #416]	; (12a10 <_dtoa_r+0x8b0>)
   12870:	add.w	r3, r3, r2, lsl #3
   12874:	ldrd	r2, r3, [r3, #-8]
   12878:	movs	r0, #0
   1287a:	bl	f134 <__aeabi_ddiv>
   1287e:	mov	r2, r4
   12880:	mov	r3, r5
   12882:	bl	eb78 <__aeabi_dsub>
   12886:	mov	sl, r0
   12888:	mov	fp, r1
   1288a:	mov	r0, r6
   1288c:	mov	r1, r7
   1288e:	bl	f440 <__aeabi_d2iz>
   12892:	mov	r4, r0
   12894:	bl	ee14 <__aeabi_i2d>
   12898:	mov	r2, r0
   1289a:	mov	r3, r1
   1289c:	mov	r0, r6
   1289e:	mov	r1, r7
   128a0:	bl	eb78 <__aeabi_dsub>
   128a4:	adds	r4, #48	; 0x30
   128a6:	ldr	r5, [sp, #36]	; 0x24
   128a8:	uxtb	r4, r4
   128aa:	mov	r6, r0
   128ac:	mov	r7, r1
   128ae:	strb	r4, [r5, #0]
   128b0:	mov	r2, r0
   128b2:	mov	r3, r1
   128b4:	mov	r0, sl
   128b6:	mov	r1, fp
   128b8:	adds	r5, #1
   128ba:	bl	f400 <__aeabi_dcmpgt>
   128be:	cmp	r0, #0
   128c0:	bne.n	12964 <_dtoa_r+0x804>
   128c2:	mov	r2, r6
   128c4:	mov	r3, r7
   128c6:	movs	r0, #0
   128c8:	ldr	r1, [pc, #316]	; (12a08 <_dtoa_r+0x8a8>)
   128ca:	bl	eb78 <__aeabi_dsub>
   128ce:	mov	r2, r0
   128d0:	mov	r3, r1
   128d2:	mov	r0, sl
   128d4:	mov	r1, fp
   128d6:	bl	f400 <__aeabi_dcmpgt>
   128da:	cmp	r0, #0
   128dc:	bne.w	12ef0 <_dtoa_r+0xd90>
   128e0:	ldr	r2, [sp, #72]	; 0x48
   128e2:	cmp	r2, #1
   128e4:	ble.w	12cd6 <_dtoa_r+0xb76>
   128e8:	ldr	r3, [sp, #72]	; 0x48
   128ea:	ldr	r2, [sp, #36]	; 0x24
   128ec:	str.w	r8, [sp, #72]	; 0x48
   128f0:	add	r3, r2
   128f2:	mov	r8, r3
   128f4:	b.n	12912 <_dtoa_r+0x7b2>
   128f6:	movs	r0, #0
   128f8:	ldr	r1, [pc, #268]	; (12a08 <_dtoa_r+0x8a8>)
   128fa:	bl	eb78 <__aeabi_dsub>
   128fe:	mov	r2, sl
   12900:	mov	r3, fp
   12902:	bl	f3c4 <__aeabi_dcmplt>
   12906:	cmp	r0, #0
   12908:	bne.w	12ef0 <_dtoa_r+0xd90>
   1290c:	cmp	r5, r8
   1290e:	beq.w	12cd2 <_dtoa_r+0xb72>
   12912:	mov	r0, sl
   12914:	mov	r1, fp
   12916:	movs	r2, #0
   12918:	ldr	r3, [pc, #248]	; (12a14 <_dtoa_r+0x8b4>)
   1291a:	bl	eee0 <__aeabi_dmul>
   1291e:	movs	r2, #0
   12920:	ldr	r3, [pc, #240]	; (12a14 <_dtoa_r+0x8b4>)
   12922:	mov	sl, r0
   12924:	mov	fp, r1
   12926:	mov	r0, r6
   12928:	mov	r1, r7
   1292a:	bl	eee0 <__aeabi_dmul>
   1292e:	mov	r7, r1
   12930:	mov	r6, r0
   12932:	bl	f440 <__aeabi_d2iz>
   12936:	mov	r4, r0
   12938:	bl	ee14 <__aeabi_i2d>
   1293c:	mov	r2, r0
   1293e:	mov	r3, r1
   12940:	mov	r0, r6
   12942:	mov	r1, r7
   12944:	bl	eb78 <__aeabi_dsub>
   12948:	adds	r4, #48	; 0x30
   1294a:	uxtb	r4, r4
   1294c:	mov	r2, sl
   1294e:	mov	r3, fp
   12950:	strb.w	r4, [r5], #1
   12954:	mov	r6, r0
   12956:	mov	r7, r1
   12958:	bl	f3c4 <__aeabi_dcmplt>
   1295c:	mov	r2, r6
   1295e:	mov	r3, r7
   12960:	cmp	r0, #0
   12962:	beq.n	128f6 <_dtoa_r+0x796>
   12964:	ldr	r3, [sp, #88]	; 0x58
   12966:	str	r3, [sp, #16]
   12968:	b.n	124f6 <_dtoa_r+0x396>
   1296a:	movs	r3, #0
   1296c:	str	r3, [sp, #44]	; 0x2c
   1296e:	ldr	r3, [sp, #20]
   12970:	cmp	r3, #0
   12972:	ble.w	12c76 <_dtoa_r+0xb16>
   12976:	mov	r5, r3
   12978:	mov	r4, r3
   1297a:	str	r3, [sp, #56]	; 0x38
   1297c:	str	r3, [sp, #32]
   1297e:	b.n	12776 <_dtoa_r+0x616>
   12980:	movs	r3, #1
   12982:	str	r3, [sp, #44]	; 0x2c
   12984:	b.n	1296e <_dtoa_r+0x80e>
   12986:	str	r4, [sp, #40]	; 0x28
   12988:	ldr	r2, [sp, #24]
   1298a:	ldr	r1, [sp, #40]	; 0x28
   1298c:	mov	r0, r9
   1298e:	bl	135dc <__pow5mult>
   12992:	mov	r4, r0
   12994:	b.n	125b4 <_dtoa_r+0x454>
   12996:	ldr	r3, [sp, #32]
   12998:	cmp	r3, #0
   1299a:	bgt.w	1239a <_dtoa_r+0x23a>
   1299e:	bne.w	12c40 <_dtoa_r+0xae0>
   129a2:	movs	r2, #0
   129a4:	ldr	r3, [pc, #112]	; (12a18 <_dtoa_r+0x8b8>)
   129a6:	ldrd	r0, r1, [sp]
   129aa:	bl	eee0 <__aeabi_dmul>
   129ae:	mov	r3, fp
   129b0:	mov	r2, sl
   129b2:	bl	f3ec <__aeabi_dcmpge>
   129b6:	ldr	r3, [sp, #32]
   129b8:	str	r3, [sp, #24]
   129ba:	mov	r6, r3
   129bc:	cmp	r0, #0
   129be:	beq.w	12b96 <_dtoa_r+0xa36>
   129c2:	ldr	r3, [sp, #20]
   129c4:	ldr	r5, [sp, #36]	; 0x24
   129c6:	mvns	r3, r3
   129c8:	str	r3, [sp, #16]
   129ca:	ldr	r1, [sp, #24]
   129cc:	mov	r0, r9
   129ce:	bl	13368 <_Bfree>
   129d2:	cmp	r6, #0
   129d4:	beq.w	124f6 <_dtoa_r+0x396>
   129d8:	b.n	126ee <_dtoa_r+0x58e>
   129da:	ldr	r2, [sp, #60]	; 0x3c
   129dc:	cmp	r2, #0
   129de:	beq.w	12e52 <_dtoa_r+0xcf2>
   129e2:	addw	r3, r3, #1075	; 0x433
   129e6:	ldr	r7, [sp, #24]
   129e8:	ldr	r5, [sp, #28]
   129ea:	b.n	12546 <_dtoa_r+0x3e6>
   129ec:	movs	r0, #28
   129ee:	b.n	12606 <_dtoa_r+0x4a6>
   129f0:	ldr	r3, [sp, #0]
   129f2:	cmp	r3, #1
   129f4:	ble.w	12ef8 <_dtoa_r+0xd98>
   129f8:	ldr	r7, [sp, #48]	; 0x30
   129fa:	movs	r0, #1
   129fc:	b.n	125ee <_dtoa_r+0x48e>
   129fe:	nop
   12a00:	.word	0x20000a60
   12a04:	.word	0x20000b28
   12a08:	.word	0x3ff00000
   12a0c:	.word	0x401c0000
   12a10:	.word	0x3fe00000
   12a14:	.word	0x40240000
   12a18:	.word	0x40140000
   12a1c:	mov	r1, r6
   12a1e:	movs	r3, #0
   12a20:	movs	r2, #10
   12a22:	mov	r0, r9
   12a24:	bl	1337c <__multadd>
   12a28:	ldr	r3, [sp, #56]	; 0x38
   12a2a:	cmp	r3, #0
   12a2c:	mov	r6, r0
   12a2e:	ble.w	12f4c <_dtoa_r+0xdec>
   12a32:	str	r3, [sp, #32]
   12a34:	cmp	r5, #0
   12a36:	ble.n	12a44 <_dtoa_r+0x8e4>
   12a38:	mov	r1, r6
   12a3a:	mov	r2, r5
   12a3c:	mov	r0, r9
   12a3e:	bl	1367c <__lshift>
   12a42:	mov	r6, r0
   12a44:	cmp	r7, #0
   12a46:	bne.w	12d42 <_dtoa_r+0xbe2>
   12a4a:	mov	r8, r6
   12a4c:	ldr	r3, [sp, #32]
   12a4e:	ldr	r2, [sp, #36]	; 0x24
   12a50:	subs	r3, #1
   12a52:	adds	r3, r2, r3
   12a54:	str	r3, [sp, #32]
   12a56:	and.w	r3, sl, #1
   12a5a:	str	r3, [sp, #40]	; 0x28
   12a5c:	mov	r7, r2
   12a5e:	ldr.w	fp, [sp, #24]
   12a62:	mov	r0, r4
   12a64:	mov	r1, fp
   12a66:	bl	12034 <quorem>
   12a6a:	mov	r1, r6
   12a6c:	mov	r5, r0
   12a6e:	mov	r0, r4
   12a70:	bl	1372c <__mcmp>
   12a74:	mov	r2, r8
   12a76:	mov	r1, fp
   12a78:	mov	sl, r0
   12a7a:	mov	r0, r9
   12a7c:	bl	13770 <__mdiff>
   12a80:	ldr	r2, [r0, #12]
   12a82:	mov	fp, r0
   12a84:	add.w	r3, r5, #48	; 0x30
   12a88:	cmp	r2, #0
   12a8a:	bne.n	12b20 <_dtoa_r+0x9c0>
   12a8c:	mov	r1, r0
   12a8e:	mov	r0, r4
   12a90:	str	r3, [sp, #28]
   12a92:	bl	1372c <__mcmp>
   12a96:	mov	r1, fp
   12a98:	str	r0, [sp, #20]
   12a9a:	mov	r0, r9
   12a9c:	bl	13368 <_Bfree>
   12aa0:	ldr	r2, [sp, #20]
   12aa2:	ldr	r3, [sp, #28]
   12aa4:	cbnz	r2, 12ab2 <_dtoa_r+0x952>
   12aa6:	ldr	r1, [sp, #0]
   12aa8:	cbnz	r1, 12ab2 <_dtoa_r+0x952>
   12aaa:	ldr	r1, [sp, #40]	; 0x28
   12aac:	cmp	r1, #0
   12aae:	beq.w	12f1c <_dtoa_r+0xdbc>
   12ab2:	cmp.w	sl, #0
   12ab6:	blt.w	12c80 <_dtoa_r+0xb20>
   12aba:	bne.n	12ac8 <_dtoa_r+0x968>
   12abc:	ldr	r1, [sp, #0]
   12abe:	cbnz	r1, 12ac8 <_dtoa_r+0x968>
   12ac0:	ldr	r1, [sp, #40]	; 0x28
   12ac2:	cmp	r1, #0
   12ac4:	beq.w	12c80 <_dtoa_r+0xb20>
   12ac8:	cmp	r2, #0
   12aca:	bgt.w	12d6a <_dtoa_r+0xc0a>
   12ace:	ldr	r2, [sp, #32]
   12ad0:	strb	r3, [r7, #0]
   12ad2:	add.w	sl, r7, #1
   12ad6:	cmp	r7, r2
   12ad8:	mov	r5, sl
   12ada:	beq.w	12d82 <_dtoa_r+0xc22>
   12ade:	mov	r1, r4
   12ae0:	movs	r3, #0
   12ae2:	movs	r2, #10
   12ae4:	mov	r0, r9
   12ae6:	bl	1337c <__multadd>
   12aea:	cmp	r6, r8
   12aec:	mov	r4, r0
   12aee:	mov	r1, r6
   12af0:	mov.w	r3, #0
   12af4:	mov.w	r2, #10
   12af8:	mov	r0, r9
   12afa:	beq.n	12b14 <_dtoa_r+0x9b4>
   12afc:	bl	1337c <__multadd>
   12b00:	mov	r1, r8
   12b02:	mov	r6, r0
   12b04:	movs	r3, #0
   12b06:	movs	r2, #10
   12b08:	mov	r0, r9
   12b0a:	bl	1337c <__multadd>
   12b0e:	mov	r7, sl
   12b10:	mov	r8, r0
   12b12:	b.n	12a5e <_dtoa_r+0x8fe>
   12b14:	bl	1337c <__multadd>
   12b18:	mov	r7, sl
   12b1a:	mov	r6, r0
   12b1c:	mov	r8, r0
   12b1e:	b.n	12a5e <_dtoa_r+0x8fe>
   12b20:	mov	r1, r0
   12b22:	mov	r0, r9
   12b24:	str	r3, [sp, #20]
   12b26:	bl	13368 <_Bfree>
   12b2a:	movs	r2, #1
   12b2c:	ldr	r3, [sp, #20]
   12b2e:	b.n	12ab2 <_dtoa_r+0x952>
   12b30:	ldr	r1, [sp, #24]
   12b32:	mov	r0, r4
   12b34:	bl	1372c <__mcmp>
   12b38:	cmp	r0, #0
   12b3a:	bge.w	1263c <_dtoa_r+0x4dc>
   12b3e:	mov	r1, r4
   12b40:	ldr	r4, [sp, #16]
   12b42:	movs	r3, #0
   12b44:	subs	r4, #1
   12b46:	movs	r2, #10
   12b48:	mov	r0, r9
   12b4a:	str	r4, [sp, #16]
   12b4c:	bl	1337c <__multadd>
   12b50:	ldr	r3, [sp, #44]	; 0x2c
   12b52:	mov	r4, r0
   12b54:	cmp	r3, #0
   12b56:	bne.w	12a1c <_dtoa_r+0x8bc>
   12b5a:	ldr	r3, [sp, #56]	; 0x38
   12b5c:	cmp	r3, #0
   12b5e:	ble.w	12f3c <_dtoa_r+0xddc>
   12b62:	str	r3, [sp, #32]
   12b64:	b.n	1264c <_dtoa_r+0x4ec>
   12b66:	ldr	r4, [sp, #40]	; 0x28
   12b68:	b.n	125b4 <_dtoa_r+0x454>
   12b6a:	ldr	r3, [sp, #0]
   12b6c:	cmp	r3, #2
   12b6e:	ble.w	12644 <_dtoa_r+0x4e4>
   12b72:	ldr	r3, [sp, #32]
   12b74:	cmp	r3, #0
   12b76:	bne.w	12eb4 <_dtoa_r+0xd54>
   12b7a:	ldr	r1, [sp, #24]
   12b7c:	movs	r2, #5
   12b7e:	mov	r0, r9
   12b80:	bl	1337c <__multadd>
   12b84:	mov	r1, r0
   12b86:	str	r0, [sp, #24]
   12b88:	mov	r0, r4
   12b8a:	bl	1372c <__mcmp>
   12b8e:	cmp	r0, #0
   12b90:	str	r4, [sp, #40]	; 0x28
   12b92:	ble.w	129c2 <_dtoa_r+0x862>
   12b96:	ldr	r2, [sp, #16]
   12b98:	ldr	r1, [sp, #36]	; 0x24
   12b9a:	movs	r3, #49	; 0x31
   12b9c:	adds	r2, #1
   12b9e:	str	r2, [sp, #16]
   12ba0:	strb	r3, [r1, #0]
   12ba2:	adds	r5, r1, #1
   12ba4:	b.n	129ca <_dtoa_r+0x86a>
   12ba6:	ldr	r2, [sp, #16]
   12ba8:	adds	r2, #1
   12baa:	str	r2, [sp, #16]
   12bac:	ldr	r2, [sp, #36]	; 0x24
   12bae:	movs	r3, #49	; 0x31
   12bb0:	strb	r3, [r2, #0]
   12bb2:	b.n	126ce <_dtoa_r+0x56e>
   12bb4:	movs	r3, #1
   12bb6:	str	r3, [sp, #44]	; 0x2c
   12bb8:	b.n	12760 <_dtoa_r+0x600>
   12bba:	ldr.w	r9, [sp, #20]
   12bbe:	b.n	124f6 <_dtoa_r+0x396>
   12bc0:	cmp.w	sl, #0
   12bc4:	bne.w	125da <_dtoa_r+0x47a>
   12bc8:	ubfx	r3, fp, #0, #20
   12bcc:	cmp	r3, #0
   12bce:	bne.w	12e4e <_dtoa_r+0xcee>
   12bd2:	bic.w	r7, fp, #2147483648	; 0x80000000
   12bd6:	lsrs	r7, r7, #20
   12bd8:	lsls	r7, r7, #20
   12bda:	cbz	r7, 12be8 <_dtoa_r+0xa88>
   12bdc:	ldr	r3, [sp, #28]
   12bde:	adds	r3, #1
   12be0:	str	r3, [sp, #28]
   12be2:	add.w	r8, r8, #1
   12be6:	movs	r7, #1
   12be8:	ldr	r3, [sp, #48]	; 0x30
   12bea:	movs	r0, #1
   12bec:	cmp	r3, #0
   12bee:	beq.w	125ee <_dtoa_r+0x48e>
   12bf2:	b.n	125dc <_dtoa_r+0x47c>
   12bf4:	mov	r0, sl
   12bf6:	bl	ee14 <__aeabi_i2d>
   12bfa:	mov	r2, r6
   12bfc:	mov	r3, r7
   12bfe:	bl	eee0 <__aeabi_dmul>
   12c02:	movs	r2, #0
   12c04:	ldr	r3, [pc, #764]	; (12f04 <_dtoa_r+0xda4>)
   12c06:	bl	eb7c <__adddf3>
   12c0a:	mov	r4, r0
   12c0c:	sub.w	r5, r1, #54525952	; 0x3400000
   12c10:	mov	r0, r6
   12c12:	mov	r1, r7
   12c14:	movs	r2, #0
   12c16:	ldr	r3, [pc, #752]	; (12f08 <_dtoa_r+0xda8>)
   12c18:	bl	eb78 <__aeabi_dsub>
   12c1c:	mov	r2, r4
   12c1e:	mov	r3, r5
   12c20:	mov	r6, r0
   12c22:	mov	r7, r1
   12c24:	bl	f400 <__aeabi_dcmpgt>
   12c28:	cmp	r0, #0
   12c2a:	bne.w	12d8a <_dtoa_r+0xc2a>
   12c2e:	mov	r2, r4
   12c30:	add.w	r3, r5, #2147483648	; 0x80000000
   12c34:	mov	r0, r6
   12c36:	mov	r1, r7
   12c38:	bl	f3c4 <__aeabi_dcmplt>
   12c3c:	cmp	r0, #0
   12c3e:	beq.n	12cd6 <_dtoa_r+0xb76>
   12c40:	movs	r3, #0
   12c42:	str	r3, [sp, #24]
   12c44:	mov	r6, r3
   12c46:	b.n	129c2 <_dtoa_r+0x862>
   12c48:	ldr	r0, [sp, #36]	; 0x24
   12c4a:	b.w	121d2 <_dtoa_r+0x72>
   12c4e:	ldr	r3, [sp, #24]
   12c50:	ldr	r2, [sp, #48]	; 0x30
   12c52:	str	r7, [sp, #24]
   12c54:	subs	r3, r7, r3
   12c56:	add	r2, r3
   12c58:	str	r2, [sp, #48]	; 0x30
   12c5a:	movs	r7, #0
   12c5c:	b.n	1253a <_dtoa_r+0x3da>
   12c5e:	vldr	d7, [sp, #64]	; 0x40
   12c62:	mov.w	sl, #2
   12c66:	vstr	d7, [sp, #72]	; 0x48
   12c6a:	b.n	127ec <_dtoa_r+0x68c>
   12c6c:	mov	r4, r3
   12c6e:	movs	r1, #0
   12c70:	str.w	r1, [r9, #68]	; 0x44
   12c74:	b.n	12798 <_dtoa_r+0x638>
   12c76:	movs	r4, #1
   12c78:	str	r4, [sp, #56]	; 0x38
   12c7a:	str	r4, [sp, #32]
   12c7c:	str	r4, [sp, #20]
   12c7e:	b.n	12c6e <_dtoa_r+0xb0e>
   12c80:	cmp	r2, #0
   12c82:	mov	sl, r3
   12c84:	ble.n	12caa <_dtoa_r+0xb4a>
   12c86:	mov	r1, r4
   12c88:	movs	r2, #1
   12c8a:	mov	r0, r9
   12c8c:	bl	1367c <__lshift>
   12c90:	ldr	r1, [sp, #24]
   12c92:	mov	r4, r0
   12c94:	bl	1372c <__mcmp>
   12c98:	cmp	r0, #0
   12c9a:	ble.w	12f2e <_dtoa_r+0xdce>
   12c9e:	cmp.w	sl, #57	; 0x39
   12ca2:	beq.w	12eb8 <_dtoa_r+0xd58>
   12ca6:	add.w	sl, r5, #49	; 0x31
   12caa:	mov	fp, r6
   12cac:	strb.w	sl, [r7]
   12cb0:	adds	r5, r7, #1
   12cb2:	mov	r6, r8
   12cb4:	str	r4, [sp, #40]	; 0x28
   12cb6:	b.n	126ce <_dtoa_r+0x56e>
   12cb8:	bne.n	12cc4 <_dtoa_r+0xb64>
   12cba:	tst.w	sl, #1
   12cbe:	beq.n	12cc4 <_dtoa_r+0xb64>
   12cc0:	b.n	126ae <_dtoa_r+0x54e>
   12cc2:	mov	r5, r2
   12cc4:	ldrb.w	r3, [r5, #-1]
   12cc8:	cmp	r3, #48	; 0x30
   12cca:	add.w	r2, r5, #4294967295
   12cce:	beq.n	12cc2 <_dtoa_r+0xb62>
   12cd0:	b.n	126ce <_dtoa_r+0x56e>
   12cd2:	ldr.w	r8, [sp, #72]	; 0x48
   12cd6:	ldrd	sl, fp, [sp, #64]	; 0x40
   12cda:	b.w	12374 <_dtoa_r+0x214>
   12cde:	ldr	r1, [sp, #36]	; 0x24
   12ce0:	movs	r2, #48	; 0x30
   12ce2:	strb	r2, [r1, #0]
   12ce4:	ldr	r2, [sp, #16]
   12ce6:	ldrb.w	r4, [r5, #-1]
   12cea:	adds	r2, #1
   12cec:	str	r2, [sp, #16]
   12cee:	b.n	124f2 <_dtoa_r+0x392>
   12cf0:	ldr	r3, [sp, #16]
   12cf2:	negs	r4, r3
   12cf4:	cmp	r4, #0
   12cf6:	beq.w	12e60 <_dtoa_r+0xd00>
   12cfa:	ldr	r3, [pc, #528]	; (12f0c <_dtoa_r+0xdac>)
   12cfc:	and.w	r2, r4, #15
   12d00:	add.w	r3, r3, r2, lsl #3
   12d04:	ldrd	r2, r3, [r3]
   12d08:	ldrd	r0, r1, [sp, #64]	; 0x40
   12d0c:	bl	eee0 <__aeabi_dmul>
   12d10:	asrs	r4, r4, #4
   12d12:	mov	r6, r0
   12d14:	mov	r7, r1
   12d16:	beq.w	12f46 <_dtoa_r+0xde6>
   12d1a:	ldr	r5, [pc, #500]	; (12f10 <_dtoa_r+0xdb0>)
   12d1c:	mov.w	sl, #2
   12d20:	lsls	r2, r4, #31
   12d22:	bpl.n	12d38 <_dtoa_r+0xbd8>
   12d24:	mov	r0, r6
   12d26:	mov	r1, r7
   12d28:	ldrd	r2, r3, [r5]
   12d2c:	bl	eee0 <__aeabi_dmul>
   12d30:	add.w	sl, sl, #1
   12d34:	mov	r6, r0
   12d36:	mov	r7, r1
   12d38:	asrs	r4, r4, #1
   12d3a:	add.w	r5, r5, #8
   12d3e:	bne.n	12d20 <_dtoa_r+0xbc0>
   12d40:	b.n	12820 <_dtoa_r+0x6c0>
   12d42:	ldr	r1, [r6, #4]
   12d44:	mov	r0, r9
   12d46:	bl	1331c <_Balloc>
   12d4a:	ldr	r3, [r6, #16]
   12d4c:	adds	r2, r3, #2
   12d4e:	mov	r5, r0
   12d50:	lsls	r2, r2, #2
   12d52:	add.w	r1, r6, #12
   12d56:	adds	r0, #12
   12d58:	bl	cfd4 <memcpy>
   12d5c:	mov	r1, r5
   12d5e:	movs	r2, #1
   12d60:	mov	r0, r9
   12d62:	bl	1367c <__lshift>
   12d66:	mov	r8, r0
   12d68:	b.n	12a4c <_dtoa_r+0x8ec>
   12d6a:	cmp	r3, #57	; 0x39
   12d6c:	beq.w	12eb8 <_dtoa_r+0xd58>
   12d70:	add.w	sl, r3, #1
   12d74:	mov	fp, r6
   12d76:	strb.w	sl, [r7]
   12d7a:	adds	r5, r7, #1
   12d7c:	mov	r6, r8
   12d7e:	str	r4, [sp, #40]	; 0x28
   12d80:	b.n	126ce <_dtoa_r+0x56e>
   12d82:	mov	fp, r6
   12d84:	mov	sl, r3
   12d86:	mov	r6, r8
   12d88:	b.n	12696 <_dtoa_r+0x536>
   12d8a:	movs	r3, #0
   12d8c:	str	r3, [sp, #24]
   12d8e:	mov	r6, r3
   12d90:	b.n	12b96 <_dtoa_r+0xa36>
   12d92:	ldr	r3, [sp, #72]	; 0x48
   12d94:	ldr	r1, [pc, #372]	; (12f0c <_dtoa_r+0xdac>)
   12d96:	subs	r2, r3, #1
   12d98:	add.w	r1, r1, r2, lsl #3
   12d9c:	mov	r3, r5
   12d9e:	str	r2, [sp, #92]	; 0x5c
   12da0:	ldrd	r0, r1, [r1]
   12da4:	mov	r2, r4
   12da6:	bl	eee0 <__aeabi_dmul>
   12daa:	strd	r0, r1, [sp, #80]	; 0x50
   12dae:	mov	r1, r7
   12db0:	mov	r0, r6
   12db2:	bl	f440 <__aeabi_d2iz>
   12db6:	mov	r4, r0
   12db8:	bl	ee14 <__aeabi_i2d>
   12dbc:	mov	r3, r1
   12dbe:	mov	r2, r0
   12dc0:	mov	r1, r7
   12dc2:	mov	r0, r6
   12dc4:	bl	eb78 <__aeabi_dsub>
   12dc8:	ldr	r3, [sp, #72]	; 0x48
   12dca:	mov	r7, r1
   12dcc:	ldr	r1, [sp, #36]	; 0x24
   12dce:	adds	r4, #48	; 0x30
   12dd0:	cmp	r3, #1
   12dd2:	mov	r6, r0
   12dd4:	strb	r4, [r1, #0]
   12dd6:	add.w	r5, r1, #1
   12dda:	beq.n	12e1e <_dtoa_r+0xcbe>
   12ddc:	ldr	r3, [sp, #72]	; 0x48
   12dde:	ldr	r2, [sp, #36]	; 0x24
   12de0:	add	r3, r2
   12de2:	mov	sl, r3
   12de4:	mov	fp, r5
   12de6:	movs	r2, #0
   12de8:	ldr	r3, [pc, #296]	; (12f14 <_dtoa_r+0xdb4>)
   12dea:	mov	r0, r6
   12dec:	mov	r1, r7
   12dee:	bl	eee0 <__aeabi_dmul>
   12df2:	mov	r7, r1
   12df4:	mov	r6, r0
   12df6:	bl	f440 <__aeabi_d2iz>
   12dfa:	mov	r4, r0
   12dfc:	bl	ee14 <__aeabi_i2d>
   12e00:	adds	r4, #48	; 0x30
   12e02:	mov	r2, r0
   12e04:	mov	r3, r1
   12e06:	mov	r0, r6
   12e08:	mov	r1, r7
   12e0a:	bl	eb78 <__aeabi_dsub>
   12e0e:	strb.w	r4, [fp], #1
   12e12:	cmp	sl, fp
   12e14:	mov	r6, r0
   12e16:	mov	r7, r1
   12e18:	bne.n	12de6 <_dtoa_r+0xc86>
   12e1a:	ldr	r3, [sp, #92]	; 0x5c
   12e1c:	add	r5, r3
   12e1e:	movs	r2, #0
   12e20:	ldr	r3, [pc, #244]	; (12f18 <_dtoa_r+0xdb8>)
   12e22:	ldrd	r0, r1, [sp, #80]	; 0x50
   12e26:	bl	eb7c <__adddf3>
   12e2a:	mov	r2, r6
   12e2c:	mov	r3, r7
   12e2e:	bl	f3c4 <__aeabi_dcmplt>
   12e32:	cmp	r0, #0
   12e34:	beq.n	12ec8 <_dtoa_r+0xd68>
   12e36:	ldr	r3, [sp, #88]	; 0x58
   12e38:	str	r3, [sp, #16]
   12e3a:	ldrb.w	r4, [r5, #-1]
   12e3e:	b.w	124da <_dtoa_r+0x37a>
   12e42:	ldr	r3, [sp, #28]
   12e44:	ldr	r2, [sp, #32]
   12e46:	subs	r5, r3, r2
   12e48:	movs	r3, #0
   12e4a:	b.w	12546 <_dtoa_r+0x3e6>
   12e4e:	movs	r7, #0
   12e50:	b.n	12be8 <_dtoa_r+0xa88>
   12e52:	ldr	r3, [sp, #96]	; 0x60
   12e54:	ldr	r7, [sp, #24]
   12e56:	ldr	r5, [sp, #28]
   12e58:	rsb	r3, r3, #54	; 0x36
   12e5c:	b.w	12546 <_dtoa_r+0x3e6>
   12e60:	ldrd	r6, r7, [sp, #64]	; 0x40
   12e64:	mov.w	sl, #2
   12e68:	b.n	12820 <_dtoa_r+0x6c0>
   12e6a:	ldr	r3, [sp, #32]
   12e6c:	cmp	r3, #0
   12e6e:	beq.w	12bf4 <_dtoa_r+0xa94>
   12e72:	ldr	r3, [sp, #56]	; 0x38
   12e74:	cmp	r3, #0
   12e76:	ble.w	12cd6 <_dtoa_r+0xb76>
   12e7a:	movs	r2, #0
   12e7c:	ldr	r3, [pc, #148]	; (12f14 <_dtoa_r+0xdb4>)
   12e7e:	mov	r0, r6
   12e80:	mov	r1, r7
   12e82:	bl	eee0 <__aeabi_dmul>
   12e86:	mov	r6, r0
   12e88:	mov	r7, r1
   12e8a:	add.w	r0, sl, #1
   12e8e:	bl	ee14 <__aeabi_i2d>
   12e92:	mov	r2, r6
   12e94:	mov	r3, r7
   12e96:	bl	eee0 <__aeabi_dmul>
   12e9a:	movs	r2, #0
   12e9c:	ldr	r3, [pc, #100]	; (12f04 <_dtoa_r+0xda4>)
   12e9e:	bl	eb7c <__adddf3>
   12ea2:	ldr	r2, [sp, #16]
   12ea4:	ldr	r3, [sp, #56]	; 0x38
   12ea6:	str	r3, [sp, #72]	; 0x48
   12ea8:	subs	r2, #1
   12eaa:	mov	r4, r0
   12eac:	sub.w	r5, r1, #54525952	; 0x3400000
   12eb0:	str	r2, [sp, #88]	; 0x58
   12eb2:	b.n	12862 <_dtoa_r+0x702>
   12eb4:	str	r4, [sp, #40]	; 0x28
   12eb6:	b.n	129c2 <_dtoa_r+0x862>
   12eb8:	movs	r2, #57	; 0x39
   12eba:	mov	fp, r6
   12ebc:	str	r4, [sp, #40]	; 0x28
   12ebe:	mov	r6, r8
   12ec0:	strb	r2, [r7, #0]
   12ec2:	adds	r5, r7, #1
   12ec4:	b.w	126b2 <_dtoa_r+0x552>
   12ec8:	ldrd	r2, r3, [sp, #80]	; 0x50
   12ecc:	movs	r0, #0
   12ece:	ldr	r1, [pc, #72]	; (12f18 <_dtoa_r+0xdb8>)
   12ed0:	bl	eb78 <__aeabi_dsub>
   12ed4:	mov	r2, r6
   12ed6:	mov	r3, r7
   12ed8:	bl	f400 <__aeabi_dcmpgt>
   12edc:	cbnz	r0, 12ee2 <_dtoa_r+0xd82>
   12ede:	b.n	12cd6 <_dtoa_r+0xb76>
   12ee0:	mov	r5, r2
   12ee2:	ldrb.w	r3, [r5, #-1]
   12ee6:	cmp	r3, #48	; 0x30
   12ee8:	add.w	r2, r5, #4294967295
   12eec:	beq.n	12ee0 <_dtoa_r+0xd80>
   12eee:	b.n	12964 <_dtoa_r+0x804>
   12ef0:	ldr	r3, [sp, #88]	; 0x58
   12ef2:	str	r3, [sp, #16]
   12ef4:	b.w	124da <_dtoa_r+0x37a>
   12ef8:	cmp.w	sl, #0
   12efc:	bne.w	129f8 <_dtoa_r+0x898>
   12f00:	b.n	12bc8 <_dtoa_r+0xa68>
   12f02:	nop
   12f04:	.word	0x401c0000
   12f08:	.word	0x40140000
   12f0c:	.word	0x20000a60
   12f10:	.word	0x20000b28
   12f14:	.word	0x40240000
   12f18:	.word	0x3fe00000
   12f1c:	cmp	r3, #57	; 0x39
   12f1e:	mov	fp, sl
   12f20:	mov	sl, r3
   12f22:	beq.n	12eb8 <_dtoa_r+0xd58>
   12f24:	cmp.w	fp, #0
   12f28:	bgt.w	12ca6 <_dtoa_r+0xb46>
   12f2c:	b.n	12caa <_dtoa_r+0xb4a>
   12f2e:	bne.w	12caa <_dtoa_r+0xb4a>
   12f32:	tst.w	sl, #1
   12f36:	beq.w	12caa <_dtoa_r+0xb4a>
   12f3a:	b.n	12c9e <_dtoa_r+0xb3e>
   12f3c:	ldr	r3, [sp, #0]
   12f3e:	cmp	r3, #2
   12f40:	bgt.n	12f8e <_dtoa_r+0xe2e>
   12f42:	ldr	r3, [sp, #56]	; 0x38
   12f44:	b.n	12b62 <_dtoa_r+0xa02>
   12f46:	mov.w	sl, #2
   12f4a:	b.n	12820 <_dtoa_r+0x6c0>
   12f4c:	ldr	r3, [sp, #0]
   12f4e:	cmp	r3, #2
   12f50:	bgt.n	12f8e <_dtoa_r+0xe2e>
   12f52:	ldr	r3, [sp, #56]	; 0x38
   12f54:	b.n	12a32 <_dtoa_r+0x8d2>
   12f56:	movs	r4, #0
   12f58:	str.w	r4, [r9, #68]	; 0x44
   12f5c:	mov	r1, r4
   12f5e:	mov	r0, r9
   12f60:	bl	1331c <_Balloc>
   12f64:	mov.w	r3, #4294967295
   12f68:	str	r3, [sp, #32]
   12f6a:	str	r3, [sp, #56]	; 0x38
   12f6c:	movs	r3, #1
   12f6e:	str	r0, [sp, #36]	; 0x24
   12f70:	str	r4, [sp, #20]
   12f72:	str.w	r0, [r9, #64]	; 0x40
   12f76:	str	r3, [sp, #44]	; 0x2c
   12f78:	b.w	12374 <_dtoa_r+0x214>
   12f7c:	beq.w	12610 <_dtoa_r+0x4b0>
   12f80:	rsb	r0, r0, #60	; 0x3c
   12f84:	b.w	12606 <_dtoa_r+0x4a6>
   12f88:	movs	r6, #1
   12f8a:	b.w	12306 <_dtoa_r+0x1a6>
   12f8e:	ldr	r3, [sp, #56]	; 0x38
   12f90:	str	r3, [sp, #32]
   12f92:	b.n	12b72 <_dtoa_r+0xa12>

00012f94 <fcvtbuf>:
   12f94:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12f98:	vpush	{d8}
   12f9c:	vmov.f32	s16, s0
   12fa0:	vmov.f32	s17, s1
   12fa4:	ldr	r5, [pc, #224]	; (13088 <fcvtbuf+0xf4>)
   12fa6:	sub	sp, #20
   12fa8:	ldr	r7, [r5, #0]
   12faa:	mov	r4, r0
   12fac:	mov	r6, r1
   12fae:	mov	r8, r2
   12fb0:	mov	r5, r3
   12fb2:	cmp	r3, #0
   12fb4:	beq.n	13052 <fcvtbuf+0xbe>
   12fb6:	movs	r2, #0
   12fb8:	ldr	r3, [pc, #208]	; (1308c <fcvtbuf+0xf8>)
   12fba:	vmov	r0, r1, d8
   12fbe:	bl	f3c4 <__aeabi_dcmplt>
   12fc2:	cbnz	r0, 13024 <fcvtbuf+0x90>
   12fc4:	vmov.f32	s0, s16
   12fc8:	vmov.f32	s1, s17
   12fcc:	add	r3, sp, #12
   12fce:	str	r3, [sp, #4]
   12fd0:	str.w	r8, [sp]
   12fd4:	mov	r0, r7
   12fd6:	mov	r3, r6
   12fd8:	mov	r2, r4
   12fda:	movs	r1, #3
   12fdc:	bl	12160 <_dtoa_r>
   12fe0:	ldr	r3, [sp, #12]
   12fe2:	ldr	r1, [r6, #0]
   12fe4:	cmp	r0, r3
   12fe6:	rsb	r1, r1, #0
   12fea:	bcs.n	13060 <fcvtbuf+0xcc>
   12fec:	subs	r1, r1, r5
   12fee:	mov	r3, r5
   12ff0:	ldrb.w	r2, [r0], #1
   12ff4:	strb.w	r2, [r3], #1
   12ff8:	ldr	r2, [sp, #12]
   12ffa:	cmp	r2, r0
   12ffc:	add.w	r6, r3, r1
   13000:	bhi.n	12ff0 <fcvtbuf+0x5c>
   13002:	cmp	r4, r6
   13004:	ble.n	13066 <fcvtbuf+0xd2>
   13006:	subs	r2, r4, r6
   13008:	add	r2, r3
   1300a:	movs	r1, #48	; 0x30
   1300c:	strb.w	r1, [r3], #1
   13010:	cmp	r2, r3
   13012:	bne.n	1300c <fcvtbuf+0x78>
   13014:	movs	r3, #0
   13016:	strb	r3, [r2, #0]
   13018:	mov	r0, r5
   1301a:	add	sp, #20
   1301c:	vpop	{d8}
   13020:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13024:	movs	r2, #0
   13026:	ldr	r3, [pc, #104]	; (13090 <fcvtbuf+0xfc>)
   13028:	vmov	r0, r1, d8
   1302c:	bl	f400 <__aeabi_dcmpgt>
   13030:	cmp	r0, #0
   13032:	beq.n	12fc4 <fcvtbuf+0x30>
   13034:	vmov.f32	s0, s16
   13038:	vmov.f32	s1, s17
   1303c:	add	r3, sp, #12
   1303e:	str	r3, [sp, #4]
   13040:	str.w	r8, [sp]
   13044:	mov	r0, r7
   13046:	mov	r3, r6
   13048:	mov	r2, r4
   1304a:	movs	r1, #2
   1304c:	bl	12160 <_dtoa_r>
   13050:	b.n	12fe0 <fcvtbuf+0x4c>
   13052:	ldr	r2, [r7, #80]	; 0x50
   13054:	add.w	r3, r0, #35	; 0x23
   13058:	cmp	r2, r3
   1305a:	ble.n	1306a <fcvtbuf+0xd6>
   1305c:	ldr	r5, [r7, #84]	; 0x54
   1305e:	b.n	12fb6 <fcvtbuf+0x22>
   13060:	mov	r6, r1
   13062:	mov	r3, r5
   13064:	b.n	13002 <fcvtbuf+0x6e>
   13066:	mov	r2, r3
   13068:	b.n	13014 <fcvtbuf+0x80>
   1306a:	add.w	r9, r0, #36	; 0x24
   1306e:	mov	r2, r9
   13070:	ldr	r1, [r7, #84]	; 0x54
   13072:	mov	r0, r7
   13074:	bl	100c0 <_realloc_r>
   13078:	mov	r5, r0
   1307a:	cmp	r0, #0
   1307c:	beq.n	13018 <fcvtbuf+0x84>
   1307e:	str.w	r9, [r7, #80]	; 0x50
   13082:	str	r0, [r7, #84]	; 0x54
   13084:	b.n	12fb6 <fcvtbuf+0x22>
   13086:	nop
   13088:	.word	0x20001118
   1308c:	.word	0x3ff00000
   13090:	.word	0xbff00000

00013094 <_malloc_trim_r>:
   13094:	push	{r3, r4, r5, r6, r7, lr}
   13096:	ldr	r7, [pc, #140]	; (13124 <_malloc_trim_r+0x90>)
   13098:	mov	r4, r1
   1309a:	mov	r6, r0
   1309c:	bl	100b8 <__malloc_lock>
   130a0:	ldr	r3, [r7, #8]
   130a2:	ldr	r5, [r3, #4]
   130a4:	bic.w	r5, r5, #3
   130a8:	subs	r1, r5, r4
   130aa:	addw	r1, r1, #4079	; 0xfef
   130ae:	bic.w	r1, r1, #4080	; 0xff0
   130b2:	bic.w	r1, r1, #15
   130b6:	sub.w	r4, r1, #4096	; 0x1000
   130ba:	cmp.w	r4, #4096	; 0x1000
   130be:	blt.n	130d0 <_malloc_trim_r+0x3c>
   130c0:	movs	r1, #0
   130c2:	mov	r0, r6
   130c4:	bl	104a0 <_sbrk_r>
   130c8:	ldr	r3, [r7, #8]
   130ca:	add	r3, r5
   130cc:	cmp	r0, r3
   130ce:	beq.n	130da <_malloc_trim_r+0x46>
   130d0:	mov	r0, r6
   130d2:	bl	100bc <__malloc_unlock>
   130d6:	movs	r0, #0
   130d8:	pop	{r3, r4, r5, r6, r7, pc}
   130da:	negs	r1, r4
   130dc:	mov	r0, r6
   130de:	bl	104a0 <_sbrk_r>
   130e2:	adds	r0, #1
   130e4:	beq.n	13102 <_malloc_trim_r+0x6e>
   130e6:	ldr	r3, [pc, #64]	; (13128 <_malloc_trim_r+0x94>)
   130e8:	ldr	r2, [r7, #8]
   130ea:	ldr	r1, [r3, #0]
   130ec:	subs	r5, r5, r4
   130ee:	orr.w	r5, r5, #1
   130f2:	mov	r0, r6
   130f4:	subs	r1, r1, r4
   130f6:	str	r5, [r2, #4]
   130f8:	str	r1, [r3, #0]
   130fa:	bl	100bc <__malloc_unlock>
   130fe:	movs	r0, #1
   13100:	pop	{r3, r4, r5, r6, r7, pc}
   13102:	movs	r1, #0
   13104:	mov	r0, r6
   13106:	bl	104a0 <_sbrk_r>
   1310a:	ldr	r2, [r7, #8]
   1310c:	subs	r3, r0, r2
   1310e:	cmp	r3, #15
   13110:	ble.n	130d0 <_malloc_trim_r+0x3c>
   13112:	ldr	r4, [pc, #24]	; (1312c <_malloc_trim_r+0x98>)
   13114:	ldr	r1, [pc, #16]	; (13128 <_malloc_trim_r+0x94>)
   13116:	ldr	r4, [r4, #0]
   13118:	orr.w	r3, r3, #1
   1311c:	subs	r0, r0, r4
   1311e:	str	r3, [r2, #4]
   13120:	str	r0, [r1, #0]
   13122:	b.n	130d0 <_malloc_trim_r+0x3c>
   13124:	.word	0x20001288
   13128:	.word	0x2000529c
   1312c:	.word	0x20001694

00013130 <_free_r>:
   13130:	cmp	r1, #0
   13132:	beq.n	131c0 <_free_r+0x90>
   13134:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13138:	mov	r5, r1
   1313a:	mov	r8, r0
   1313c:	bl	100b8 <__malloc_lock>
   13140:	ldr.w	r7, [r5, #-4]
   13144:	ldr	r1, [pc, #424]	; (132f0 <_free_r+0x1c0>)
   13146:	bic.w	r3, r7, #1
   1314a:	sub.w	r4, r5, #8
   1314e:	adds	r2, r4, r3
   13150:	ldr	r6, [r1, #8]
   13152:	ldr	r0, [r2, #4]
   13154:	cmp	r2, r6
   13156:	bic.w	r0, r0, #3
   1315a:	beq.n	13222 <_free_r+0xf2>
   1315c:	lsls	r6, r7, #31
   1315e:	str	r0, [r2, #4]
   13160:	bmi.n	1317a <_free_r+0x4a>
   13162:	ldr.w	r7, [r5, #-8]
   13166:	subs	r4, r4, r7
   13168:	add.w	lr, r1, #8
   1316c:	ldr	r5, [r4, #8]
   1316e:	cmp	r5, lr
   13170:	add	r3, r7
   13172:	beq.n	13254 <_free_r+0x124>
   13174:	ldr	r7, [r4, #12]
   13176:	str	r7, [r5, #12]
   13178:	str	r5, [r7, #8]
   1317a:	adds	r5, r2, r0
   1317c:	ldr	r5, [r5, #4]
   1317e:	lsls	r5, r5, #31
   13180:	bpl.n	13208 <_free_r+0xd8>
   13182:	orr.w	r2, r3, #1
   13186:	str	r2, [r4, #4]
   13188:	str	r3, [r4, r3]
   1318a:	cmp.w	r3, #512	; 0x200
   1318e:	bcs.n	131c2 <_free_r+0x92>
   13190:	lsrs	r3, r3, #3
   13192:	adds	r2, r3, #1
   13194:	ldr	r5, [r1, #4]
   13196:	ldr.w	r7, [r1, r2, lsl #3]
   1319a:	str	r7, [r4, #8]
   1319c:	movs	r0, #1
   1319e:	asrs	r3, r3, #2
   131a0:	lsl.w	r3, r0, r3
   131a4:	add.w	r0, r1, r2, lsl #3
   131a8:	orrs	r5, r3
   131aa:	subs	r0, #8
   131ac:	str	r0, [r4, #12]
   131ae:	str	r5, [r1, #4]
   131b0:	str.w	r4, [r1, r2, lsl #3]
   131b4:	str	r4, [r7, #12]
   131b6:	mov	r0, r8
   131b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   131bc:	b.w	100bc <__malloc_unlock>
   131c0:	bx	lr
   131c2:	lsrs	r2, r3, #9
   131c4:	cmp	r2, #4
   131c6:	bhi.n	13270 <_free_r+0x140>
   131c8:	lsrs	r2, r3, #6
   131ca:	add.w	r7, r2, #57	; 0x39
   131ce:	lsls	r7, r7, #1
   131d0:	add.w	r5, r2, #56	; 0x38
   131d4:	add.w	r0, r1, r7, lsl #2
   131d8:	ldr.w	r2, [r1, r7, lsl #2]
   131dc:	ldr	r1, [pc, #272]	; (132f0 <_free_r+0x1c0>)
   131de:	subs	r0, #8
   131e0:	cmp	r0, r2
   131e2:	beq.n	13280 <_free_r+0x150>
   131e4:	ldr	r1, [r2, #4]
   131e6:	bic.w	r1, r1, #3
   131ea:	cmp	r3, r1
   131ec:	bcs.n	131f4 <_free_r+0xc4>
   131ee:	ldr	r2, [r2, #8]
   131f0:	cmp	r0, r2
   131f2:	bne.n	131e4 <_free_r+0xb4>
   131f4:	ldr	r0, [r2, #12]
   131f6:	str	r0, [r4, #12]
   131f8:	str	r2, [r4, #8]
   131fa:	str	r4, [r0, #8]
   131fc:	str	r4, [r2, #12]
   131fe:	mov	r0, r8
   13200:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   13204:	b.w	100bc <__malloc_unlock>
   13208:	ldr	r5, [r2, #8]
   1320a:	ldr	r7, [pc, #232]	; (132f4 <_free_r+0x1c4>)
   1320c:	cmp	r5, r7
   1320e:	add	r3, r0
   13210:	beq.n	13292 <_free_r+0x162>
   13212:	ldr	r0, [r2, #12]
   13214:	str	r0, [r5, #12]
   13216:	orr.w	r2, r3, #1
   1321a:	str	r5, [r0, #8]
   1321c:	str	r2, [r4, #4]
   1321e:	str	r3, [r4, r3]
   13220:	b.n	1318a <_free_r+0x5a>
   13222:	lsls	r7, r7, #31
   13224:	add	r3, r0
   13226:	bmi.n	13238 <_free_r+0x108>
   13228:	ldr.w	r2, [r5, #-8]
   1322c:	subs	r4, r4, r2
   1322e:	add	r3, r2
   13230:	ldr	r0, [r4, #8]
   13232:	ldr	r2, [r4, #12]
   13234:	str	r2, [r0, #12]
   13236:	str	r0, [r2, #8]
   13238:	ldr	r2, [pc, #188]	; (132f8 <_free_r+0x1c8>)
   1323a:	ldr	r2, [r2, #0]
   1323c:	orr.w	r0, r3, #1
   13240:	cmp	r3, r2
   13242:	str	r0, [r4, #4]
   13244:	str	r4, [r1, #8]
   13246:	bcc.n	131b6 <_free_r+0x86>
   13248:	ldr	r3, [pc, #176]	; (132fc <_free_r+0x1cc>)
   1324a:	mov	r0, r8
   1324c:	ldr	r1, [r3, #0]
   1324e:	bl	13094 <_malloc_trim_r>
   13252:	b.n	131b6 <_free_r+0x86>
   13254:	adds	r1, r2, r0
   13256:	ldr	r1, [r1, #4]
   13258:	lsls	r1, r1, #31
   1325a:	bmi.n	132e6 <_free_r+0x1b6>
   1325c:	ldr	r1, [r2, #8]
   1325e:	ldr	r2, [r2, #12]
   13260:	str	r2, [r1, #12]
   13262:	add	r3, r0
   13264:	orr.w	r0, r3, #1
   13268:	str	r1, [r2, #8]
   1326a:	str	r0, [r4, #4]
   1326c:	str	r3, [r4, r3]
   1326e:	b.n	131b6 <_free_r+0x86>
   13270:	cmp	r2, #20
   13272:	bhi.n	132a4 <_free_r+0x174>
   13274:	add.w	r7, r2, #92	; 0x5c
   13278:	lsls	r7, r7, #1
   1327a:	add.w	r5, r2, #91	; 0x5b
   1327e:	b.n	131d4 <_free_r+0xa4>
   13280:	asrs	r2, r5, #2
   13282:	ldr	r3, [r1, #4]
   13284:	movs	r5, #1
   13286:	lsl.w	r2, r5, r2
   1328a:	orrs	r3, r2
   1328c:	str	r3, [r1, #4]
   1328e:	mov	r2, r0
   13290:	b.n	131f6 <_free_r+0xc6>
   13292:	orr.w	r2, r3, #1
   13296:	str	r4, [r1, #20]
   13298:	str	r4, [r1, #16]
   1329a:	str	r5, [r4, #12]
   1329c:	str	r5, [r4, #8]
   1329e:	str	r2, [r4, #4]
   132a0:	str	r3, [r4, r3]
   132a2:	b.n	131b6 <_free_r+0x86>
   132a4:	cmp	r2, #84	; 0x54
   132a6:	bhi.n	132b6 <_free_r+0x186>
   132a8:	lsrs	r2, r3, #12
   132aa:	add.w	r7, r2, #111	; 0x6f
   132ae:	lsls	r7, r7, #1
   132b0:	add.w	r5, r2, #110	; 0x6e
   132b4:	b.n	131d4 <_free_r+0xa4>
   132b6:	cmp.w	r2, #340	; 0x154
   132ba:	bhi.n	132ca <_free_r+0x19a>
   132bc:	lsrs	r2, r3, #15
   132be:	add.w	r7, r2, #120	; 0x78
   132c2:	lsls	r7, r7, #1
   132c4:	add.w	r5, r2, #119	; 0x77
   132c8:	b.n	131d4 <_free_r+0xa4>
   132ca:	movw	r0, #1364	; 0x554
   132ce:	cmp	r2, r0
   132d0:	bhi.n	132e0 <_free_r+0x1b0>
   132d2:	lsrs	r2, r3, #18
   132d4:	add.w	r7, r2, #125	; 0x7d
   132d8:	lsls	r7, r7, #1
   132da:	add.w	r5, r2, #124	; 0x7c
   132de:	b.n	131d4 <_free_r+0xa4>
   132e0:	movs	r7, #254	; 0xfe
   132e2:	movs	r5, #126	; 0x7e
   132e4:	b.n	131d4 <_free_r+0xa4>
   132e6:	orr.w	r2, r3, #1
   132ea:	str	r2, [r4, #4]
   132ec:	str	r3, [r4, r3]
   132ee:	b.n	131b6 <_free_r+0x86>
   132f0:	.word	0x20001288
   132f4:	.word	0x20001290
   132f8:	.word	0x20001690
   132fc:	.word	0x20005298

00013300 <_localeconv_r>:
   13300:	ldr	r2, [pc, #16]	; (13314 <_localeconv_r+0x14>)
   13302:	ldr	r3, [pc, #20]	; (13318 <_localeconv_r+0x18>)
   13304:	ldr	r2, [r2, #0]
   13306:	ldr	r0, [r2, #52]	; 0x34
   13308:	cmp	r0, #0
   1330a:	it	eq
   1330c:	moveq	r0, r3
   1330e:	adds	r0, #240	; 0xf0
   13310:	bx	lr
   13312:	nop
   13314:	.word	0x20001118
   13318:	.word	0x2000111c

0001331c <_Balloc>:
   1331c:	ldr	r3, [r0, #76]	; 0x4c
   1331e:	push	{r4, r5, r6, lr}
   13320:	mov	r5, r0
   13322:	mov	r4, r1
   13324:	cbz	r3, 1333a <_Balloc+0x1e>
   13326:	ldr.w	r0, [r3, r4, lsl #2]
   1332a:	cbz	r0, 1334e <_Balloc+0x32>
   1332c:	ldr	r2, [r0, #0]
   1332e:	str.w	r2, [r3, r4, lsl #2]
   13332:	movs	r3, #0
   13334:	str	r3, [r0, #16]
   13336:	str	r3, [r0, #12]
   13338:	pop	{r4, r5, r6, pc}
   1333a:	movs	r2, #33	; 0x21
   1333c:	movs	r1, #4
   1333e:	bl	f7a8 <_calloc_r>
   13342:	str	r0, [r5, #76]	; 0x4c
   13344:	mov	r3, r0
   13346:	cmp	r0, #0
   13348:	bne.n	13326 <_Balloc+0xa>
   1334a:	movs	r0, #0
   1334c:	pop	{r4, r5, r6, pc}
   1334e:	movs	r1, #1
   13350:	lsl.w	r6, r1, r4
   13354:	adds	r2, r6, #5
   13356:	mov	r0, r5
   13358:	lsls	r2, r2, #2
   1335a:	bl	f7a8 <_calloc_r>
   1335e:	cmp	r0, #0
   13360:	beq.n	1334a <_Balloc+0x2e>
   13362:	str	r4, [r0, #4]
   13364:	str	r6, [r0, #8]
   13366:	b.n	13332 <_Balloc+0x16>

00013368 <_Bfree>:
   13368:	cbz	r1, 13378 <_Bfree+0x10>
   1336a:	ldr	r3, [r0, #76]	; 0x4c
   1336c:	ldr	r2, [r1, #4]
   1336e:	ldr.w	r0, [r3, r2, lsl #2]
   13372:	str	r0, [r1, #0]
   13374:	str.w	r1, [r3, r2, lsl #2]
   13378:	bx	lr
   1337a:	nop

0001337c <__multadd>:
   1337c:	push	{r4, r5, r6, r7, lr}
   1337e:	ldr	r4, [r1, #16]
   13380:	sub	sp, #12
   13382:	mov	r5, r1
   13384:	mov	r6, r0
   13386:	add.w	lr, r1, #20
   1338a:	movs	r7, #0
   1338c:	ldr.w	r0, [lr]
   13390:	uxth	r1, r0
   13392:	mla	r1, r2, r1, r3
   13396:	lsrs	r3, r1, #16
   13398:	lsrs	r0, r0, #16
   1339a:	mla	r3, r2, r0, r3
   1339e:	uxth	r1, r1
   133a0:	adds	r7, #1
   133a2:	add.w	r1, r1, r3, lsl #16
   133a6:	cmp	r4, r7
   133a8:	str.w	r1, [lr], #4
   133ac:	mov.w	r3, r3, lsr #16
   133b0:	bgt.n	1338c <__multadd+0x10>
   133b2:	cbz	r3, 133c4 <__multadd+0x48>
   133b4:	ldr	r2, [r5, #8]
   133b6:	cmp	r4, r2
   133b8:	bge.n	133ca <__multadd+0x4e>
   133ba:	add.w	r2, r5, r4, lsl #2
   133be:	adds	r4, #1
   133c0:	str	r3, [r2, #20]
   133c2:	str	r4, [r5, #16]
   133c4:	mov	r0, r5
   133c6:	add	sp, #12
   133c8:	pop	{r4, r5, r6, r7, pc}
   133ca:	ldr	r1, [r5, #4]
   133cc:	str	r3, [sp, #4]
   133ce:	adds	r1, #1
   133d0:	mov	r0, r6
   133d2:	bl	1331c <_Balloc>
   133d6:	ldr	r2, [r5, #16]
   133d8:	adds	r2, #2
   133da:	add.w	r1, r5, #12
   133de:	mov	r7, r0
   133e0:	lsls	r2, r2, #2
   133e2:	adds	r0, #12
   133e4:	bl	cfd4 <memcpy>
   133e8:	ldr	r2, [r6, #76]	; 0x4c
   133ea:	ldr	r1, [r5, #4]
   133ec:	ldr	r3, [sp, #4]
   133ee:	ldr.w	r0, [r2, r1, lsl #2]
   133f2:	str	r0, [r5, #0]
   133f4:	str.w	r5, [r2, r1, lsl #2]
   133f8:	mov	r5, r7
   133fa:	b.n	133ba <__multadd+0x3e>

000133fc <__hi0bits>:
   133fc:	lsrs	r3, r0, #16
   133fe:	lsls	r3, r3, #16
   13400:	cbnz	r3, 13430 <__hi0bits+0x34>
   13402:	lsls	r0, r0, #16
   13404:	movs	r3, #16
   13406:	tst.w	r0, #4278190080	; 0xff000000
   1340a:	itt	eq
   1340c:	lsleq	r0, r0, #8
   1340e:	addeq	r3, #8
   13410:	tst.w	r0, #4026531840	; 0xf0000000
   13414:	itt	eq
   13416:	lsleq	r0, r0, #4
   13418:	addeq	r3, #4
   1341a:	tst.w	r0, #3221225472	; 0xc0000000
   1341e:	itt	eq
   13420:	lsleq	r0, r0, #2
   13422:	addeq	r3, #2
   13424:	cmp	r0, #0
   13426:	blt.n	13438 <__hi0bits+0x3c>
   13428:	lsls	r2, r0, #1
   1342a:	bmi.n	13434 <__hi0bits+0x38>
   1342c:	movs	r0, #32
   1342e:	bx	lr
   13430:	movs	r3, #0
   13432:	b.n	13406 <__hi0bits+0xa>
   13434:	adds	r0, r3, #1
   13436:	bx	lr
   13438:	mov	r0, r3
   1343a:	bx	lr

0001343c <__lo0bits>:
   1343c:	ldr	r3, [r0, #0]
   1343e:	ands.w	r2, r3, #7
   13442:	beq.n	13454 <__lo0bits+0x18>
   13444:	lsls	r1, r3, #31
   13446:	bmi.n	1348a <__lo0bits+0x4e>
   13448:	lsls	r2, r3, #30
   1344a:	bmi.n	1348e <__lo0bits+0x52>
   1344c:	lsrs	r3, r3, #2
   1344e:	str	r3, [r0, #0]
   13450:	movs	r0, #2
   13452:	bx	lr
   13454:	uxth	r1, r3
   13456:	cbnz	r1, 1345c <__lo0bits+0x20>
   13458:	lsrs	r3, r3, #16
   1345a:	movs	r2, #16
   1345c:	tst.w	r3, #255	; 0xff
   13460:	itt	eq
   13462:	lsreq	r3, r3, #8
   13464:	addeq	r2, #8
   13466:	lsls	r1, r3, #28
   13468:	itt	eq
   1346a:	lsreq	r3, r3, #4
   1346c:	addeq	r2, #4
   1346e:	lsls	r1, r3, #30
   13470:	itt	eq
   13472:	lsreq	r3, r3, #2
   13474:	addeq	r2, #2
   13476:	lsls	r1, r3, #31
   13478:	bmi.n	13484 <__lo0bits+0x48>
   1347a:	lsrs	r3, r3, #1
   1347c:	bne.n	13482 <__lo0bits+0x46>
   1347e:	movs	r0, #32
   13480:	bx	lr
   13482:	adds	r2, #1
   13484:	str	r3, [r0, #0]
   13486:	mov	r0, r2
   13488:	bx	lr
   1348a:	movs	r0, #0
   1348c:	bx	lr
   1348e:	lsrs	r3, r3, #1
   13490:	str	r3, [r0, #0]
   13492:	movs	r0, #1
   13494:	bx	lr
   13496:	nop

00013498 <__i2b>:
   13498:	push	{r4, lr}
   1349a:	mov	r4, r1
   1349c:	movs	r1, #1
   1349e:	bl	1331c <_Balloc>
   134a2:	movs	r2, #1
   134a4:	str	r4, [r0, #20]
   134a6:	str	r2, [r0, #16]
   134a8:	pop	{r4, pc}
   134aa:	nop

000134ac <__multiply>:
   134ac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   134b0:	ldr	r5, [r1, #16]
   134b2:	ldr	r7, [r2, #16]
   134b4:	cmp	r5, r7
   134b6:	sub	sp, #12
   134b8:	mov	r4, r1
   134ba:	mov	r6, r2
   134bc:	bge.n	134c8 <__multiply+0x1c>
   134be:	mov	r2, r5
   134c0:	mov	r4, r6
   134c2:	mov	r5, r7
   134c4:	mov	r6, r1
   134c6:	mov	r7, r2
   134c8:	ldr	r3, [r4, #8]
   134ca:	ldr	r1, [r4, #4]
   134cc:	add.w	r8, r5, r7
   134d0:	cmp	r8, r3
   134d2:	it	gt
   134d4:	addgt	r1, #1
   134d6:	bl	1331c <_Balloc>
   134da:	add.w	ip, r0, #20
   134de:	add.w	r9, ip, r8, lsl #2
   134e2:	cmp	ip, r9
   134e4:	str	r0, [sp, #0]
   134e6:	bcs.n	134f4 <__multiply+0x48>
   134e8:	mov	r3, ip
   134ea:	movs	r1, #0
   134ec:	str.w	r1, [r3], #4
   134f0:	cmp	r9, r3
   134f2:	bhi.n	134ec <__multiply+0x40>
   134f4:	add.w	r2, r6, #20
   134f8:	add.w	sl, r2, r7, lsl #2
   134fc:	add.w	r3, r4, #20
   13500:	cmp	r2, sl
   13502:	add.w	lr, r3, r5, lsl #2
   13506:	bcs.n	135b2 <__multiply+0x106>
   13508:	str.w	r9, [sp, #4]
   1350c:	mov	r9, r3
   1350e:	ldr.w	r3, [r2], #4
   13512:	uxth.w	fp, r3
   13516:	cmp.w	fp, #0
   1351a:	beq.n	1355e <__multiply+0xb2>
   1351c:	movs	r0, #0
   1351e:	mov	r7, r9
   13520:	mov	r6, ip
   13522:	mov	r5, r0
   13524:	b.n	13528 <__multiply+0x7c>
   13526:	mov	r6, r3
   13528:	ldr.w	r4, [r7], #4
   1352c:	ldr	r0, [r6, #0]
   1352e:	uxth	r1, r4
   13530:	uxth	r3, r0
   13532:	mla	r1, fp, r1, r3
   13536:	lsrs	r4, r4, #16
   13538:	lsrs	r0, r0, #16
   1353a:	adds	r3, r1, r5
   1353c:	mla	r0, fp, r4, r0
   13540:	add.w	r0, r0, r3, lsr #16
   13544:	uxth	r1, r3
   13546:	mov	r3, r6
   13548:	orr.w	r1, r1, r0, lsl #16
   1354c:	cmp	lr, r7
   1354e:	mov.w	r5, r0, lsr #16
   13552:	str.w	r1, [r3], #4
   13556:	bhi.n	13526 <__multiply+0x7a>
   13558:	str	r5, [r6, #4]
   1355a:	ldr.w	r3, [r2, #-4]
   1355e:	movs.w	fp, r3, lsr #16
   13562:	beq.n	135a6 <__multiply+0xfa>
   13564:	ldr.w	r3, [ip]
   13568:	mov	r7, ip
   1356a:	mov	r0, r3
   1356c:	mov	r5, r9
   1356e:	movs	r1, #0
   13570:	b.n	13574 <__multiply+0xc8>
   13572:	mov	r7, r6
   13574:	ldrh	r4, [r5, #0]
   13576:	lsrs	r0, r0, #16
   13578:	mla	r0, fp, r4, r0
   1357c:	add	r1, r0
   1357e:	uxth	r4, r3
   13580:	mov	r6, r7
   13582:	orr.w	r3, r4, r1, lsl #16
   13586:	str.w	r3, [r6], #4
   1358a:	ldr	r0, [r7, #4]
   1358c:	ldr.w	r4, [r5], #4
   13590:	uxth	r3, r0
   13592:	lsrs	r4, r4, #16
   13594:	mla	r4, fp, r4, r3
   13598:	add.w	r3, r4, r1, lsr #16
   1359c:	cmp	lr, r5
   1359e:	mov.w	r1, r3, lsr #16
   135a2:	bhi.n	13572 <__multiply+0xc6>
   135a4:	str	r3, [r7, #4]
   135a6:	cmp	sl, r2
   135a8:	add.w	ip, ip, #4
   135ac:	bhi.n	1350e <__multiply+0x62>
   135ae:	ldr.w	r9, [sp, #4]
   135b2:	cmp.w	r8, #0
   135b6:	ble.n	135d0 <__multiply+0x124>
   135b8:	ldr.w	r3, [r9, #-4]
   135bc:	sub.w	r9, r9, #4
   135c0:	cbz	r3, 135ca <__multiply+0x11e>
   135c2:	b.n	135d0 <__multiply+0x124>
   135c4:	ldr.w	r3, [r9, #-4]!
   135c8:	cbnz	r3, 135d0 <__multiply+0x124>
   135ca:	subs.w	r8, r8, #1
   135ce:	bne.n	135c4 <__multiply+0x118>
   135d0:	ldr	r0, [sp, #0]
   135d2:	str.w	r8, [r0, #16]
   135d6:	add	sp, #12
   135d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000135dc <__pow5mult>:
   135dc:	ands.w	r3, r2, #3
   135e0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   135e4:	mov	r4, r2
   135e6:	mov	r7, r0
   135e8:	bne.n	13648 <__pow5mult+0x6c>
   135ea:	mov	r6, r1
   135ec:	asrs	r4, r4, #2
   135ee:	beq.n	1362a <__pow5mult+0x4e>
   135f0:	ldr	r5, [r7, #72]	; 0x48
   135f2:	cbz	r5, 1365a <__pow5mult+0x7e>
   135f4:	lsls	r3, r4, #31
   135f6:	mov.w	r8, #0
   135fa:	bmi.n	1360a <__pow5mult+0x2e>
   135fc:	asrs	r4, r4, #1
   135fe:	beq.n	1362a <__pow5mult+0x4e>
   13600:	ldr	r0, [r5, #0]
   13602:	cbz	r0, 13630 <__pow5mult+0x54>
   13604:	mov	r5, r0
   13606:	lsls	r3, r4, #31
   13608:	bpl.n	135fc <__pow5mult+0x20>
   1360a:	mov	r2, r5
   1360c:	mov	r1, r6
   1360e:	mov	r0, r7
   13610:	bl	134ac <__multiply>
   13614:	cbz	r6, 13644 <__pow5mult+0x68>
   13616:	ldr	r2, [r6, #4]
   13618:	ldr	r3, [r7, #76]	; 0x4c
   1361a:	asrs	r4, r4, #1
   1361c:	ldr.w	r1, [r3, r2, lsl #2]
   13620:	str	r1, [r6, #0]
   13622:	str.w	r6, [r3, r2, lsl #2]
   13626:	mov	r6, r0
   13628:	bne.n	13600 <__pow5mult+0x24>
   1362a:	mov	r0, r6
   1362c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13630:	mov	r2, r5
   13632:	mov	r1, r5
   13634:	mov	r0, r7
   13636:	bl	134ac <__multiply>
   1363a:	str	r0, [r5, #0]
   1363c:	str.w	r8, [r0]
   13640:	mov	r5, r0
   13642:	b.n	13606 <__pow5mult+0x2a>
   13644:	mov	r6, r0
   13646:	b.n	135fc <__pow5mult+0x20>
   13648:	subs	r2, r3, #1
   1364a:	ldr	r5, [pc, #44]	; (13678 <__pow5mult+0x9c>)
   1364c:	movs	r3, #0
   1364e:	ldr.w	r2, [r5, r2, lsl #2]
   13652:	bl	1337c <__multadd>
   13656:	mov	r6, r0
   13658:	b.n	135ec <__pow5mult+0x10>
   1365a:	movs	r1, #1
   1365c:	mov	r0, r7
   1365e:	bl	1331c <_Balloc>
   13662:	movw	r1, #625	; 0x271
   13666:	movs	r2, #1
   13668:	movs	r3, #0
   1366a:	str	r1, [r0, #20]
   1366c:	str	r2, [r0, #16]
   1366e:	mov	r5, r0
   13670:	str	r0, [r7, #72]	; 0x48
   13672:	str	r3, [r0, #0]
   13674:	b.n	135f4 <__pow5mult+0x18>
   13676:	nop
   13678:	.word	0x20000b50

0001367c <__lshift>:
   1367c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13680:	mov	r9, r2
   13682:	ldr	r2, [r1, #16]
   13684:	ldr	r3, [r1, #8]
   13686:	mov.w	r4, r9, asr #5
   1368a:	add.w	r8, r4, r2
   1368e:	add.w	r5, r8, #1
   13692:	cmp	r5, r3
   13694:	mov	r6, r1
   13696:	mov	sl, r0
   13698:	ldr	r1, [r1, #4]
   1369a:	ble.n	136a6 <__lshift+0x2a>
   1369c:	lsls	r3, r3, #1
   1369e:	cmp	r5, r3
   136a0:	add.w	r1, r1, #1
   136a4:	bgt.n	1369c <__lshift+0x20>
   136a6:	mov	r0, sl
   136a8:	bl	1331c <_Balloc>
   136ac:	cmp	r4, #0
   136ae:	add.w	r2, r0, #20
   136b2:	ble.n	13726 <__lshift+0xaa>
   136b4:	add.w	r3, r2, r4, lsl #2
   136b8:	movs	r1, #0
   136ba:	str.w	r1, [r2], #4
   136be:	cmp	r3, r2
   136c0:	bne.n	136ba <__lshift+0x3e>
   136c2:	ldr	r4, [r6, #16]
   136c4:	add.w	r1, r6, #20
   136c8:	ands.w	r9, r9, #31
   136cc:	add.w	lr, r1, r4, lsl #2
   136d0:	beq.n	13716 <__lshift+0x9a>
   136d2:	rsb	r2, r9, #32
   136d6:	movs	r4, #0
   136d8:	ldr	r7, [r1, #0]
   136da:	lsl.w	ip, r7, r9
   136de:	orr.w	r4, ip, r4
   136e2:	mov	ip, r3
   136e4:	str.w	r4, [r3], #4
   136e8:	ldr.w	r4, [r1], #4
   136ec:	cmp	lr, r1
   136ee:	lsr.w	r4, r4, r2
   136f2:	bhi.n	136d8 <__lshift+0x5c>
   136f4:	str.w	r4, [ip, #4]
   136f8:	cbz	r4, 136fe <__lshift+0x82>
   136fa:	add.w	r5, r8, #2
   136fe:	ldr.w	r3, [sl, #76]	; 0x4c
   13702:	ldr	r2, [r6, #4]
   13704:	subs	r5, #1
   13706:	ldr.w	r1, [r3, r2, lsl #2]
   1370a:	str	r5, [r0, #16]
   1370c:	str	r1, [r6, #0]
   1370e:	str.w	r6, [r3, r2, lsl #2]
   13712:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13716:	subs	r3, #4
   13718:	ldr.w	r2, [r1], #4
   1371c:	str.w	r2, [r3, #4]!
   13720:	cmp	lr, r1
   13722:	bhi.n	13718 <__lshift+0x9c>
   13724:	b.n	136fe <__lshift+0x82>
   13726:	mov	r3, r2
   13728:	b.n	136c2 <__lshift+0x46>
   1372a:	nop

0001372c <__mcmp>:
   1372c:	ldr	r2, [r0, #16]
   1372e:	ldr	r3, [r1, #16]
   13730:	subs	r2, r2, r3
   13732:	bne.n	1375c <__mcmp+0x30>
   13734:	lsls	r3, r3, #2
   13736:	adds	r0, #20
   13738:	adds	r1, #20
   1373a:	add	r1, r3
   1373c:	push	{r4}
   1373e:	add	r3, r0
   13740:	b.n	13746 <__mcmp+0x1a>
   13742:	cmp	r0, r3
   13744:	bcs.n	13760 <__mcmp+0x34>
   13746:	ldr.w	r4, [r3, #-4]!
   1374a:	ldr.w	r2, [r1, #-4]!
   1374e:	cmp	r4, r2
   13750:	beq.n	13742 <__mcmp+0x16>
   13752:	bcc.n	13768 <__mcmp+0x3c>
   13754:	movs	r0, #1
   13756:	ldr.w	r4, [sp], #4
   1375a:	bx	lr
   1375c:	mov	r0, r2
   1375e:	bx	lr
   13760:	movs	r0, #0
   13762:	ldr.w	r4, [sp], #4
   13766:	bx	lr
   13768:	mov.w	r0, #4294967295
   1376c:	b.n	13756 <__mcmp+0x2a>
   1376e:	nop

00013770 <__mdiff>:
   13770:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13774:	ldr	r3, [r1, #16]
   13776:	mov	r7, r1
   13778:	ldr	r1, [r2, #16]
   1377a:	subs	r3, r3, r1
   1377c:	cmp	r3, #0
   1377e:	mov	r8, r2
   13780:	bne.n	137b2 <__mdiff+0x42>
   13782:	lsls	r1, r1, #2
   13784:	add.w	r2, r7, #20
   13788:	add.w	r5, r8, #20
   1378c:	adds	r3, r2, r1
   1378e:	add	r1, r5
   13790:	b.n	13796 <__mdiff+0x26>
   13792:	cmp	r2, r3
   13794:	bcs.n	13854 <__mdiff+0xe4>
   13796:	ldr.w	r6, [r3, #-4]!
   1379a:	ldr.w	r4, [r1, #-4]!
   1379e:	cmp	r6, r4
   137a0:	beq.n	13792 <__mdiff+0x22>
   137a2:	bcs.n	13866 <__mdiff+0xf6>
   137a4:	mov	r3, r7
   137a6:	mov	r4, r2
   137a8:	mov	r7, r8
   137aa:	mov.w	r9, #1
   137ae:	mov	r8, r3
   137b0:	b.n	137c0 <__mdiff+0x50>
   137b2:	blt.n	13870 <__mdiff+0x100>
   137b4:	add.w	r5, r7, #20
   137b8:	add.w	r4, r2, #20
   137bc:	mov.w	r9, #0
   137c0:	ldr	r1, [r7, #4]
   137c2:	bl	1331c <_Balloc>
   137c6:	ldr.w	r3, [r8, #16]
   137ca:	ldr	r6, [r7, #16]
   137cc:	str.w	r9, [r0, #12]
   137d0:	add.w	ip, r4, r3, lsl #2
   137d4:	mov	lr, r4
   137d6:	add.w	r7, r5, r6, lsl #2
   137da:	add.w	r4, r0, #20
   137de:	movs	r3, #0
   137e0:	ldr.w	r1, [lr], #4
   137e4:	ldr.w	r8, [r5], #4
   137e8:	uxth	r2, r1
   137ea:	uxtah	r3, r3, r8
   137ee:	lsrs	r1, r1, #16
   137f0:	subs	r2, r3, r2
   137f2:	rsb	r3, r1, r8, lsr #16
   137f6:	add.w	r3, r3, r2, asr #16
   137fa:	uxth	r2, r2
   137fc:	orr.w	r2, r2, r3, lsl #16
   13800:	cmp	ip, lr
   13802:	str.w	r2, [r4], #4
   13806:	mov.w	r3, r3, asr #16
   1380a:	bhi.n	137e0 <__mdiff+0x70>
   1380c:	cmp	r7, r5
   1380e:	bls.n	13840 <__mdiff+0xd0>
   13810:	mov	ip, r4
   13812:	mov	r1, r5
   13814:	ldr.w	lr, [r1], #4
   13818:	uxtah	r2, r3, lr
   1381c:	asrs	r3, r2, #16
   1381e:	add.w	r3, r3, lr, lsr #16
   13822:	uxth	r2, r2
   13824:	orr.w	r2, r2, r3, lsl #16
   13828:	cmp	r7, r1
   1382a:	str.w	r2, [ip], #4
   1382e:	mov.w	r3, r3, asr #16
   13832:	bhi.n	13814 <__mdiff+0xa4>
   13834:	mvns	r5, r5
   13836:	add	r5, r7
   13838:	bic.w	r5, r5, #3
   1383c:	adds	r5, #4
   1383e:	add	r4, r5
   13840:	subs	r4, #4
   13842:	cbnz	r2, 1384e <__mdiff+0xde>
   13844:	ldr.w	r3, [r4, #-4]!
   13848:	subs	r6, #1
   1384a:	cmp	r3, #0
   1384c:	beq.n	13844 <__mdiff+0xd4>
   1384e:	str	r6, [r0, #16]
   13850:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13854:	movs	r1, #0
   13856:	bl	1331c <_Balloc>
   1385a:	movs	r2, #1
   1385c:	movs	r3, #0
   1385e:	str	r2, [r0, #16]
   13860:	str	r3, [r0, #20]
   13862:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13866:	mov	r4, r5
   13868:	mov.w	r9, #0
   1386c:	mov	r5, r2
   1386e:	b.n	137c0 <__mdiff+0x50>
   13870:	mov	r3, r7
   13872:	add.w	r4, r7, #20
   13876:	add.w	r5, r8, #20
   1387a:	mov	r7, r8
   1387c:	mov.w	r9, #1
   13880:	mov	r8, r3
   13882:	b.n	137c0 <__mdiff+0x50>

00013884 <__d2b>:
   13884:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13888:	vmov	r6, r7, d0
   1388c:	sub	sp, #12
   1388e:	mov	r8, r1
   13890:	movs	r1, #1
   13892:	mov	r4, r7
   13894:	ubfx	r5, r7, #20, #11
   13898:	mov	r7, r2
   1389a:	bl	1331c <_Balloc>
   1389e:	ubfx	r4, r4, #0, #20
   138a2:	mov	r9, r0
   138a4:	cbz	r5, 138aa <__d2b+0x26>
   138a6:	orr.w	r4, r4, #1048576	; 0x100000
   138aa:	str	r4, [sp, #4]
   138ac:	cbz	r6, 138f6 <__d2b+0x72>
   138ae:	add	r0, sp, #8
   138b0:	str.w	r6, [r0, #-8]!
   138b4:	bl	1343c <__lo0bits>
   138b8:	cmp	r0, #0
   138ba:	bne.n	13926 <__d2b+0xa2>
   138bc:	ldmia.w	sp, {r2, r3}
   138c0:	str.w	r2, [r9, #20]
   138c4:	cmp	r3, #0
   138c6:	ite	eq
   138c8:	moveq	r1, #1
   138ca:	movne	r1, #2
   138cc:	str.w	r3, [r9, #24]
   138d0:	str.w	r1, [r9, #16]
   138d4:	cbnz	r5, 1390e <__d2b+0x8a>
   138d6:	add.w	r3, r9, r1, lsl #2
   138da:	subw	r0, r0, #1074	; 0x432
   138de:	str.w	r0, [r8]
   138e2:	ldr	r0, [r3, #16]
   138e4:	bl	133fc <__hi0bits>
   138e8:	rsb	r0, r0, r1, lsl #5
   138ec:	str	r0, [r7, #0]
   138ee:	mov	r0, r9
   138f0:	add	sp, #12
   138f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   138f6:	add	r0, sp, #4
   138f8:	bl	1343c <__lo0bits>
   138fc:	ldr	r3, [sp, #4]
   138fe:	str.w	r3, [r9, #20]
   13902:	movs	r1, #1
   13904:	adds	r0, #32
   13906:	str.w	r1, [r9, #16]
   1390a:	cmp	r5, #0
   1390c:	beq.n	138d6 <__d2b+0x52>
   1390e:	subw	r5, r5, #1075	; 0x433
   13912:	add	r5, r0
   13914:	rsb	r0, r0, #53	; 0x35
   13918:	str.w	r5, [r8]
   1391c:	str	r0, [r7, #0]
   1391e:	mov	r0, r9
   13920:	add	sp, #12
   13922:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13926:	ldmia.w	sp, {r2, r3}
   1392a:	rsb	r1, r0, #32
   1392e:	lsl.w	r1, r3, r1
   13932:	orrs	r2, r1
   13934:	lsrs	r3, r0
   13936:	str	r3, [sp, #4]
   13938:	str.w	r2, [r9, #20]
   1393c:	b.n	138c4 <__d2b+0x40>
   1393e:	nop

00013940 <__ssprint_r>:
   13940:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13944:	ldr	r3, [r2, #8]
   13946:	sub	sp, #12
   13948:	mov	r8, r2
   1394a:	cmp	r3, #0
   1394c:	beq.n	13a34 <__ssprint_r+0xf4>
   1394e:	mov	fp, r0
   13950:	mov.w	r9, #0
   13954:	ldr	r6, [r2, #0]
   13956:	ldr	r0, [r1, #0]
   13958:	ldr	r3, [r1, #8]
   1395a:	mov	r5, r1
   1395c:	mov	r4, r9
   1395e:	cmp	r4, #0
   13960:	beq.n	139ee <__ssprint_r+0xae>
   13962:	cmp	r4, r3
   13964:	mov	r7, r3
   13966:	mov	sl, r3
   13968:	bcc.n	139f8 <__ssprint_r+0xb8>
   1396a:	ldrh	r3, [r5, #12]
   1396c:	tst.w	r3, #1152	; 0x480
   13970:	beq.n	139ce <__ssprint_r+0x8e>
   13972:	ldr	r7, [r5, #20]
   13974:	ldr	r1, [r5, #16]
   13976:	add.w	r7, r7, r7, lsl #1
   1397a:	rsb	sl, r1, r0
   1397e:	add.w	r7, r7, r7, lsr #31
   13982:	adds	r0, r4, #1
   13984:	asrs	r7, r7, #1
   13986:	add	r0, sl
   13988:	cmp	r0, r7
   1398a:	mov	r2, r7
   1398c:	itt	hi
   1398e:	movhi	r7, r0
   13990:	movhi	r2, r7
   13992:	lsls	r3, r3, #21
   13994:	bpl.n	139fe <__ssprint_r+0xbe>
   13996:	mov	r1, r2
   13998:	mov	r0, fp
   1399a:	bl	f8b4 <_malloc_r>
   1399e:	cmp	r0, #0
   139a0:	beq.n	13a12 <__ssprint_r+0xd2>
   139a2:	mov	r2, sl
   139a4:	ldr	r1, [r5, #16]
   139a6:	str	r0, [sp, #4]
   139a8:	bl	cfd4 <memcpy>
   139ac:	ldrh	r2, [r5, #12]
   139ae:	ldr	r3, [sp, #4]
   139b0:	bic.w	r2, r2, #1152	; 0x480
   139b4:	orr.w	r2, r2, #128	; 0x80
   139b8:	strh	r2, [r5, #12]
   139ba:	rsb	r2, sl, r7
   139be:	add.w	r0, r3, sl
   139c2:	str	r7, [r5, #20]
   139c4:	str	r3, [r5, #16]
   139c6:	str	r0, [r5, #0]
   139c8:	str	r2, [r5, #8]
   139ca:	mov	r7, r4
   139cc:	mov	sl, r4
   139ce:	mov	r2, sl
   139d0:	mov	r1, r9
   139d2:	bl	ff54 <memmove>
   139d6:	ldr.w	r2, [r8, #8]
   139da:	ldr	r3, [r5, #8]
   139dc:	ldr	r0, [r5, #0]
   139de:	subs	r3, r3, r7
   139e0:	add	r0, sl
   139e2:	subs	r4, r2, r4
   139e4:	str	r3, [r5, #8]
   139e6:	str	r0, [r5, #0]
   139e8:	str.w	r4, [r8, #8]
   139ec:	cbz	r4, 13a34 <__ssprint_r+0xf4>
   139ee:	ldr.w	r9, [r6]
   139f2:	ldr	r4, [r6, #4]
   139f4:	adds	r6, #8
   139f6:	b.n	1395e <__ssprint_r+0x1e>
   139f8:	mov	r7, r4
   139fa:	mov	sl, r4
   139fc:	b.n	139ce <__ssprint_r+0x8e>
   139fe:	mov	r0, fp
   13a00:	bl	100c0 <_realloc_r>
   13a04:	mov	r3, r0
   13a06:	cmp	r0, #0
   13a08:	bne.n	139ba <__ssprint_r+0x7a>
   13a0a:	ldr	r1, [r5, #16]
   13a0c:	mov	r0, fp
   13a0e:	bl	13130 <_free_r>
   13a12:	movs	r3, #12
   13a14:	str.w	r3, [fp]
   13a18:	ldrh	r3, [r5, #12]
   13a1a:	movs	r2, #0
   13a1c:	orr.w	r3, r3, #64	; 0x40
   13a20:	mov.w	r0, #4294967295
   13a24:	strh	r3, [r5, #12]
   13a26:	str.w	r2, [r8, #8]
   13a2a:	str.w	r2, [r8, #4]
   13a2e:	add	sp, #12
   13a30:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13a34:	movs	r0, #0
   13a36:	str.w	r0, [r8, #4]
   13a3a:	add	sp, #12
   13a3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00013a40 <_vasnprintf_r>:
   13a40:	push	{r4, r5, r6, lr}
   13a42:	mov	r5, r2
   13a44:	sub	sp, #104	; 0x68
   13a46:	ldr	r4, [r2, #0]
   13a48:	cbz	r1, 13a4e <_vasnprintf_r+0xe>
   13a4a:	cmp	r4, #0
   13a4c:	bne.n	13a84 <_vasnprintf_r+0x44>
   13a4e:	movs	r4, #0
   13a50:	mov.w	r2, #648	; 0x288
   13a54:	strh.w	r2, [sp, #12]
   13a58:	str	r4, [sp, #0]
   13a5a:	str	r4, [sp, #16]
   13a5c:	mov	r2, r3
   13a5e:	movw	r6, #65535	; 0xffff
   13a62:	ldr	r3, [sp, #120]	; 0x78
   13a64:	str	r4, [sp, #8]
   13a66:	mov	r1, sp
   13a68:	str	r4, [sp, #20]
   13a6a:	strh.w	r6, [sp, #14]
   13a6e:	bl	10800 <_svfprintf_r>
   13a72:	cmp	r0, #0
   13a74:	blt.n	13a9a <_vasnprintf_r+0x5a>
   13a76:	ldr	r3, [sp, #0]
   13a78:	str	r0, [r5, #0]
   13a7a:	movs	r2, #0
   13a7c:	strb	r2, [r3, #0]
   13a7e:	ldr	r0, [sp, #16]
   13a80:	add	sp, #104	; 0x68
   13a82:	pop	{r4, r5, r6, pc}
   13a84:	mov.w	r2, #1544	; 0x608
   13a88:	str	r1, [sp, #0]
   13a8a:	str	r1, [sp, #16]
   13a8c:	strh.w	r2, [sp, #12]
   13a90:	bge.n	13a5c <_vasnprintf_r+0x1c>
   13a92:	movs	r3, #139	; 0x8b
   13a94:	str	r3, [r0, #0]
   13a96:	movs	r0, #0
   13a98:	b.n	13a80 <_vasnprintf_r+0x40>
   13a9a:	movs	r0, #0
   13a9c:	b.n	13a80 <_vasnprintf_r+0x40>
   13a9e:	nop

00013aa0 <___init_veneer>:
   13aa0:	ldr.w	pc, [pc]	; 13aa4 <___init_veneer+0x4>
   13aa4:	.word	0x600015e5
	...

Disassembly of section .fini:

00013ab0 <_fini>:
   13ab0:	push	{r3, r4, r5, r6, r7, lr}
   13ab2:	nop

Disassembly of section .text.csf:

60016f98 <_heap_end+0x3fd96f98>:
60016f98:	.word	0xffffffff
60016f9c:	.word	0xffffffff
60016fa0:	.word	0xffffffff
60016fa4:	.word	0xffffffff
60016fa8:	.word	0xffffffff
60016fac:	.word	0xffffffff
60016fb0:	.word	0xffffffff
60016fb4:	.word	0xffffffff
60016fb8:	.word	0xffffffff
60016fbc:	.word	0xffffffff
60016fc0:	.word	0xffffffff
60016fc4:	.word	0xffffffff
60016fc8:	.word	0xffffffff
60016fcc:	.word	0xffffffff
60016fd0:	.word	0xffffffff
60016fd4:	.word	0xffffffff
60016fd8:	.word	0xffffffff
60016fdc:	.word	0xffffffff
60016fe0:	.word	0xffffffff
60016fe4:	.word	0xffffffff
60016fe8:	.word	0xffffffff
60016fec:	.word	0xffffffff
60016ff0:	.word	0xffffffff
60016ff4:	.word	0xffffffff
60016ff8:	.word	0xffffffff
60016ffc:	.word	0xffffffff

60017000 <hab_csf>:
	...
